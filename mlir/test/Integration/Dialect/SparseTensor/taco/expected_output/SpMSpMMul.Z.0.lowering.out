// -----// IR Dump After LinalgGeneralization (linalg-generalize-named-ops) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
  %0 = bufferization.alloc_tensor() : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  %1 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"]} ins(%arg0, %arg1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) outs(%0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %2 = arith.mulf %in, %in_0 : f32
    %3 = arith.addf %out, %2 : f32
    linalg.yield %3 : f32
  } -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  return %1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
}

// -----// IR Dump After PreSparsificationRewrite (pre-sparsification-rewrite) //----- //
#map = affine_map<(d0, d1, d2) -> (d0, d2)>
#map1 = affine_map<(d0, d1, d2) -> (d2, d1)>
#map2 = affine_map<(d0, d1, d2) -> (d0, d1)>
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %0 = bufferization.alloc_tensor() : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "reduction"]} ins(%arg0, %arg1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) outs(%0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %2 = arith.mulf %in, %in_0 : f32
      %3 = arith.addf %out, %2 : f32
      linalg.yield %3 : f32
    } -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After EmptyTensorToAllocTensor (empty-tensor-to-alloc-tensor) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
  %0 = bufferization.alloc_tensor() : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  %1 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"]} ins(%arg0, %arg1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) outs(%0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %2 = arith.mulf %in, %in_0 : f32
    %3 = arith.addf %out, %2 : f32
    linalg.yield %3 : f32
  } -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  return %1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
}

// -----// IR Dump After SparsificationPass (sparsification) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %2 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.values %arg0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xf32>
    %4 = sparse_tensor.positions %arg1 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>> to memref<?xindex>
    %5 = sparse_tensor.coordinates %arg1 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>> to memref<?xindex>
    %6 = sparse_tensor.values %arg1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>> to memref<?xf32>
    %7 = sparse_tensor.values %0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    scf.parallel (%arg2) = (%c0) to (%c128) step (%c1) {
      scf.parallel (%arg3) = (%c0) to (%c128) step (%c1) {
        %9 = arith.muli %arg2, %c128 : index
        %10 = arith.addi %9, %arg3 : index
        %11 = memref.load %7[%10] : memref<?xf32>
        %12 = memref.load %1[%arg2] : memref<?xindex>
        %13 = arith.addi %arg2, %c1 : index
        %14 = memref.load %1[%13] : memref<?xindex>
        %15 = memref.load %4[%arg3] : memref<?xindex>
        %16 = arith.addi %arg3, %c1 : index
        %17 = memref.load %4[%16] : memref<?xindex>
        %18:3 = scf.while (%arg4 = %12, %arg5 = %15, %arg6 = %11) : (index, index, f32) -> (index, index, f32) {
          %19 = arith.cmpi ult, %arg4, %14 : index
          %20 = arith.cmpi ult, %arg5, %17 : index
          %21 = arith.andi %19, %20 : i1
          scf.condition(%21) %arg4, %arg5, %arg6 : index, index, f32
        } do {
        ^bb0(%arg4: index, %arg5: index, %arg6: f32):
          %19 = memref.load %2[%arg4] : memref<?xindex>
          %20 = memref.load %5[%arg5] : memref<?xindex>
          %21 = arith.cmpi ult, %20, %19 : index
          %22 = arith.select %21, %20, %19 : index
          %23 = arith.cmpi eq, %19, %22 : index
          %24 = arith.cmpi eq, %20, %22 : index
          %25 = arith.andi %23, %24 : i1
          %26 = scf.if %25 -> (f32) {
            %33 = memref.load %3[%arg4] : memref<?xf32>
            %34 = memref.load %6[%arg5] : memref<?xf32>
            %35 = arith.mulf %33, %34 : f32
            %36 = arith.addf %arg6, %35 : f32
            scf.yield %36 : f32
          } else {
            scf.yield %arg6 : f32
          }
          %27 = arith.cmpi eq, %19, %22 : index
          %28 = arith.addi %arg4, %c1 : index
          %29 = arith.select %27, %28, %arg4 : index
          %30 = arith.cmpi eq, %20, %22 : index
          %31 = arith.addi %arg5, %c1 : index
          %32 = arith.select %30, %31, %arg5 : index
          scf.yield %29, %32, %26 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        memref.store %18#2, %7[%10] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %8 = sparse_tensor.load %0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %8 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After PostSparsificationRewrite (post-sparsification-rewrite) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>>) -> tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %2 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.values %arg0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xf32>
    %4 = sparse_tensor.positions %arg1 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>> to memref<?xindex>
    %5 = sparse_tensor.coordinates %arg1 {level = 1 : index} : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>> to memref<?xindex>
    %6 = sparse_tensor.values %arg1 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ], dimToLvl = affine_map<(d0, d1) -> (d1, d0)> }>> to memref<?xf32>
    %7 = sparse_tensor.values %0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    scf.parallel (%arg2) = (%c0) to (%c128) step (%c1) {
      scf.parallel (%arg3) = (%c0) to (%c128) step (%c1) {
        %9 = arith.muli %arg2, %c128 : index
        %10 = arith.addi %9, %arg3 : index
        %11 = memref.load %7[%10] : memref<?xf32>
        %12 = memref.load %1[%arg2] : memref<?xindex>
        %13 = arith.addi %arg2, %c1 : index
        %14 = memref.load %1[%13] : memref<?xindex>
        %15 = memref.load %4[%arg3] : memref<?xindex>
        %16 = arith.addi %arg3, %c1 : index
        %17 = memref.load %4[%16] : memref<?xindex>
        %18:3 = scf.while (%arg4 = %12, %arg5 = %15, %arg6 = %11) : (index, index, f32) -> (index, index, f32) {
          %19 = arith.cmpi ult, %arg4, %14 : index
          %20 = arith.cmpi ult, %arg5, %17 : index
          %21 = arith.andi %19, %20 : i1
          scf.condition(%21) %arg4, %arg5, %arg6 : index, index, f32
        } do {
        ^bb0(%arg4: index, %arg5: index, %arg6: f32):
          %19 = memref.load %2[%arg4] : memref<?xindex>
          %20 = memref.load %5[%arg5] : memref<?xindex>
          %21 = arith.cmpi ult, %20, %19 : index
          %22 = arith.select %21, %20, %19 : index
          %23 = arith.cmpi eq, %19, %22 : index
          %24 = arith.cmpi eq, %20, %22 : index
          %25 = arith.andi %23, %24 : i1
          %26 = scf.if %25 -> (f32) {
            %33 = memref.load %3[%arg4] : memref<?xf32>
            %34 = memref.load %6[%arg5] : memref<?xf32>
            %35 = arith.mulf %33, %34 : f32
            %36 = arith.addf %arg6, %35 : f32
            scf.yield %36 : f32
          } else {
            scf.yield %arg6 : f32
          }
          %27 = arith.cmpi eq, %19, %22 : index
          %28 = arith.addi %arg4, %c1 : index
          %29 = arith.select %27, %28, %arg4 : index
          %30 = arith.cmpi eq, %20, %22 : index
          %31 = arith.addi %arg5, %c1 : index
          %32 = arith.select %30, %31, %arg5 : index
          scf.yield %29, %32, %26 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        memref.store %18#2, %7[%10] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %8 = sparse_tensor.load %0 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %8 : tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After SparseTensorCodegen (sparse-tensor-codegen) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> (memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c128_0 = arith.constant 128 : index
    %c128_1 = arith.constant 128 : index
    %0 = arith.muli %c128_0, %c128_1 : index
    %alloc = memref.alloc(%0) : memref<?xf32>
    %1 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %c0_2 = arith.constant 0 : index
    %2 = sparse_tensor.storage_specifier.set %1  lvl_sz at 0 with %c128_0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %3 = sparse_tensor.storage_specifier.set %2  lvl_sz at 1 with %c128_1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %c1_3 = arith.constant 1 : index
    %c128_4 = arith.constant 128 : index
    %4 = arith.muli %c1_3, %c128_4 : index
    %c128_5 = arith.constant 128 : index
    %5 = arith.muli %4, %c128_5 : index
    %cst = arith.constant 0.000000e+00 : f32
    %6 = sparse_tensor.storage_specifier.get %3  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %outBuffer, %newSize = sparse_tensor.push_back %6, %alloc, %cst, %5 : index, memref<?xf32>, f32, index
    %7 = sparse_tensor.storage_specifier.set %3  val_mem_sz with %newSize : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %8 = builtin.unrealized_conversion_cast %outBuffer, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      scf.parallel (%arg9) = (%c0) to (%c128) step (%c1) {
        %10 = arith.muli %arg8, %c128 : index
        %11 = arith.addi %10, %arg9 : index
        %12 = memref.load %outBuffer[%11] : memref<?xf32>
        %13 = memref.load %arg0[%arg8] : memref<?xindex>
        %14 = arith.addi %arg8, %c1 : index
        %15 = memref.load %arg0[%14] : memref<?xindex>
        %16 = memref.load %arg4[%arg9] : memref<?xindex>
        %17 = arith.addi %arg9, %c1 : index
        %18 = memref.load %arg4[%17] : memref<?xindex>
        %19:3 = scf.while (%arg10 = %13, %arg11 = %16, %arg12 = %12) : (index, index, f32) -> (index, index, f32) {
          %20 = arith.cmpi ult, %arg10, %15 : index
          %21 = arith.cmpi ult, %arg11, %18 : index
          %22 = arith.andi %20, %21 : i1
          scf.condition(%22) %arg10, %arg11, %arg12 : index, index, f32
        } do {
        ^bb0(%arg10: index, %arg11: index, %arg12: f32):
          %20 = memref.load %arg1[%arg10] : memref<?xindex>
          %21 = memref.load %arg5[%arg11] : memref<?xindex>
          %22 = arith.cmpi ult, %21, %20 : index
          %23 = arith.select %22, %21, %20 : index
          %24 = arith.cmpi eq, %20, %23 : index
          %25 = arith.cmpi eq, %21, %23 : index
          %26 = arith.andi %24, %25 : i1
          %27 = scf.if %26 -> (f32) {
            %34 = memref.load %arg2[%arg10] : memref<?xf32>
            %35 = memref.load %arg6[%arg11] : memref<?xf32>
            %36 = arith.mulf %34, %35 : f32
            %37 = arith.addf %arg12, %36 : f32
            scf.yield %37 : f32
          } else {
            scf.yield %arg12 : f32
          }
          %28 = arith.cmpi eq, %20, %23 : index
          %29 = arith.addi %arg10, %c1 : index
          %30 = arith.select %28, %29, %arg10 : index
          %31 = arith.cmpi eq, %21, %23 : index
          %32 = arith.addi %arg11, %c1 : index
          %33 = arith.select %31, %32, %arg11 : index
          scf.yield %30, %33, %27 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        memref.store %19#2, %outBuffer[%11] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %9 = builtin.unrealized_conversion_cast %outBuffer, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to tensor<128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %outBuffer, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After SparseBufferRewrite (sparse-buffer-rewrite) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> (memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) attributes {llvm.emit_c_interface} {
    %c16384 = arith.constant 16384 : index
    %c128 = arith.constant 128 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc(%c16384) : memref<?xf32>
    %0 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = sparse_tensor.storage_specifier.set %0  lvl_sz at 0 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %2 = sparse_tensor.storage_specifier.set %1  lvl_sz at 1 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %3 = sparse_tensor.storage_specifier.get %2  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %4 = arith.addi %3, %c16384 : index
    %5 = arith.cmpi ugt, %4, %c16384 : index
    %6 = scf.if %5 -> (memref<?xf32>) {
      %8 = scf.while (%arg8 = %c16384) : (index) -> index {
        %10 = arith.muli %arg8, %c2 : index
        %11 = arith.cmpi ugt, %4, %10 : index
        scf.condition(%11) %10 : index
      } do {
      ^bb0(%arg8: index):
        scf.yield %arg8 : index
      }
      %9 = memref.realloc %alloc(%8) : memref<?xf32> to memref<?xf32>
      scf.yield %9 : memref<?xf32>
    } else {
      scf.yield %alloc : memref<?xf32>
    }
    %subview = memref.subview %6[%3] [%c16384] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %7 = sparse_tensor.storage_specifier.set %2  val_mem_sz with %4 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      scf.parallel (%arg9) = (%c0) to (%c128) step (%c1) {
        %8 = arith.muli %arg8, %c128 : index
        %9 = arith.addi %8, %arg9 : index
        %10 = memref.load %6[%9] : memref<?xf32>
        %11 = memref.load %arg0[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg0[%12] : memref<?xindex>
        %14 = memref.load %arg4[%arg9] : memref<?xindex>
        %15 = arith.addi %arg9, %c1 : index
        %16 = memref.load %arg4[%15] : memref<?xindex>
        %17:3 = scf.while (%arg10 = %11, %arg11 = %14, %arg12 = %10) : (index, index, f32) -> (index, index, f32) {
          %18 = arith.cmpi ult, %arg10, %13 : index
          %19 = arith.cmpi ult, %arg11, %16 : index
          %20 = arith.andi %18, %19 : i1
          scf.condition(%20) %arg10, %arg11, %arg12 : index, index, f32
        } do {
        ^bb0(%arg10: index, %arg11: index, %arg12: f32):
          %18 = memref.load %arg1[%arg10] : memref<?xindex>
          %19 = memref.load %arg5[%arg11] : memref<?xindex>
          %20 = arith.cmpi ult, %19, %18 : index
          %21 = arith.select %20, %19, %18 : index
          %22 = arith.cmpi eq, %18, %21 : index
          %23 = arith.cmpi eq, %19, %21 : index
          %24 = arith.andi %22, %23 : i1
          %25 = scf.if %24 -> (f32) {
            %32 = memref.load %arg2[%arg10] : memref<?xf32>
            %33 = memref.load %arg6[%arg11] : memref<?xf32>
            %34 = arith.mulf %32, %33 : f32
            %35 = arith.addf %arg12, %34 : f32
            scf.yield %35 : f32
          } else {
            scf.yield %arg12 : f32
          }
          %26 = arith.cmpi eq, %18, %21 : index
          %27 = arith.addi %arg10, %c1 : index
          %28 = arith.select %26, %27, %arg10 : index
          %29 = arith.cmpi eq, %19, %21 : index
          %30 = arith.addi %arg11, %c1 : index
          %31 = arith.select %29, %30, %arg11 : index
          scf.yield %28, %31, %25 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        memref.store %17#2, %6[%9] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %6, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After StorageSpecifierToLLVM (sparse-storage-specifier-to-llvm) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c16384 = arith.constant 16384 : index
    %c128 = arith.constant 128 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc(%c16384) : memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %c0_i64 = arith.constant 0 : i64
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = arith.index_cast %c128 : index to i64
    %3 = llvm.insertvalue %2, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %4 = arith.index_cast %c128 : index to i64
    %5 = llvm.insertvalue %4, %3[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %6 = llvm.extractvalue %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %7 = arith.index_cast %6 : i64 to index
    %8 = arith.addi %7, %c16384 : index
    %9 = arith.cmpi ugt, %8, %c16384 : index
    %10 = scf.if %9 -> (memref<?xf32>) {
      %13 = scf.while (%arg8 = %c16384) : (index) -> index {
        %15 = arith.muli %arg8, %c2 : index
        %16 = arith.cmpi ugt, %8, %15 : index
        scf.condition(%16) %15 : index
      } do {
      ^bb0(%arg8: index):
        scf.yield %arg8 : index
      }
      %14 = memref.realloc %alloc(%13) : memref<?xf32> to memref<?xf32>
      scf.yield %14 : memref<?xf32>
    } else {
      scf.yield %alloc : memref<?xf32>
    }
    %subview = memref.subview %10[%7] [%c16384] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %11 = arith.index_cast %8 : index to i64
    %12 = llvm.insertvalue %11, %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      scf.parallel (%arg9) = (%c0) to (%c128) step (%c1) {
        %13 = arith.muli %arg8, %c128 : index
        %14 = arith.addi %13, %arg9 : index
        %15 = memref.load %10[%14] : memref<?xf32>
        %16 = memref.load %arg0[%arg8] : memref<?xindex>
        %17 = arith.addi %arg8, %c1 : index
        %18 = memref.load %arg0[%17] : memref<?xindex>
        %19 = memref.load %arg4[%arg9] : memref<?xindex>
        %20 = arith.addi %arg9, %c1 : index
        %21 = memref.load %arg4[%20] : memref<?xindex>
        %22:3 = scf.while (%arg10 = %16, %arg11 = %19, %arg12 = %15) : (index, index, f32) -> (index, index, f32) {
          %23 = arith.cmpi ult, %arg10, %18 : index
          %24 = arith.cmpi ult, %arg11, %21 : index
          %25 = arith.andi %23, %24 : i1
          scf.condition(%25) %arg10, %arg11, %arg12 : index, index, f32
        } do {
        ^bb0(%arg10: index, %arg11: index, %arg12: f32):
          %23 = memref.load %arg1[%arg10] : memref<?xindex>
          %24 = memref.load %arg5[%arg11] : memref<?xindex>
          %25 = arith.cmpi ult, %24, %23 : index
          %26 = arith.select %25, %24, %23 : index
          %27 = arith.cmpi eq, %23, %26 : index
          %28 = arith.cmpi eq, %24, %26 : index
          %29 = arith.andi %27, %28 : i1
          %30 = scf.if %29 -> (f32) {
            %37 = memref.load %arg2[%arg10] : memref<?xf32>
            %38 = memref.load %arg6[%arg11] : memref<?xf32>
            %39 = arith.mulf %37, %38 : f32
            %40 = arith.addf %arg12, %39 : f32
            scf.yield %40 : f32
          } else {
            scf.yield %arg12 : f32
          }
          %31 = arith.cmpi eq, %23, %26 : index
          %32 = arith.addi %arg10, %c1 : index
          %33 = arith.select %31, %32, %arg10 : index
          %34 = arith.cmpi eq, %24, %26 : index
          %35 = arith.addi %arg11, %c1 : index
          %36 = arith.select %34, %35, %arg11 : index
          scf.yield %33, %36, %30 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        memref.store %22#2, %10[%14] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %10, %12 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After mlir::sparse_tensor::SparsificationAndBufferizationPass () //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c16384 = arith.constant 16384 : index
    %c128 = arith.constant 128 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc(%c16384) : memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %c0_i64 = arith.constant 0 : i64
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = arith.index_cast %c128 : index to i64
    %3 = llvm.insertvalue %2, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %4 = arith.index_cast %c128 : index to i64
    %5 = llvm.insertvalue %4, %3[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %6 = llvm.extractvalue %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %7 = arith.index_cast %6 : i64 to index
    %8 = arith.addi %7, %c16384 : index
    %9 = arith.cmpi ugt, %8, %c16384 : index
    %10 = scf.if %9 -> (memref<?xf32>) {
      %13 = scf.while (%arg8 = %c16384) : (index) -> index {
        %15 = arith.muli %arg8, %c2 : index
        %16 = arith.cmpi ugt, %8, %15 : index
        scf.condition(%16) %15 : index
      } do {
      ^bb0(%arg8: index):
        scf.yield %arg8 : index
      }
      %14 = memref.realloc %alloc(%13) : memref<?xf32> to memref<?xf32>
      scf.yield %14 : memref<?xf32>
    } else {
      scf.yield %alloc : memref<?xf32>
    }
    %subview = memref.subview %10[%7] [%c16384] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %11 = arith.index_cast %8 : index to i64
    %12 = llvm.insertvalue %11, %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      scf.parallel (%arg9) = (%c0) to (%c128) step (%c1) {
        %13 = arith.muli %arg8, %c128 : index
        %14 = arith.addi %13, %arg9 : index
        %15 = memref.load %10[%14] : memref<?xf32>
        %16 = memref.load %arg0[%arg8] : memref<?xindex>
        %17 = arith.addi %arg8, %c1 : index
        %18 = memref.load %arg0[%17] : memref<?xindex>
        %19 = memref.load %arg4[%arg9] : memref<?xindex>
        %20 = arith.addi %arg9, %c1 : index
        %21 = memref.load %arg4[%20] : memref<?xindex>
        %22:3 = scf.while (%arg10 = %16, %arg11 = %19, %arg12 = %15) : (index, index, f32) -> (index, index, f32) {
          %23 = arith.cmpi ult, %arg10, %18 : index
          %24 = arith.cmpi ult, %arg11, %21 : index
          %25 = arith.andi %23, %24 : i1
          scf.condition(%25) %arg10, %arg11, %arg12 : index, index, f32
        } do {
        ^bb0(%arg10: index, %arg11: index, %arg12: f32):
          %23 = memref.load %arg1[%arg10] : memref<?xindex>
          %24 = memref.load %arg5[%arg11] : memref<?xindex>
          %25 = arith.cmpi ult, %24, %23 : index
          %26 = arith.select %25, %24, %23 : index
          %27 = arith.cmpi eq, %23, %26 : index
          %28 = arith.cmpi eq, %24, %26 : index
          %29 = arith.andi %27, %28 : i1
          %30 = scf.if %29 -> (f32) {
            %37 = memref.load %arg2[%arg10] : memref<?xf32>
            %38 = memref.load %arg6[%arg11] : memref<?xf32>
            %39 = arith.mulf %37, %38 : f32
            %40 = arith.addf %arg12, %39 : f32
            scf.yield %40 : f32
          } else {
            scf.yield %arg12 : f32
          }
          %31 = arith.cmpi eq, %23, %26 : index
          %32 = arith.addi %arg10, %c1 : index
          %33 = arith.select %31, %32, %arg10 : index
          %34 = arith.cmpi eq, %24, %26 : index
          %35 = arith.addi %arg11, %c1 : index
          %36 = arith.select %34, %35, %arg11 : index
          scf.yield %33, %36, %30 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        memref.store %22#2, %10[%14] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %10, %12 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c16384_i64 = arith.constant 16384 : i64
  %c0 = arith.constant 0 : index
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() : memref<16384xf32>
  %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  linalg.fill ins(%cst : f32) outs(%alloc : memref<16384xf32>)
  %4 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8, %arg9) = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
    %5 = arith.muli %arg8, %c128 : index
    %6 = arith.addi %5, %arg9 : index
    %7 = memref.load %alloc[%6] : memref<16384xf32>
    %8 = memref.load %arg0[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg0[%9] : memref<?xindex>
    %11 = memref.load %arg4[%arg9] : memref<?xindex>
    %12 = arith.addi %arg9, %c1 : index
    %13 = memref.load %arg4[%12] : memref<?xindex>
    %14:3 = scf.while (%arg10 = %8, %arg11 = %11, %arg12 = %7) : (index, index, f32) -> (index, index, f32) {
      %15 = arith.cmpi ult, %arg10, %10 : index
      %16 = arith.cmpi ult, %arg11, %13 : index
      %17 = arith.andi %15, %16 : i1
      scf.condition(%17) %arg10, %arg11, %arg12 : index, index, f32
    } do {
    ^bb0(%arg10: index, %arg11: index, %arg12: f32):
      %15 = memref.load %arg1[%arg10] : memref<?xindex>
      %16 = memref.load %arg5[%arg11] : memref<?xindex>
      %17 = arith.cmpi ult, %16, %15 : index
      %18 = arith.select %17, %16, %15 : index
      %19 = arith.cmpi eq, %15, %18 : index
      %20 = arith.cmpi eq, %16, %18 : index
      %21 = arith.andi %19, %20 : i1
      %22 = scf.if %21 -> (f32) {
        %29 = memref.load %arg2[%arg10] : memref<?xf32>
        %30 = memref.load %arg6[%arg11] : memref<?xf32>
        %31 = arith.mulf %29, %30 : f32
        %32 = arith.addf %arg12, %31 : f32
        scf.yield %32 : f32
      } else {
        scf.yield %arg12 : f32
      }
      %23 = arith.cmpi eq, %15, %18 : index
      %24 = arith.addi %arg10, %c1 : index
      %25 = arith.select %23, %24, %arg10 : index
      %26 = arith.cmpi eq, %16, %18 : index
      %27 = arith.addi %arg11, %c1 : index
      %28 = arith.select %26, %27, %arg11 : index
      scf.yield %25, %28, %22 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    memref.store %14#2, %alloc[%6] : memref<16384xf32>
    scf.yield
  }
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c16384_i64 = arith.constant 16384 : i64
  %c0 = arith.constant 0 : index
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() : memref<16384xf32>
  %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  linalg.fill ins(%cst : f32) outs(%alloc : memref<16384xf32>)
  %4 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8, %arg9) = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
    %5 = arith.muli %arg8, %c128 : index
    %6 = arith.addi %5, %arg9 : index
    %7 = memref.load %alloc[%6] : memref<16384xf32>
    %8 = memref.load %arg0[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg0[%9] : memref<?xindex>
    %11 = memref.load %arg4[%arg9] : memref<?xindex>
    %12 = arith.addi %arg9, %c1 : index
    %13 = memref.load %arg4[%12] : memref<?xindex>
    %14:3 = scf.while (%arg10 = %8, %arg11 = %11, %arg12 = %7) : (index, index, f32) -> (index, index, f32) {
      %15 = arith.cmpi ult, %arg10, %10 : index
      %16 = arith.cmpi ult, %arg11, %13 : index
      %17 = arith.andi %15, %16 : i1
      scf.condition(%17) %arg10, %arg11, %arg12 : index, index, f32
    } do {
    ^bb0(%arg10: index, %arg11: index, %arg12: f32):
      %15 = memref.load %arg1[%arg10] : memref<?xindex>
      %16 = memref.load %arg5[%arg11] : memref<?xindex>
      %17 = arith.cmpi ult, %16, %15 : index
      %18 = arith.select %17, %16, %15 : index
      %19 = arith.cmpi eq, %15, %18 : index
      %20 = arith.cmpi eq, %16, %18 : index
      %21 = arith.andi %19, %20 : i1
      %22 = scf.if %21 -> (f32) {
        %29 = memref.load %arg2[%arg10] : memref<?xf32>
        %30 = memref.load %arg6[%arg11] : memref<?xf32>
        %31 = arith.mulf %29, %30 : f32
        %32 = arith.addf %arg12, %31 : f32
        scf.yield %32 : f32
      } else {
        scf.yield %arg12 : f32
      }
      %23 = arith.cmpi eq, %15, %18 : index
      %24 = arith.addi %arg10, %c1 : index
      %25 = arith.select %23, %24, %arg10 : index
      %26 = arith.cmpi eq, %16, %18 : index
      %27 = arith.addi %arg11, %c1 : index
      %28 = arith.select %26, %27, %arg11 : index
      scf.yield %25, %28, %22 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    memref.store %14#2, %alloc[%6] : memref<16384xf32>
    scf.yield
  }
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() : memref<16384xf32>
  %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg8 = %c0 to %c16384 step %c1 {
    memref.store %cst, %alloc[%arg8] : memref<16384xf32>
  }
  %4 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8, %arg9) = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
    %5 = arith.muli %arg8, %c128 : index
    %6 = arith.addi %5, %arg9 : index
    %7 = memref.load %alloc[%6] : memref<16384xf32>
    %8 = memref.load %arg0[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg0[%9] : memref<?xindex>
    %11 = memref.load %arg4[%arg9] : memref<?xindex>
    %12 = arith.addi %arg9, %c1 : index
    %13 = memref.load %arg4[%12] : memref<?xindex>
    %14:3 = scf.while (%arg10 = %8, %arg11 = %11, %arg12 = %7) : (index, index, f32) -> (index, index, f32) {
      %15 = arith.cmpi ult, %arg10, %10 : index
      %16 = arith.cmpi ult, %arg11, %13 : index
      %17 = arith.andi %15, %16 : i1
      scf.condition(%17) %arg10, %arg11, %arg12 : index, index, f32
    } do {
    ^bb0(%arg10: index, %arg11: index, %arg12: f32):
      %15 = memref.load %arg1[%arg10] : memref<?xindex>
      %16 = memref.load %arg5[%arg11] : memref<?xindex>
      %17 = arith.cmpi ult, %16, %15 : index
      %18 = arith.select %17, %16, %15 : index
      %19 = arith.cmpi eq, %15, %18 : index
      %20 = arith.cmpi eq, %16, %18 : index
      %21 = arith.andi %19, %20 : i1
      %22 = scf.if %21 -> (f32) {
        %29 = memref.load %arg2[%arg10] : memref<?xf32>
        %30 = memref.load %arg6[%arg11] : memref<?xf32>
        %31 = arith.mulf %29, %30 : f32
        %32 = arith.addf %arg12, %31 : f32
        scf.yield %32 : f32
      } else {
        scf.yield %arg12 : f32
      }
      %23 = arith.cmpi eq, %15, %18 : index
      %24 = arith.addi %arg10, %c1 : index
      %25 = arith.select %23, %24, %arg10 : index
      %26 = arith.cmpi eq, %16, %18 : index
      %27 = arith.addi %arg11, %c1 : index
      %28 = arith.select %26, %27, %arg11 : index
      scf.yield %25, %28, %22 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    memref.store %14#2, %alloc[%6] : memref<16384xf32>
    scf.yield
  }
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() : memref<16384xf32>
  %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg8 = %c0 to %c16384 step %c1 {
    memref.store %cst, %alloc[%arg8] : memref<16384xf32>
  }
  %4 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8, %arg9) = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
    %5 = arith.muli %arg8, %c128 : index
    %6 = arith.addi %5, %arg9 : index
    %7 = memref.load %alloc[%6] : memref<16384xf32>
    %8 = memref.load %arg0[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg0[%9] : memref<?xindex>
    %11 = memref.load %arg4[%arg9] : memref<?xindex>
    %12 = arith.addi %arg9, %c1 : index
    %13 = memref.load %arg4[%12] : memref<?xindex>
    %14:3 = scf.while (%arg10 = %8, %arg11 = %11, %arg12 = %7) : (index, index, f32) -> (index, index, f32) {
      %15 = arith.cmpi ult, %arg10, %10 : index
      %16 = arith.cmpi ult, %arg11, %13 : index
      %17 = arith.andi %15, %16 : i1
      scf.condition(%17) %arg10, %arg11, %arg12 : index, index, f32
    } do {
    ^bb0(%arg10: index, %arg11: index, %arg12: f32):
      %15 = memref.load %arg1[%arg10] : memref<?xindex>
      %16 = memref.load %arg5[%arg11] : memref<?xindex>
      %17 = arith.cmpi ult, %16, %15 : index
      %18 = arith.select %17, %16, %15 : index
      %19 = arith.cmpi eq, %15, %18 : index
      %20 = arith.cmpi eq, %16, %18 : index
      %21 = arith.andi %19, %20 : i1
      %22 = scf.if %21 -> (f32) {
        %29 = memref.load %arg2[%arg10] : memref<?xf32>
        %30 = memref.load %arg6[%arg11] : memref<?xf32>
        %31 = arith.mulf %29, %30 : f32
        %32 = arith.addf %arg12, %31 : f32
        scf.yield %32 : f32
      } else {
        scf.yield %arg12 : f32
      }
      %23 = arith.cmpi eq, %15, %18 : index
      %24 = arith.addi %arg10, %c1 : index
      %25 = arith.select %23, %24, %arg10 : index
      %26 = arith.cmpi eq, %16, %18 : index
      %27 = arith.addi %arg11, %c1 : index
      %28 = arith.select %26, %27, %arg11 : index
      scf.yield %25, %28, %22 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    memref.store %14#2, %alloc[%6] : memref<16384xf32>
    scf.yield
  }
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertSCFToOpenMPPass (convert-scf-to-openmp) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() : memref<16384xf32>
    %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.for %arg8 = %c0 to %c16384 step %c1 {
      memref.store %cst, %alloc[%arg8] : memref<16384xf32>
    }
    %4 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %5 = llvm.mlir.constant(1 : i64) : i64
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        memref.alloca_scope  {
          %6 = arith.muli %arg8, %c128 : index
          %7 = arith.addi %6, %arg9 : index
          %8 = memref.load %alloc[%7] : memref<16384xf32>
          %9 = memref.load %arg0[%arg8] : memref<?xindex>
          %10 = arith.addi %arg8, %c1 : index
          %11 = memref.load %arg0[%10] : memref<?xindex>
          %12 = memref.load %arg4[%arg9] : memref<?xindex>
          %13 = arith.addi %arg9, %c1 : index
          %14 = memref.load %arg4[%13] : memref<?xindex>
          %15:3 = scf.while (%arg10 = %9, %arg11 = %12, %arg12 = %8) : (index, index, f32) -> (index, index, f32) {
            %16 = arith.cmpi ult, %arg10, %11 : index
            %17 = arith.cmpi ult, %arg11, %14 : index
            %18 = arith.andi %16, %17 : i1
            scf.condition(%18) %arg10, %arg11, %arg12 : index, index, f32
          } do {
          ^bb0(%arg10: index, %arg11: index, %arg12: f32):
            %16 = memref.load %arg1[%arg10] : memref<?xindex>
            %17 = memref.load %arg5[%arg11] : memref<?xindex>
            %18 = arith.cmpi ult, %17, %16 : index
            %19 = arith.select %18, %17, %16 : index
            %20 = arith.cmpi eq, %16, %19 : index
            %21 = arith.cmpi eq, %17, %19 : index
            %22 = arith.andi %20, %21 : i1
            %23 = scf.if %22 -> (f32) {
              %30 = memref.load %arg2[%arg10] : memref<?xf32>
              %31 = memref.load %arg6[%arg11] : memref<?xf32>
              %32 = arith.mulf %30, %31 : f32
              %33 = arith.addf %arg12, %32 : f32
              scf.yield %33 : f32
            } else {
              scf.yield %arg12 : f32
            }
            %24 = arith.cmpi eq, %16, %19 : index
            %25 = arith.addi %arg10, %c1 : index
            %26 = arith.select %24, %25, %arg10 : index
            %27 = arith.cmpi eq, %17, %19 : index
            %28 = arith.addi %arg11, %c1 : index
            %29 = arith.select %27, %28, %arg11 : index
            scf.yield %26, %29, %23 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          memref.store %15#2, %alloc[%7] : memref<16384xf32>
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() : memref<16384xf32>
  %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg8 = %c0 to %c16384 step %c1 {
    memref.store %cst, %alloc[%arg8] : memref<16384xf32>
  }
  %4 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
      %5 = arith.muli %arg8, %c128 : index
      %6 = arith.addi %5, %arg9 : index
      %7 = memref.load %alloc[%6] : memref<16384xf32>
      %8 = memref.load %arg0[%arg8] : memref<?xindex>
      %9 = arith.addi %arg8, %c1 : index
      %10 = memref.load %arg0[%9] : memref<?xindex>
      %11 = memref.load %arg4[%arg9] : memref<?xindex>
      %12 = arith.addi %arg9, %c1 : index
      %13 = memref.load %arg4[%12] : memref<?xindex>
      %14:3 = scf.while (%arg10 = %8, %arg11 = %11, %arg12 = %7) : (index, index, f32) -> (index, index, f32) {
        %15 = arith.cmpi ult, %arg10, %10 : index
        %16 = arith.cmpi ult, %arg11, %13 : index
        %17 = arith.andi %15, %16 : i1
        scf.condition(%17) %arg10, %arg11, %arg12 : index, index, f32
      } do {
      ^bb0(%arg10: index, %arg11: index, %arg12: f32):
        %15 = memref.load %arg1[%arg10] : memref<?xindex>
        %16 = memref.load %arg5[%arg11] : memref<?xindex>
        %17 = arith.cmpi ult, %16, %15 : index
        %18 = arith.select %17, %16, %15 : index
        %19 = arith.cmpi eq, %15, %18 : index
        %20 = arith.cmpi eq, %16, %18 : index
        %21 = arith.andi %19, %20 : i1
        %22 = scf.if %21 -> (f32) {
          %29 = memref.load %arg2[%arg10] : memref<?xf32>
          %30 = memref.load %arg6[%arg11] : memref<?xf32>
          %31 = arith.mulf %29, %30 : f32
          %32 = arith.addf %arg12, %31 : f32
          scf.yield %32 : f32
        } else {
          scf.yield %arg12 : f32
        }
        %23 = arith.cmpi eq, %15, %18 : index
        %24 = arith.addi %arg10, %c1 : index
        %25 = arith.select %23, %24, %arg10 : index
        %26 = arith.cmpi eq, %16, %18 : index
        %27 = arith.addi %arg11, %c1 : index
        %28 = arith.select %26, %27, %arg11 : index
        scf.yield %25, %28, %22 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      memref.store %14#2, %alloc[%6] : memref<16384xf32>
      omp.yield
    }
    omp.terminator
  }
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() : memref<16384xf32>
  %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
  %5 = arith.cmpi slt, %4, %c16384 : index
  cf.cond_br %5, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  memref.store %cst, %alloc[%4] : memref<16384xf32>
  %6 = arith.addi %4, %c1 : index
  cf.br ^bb1(%6 : index)
^bb3:  // pred: ^bb1
  %7 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
      %8 = arith.muli %arg8, %c128 : index
      %9 = arith.addi %8, %arg9 : index
      %10 = memref.load %alloc[%9] : memref<16384xf32>
      %11 = memref.load %arg0[%arg8] : memref<?xindex>
      %12 = arith.addi %arg8, %c1 : index
      %13 = memref.load %arg0[%12] : memref<?xindex>
      %14 = memref.load %arg4[%arg9] : memref<?xindex>
      %15 = arith.addi %arg9, %c1 : index
      %16 = memref.load %arg4[%15] : memref<?xindex>
      cf.br ^bb1(%11, %14, %10 : index, index, f32)
    ^bb1(%17: index, %18: index, %19: f32):  // 2 preds: ^bb0, ^bb6
      %20 = arith.cmpi ult, %17, %13 : index
      %21 = arith.cmpi ult, %18, %16 : index
      %22 = arith.andi %20, %21 : i1
      cf.cond_br %22, ^bb2(%17, %18, %19 : index, index, f32), ^bb7
    ^bb2(%23: index, %24: index, %25: f32):  // pred: ^bb1
      %26 = memref.load %arg1[%23] : memref<?xindex>
      %27 = memref.load %arg5[%24] : memref<?xindex>
      %28 = arith.cmpi ult, %27, %26 : index
      %29 = arith.select %28, %27, %26 : index
      %30 = arith.cmpi eq, %26, %29 : index
      %31 = arith.cmpi eq, %27, %29 : index
      %32 = arith.andi %30, %31 : i1
      cf.cond_br %32, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %33 = memref.load %arg2[%23] : memref<?xf32>
      %34 = memref.load %arg6[%24] : memref<?xf32>
      %35 = arith.mulf %33, %34 : f32
      %36 = arith.addf %25, %35 : f32
      cf.br ^bb5(%36 : f32)
    ^bb4:  // pred: ^bb2
      cf.br ^bb5(%25 : f32)
    ^bb5(%37: f32):  // 2 preds: ^bb3, ^bb4
      cf.br ^bb6
    ^bb6:  // pred: ^bb5
      %38 = arith.cmpi eq, %26, %29 : index
      %39 = arith.addi %23, %c1 : index
      %40 = arith.select %38, %39, %23 : index
      %41 = arith.cmpi eq, %27, %29 : index
      %42 = arith.addi %24, %c1 : index
      %43 = arith.select %41, %42, %24 : index
      cf.br ^bb1(%40, %43, %37 : index, index, f32)
    ^bb7:  // pred: ^bb1
      memref.store %19, %alloc[%9] : memref<16384xf32>
      omp.yield
    }
    omp.terminator
  }
  return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ExpandStridedMetadata (expand-strided-metadata) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() : memref<16384xf32>
    %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %c16384 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc[%4] : memref<16384xf32>
    %6 = arith.addi %4, %c1 : index
    cf.br ^bb1(%6 : index)
  ^bb3:  // pred: ^bb1
    %7 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %8 = arith.muli %arg8, %c128 : index
        %9 = arith.addi %8, %arg9 : index
        %10 = memref.load %alloc[%9] : memref<16384xf32>
        %11 = memref.load %arg0[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg0[%12] : memref<?xindex>
        %14 = memref.load %arg4[%arg9] : memref<?xindex>
        %15 = arith.addi %arg9, %c1 : index
        %16 = memref.load %arg4[%15] : memref<?xindex>
        cf.br ^bb1(%11, %14, %10 : index, index, f32)
      ^bb1(%17: index, %18: index, %19: f32):  // 2 preds: ^bb0, ^bb6
        %20 = arith.cmpi ult, %17, %13 : index
        %21 = arith.cmpi ult, %18, %16 : index
        %22 = arith.andi %20, %21 : i1
        cf.cond_br %22, ^bb2(%17, %18, %19 : index, index, f32), ^bb7
      ^bb2(%23: index, %24: index, %25: f32):  // pred: ^bb1
        %26 = memref.load %arg1[%23] : memref<?xindex>
        %27 = memref.load %arg5[%24] : memref<?xindex>
        %28 = arith.cmpi ult, %27, %26 : index
        %29 = arith.select %28, %27, %26 : index
        %30 = arith.cmpi eq, %26, %29 : index
        %31 = arith.cmpi eq, %27, %29 : index
        %32 = arith.andi %30, %31 : i1
        cf.cond_br %32, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %33 = memref.load %arg2[%23] : memref<?xf32>
        %34 = memref.load %arg6[%24] : memref<?xf32>
        %35 = arith.mulf %33, %34 : f32
        %36 = arith.addf %25, %35 : f32
        cf.br ^bb5(%36 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%25 : f32)
      ^bb5(%37: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %38 = arith.cmpi eq, %26, %29 : index
        %39 = arith.addi %23, %c1 : index
        %40 = arith.select %38, %39, %23 : index
        %41 = arith.cmpi eq, %27, %29 : index
        %42 = arith.addi %24, %c1 : index
        %43 = arith.select %41, %42, %24 : index
        cf.br ^bb1(%40, %43, %37 : index, index, f32)
      ^bb7:  // pred: ^bb1
        memref.store %19, %alloc[%9] : memref<16384xf32>
        omp.yield
      }
      omp.terminator
    }
    return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertAffineToStandard (lower-affine) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() : memref<16384xf32>
    %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %c16384 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc[%4] : memref<16384xf32>
    %6 = arith.addi %4, %c1 : index
    cf.br ^bb1(%6 : index)
  ^bb3:  // pred: ^bb1
    %7 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %8 = arith.muli %arg8, %c128 : index
        %9 = arith.addi %8, %arg9 : index
        %10 = memref.load %alloc[%9] : memref<16384xf32>
        %11 = memref.load %arg0[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg0[%12] : memref<?xindex>
        %14 = memref.load %arg4[%arg9] : memref<?xindex>
        %15 = arith.addi %arg9, %c1 : index
        %16 = memref.load %arg4[%15] : memref<?xindex>
        cf.br ^bb1(%11, %14, %10 : index, index, f32)
      ^bb1(%17: index, %18: index, %19: f32):  // 2 preds: ^bb0, ^bb6
        %20 = arith.cmpi ult, %17, %13 : index
        %21 = arith.cmpi ult, %18, %16 : index
        %22 = arith.andi %20, %21 : i1
        cf.cond_br %22, ^bb2(%17, %18, %19 : index, index, f32), ^bb7
      ^bb2(%23: index, %24: index, %25: f32):  // pred: ^bb1
        %26 = memref.load %arg1[%23] : memref<?xindex>
        %27 = memref.load %arg5[%24] : memref<?xindex>
        %28 = arith.cmpi ult, %27, %26 : index
        %29 = arith.select %28, %27, %26 : index
        %30 = arith.cmpi eq, %26, %29 : index
        %31 = arith.cmpi eq, %27, %29 : index
        %32 = arith.andi %30, %31 : i1
        cf.cond_br %32, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %33 = memref.load %arg2[%23] : memref<?xf32>
        %34 = memref.load %arg6[%24] : memref<?xf32>
        %35 = arith.mulf %33, %34 : f32
        %36 = arith.addf %25, %35 : f32
        cf.br ^bb5(%36 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%25 : f32)
      ^bb5(%37: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %38 = arith.cmpi eq, %26, %29 : index
        %39 = arith.addi %23, %c1 : index
        %40 = arith.select %38, %39, %23 : index
        %41 = arith.cmpi eq, %27, %29 : index
        %42 = arith.addi %24, %c1 : index
        %43 = arith.select %41, %42, %24 : index
        cf.br ^bb1(%40, %43, %37 : index, index, f32)
      ^bb7:  // pred: ^bb1
        memref.store %19, %alloc[%9] : memref<16384xf32>
        omp.yield
      }
      omp.terminator
    }
    return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() : memref<16384xf32>
    %cast = memref.cast %alloc : memref<16384xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c128_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %c16384 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc[%4] : memref<16384xf32>
    %6 = arith.addi %4, %c1 : index
    cf.br ^bb1(%6 : index)
  ^bb3:  // pred: ^bb1
    %7 = llvm.insertvalue %c16384_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %8 = arith.muli %arg8, %c128 : index
        %9 = arith.addi %8, %arg9 : index
        %10 = memref.load %alloc[%9] : memref<16384xf32>
        %11 = memref.load %arg0[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg0[%12] : memref<?xindex>
        %14 = memref.load %arg4[%arg9] : memref<?xindex>
        %15 = arith.addi %arg9, %c1 : index
        %16 = memref.load %arg4[%15] : memref<?xindex>
        cf.br ^bb1(%11, %14, %10 : index, index, f32)
      ^bb1(%17: index, %18: index, %19: f32):  // 2 preds: ^bb0, ^bb6
        %20 = arith.cmpi ult, %17, %13 : index
        %21 = arith.cmpi ult, %18, %16 : index
        %22 = arith.andi %20, %21 : i1
        cf.cond_br %22, ^bb2(%17, %18, %19 : index, index, f32), ^bb7
      ^bb2(%23: index, %24: index, %25: f32):  // pred: ^bb1
        %26 = memref.load %arg1[%23] : memref<?xindex>
        %27 = memref.load %arg5[%24] : memref<?xindex>
        %28 = arith.cmpi ult, %27, %26 : index
        %29 = arith.select %28, %27, %26 : index
        %30 = arith.cmpi eq, %26, %29 : index
        %31 = arith.cmpi eq, %27, %29 : index
        %32 = arith.andi %30, %31 : i1
        cf.cond_br %32, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %33 = memref.load %arg2[%23] : memref<?xf32>
        %34 = memref.load %arg6[%24] : memref<?xf32>
        %35 = arith.mulf %33, %34 : f32
        %36 = arith.addf %25, %35 : f32
        cf.br ^bb5(%36 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%25 : f32)
      ^bb5(%37: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %38 = arith.cmpi eq, %26, %29 : index
        %39 = arith.addi %23, %c1 : index
        %40 = arith.select %38, %39, %23 : index
        %41 = arith.cmpi eq, %27, %29 : index
        %42 = arith.addi %24, %c1 : index
        %43 = arith.select %41, %42, %24 : index
        cf.br ^bb1(%40, %43, %37 : index, index, f32)
      ^bb7:  // pred: ^bb1
        memref.store %19, %alloc[%9] : memref<16384xf32>
        omp.yield
      }
      omp.terminator
    }
    return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After FinalizeMemRefToLLVMConversionPass (finalize-memref-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %6 = llvm.mlir.constant(16384 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.null : !llvm.ptr
    %9 = llvm.getelementptr %8[%6] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
    %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c16384 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.getelementptr %27[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %28 : f32, !llvm.ptr
    %29 = arith.addi %24, %c1 : index
    cf.br ^bb1(%29 : index)
  ^bb3:  // pred: ^bb1
    %30 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %31 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %32 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %33 = arith.muli %arg8, %c128 : index
        %34 = arith.addi %33, %arg9 : index
        %35 = builtin.unrealized_conversion_cast %34 : index to i64
        %36 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %37 = llvm.getelementptr %36[%35] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %38 = llvm.load %37 : !llvm.ptr -> f32
        %39 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %40 = llvm.getelementptr %39[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %41 = llvm.load %40 : !llvm.ptr -> i64
        %42 = builtin.unrealized_conversion_cast %41 : i64 to index
        %43 = arith.addi %arg8, %c1 : index
        %44 = builtin.unrealized_conversion_cast %43 : index to i64
        %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %46 = llvm.getelementptr %45[%44] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %47 = llvm.load %46 : !llvm.ptr -> i64
        %48 = builtin.unrealized_conversion_cast %47 : i64 to index
        %49 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %50 = llvm.getelementptr %49[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %51 = llvm.load %50 : !llvm.ptr -> i64
        %52 = builtin.unrealized_conversion_cast %51 : i64 to index
        %53 = arith.addi %arg9, %c1 : index
        %54 = builtin.unrealized_conversion_cast %53 : index to i64
        %55 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %56 = llvm.getelementptr %55[%54] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %57 = llvm.load %56 : !llvm.ptr -> i64
        %58 = builtin.unrealized_conversion_cast %57 : i64 to index
        cf.br ^bb1(%42, %52, %38 : index, index, f32)
      ^bb1(%59: index, %60: index, %61: f32):  // 2 preds: ^bb0, ^bb6
        %62 = arith.cmpi ult, %59, %48 : index
        %63 = arith.cmpi ult, %60, %58 : index
        %64 = arith.andi %62, %63 : i1
        cf.cond_br %64, ^bb2(%59, %60, %61 : index, index, f32), ^bb7
      ^bb2(%65: index, %66: index, %67: f32):  // pred: ^bb1
        %68 = builtin.unrealized_conversion_cast %65 : index to i64
        %69 = builtin.unrealized_conversion_cast %66 : index to i64
        %70 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %71 = llvm.getelementptr %70[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %72 = llvm.load %71 : !llvm.ptr -> i64
        %73 = builtin.unrealized_conversion_cast %72 : i64 to index
        %74 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %75 = llvm.getelementptr %74[%69] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %76 = llvm.load %75 : !llvm.ptr -> i64
        %77 = builtin.unrealized_conversion_cast %76 : i64 to index
        %78 = arith.cmpi ult, %77, %73 : index
        %79 = arith.select %78, %77, %73 : index
        %80 = arith.cmpi eq, %73, %79 : index
        %81 = arith.cmpi eq, %77, %79 : index
        %82 = arith.andi %80, %81 : i1
        cf.cond_br %82, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %83 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %84 = llvm.getelementptr %83[%68] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %85 = llvm.load %84 : !llvm.ptr -> f32
        %86 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %87 = llvm.getelementptr %86[%69] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %88 = llvm.load %87 : !llvm.ptr -> f32
        %89 = arith.mulf %85, %88 : f32
        %90 = arith.addf %67, %89 : f32
        cf.br ^bb5(%90 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%67 : f32)
      ^bb5(%91: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %92 = arith.cmpi eq, %73, %79 : index
        %93 = arith.addi %65, %c1 : index
        %94 = arith.select %92, %93, %65 : index
        %95 = arith.cmpi eq, %77, %79 : index
        %96 = arith.addi %66, %c1 : index
        %97 = arith.select %95, %96, %66 : index
        cf.br ^bb1(%94, %97, %91 : index, index, f32)
      ^bb7:  // pred: ^bb1
        %98 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %99 = llvm.getelementptr %98[%35] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %61, %99 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    return %19, %30 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %6 = llvm.mlir.constant(16384 : index) : i64
  %7 = llvm.mlir.constant(1 : index) : i64
  %8 = llvm.mlir.null : !llvm.ptr
  %9 = llvm.getelementptr %8[16384] : (!llvm.ptr) -> !llvm.ptr, f32
  %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
  %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
  %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.mlir.constant(0 : index) : i64
  %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
  %25 = builtin.unrealized_conversion_cast %24 : index to i64
  %26 = arith.cmpi slt, %24, %c16384 : index
  cf.cond_br %26, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %27 : f32, !llvm.ptr
  %28 = arith.addi %24, %c1 : index
  cf.br ^bb1(%28 : index)
^bb3:  // pred: ^bb1
  %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
      %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
      %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
      %32 = arith.muli %arg8, %c128 : index
      %33 = arith.addi %32, %arg9 : index
      %34 = builtin.unrealized_conversion_cast %33 : index to i64
      %35 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %36 = llvm.load %35 : !llvm.ptr -> f32
      %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %39 = llvm.load %38 : !llvm.ptr -> i64
      %40 = builtin.unrealized_conversion_cast %39 : i64 to index
      %41 = arith.addi %arg8, %c1 : index
      %42 = builtin.unrealized_conversion_cast %41 : index to i64
      %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %45 = llvm.load %44 : !llvm.ptr -> i64
      %46 = builtin.unrealized_conversion_cast %45 : i64 to index
      %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %49 = llvm.load %48 : !llvm.ptr -> i64
      %50 = builtin.unrealized_conversion_cast %49 : i64 to index
      %51 = arith.addi %arg9, %c1 : index
      %52 = builtin.unrealized_conversion_cast %51 : index to i64
      %53 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %55 = llvm.load %54 : !llvm.ptr -> i64
      %56 = builtin.unrealized_conversion_cast %55 : i64 to index
      cf.br ^bb1(%40, %50, %36 : index, index, f32)
    ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
      %60 = arith.cmpi ult, %57, %46 : index
      %61 = arith.cmpi ult, %58, %56 : index
      %62 = arith.andi %60, %61 : i1
      cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
    ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
      %66 = builtin.unrealized_conversion_cast %63 : index to i64
      %67 = builtin.unrealized_conversion_cast %64 : index to i64
      %68 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %70 = llvm.load %69 : !llvm.ptr -> i64
      %71 = builtin.unrealized_conversion_cast %70 : i64 to index
      %72 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %74 = llvm.load %73 : !llvm.ptr -> i64
      %75 = builtin.unrealized_conversion_cast %74 : i64 to index
      %76 = arith.cmpi ult, %75, %71 : index
      %77 = arith.select %76, %75, %71 : index
      %78 = arith.cmpi eq, %71, %77 : index
      %79 = arith.cmpi eq, %75, %77 : index
      %80 = arith.andi %78, %79 : i1
      cf.cond_br %80, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %81 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %83 = llvm.load %82 : !llvm.ptr -> f32
      %84 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %86 = llvm.load %85 : !llvm.ptr -> f32
      %87 = arith.mulf %83, %86 : f32
      %88 = arith.addf %65, %87 : f32
      cf.br ^bb5(%88 : f32)
    ^bb4:  // pred: ^bb2
      cf.br ^bb5(%65 : f32)
    ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
      cf.br ^bb6
    ^bb6:  // pred: ^bb5
      %90 = arith.cmpi eq, %71, %77 : index
      %91 = arith.addi %63, %c1 : index
      %92 = arith.select %90, %91, %63 : index
      %93 = arith.cmpi eq, %75, %77 : index
      %94 = arith.addi %64, %c1 : index
      %95 = arith.select %93, %94, %64 : index
      cf.br ^bb1(%92, %95, %89 : index, index, f32)
    ^bb7:  // pred: ^bb1
      %96 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %59, %96 : f32, !llvm.ptr
      omp.yield
    }
    omp.terminator
  }
  return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %6 = llvm.mlir.constant(16384 : index) : i64
  %7 = llvm.mlir.constant(1 : index) : i64
  %8 = llvm.mlir.null : !llvm.ptr
  %9 = llvm.getelementptr %8[16384] : (!llvm.ptr) -> !llvm.ptr, f32
  %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
  %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
  %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.mlir.constant(0 : index) : i64
  %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
  %25 = builtin.unrealized_conversion_cast %24 : index to i64
  %26 = arith.cmpi slt, %24, %c16384 : index
  cf.cond_br %26, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %27 : f32, !llvm.ptr
  %28 = arith.addi %24, %c1 : index
  cf.br ^bb1(%28 : index)
^bb3:  // pred: ^bb1
  %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
      %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
      %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
      %32 = arith.muli %arg8, %c128 : index
      %33 = arith.addi %32, %arg9 : index
      %34 = builtin.unrealized_conversion_cast %33 : index to i64
      %35 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %36 = llvm.load %35 : !llvm.ptr -> f32
      %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %39 = llvm.load %38 : !llvm.ptr -> i64
      %40 = builtin.unrealized_conversion_cast %39 : i64 to index
      %41 = arith.addi %arg8, %c1 : index
      %42 = builtin.unrealized_conversion_cast %41 : index to i64
      %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %45 = llvm.load %44 : !llvm.ptr -> i64
      %46 = builtin.unrealized_conversion_cast %45 : i64 to index
      %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %49 = llvm.load %48 : !llvm.ptr -> i64
      %50 = builtin.unrealized_conversion_cast %49 : i64 to index
      %51 = arith.addi %arg9, %c1 : index
      %52 = builtin.unrealized_conversion_cast %51 : index to i64
      %53 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %55 = llvm.load %54 : !llvm.ptr -> i64
      %56 = builtin.unrealized_conversion_cast %55 : i64 to index
      cf.br ^bb1(%40, %50, %36 : index, index, f32)
    ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
      %60 = arith.cmpi ult, %57, %46 : index
      %61 = arith.cmpi ult, %58, %56 : index
      %62 = arith.andi %60, %61 : i1
      cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
    ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
      %66 = builtin.unrealized_conversion_cast %63 : index to i64
      %67 = builtin.unrealized_conversion_cast %64 : index to i64
      %68 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %70 = llvm.load %69 : !llvm.ptr -> i64
      %71 = builtin.unrealized_conversion_cast %70 : i64 to index
      %72 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %74 = llvm.load %73 : !llvm.ptr -> i64
      %75 = builtin.unrealized_conversion_cast %74 : i64 to index
      %76 = arith.cmpi ult, %75, %71 : index
      %77 = arith.select %76, %75, %71 : index
      %78 = arith.cmpi eq, %71, %77 : index
      %79 = arith.cmpi eq, %75, %77 : index
      %80 = arith.andi %78, %79 : i1
      cf.cond_br %80, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %81 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %83 = llvm.load %82 : !llvm.ptr -> f32
      %84 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %86 = llvm.load %85 : !llvm.ptr -> f32
      %87 = arith.mulf %83, %86 : f32
      %88 = arith.addf %65, %87 : f32
      cf.br ^bb5(%88 : f32)
    ^bb4:  // pred: ^bb2
      cf.br ^bb5(%65 : f32)
    ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
      cf.br ^bb6
    ^bb6:  // pred: ^bb5
      %90 = arith.cmpi eq, %71, %77 : index
      %91 = arith.addi %63, %c1 : index
      %92 = arith.select %90, %91, %63 : index
      %93 = arith.cmpi eq, %75, %77 : index
      %94 = arith.addi %64, %c1 : index
      %95 = arith.select %93, %94, %64 : index
      cf.br ^bb1(%92, %95, %89 : index, index, f32)
    ^bb7:  // pred: ^bb1
      %96 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %59, %96 : f32, !llvm.ptr
      omp.yield
    }
    omp.terminator
  }
  return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %c16384 = arith.constant 16384 : index
  %c1 = arith.constant 1 : index
  %c16384_i64 = arith.constant 16384 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %6 = llvm.mlir.constant(16384 : index) : i64
  %7 = llvm.mlir.constant(1 : index) : i64
  %8 = llvm.mlir.null : !llvm.ptr
  %9 = llvm.getelementptr %8[16384] : (!llvm.ptr) -> !llvm.ptr, f32
  %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
  %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
  %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.mlir.constant(0 : index) : i64
  %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
  %25 = builtin.unrealized_conversion_cast %24 : index to i64
  %26 = arith.cmpi slt, %24, %c16384 : index
  cf.cond_br %26, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %27 : f32, !llvm.ptr
  %28 = arith.addi %24, %c1 : index
  cf.br ^bb1(%28 : index)
^bb3:  // pred: ^bb1
  %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
      %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
      %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
      %32 = arith.muli %arg8, %c128 : index
      %33 = arith.addi %32, %arg9 : index
      %34 = builtin.unrealized_conversion_cast %33 : index to i64
      %35 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %36 = llvm.load %35 : !llvm.ptr -> f32
      %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %39 = llvm.load %38 : !llvm.ptr -> i64
      %40 = builtin.unrealized_conversion_cast %39 : i64 to index
      %41 = arith.addi %arg8, %c1 : index
      %42 = builtin.unrealized_conversion_cast %41 : index to i64
      %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %45 = llvm.load %44 : !llvm.ptr -> i64
      %46 = builtin.unrealized_conversion_cast %45 : i64 to index
      %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %49 = llvm.load %48 : !llvm.ptr -> i64
      %50 = builtin.unrealized_conversion_cast %49 : i64 to index
      %51 = arith.addi %arg9, %c1 : index
      %52 = builtin.unrealized_conversion_cast %51 : index to i64
      %53 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %55 = llvm.load %54 : !llvm.ptr -> i64
      %56 = builtin.unrealized_conversion_cast %55 : i64 to index
      cf.br ^bb1(%40, %50, %36 : index, index, f32)
    ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
      %60 = arith.cmpi ult, %57, %46 : index
      %61 = arith.cmpi ult, %58, %56 : index
      %62 = arith.andi %60, %61 : i1
      cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
    ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
      %66 = builtin.unrealized_conversion_cast %63 : index to i64
      %67 = builtin.unrealized_conversion_cast %64 : index to i64
      %68 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %70 = llvm.load %69 : !llvm.ptr -> i64
      %71 = builtin.unrealized_conversion_cast %70 : i64 to index
      %72 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %74 = llvm.load %73 : !llvm.ptr -> i64
      %75 = builtin.unrealized_conversion_cast %74 : i64 to index
      %76 = arith.cmpi ult, %75, %71 : index
      %77 = arith.select %76, %75, %71 : index
      %78 = arith.cmpi eq, %71, %77 : index
      %79 = arith.cmpi eq, %75, %77 : index
      %80 = arith.andi %78, %79 : i1
      cf.cond_br %80, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %81 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %83 = llvm.load %82 : !llvm.ptr -> f32
      %84 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %86 = llvm.load %85 : !llvm.ptr -> f32
      %87 = arith.mulf %83, %86 : f32
      %88 = arith.addf %65, %87 : f32
      cf.br ^bb5(%88 : f32)
    ^bb4:  // pred: ^bb2
      cf.br ^bb5(%65 : f32)
    ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
      cf.br ^bb6
    ^bb6:  // pred: ^bb5
      %90 = arith.cmpi eq, %71, %77 : index
      %91 = arith.addi %63, %c1 : index
      %92 = arith.select %90, %91, %63 : index
      %93 = arith.cmpi eq, %75, %77 : index
      %94 = arith.addi %64, %c1 : index
      %95 = arith.select %93, %94, %64 : index
      cf.br ^bb1(%92, %95, %89 : index, index, f32)
    ^bb7:  // pred: ^bb1
      %96 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %59, %96 : f32, !llvm.ptr
      omp.yield
    }
    omp.terminator
  }
  return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertMathToLibm (convert-math-to-libm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %6 = llvm.mlir.constant(16384 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.null : !llvm.ptr
    %9 = llvm.getelementptr %8[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
    %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c16384 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %32 = arith.muli %arg8, %c128 : index
        %33 = arith.addi %32, %arg9 : index
        %34 = builtin.unrealized_conversion_cast %33 : index to i64
        %35 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %36 = llvm.load %35 : !llvm.ptr -> f32
        %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = arith.addi %arg8, %c1 : index
        %42 = builtin.unrealized_conversion_cast %41 : index to i64
        %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %45 = llvm.load %44 : !llvm.ptr -> i64
        %46 = builtin.unrealized_conversion_cast %45 : i64 to index
        %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        %51 = arith.addi %arg9, %c1 : index
        %52 = builtin.unrealized_conversion_cast %51 : index to i64
        %53 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %55 = llvm.load %54 : !llvm.ptr -> i64
        %56 = builtin.unrealized_conversion_cast %55 : i64 to index
        cf.br ^bb1(%40, %50, %36 : index, index, f32)
      ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
        %60 = arith.cmpi ult, %57, %46 : index
        %61 = arith.cmpi ult, %58, %56 : index
        %62 = arith.andi %60, %61 : i1
        cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
      ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
        %66 = builtin.unrealized_conversion_cast %63 : index to i64
        %67 = builtin.unrealized_conversion_cast %64 : index to i64
        %68 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %70 = llvm.load %69 : !llvm.ptr -> i64
        %71 = builtin.unrealized_conversion_cast %70 : i64 to index
        %72 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %74 = llvm.load %73 : !llvm.ptr -> i64
        %75 = builtin.unrealized_conversion_cast %74 : i64 to index
        %76 = arith.cmpi ult, %75, %71 : index
        %77 = arith.select %76, %75, %71 : index
        %78 = arith.cmpi eq, %71, %77 : index
        %79 = arith.cmpi eq, %75, %77 : index
        %80 = arith.andi %78, %79 : i1
        cf.cond_br %80, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %81 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %83 = llvm.load %82 : !llvm.ptr -> f32
        %84 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %86 = llvm.load %85 : !llvm.ptr -> f32
        %87 = arith.mulf %83, %86 : f32
        %88 = arith.addf %65, %87 : f32
        cf.br ^bb5(%88 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%65 : f32)
      ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %90 = arith.cmpi eq, %71, %77 : index
        %91 = arith.addi %63, %c1 : index
        %92 = arith.select %90, %91, %63 : index
        %93 = arith.cmpi eq, %75, %77 : index
        %94 = arith.addi %64, %c1 : index
        %95 = arith.select %93, %94, %64 : index
        cf.br ^bb1(%92, %95, %89 : index, index, f32)
      ^bb7:  // pred: ^bb1
        %96 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %59, %96 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToLibm (convert-complex-to-libm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %c16384 = arith.constant 16384 : index
    %c1 = arith.constant 1 : index
    %c16384_i64 = arith.constant 16384 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %6 = llvm.mlir.constant(16384 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.null : !llvm.ptr
    %9 = llvm.getelementptr %8[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
    %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c16384 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %32 = arith.muli %arg8, %c128 : index
        %33 = arith.addi %32, %arg9 : index
        %34 = builtin.unrealized_conversion_cast %33 : index to i64
        %35 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %36 = llvm.load %35 : !llvm.ptr -> f32
        %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = arith.addi %arg8, %c1 : index
        %42 = builtin.unrealized_conversion_cast %41 : index to i64
        %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %45 = llvm.load %44 : !llvm.ptr -> i64
        %46 = builtin.unrealized_conversion_cast %45 : i64 to index
        %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        %51 = arith.addi %arg9, %c1 : index
        %52 = builtin.unrealized_conversion_cast %51 : index to i64
        %53 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %55 = llvm.load %54 : !llvm.ptr -> i64
        %56 = builtin.unrealized_conversion_cast %55 : i64 to index
        cf.br ^bb1(%40, %50, %36 : index, index, f32)
      ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
        %60 = arith.cmpi ult, %57, %46 : index
        %61 = arith.cmpi ult, %58, %56 : index
        %62 = arith.andi %60, %61 : i1
        cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
      ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
        %66 = builtin.unrealized_conversion_cast %63 : index to i64
        %67 = builtin.unrealized_conversion_cast %64 : index to i64
        %68 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %70 = llvm.load %69 : !llvm.ptr -> i64
        %71 = builtin.unrealized_conversion_cast %70 : i64 to index
        %72 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %74 = llvm.load %73 : !llvm.ptr -> i64
        %75 = builtin.unrealized_conversion_cast %74 : i64 to index
        %76 = arith.cmpi ult, %75, %71 : index
        %77 = arith.select %76, %75, %71 : index
        %78 = arith.cmpi eq, %71, %77 : index
        %79 = arith.cmpi eq, %75, %77 : index
        %80 = arith.andi %78, %79 : i1
        cf.cond_br %80, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %81 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %83 = llvm.load %82 : !llvm.ptr -> f32
        %84 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %86 = llvm.load %85 : !llvm.ptr -> f32
        %87 = arith.mulf %83, %86 : f32
        %88 = arith.addf %65, %87 : f32
        cf.br ^bb5(%88 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%65 : f32)
      ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %90 = arith.cmpi eq, %71, %77 : index
        %91 = arith.addi %63, %c1 : index
        %92 = arith.select %90, %91, %63 : index
        %93 = arith.cmpi eq, %75, %77 : index
        %94 = arith.addi %64, %c1 : index
        %95 = arith.select %93, %94, %64 : index
        cf.br ^bb1(%92, %95, %89 : index, index, f32)
      ^bb7:  // pred: ^bb1
        %96 = llvm.getelementptr %11[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %59, %96 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(1 : index) : i64
    %2 = llvm.mlir.constant(16384 : index) : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0_i64 = arith.constant 0 : i64
    %c128_i64 = arith.constant 128 : i64
    %c16384_i64 = arith.constant 16384 : i64
    %c1 = arith.constant 1 : index
    %c16384 = arith.constant 16384 : index
    %c0 = arith.constant 0 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = llvm.mlir.null : !llvm.ptr
    %10 = llvm.getelementptr %9[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %11 = llvm.ptrtoint %10 : !llvm.ptr to i64
    %12 = llvm.call @malloc(%11) : (i64) -> !llvm.ptr
    %13 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %0, %15[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %2, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %1, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c16384 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %32 = arith.muli %arg8, %c128 : index
        %33 = arith.addi %32, %arg9 : index
        %34 = builtin.unrealized_conversion_cast %33 : index to i64
        %35 = llvm.getelementptr %12[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %36 = llvm.load %35 : !llvm.ptr -> f32
        %37 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = arith.addi %arg8, %c1 : index
        %42 = builtin.unrealized_conversion_cast %41 : index to i64
        %43 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %45 = llvm.load %44 : !llvm.ptr -> i64
        %46 = builtin.unrealized_conversion_cast %45 : i64 to index
        %47 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        %51 = arith.addi %arg9, %c1 : index
        %52 = builtin.unrealized_conversion_cast %51 : index to i64
        %53 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %55 = llvm.load %54 : !llvm.ptr -> i64
        %56 = builtin.unrealized_conversion_cast %55 : i64 to index
        cf.br ^bb1(%40, %50, %36 : index, index, f32)
      ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
        %60 = arith.cmpi ult, %57, %46 : index
        %61 = arith.cmpi ult, %58, %56 : index
        %62 = arith.andi %60, %61 : i1
        cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
      ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
        %66 = builtin.unrealized_conversion_cast %63 : index to i64
        %67 = builtin.unrealized_conversion_cast %64 : index to i64
        %68 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %70 = llvm.load %69 : !llvm.ptr -> i64
        %71 = builtin.unrealized_conversion_cast %70 : i64 to index
        %72 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %74 = llvm.load %73 : !llvm.ptr -> i64
        %75 = builtin.unrealized_conversion_cast %74 : i64 to index
        %76 = arith.cmpi ult, %75, %71 : index
        %77 = arith.select %76, %75, %71 : index
        %78 = arith.cmpi eq, %71, %77 : index
        %79 = arith.cmpi eq, %75, %77 : index
        %80 = arith.andi %78, %79 : i1
        cf.cond_br %80, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %81 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %83 = llvm.load %82 : !llvm.ptr -> f32
        %84 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %86 = llvm.load %85 : !llvm.ptr -> f32
        %87 = arith.mulf %83, %86 : f32
        %88 = arith.addf %65, %87 : f32
        cf.br ^bb5(%88 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%65 : f32)
      ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %90 = arith.cmpi eq, %71, %77 : index
        %91 = arith.addi %63, %c1 : index
        %92 = arith.select %90, %91, %63 : index
        %93 = arith.cmpi eq, %75, %77 : index
        %94 = arith.addi %64, %c1 : index
        %95 = arith.select %93, %94, %64 : index
        cf.br ^bb1(%92, %95, %89 : index, index, f32)
      ^bb7:  // pred: ^bb1
        %96 = llvm.getelementptr %12[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %59, %96 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToLLVMPass (convert-complex-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(1 : index) : i64
    %2 = llvm.mlir.constant(16384 : index) : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0_i64 = arith.constant 0 : i64
    %c128_i64 = arith.constant 128 : i64
    %c16384_i64 = arith.constant 16384 : i64
    %c1 = arith.constant 1 : index
    %c16384 = arith.constant 16384 : index
    %c0 = arith.constant 0 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = llvm.mlir.null : !llvm.ptr
    %10 = llvm.getelementptr %9[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %11 = llvm.ptrtoint %10 : !llvm.ptr to i64
    %12 = llvm.call @malloc(%11) : (i64) -> !llvm.ptr
    %13 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %0, %15[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %2, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %1, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c16384 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %32 = arith.muli %arg8, %c128 : index
        %33 = arith.addi %32, %arg9 : index
        %34 = builtin.unrealized_conversion_cast %33 : index to i64
        %35 = llvm.getelementptr %12[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %36 = llvm.load %35 : !llvm.ptr -> f32
        %37 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = arith.addi %arg8, %c1 : index
        %42 = builtin.unrealized_conversion_cast %41 : index to i64
        %43 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %45 = llvm.load %44 : !llvm.ptr -> i64
        %46 = builtin.unrealized_conversion_cast %45 : i64 to index
        %47 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        %51 = arith.addi %arg9, %c1 : index
        %52 = builtin.unrealized_conversion_cast %51 : index to i64
        %53 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %55 = llvm.load %54 : !llvm.ptr -> i64
        %56 = builtin.unrealized_conversion_cast %55 : i64 to index
        cf.br ^bb1(%40, %50, %36 : index, index, f32)
      ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
        %60 = arith.cmpi ult, %57, %46 : index
        %61 = arith.cmpi ult, %58, %56 : index
        %62 = arith.andi %60, %61 : i1
        cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
      ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
        %66 = builtin.unrealized_conversion_cast %63 : index to i64
        %67 = builtin.unrealized_conversion_cast %64 : index to i64
        %68 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %70 = llvm.load %69 : !llvm.ptr -> i64
        %71 = builtin.unrealized_conversion_cast %70 : i64 to index
        %72 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %74 = llvm.load %73 : !llvm.ptr -> i64
        %75 = builtin.unrealized_conversion_cast %74 : i64 to index
        %76 = arith.cmpi ult, %75, %71 : index
        %77 = arith.select %76, %75, %71 : index
        %78 = arith.cmpi eq, %71, %77 : index
        %79 = arith.cmpi eq, %75, %77 : index
        %80 = arith.andi %78, %79 : i1
        cf.cond_br %80, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %81 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %83 = llvm.load %82 : !llvm.ptr -> f32
        %84 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %86 = llvm.load %85 : !llvm.ptr -> f32
        %87 = arith.mulf %83, %86 : f32
        %88 = arith.addf %65, %87 : f32
        cf.br ^bb5(%88 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%65 : f32)
      ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %90 = arith.cmpi eq, %71, %77 : index
        %91 = arith.addi %63, %c1 : index
        %92 = arith.select %90, %91, %63 : index
        %93 = arith.cmpi eq, %75, %77 : index
        %94 = arith.addi %64, %c1 : index
        %95 = arith.select %93, %94, %64 : index
        cf.br ^bb1(%92, %95, %89 : index, index, f32)
      ^bb7:  // pred: ^bb1
        %96 = llvm.getelementptr %12[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %59, %96 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMMul.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(1 : index) : i64
    %2 = llvm.mlir.constant(16384 : index) : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0_i64 = arith.constant 0 : i64
    %c128_i64 = arith.constant 128 : i64
    %c16384_i64 = arith.constant 16384 : i64
    %c1 = arith.constant 1 : index
    %c16384 = arith.constant 16384 : index
    %c0 = arith.constant 0 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = llvm.mlir.null : !llvm.ptr
    %10 = llvm.getelementptr %9[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %11 = llvm.ptrtoint %10 : !llvm.ptr to i64
    %12 = llvm.call @malloc(%11) : (i64) -> !llvm.ptr
    %13 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %0, %15[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %2, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %1, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c128_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c16384 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c16384_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8, %arg9) : index = (%c0, %c0) to (%c128, %c128) step (%c1, %c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %32 = arith.muli %arg8, %c128 : index
        %33 = arith.addi %32, %arg9 : index
        %34 = builtin.unrealized_conversion_cast %33 : index to i64
        %35 = llvm.getelementptr %12[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %36 = llvm.load %35 : !llvm.ptr -> f32
        %37 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = arith.addi %arg8, %c1 : index
        %42 = builtin.unrealized_conversion_cast %41 : index to i64
        %43 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %45 = llvm.load %44 : !llvm.ptr -> i64
        %46 = builtin.unrealized_conversion_cast %45 : i64 to index
        %47 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        %51 = arith.addi %arg9, %c1 : index
        %52 = builtin.unrealized_conversion_cast %51 : index to i64
        %53 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %55 = llvm.load %54 : !llvm.ptr -> i64
        %56 = builtin.unrealized_conversion_cast %55 : i64 to index
        cf.br ^bb1(%40, %50, %36 : index, index, f32)
      ^bb1(%57: index, %58: index, %59: f32):  // 2 preds: ^bb0, ^bb6
        %60 = arith.cmpi ult, %57, %46 : index
        %61 = arith.cmpi ult, %58, %56 : index
        %62 = arith.andi %60, %61 : i1
        cf.cond_br %62, ^bb2(%57, %58, %59 : index, index, f32), ^bb7
      ^bb2(%63: index, %64: index, %65: f32):  // pred: ^bb1
        %66 = builtin.unrealized_conversion_cast %63 : index to i64
        %67 = builtin.unrealized_conversion_cast %64 : index to i64
        %68 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %70 = llvm.load %69 : !llvm.ptr -> i64
        %71 = builtin.unrealized_conversion_cast %70 : i64 to index
        %72 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %74 = llvm.load %73 : !llvm.ptr -> i64
        %75 = builtin.unrealized_conversion_cast %74 : i64 to index
        %76 = arith.cmpi ult, %75, %71 : index
        %77 = arith.select %76, %75, %71 : index
        %78 = arith.cmpi eq, %71, %77 : index
        %79 = arith.cmpi eq, %75, %77 : index
        %80 = arith.andi %78, %79 : i1
        cf.cond_br %80, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %81 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %83 = llvm.load %82 : !llvm.ptr -> f32
        %84 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %86 = llvm.load %85 : !llvm.ptr -> f32
        %87 = arith.mulf %83, %86 : f32
        %88 = arith.addf %65, %87 : f32
        cf.br ^bb5(%88 : f32)
      ^bb4:  // pred: ^bb2
        cf.br ^bb5(%65 : f32)
      ^bb5(%89: f32):  // 2 preds: ^bb3, ^bb4
        cf.br ^bb6
      ^bb6:  // pred: ^bb5
        %90 = arith.cmpi eq, %71, %77 : index
        %91 = arith.addi %63, %c1 : index
        %92 = arith.select %90, %91, %63 : index
        %93 = arith.cmpi eq, %75, %77 : index
        %94 = arith.addi %64, %c1 : index
        %95 = arith.select %93, %94, %64 : index
        cf.br ^bb1(%92, %95, %89 : index, index, f32)
      ^bb7:  // pred: ^bb1
        %96 = llvm.getelementptr %12[%34] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %59, %96 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertOpenMPToLLVMPass (convert-openmp-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @SpMSpMMul.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg16: !llvm.ptr, %arg17: !llvm.ptr, %arg18: i64, %arg19: i64, %arg20: i64, %arg21: !llvm.ptr, %arg22: !llvm.ptr, %arg23: i64, %arg24: i64, %arg25: i64, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg16, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg17, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg18, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg19, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg20, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg21, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg22, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg23, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg24, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg25, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg26, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg27, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg28, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg29, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg30, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %42 = llvm.mlir.constant(0 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.mlir.constant(16384 : index) : i64
    %45 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %46 = llvm.mlir.constant(128 : index) : i64
    %47 = llvm.mlir.constant(0 : i64) : i64
    %48 = llvm.mlir.constant(128 : i64) : i64
    %49 = llvm.mlir.constant(16384 : i64) : i64
    %50 = llvm.mlir.constant(1 : index) : i64
    %51 = llvm.mlir.constant(16384 : index) : i64
    %52 = llvm.mlir.constant(0 : index) : i64
    %53 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %54 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %55 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %56 = builtin.unrealized_conversion_cast %34 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = builtin.unrealized_conversion_cast %20 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %58 = builtin.unrealized_conversion_cast %41 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %59 = llvm.mlir.null : !llvm.ptr
    %60 = llvm.getelementptr %59[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %61 = llvm.ptrtoint %60 : !llvm.ptr to i64
    %62 = llvm.call @malloc(%61) : (i64) -> !llvm.ptr
    %63 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %64 = llvm.insertvalue %62, %63[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %62, %64[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %42, %65[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %44, %66[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %43, %67[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %70 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %71 = llvm.insertvalue %47, %70[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %72 = llvm.insertvalue %48, %71[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %73 = llvm.insertvalue %48, %72[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%52 : i64)
  ^bb1(%74: i64):  // 2 preds: ^bb0, ^bb2
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = builtin.unrealized_conversion_cast %75 : index to i64
    %77 = llvm.icmp "slt" %74, %51 : i64
    llvm.cond_br %77, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %78 = llvm.getelementptr %62[%76] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %45, %78 : f32, !llvm.ptr
    %79 = llvm.add %74, %50  : i64
    llvm.br ^bb1(%79 : i64)
  ^bb3:  // pred: ^bb1
    %80 = llvm.insertvalue %49, %73[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg32, %arg33) : i64 = (%52, %52) to (%46, %46) step (%50, %50) {
        %84 = builtin.unrealized_conversion_cast %arg33 : i64 to index
        %85 = builtin.unrealized_conversion_cast %arg32 : i64 to index
        %86 = builtin.unrealized_conversion_cast %85 : index to i64
        %87 = builtin.unrealized_conversion_cast %84 : index to i64
        %88 = llvm.mul %arg32, %46  : i64
        %89 = llvm.add %88, %arg33  : i64
        %90 = builtin.unrealized_conversion_cast %89 : i64 to index
        %91 = builtin.unrealized_conversion_cast %90 : index to i64
        %92 = llvm.getelementptr %62[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %93 = llvm.load %92 : !llvm.ptr -> f32
        %94 = llvm.extractvalue %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %95 = llvm.getelementptr %94[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %96 = llvm.load %95 : !llvm.ptr -> i64
        %97 = builtin.unrealized_conversion_cast %96 : i64 to index
        %98 = llvm.add %arg32, %50  : i64
        %99 = builtin.unrealized_conversion_cast %98 : i64 to index
        %100 = builtin.unrealized_conversion_cast %99 : index to i64
        %101 = llvm.extractvalue %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %103 = llvm.load %102 : !llvm.ptr -> i64
        %104 = builtin.unrealized_conversion_cast %103 : i64 to index
        %105 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %106 = llvm.getelementptr %105[%87] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %107 = llvm.load %106 : !llvm.ptr -> i64
        %108 = builtin.unrealized_conversion_cast %107 : i64 to index
        %109 = llvm.add %arg33, %50  : i64
        %110 = builtin.unrealized_conversion_cast %109 : i64 to index
        %111 = builtin.unrealized_conversion_cast %110 : index to i64
        %112 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %113 = llvm.getelementptr %112[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %114 = llvm.load %113 : !llvm.ptr -> i64
        %115 = builtin.unrealized_conversion_cast %114 : i64 to index
        llvm.br ^bb1(%96, %107, %93 : i64, i64, f32)
      ^bb1(%116: i64, %117: i64, %118: f32):  // 2 preds: ^bb0, ^bb6
        %119 = llvm.icmp "ult" %116, %103 : i64
        %120 = llvm.icmp "ult" %117, %114 : i64
        %121 = llvm.and %119, %120  : i1
        llvm.cond_br %121, ^bb2(%116, %117, %118 : i64, i64, f32), ^bb7
      ^bb2(%122: i64, %123: i64, %124: f32):  // pred: ^bb1
        %125 = builtin.unrealized_conversion_cast %123 : i64 to index
        %126 = builtin.unrealized_conversion_cast %122 : i64 to index
        %127 = builtin.unrealized_conversion_cast %126 : index to i64
        %128 = builtin.unrealized_conversion_cast %125 : index to i64
        %129 = llvm.extractvalue %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %130 = llvm.getelementptr %129[%127] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %131 = llvm.load %130 : !llvm.ptr -> i64
        %132 = builtin.unrealized_conversion_cast %131 : i64 to index
        %133 = llvm.extractvalue %56[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %134 = llvm.getelementptr %133[%128] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %135 = llvm.load %134 : !llvm.ptr -> i64
        %136 = builtin.unrealized_conversion_cast %135 : i64 to index
        %137 = llvm.icmp "ult" %135, %131 : i64
        %138 = llvm.select %137, %135, %131 : i1, i64
        %139 = llvm.icmp "eq" %131, %138 : i64
        %140 = llvm.icmp "eq" %135, %138 : i64
        %141 = llvm.and %139, %140  : i1
        llvm.cond_br %141, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %142 = llvm.extractvalue %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %143 = llvm.getelementptr %142[%127] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %144 = llvm.load %143 : !llvm.ptr -> f32
        %145 = llvm.extractvalue %58[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %146 = llvm.getelementptr %145[%128] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %147 = llvm.load %146 : !llvm.ptr -> f32
        %148 = llvm.fmul %144, %147  : f32
        %149 = llvm.fadd %124, %148  : f32
        llvm.br ^bb5(%149 : f32)
      ^bb4:  // pred: ^bb2
        llvm.br ^bb5(%124 : f32)
      ^bb5(%150: f32):  // 2 preds: ^bb3, ^bb4
        llvm.br ^bb6
      ^bb6:  // pred: ^bb5
        %151 = llvm.icmp "eq" %131, %138 : i64
        %152 = llvm.add %122, %50  : i64
        %153 = llvm.select %151, %152, %122 : i1, i64
        %154 = llvm.icmp "eq" %135, %138 : i64
        %155 = llvm.add %123, %50  : i64
        %156 = llvm.select %154, %155, %123 : i1, i64
        llvm.br ^bb1(%153, %156, %150 : i64, i64, f32)
      ^bb7:  // pred: ^bb1
        %157 = llvm.getelementptr %62[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %118, %157 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    %81 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %82 = llvm.insertvalue %68, %81[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %83 = llvm.insertvalue %80, %82[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %83 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_SpMSpMMul.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @SpMSpMMul.Z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %arg4, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %arg8) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %36, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ConvertFuncToLLVMPass (convert-func-to-llvm) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @SpMSpMMul.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg16: !llvm.ptr, %arg17: !llvm.ptr, %arg18: i64, %arg19: i64, %arg20: i64, %arg21: !llvm.ptr, %arg22: !llvm.ptr, %arg23: i64, %arg24: i64, %arg25: i64, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg16, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg17, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg18, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg19, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg20, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg21, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg22, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg23, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg24, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg25, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg26, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg27, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg28, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg29, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg30, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %42 = llvm.mlir.constant(0 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.mlir.constant(16384 : index) : i64
    %45 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %46 = llvm.mlir.constant(128 : index) : i64
    %47 = llvm.mlir.constant(0 : i64) : i64
    %48 = llvm.mlir.constant(128 : i64) : i64
    %49 = llvm.mlir.constant(16384 : i64) : i64
    %50 = llvm.mlir.constant(1 : index) : i64
    %51 = llvm.mlir.constant(16384 : index) : i64
    %52 = llvm.mlir.constant(0 : index) : i64
    %53 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %54 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %55 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %56 = builtin.unrealized_conversion_cast %34 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = builtin.unrealized_conversion_cast %20 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %58 = builtin.unrealized_conversion_cast %41 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %59 = llvm.mlir.null : !llvm.ptr
    %60 = llvm.getelementptr %59[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %61 = llvm.ptrtoint %60 : !llvm.ptr to i64
    %62 = llvm.call @malloc(%61) : (i64) -> !llvm.ptr
    %63 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %64 = llvm.insertvalue %62, %63[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %62, %64[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %42, %65[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %44, %66[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %43, %67[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %70 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %71 = llvm.insertvalue %47, %70[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %72 = llvm.insertvalue %48, %71[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %73 = llvm.insertvalue %48, %72[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%52 : i64)
  ^bb1(%74: i64):  // 2 preds: ^bb0, ^bb2
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = builtin.unrealized_conversion_cast %75 : index to i64
    %77 = llvm.icmp "slt" %74, %51 : i64
    llvm.cond_br %77, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %78 = llvm.getelementptr %62[%76] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %45, %78 : f32, !llvm.ptr
    %79 = llvm.add %74, %50  : i64
    llvm.br ^bb1(%79 : i64)
  ^bb3:  // pred: ^bb1
    %80 = llvm.insertvalue %49, %73[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg32, %arg33) : i64 = (%52, %52) to (%46, %46) step (%50, %50) {
        %84 = builtin.unrealized_conversion_cast %arg33 : i64 to index
        %85 = builtin.unrealized_conversion_cast %arg32 : i64 to index
        %86 = builtin.unrealized_conversion_cast %85 : index to i64
        %87 = builtin.unrealized_conversion_cast %84 : index to i64
        %88 = llvm.mul %arg32, %46  : i64
        %89 = llvm.add %88, %arg33  : i64
        %90 = builtin.unrealized_conversion_cast %89 : i64 to index
        %91 = builtin.unrealized_conversion_cast %90 : index to i64
        %92 = llvm.getelementptr %62[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %93 = llvm.load %92 : !llvm.ptr -> f32
        %94 = llvm.extractvalue %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %95 = llvm.getelementptr %94[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %96 = llvm.load %95 : !llvm.ptr -> i64
        %97 = builtin.unrealized_conversion_cast %96 : i64 to index
        %98 = llvm.add %arg32, %50  : i64
        %99 = builtin.unrealized_conversion_cast %98 : i64 to index
        %100 = builtin.unrealized_conversion_cast %99 : index to i64
        %101 = llvm.extractvalue %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %103 = llvm.load %102 : !llvm.ptr -> i64
        %104 = builtin.unrealized_conversion_cast %103 : i64 to index
        %105 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %106 = llvm.getelementptr %105[%87] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %107 = llvm.load %106 : !llvm.ptr -> i64
        %108 = builtin.unrealized_conversion_cast %107 : i64 to index
        %109 = llvm.add %arg33, %50  : i64
        %110 = builtin.unrealized_conversion_cast %109 : i64 to index
        %111 = builtin.unrealized_conversion_cast %110 : index to i64
        %112 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %113 = llvm.getelementptr %112[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %114 = llvm.load %113 : !llvm.ptr -> i64
        %115 = builtin.unrealized_conversion_cast %114 : i64 to index
        llvm.br ^bb1(%96, %107, %93 : i64, i64, f32)
      ^bb1(%116: i64, %117: i64, %118: f32):  // 2 preds: ^bb0, ^bb6
        %119 = llvm.icmp "ult" %116, %103 : i64
        %120 = llvm.icmp "ult" %117, %114 : i64
        %121 = llvm.and %119, %120  : i1
        llvm.cond_br %121, ^bb2(%116, %117, %118 : i64, i64, f32), ^bb7
      ^bb2(%122: i64, %123: i64, %124: f32):  // pred: ^bb1
        %125 = builtin.unrealized_conversion_cast %123 : i64 to index
        %126 = builtin.unrealized_conversion_cast %122 : i64 to index
        %127 = builtin.unrealized_conversion_cast %126 : index to i64
        %128 = builtin.unrealized_conversion_cast %125 : index to i64
        %129 = llvm.extractvalue %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %130 = llvm.getelementptr %129[%127] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %131 = llvm.load %130 : !llvm.ptr -> i64
        %132 = builtin.unrealized_conversion_cast %131 : i64 to index
        %133 = llvm.extractvalue %56[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %134 = llvm.getelementptr %133[%128] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %135 = llvm.load %134 : !llvm.ptr -> i64
        %136 = builtin.unrealized_conversion_cast %135 : i64 to index
        %137 = llvm.icmp "ult" %135, %131 : i64
        %138 = llvm.select %137, %135, %131 : i1, i64
        %139 = llvm.icmp "eq" %131, %138 : i64
        %140 = llvm.icmp "eq" %135, %138 : i64
        %141 = llvm.and %139, %140  : i1
        llvm.cond_br %141, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %142 = llvm.extractvalue %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %143 = llvm.getelementptr %142[%127] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %144 = llvm.load %143 : !llvm.ptr -> f32
        %145 = llvm.extractvalue %58[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %146 = llvm.getelementptr %145[%128] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %147 = llvm.load %146 : !llvm.ptr -> f32
        %148 = llvm.fmul %144, %147  : f32
        %149 = llvm.fadd %124, %148  : f32
        llvm.br ^bb5(%149 : f32)
      ^bb4:  // pred: ^bb2
        llvm.br ^bb5(%124 : f32)
      ^bb5(%150: f32):  // 2 preds: ^bb3, ^bb4
        llvm.br ^bb6
      ^bb6:  // pred: ^bb5
        %151 = llvm.icmp "eq" %131, %138 : i64
        %152 = llvm.add %122, %50  : i64
        %153 = llvm.select %151, %152, %122 : i1, i64
        %154 = llvm.icmp "eq" %135, %138 : i64
        %155 = llvm.add %123, %50  : i64
        %156 = llvm.select %154, %155, %123 : i1, i64
        llvm.br ^bb1(%153, %156, %150 : i64, i64, f32)
      ^bb7:  // pred: ^bb1
        %157 = llvm.getelementptr %62[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %118, %157 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    %81 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %82 = llvm.insertvalue %68, %81[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %83 = llvm.insertvalue %80, %82[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %83 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_SpMSpMMul.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @SpMSpMMul.Z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %arg4, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %arg8) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %36, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ReconcileUnrealizedCasts (reconcile-unrealized-casts) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @SpMSpMMul.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg16: !llvm.ptr, %arg17: !llvm.ptr, %arg18: i64, %arg19: i64, %arg20: i64, %arg21: !llvm.ptr, %arg22: !llvm.ptr, %arg23: i64, %arg24: i64, %arg25: i64, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.insertvalue %arg5, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.insertvalue %arg6, %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg7, %8[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg8, %9[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg9, %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %arg12, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg13, %15[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg14, %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.insertvalue %arg16, %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg17, %19[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg18, %20[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %arg19, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg20, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.insertvalue %arg21, %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg22, %25[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg23, %26[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg24, %27[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.insertvalue %arg25, %28[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.insertvalue %arg26, %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg27, %31[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg28, %32[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %arg29, %33[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %arg30, %34[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.mlir.constant(0 : index) : i64
    %37 = llvm.mlir.constant(1 : index) : i64
    %38 = llvm.mlir.constant(16384 : index) : i64
    %39 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %40 = llvm.mlir.constant(128 : index) : i64
    %41 = llvm.mlir.constant(0 : i64) : i64
    %42 = llvm.mlir.constant(128 : i64) : i64
    %43 = llvm.mlir.constant(16384 : i64) : i64
    %44 = llvm.mlir.constant(1 : index) : i64
    %45 = llvm.mlir.constant(16384 : index) : i64
    %46 = llvm.mlir.constant(0 : index) : i64
    %47 = llvm.mlir.null : !llvm.ptr
    %48 = llvm.getelementptr %47[16384] : (!llvm.ptr) -> !llvm.ptr, f32
    %49 = llvm.ptrtoint %48 : !llvm.ptr to i64
    %50 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %51 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %52 = llvm.insertvalue %50, %51[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %50, %52[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %36, %53[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %38, %54[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.insertvalue %37, %55[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %58 = llvm.insertvalue %41, %57[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %59 = llvm.insertvalue %42, %58[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %60 = llvm.insertvalue %42, %59[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%46 : i64)
  ^bb1(%61: i64):  // 2 preds: ^bb0, ^bb2
    %62 = llvm.icmp "slt" %61, %45 : i64
    llvm.cond_br %62, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %63 = llvm.getelementptr %50[%61] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %39, %63 : f32, !llvm.ptr
    %64 = llvm.add %61, %44  : i64
    llvm.br ^bb1(%64 : i64)
  ^bb3:  // pred: ^bb1
    %65 = llvm.insertvalue %43, %60[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg32, %arg33) : i64 = (%46, %46) to (%40, %40) step (%44, %44) {
        %69 = llvm.mul %arg32, %40  : i64
        %70 = llvm.add %69, %arg33  : i64
        %71 = llvm.getelementptr %50[%70] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %72 = llvm.load %71 : !llvm.ptr -> f32
        %73 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %74 = llvm.getelementptr %73[%arg32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %75 = llvm.load %74 : !llvm.ptr -> i64
        %76 = llvm.add %arg32, %44  : i64
        %77 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %78 = llvm.getelementptr %77[%76] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %79 = llvm.load %78 : !llvm.ptr -> i64
        %80 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %81 = llvm.getelementptr %80[%arg33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %82 = llvm.load %81 : !llvm.ptr -> i64
        %83 = llvm.add %arg33, %44  : i64
        %84 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %86 = llvm.load %85 : !llvm.ptr -> i64
        llvm.br ^bb1(%75, %82, %72 : i64, i64, f32)
      ^bb1(%87: i64, %88: i64, %89: f32):  // 2 preds: ^bb0, ^bb6
        %90 = llvm.icmp "ult" %87, %79 : i64
        %91 = llvm.icmp "ult" %88, %86 : i64
        %92 = llvm.and %90, %91  : i1
        llvm.cond_br %92, ^bb2(%87, %88, %89 : i64, i64, f32), ^bb7
      ^bb2(%93: i64, %94: i64, %95: f32):  // pred: ^bb1
        %96 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %97 = llvm.getelementptr %96[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %98 = llvm.load %97 : !llvm.ptr -> i64
        %99 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.getelementptr %99[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %101 = llvm.load %100 : !llvm.ptr -> i64
        %102 = llvm.icmp "ult" %101, %98 : i64
        %103 = llvm.select %102, %101, %98 : i1, i64
        %104 = llvm.icmp "eq" %98, %103 : i64
        %105 = llvm.icmp "eq" %101, %103 : i64
        %106 = llvm.and %104, %105  : i1
        llvm.cond_br %106, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %107 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %108 = llvm.getelementptr %107[%93] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %109 = llvm.load %108 : !llvm.ptr -> f32
        %110 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %111 = llvm.getelementptr %110[%94] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %112 = llvm.load %111 : !llvm.ptr -> f32
        %113 = llvm.fmul %109, %112  : f32
        %114 = llvm.fadd %95, %113  : f32
        llvm.br ^bb5(%114 : f32)
      ^bb4:  // pred: ^bb2
        llvm.br ^bb5(%95 : f32)
      ^bb5(%115: f32):  // 2 preds: ^bb3, ^bb4
        llvm.br ^bb6
      ^bb6:  // pred: ^bb5
        %116 = llvm.icmp "eq" %98, %103 : i64
        %117 = llvm.add %93, %44  : i64
        %118 = llvm.select %116, %117, %93 : i1, i64
        %119 = llvm.icmp "eq" %101, %103 : i64
        %120 = llvm.add %94, %44  : i64
        %121 = llvm.select %119, %120, %94 : i1, i64
        llvm.br ^bb1(%118, %121, %115 : i64, i64, f32)
      ^bb7:  // pred: ^bb1
        %122 = llvm.getelementptr %50[%70] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %89, %122 : f32, !llvm.ptr
        omp.yield
      }
      omp.terminator
    }
    %66 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %67 = llvm.insertvalue %56, %66[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %68 = llvm.insertvalue %65, %67[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %68 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_SpMSpMMul.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @SpMSpMMul.Z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %arg4, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %arg8) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %36, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


