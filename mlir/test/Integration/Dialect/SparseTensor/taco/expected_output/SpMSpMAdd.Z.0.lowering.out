// -----// IR Dump After LinalgGeneralization (linalg-generalize-named-ops) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
  %0 = bufferization.alloc_tensor() : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  %1 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%arg0, %arg1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) outs(%0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %2 = arith.addf %in, %in_0 : f32
    linalg.yield %2 : f32
  } -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  return %1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
}

// -----// IR Dump After PreSparsificationRewrite (pre-sparsification-rewrite) //----- //
#map = affine_map<(d0, d1) -> (d0, d1)>
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %0 = bufferization.alloc_tensor() : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = linalg.generic {indexing_maps = [#map, #map, #map], iterator_types = ["parallel", "parallel"]} ins(%arg0, %arg1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) outs(%0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %2 = arith.addf %in, %in_0 : f32
      linalg.yield %2 : f32
    } -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After EmptyTensorToAllocTensor (empty-tensor-to-alloc-tensor) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
  %0 = bufferization.alloc_tensor() : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  %1 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%arg0, %arg1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) outs(%0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %2 = arith.addf %in, %in_0 : f32
    linalg.yield %2 : f32
  } -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  return %1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
}

// -----// IR Dump After SparsificationPass (sparsification) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %2 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.values %arg0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xf32>
    %4 = sparse_tensor.positions %arg1 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %5 = sparse_tensor.coordinates %arg1 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %6 = sparse_tensor.values %arg1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xf32>
    %7 = sparse_tensor.values %0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    scf.parallel (%arg2) = (%c0) to (%c128) step (%c1) {
      %9 = memref.load %1[%arg2] : memref<?xindex>
      %10 = arith.addi %arg2, %c1 : index
      %11 = memref.load %1[%10] : memref<?xindex>
      %12 = memref.load %4[%arg2] : memref<?xindex>
      %13 = arith.addi %arg2, %c1 : index
      %14 = memref.load %4[%13] : memref<?xindex>
      %15:2 = scf.while (%arg3 = %9, %arg4 = %12) : (index, index) -> (index, index) {
        %16 = arith.cmpi ult, %arg3, %11 : index
        %17 = arith.cmpi ult, %arg4, %14 : index
        %18 = arith.andi %16, %17 : i1
        scf.condition(%18) %arg3, %arg4 : index, index
      } do {
      ^bb0(%arg3: index, %arg4: index):
        %16 = memref.load %2[%arg3] : memref<?xindex>
        %17 = memref.load %5[%arg4] : memref<?xindex>
        %18 = arith.cmpi ult, %17, %16 : index
        %19 = arith.select %18, %17, %16 : index
        %20 = arith.muli %arg2, %c256 : index
        %21 = arith.addi %20, %19 : index
        %22 = arith.cmpi eq, %16, %19 : index
        %23 = arith.cmpi eq, %17, %19 : index
        %24 = arith.andi %22, %23 : i1
        scf.if %24 {
          %31 = memref.load %3[%arg3] : memref<?xf32>
          %32 = memref.load %6[%arg4] : memref<?xf32>
          %33 = arith.addf %31, %32 : f32
          memref.store %33, %7[%21] : memref<?xf32>
        } else {
          %31 = arith.cmpi eq, %16, %19 : index
          scf.if %31 {
            %32 = memref.load %3[%arg3] : memref<?xf32>
            memref.store %32, %7[%21] : memref<?xf32>
          } else {
            %32 = arith.cmpi eq, %17, %19 : index
            scf.if %32 {
              %33 = memref.load %6[%arg4] : memref<?xf32>
              memref.store %33, %7[%21] : memref<?xf32>
            } else {
            }
          }
        }
        %25 = arith.cmpi eq, %16, %19 : index
        %26 = arith.addi %arg3, %c1 : index
        %27 = arith.select %25, %26, %arg3 : index
        %28 = arith.cmpi eq, %17, %19 : index
        %29 = arith.addi %arg4, %c1 : index
        %30 = arith.select %28, %29, %arg4 : index
        scf.yield %27, %30 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg3) = (%15#0) to (%11) step (%c1) {
        %16 = memref.load %2[%arg3] : memref<?xindex>
        %17 = arith.muli %arg2, %c256 : index
        %18 = arith.addi %17, %16 : index
        %19 = memref.load %3[%arg3] : memref<?xf32>
        memref.store %19, %7[%18] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg3) = (%15#1) to (%14) step (%c1) {
        %16 = memref.load %5[%arg3] : memref<?xindex>
        %17 = arith.muli %arg2, %c256 : index
        %18 = arith.addi %17, %16 : index
        %19 = memref.load %6[%arg3] : memref<?xf32>
        memref.store %19, %7[%18] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %8 = sparse_tensor.load %0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %8 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After PostSparsificationRewrite (post-sparsification-rewrite) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg1: tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %2 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.values %arg0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xf32>
    %4 = sparse_tensor.positions %arg1 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %5 = sparse_tensor.coordinates %arg1 {level = 1 : index} : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xindex>
    %6 = sparse_tensor.values %arg1 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>> to memref<?xf32>
    %7 = sparse_tensor.values %0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    scf.parallel (%arg2) = (%c0) to (%c128) step (%c1) {
      %9 = memref.load %1[%arg2] : memref<?xindex>
      %10 = arith.addi %arg2, %c1 : index
      %11 = memref.load %1[%10] : memref<?xindex>
      %12 = memref.load %4[%arg2] : memref<?xindex>
      %13 = arith.addi %arg2, %c1 : index
      %14 = memref.load %4[%13] : memref<?xindex>
      %15:2 = scf.while (%arg3 = %9, %arg4 = %12) : (index, index) -> (index, index) {
        %16 = arith.cmpi ult, %arg3, %11 : index
        %17 = arith.cmpi ult, %arg4, %14 : index
        %18 = arith.andi %16, %17 : i1
        scf.condition(%18) %arg3, %arg4 : index, index
      } do {
      ^bb0(%arg3: index, %arg4: index):
        %16 = memref.load %2[%arg3] : memref<?xindex>
        %17 = memref.load %5[%arg4] : memref<?xindex>
        %18 = arith.cmpi ult, %17, %16 : index
        %19 = arith.select %18, %17, %16 : index
        %20 = arith.muli %arg2, %c256 : index
        %21 = arith.addi %20, %19 : index
        %22 = arith.cmpi eq, %16, %19 : index
        %23 = arith.cmpi eq, %17, %19 : index
        %24 = arith.andi %22, %23 : i1
        scf.if %24 {
          %31 = memref.load %3[%arg3] : memref<?xf32>
          %32 = memref.load %6[%arg4] : memref<?xf32>
          %33 = arith.addf %31, %32 : f32
          memref.store %33, %7[%21] : memref<?xf32>
        } else {
          %31 = arith.cmpi eq, %16, %19 : index
          scf.if %31 {
            %32 = memref.load %3[%arg3] : memref<?xf32>
            memref.store %32, %7[%21] : memref<?xf32>
          } else {
            %32 = arith.cmpi eq, %17, %19 : index
            scf.if %32 {
              %33 = memref.load %6[%arg4] : memref<?xf32>
              memref.store %33, %7[%21] : memref<?xf32>
            } else {
            }
          }
        }
        %25 = arith.cmpi eq, %16, %19 : index
        %26 = arith.addi %arg3, %c1 : index
        %27 = arith.select %25, %26, %arg3 : index
        %28 = arith.cmpi eq, %17, %19 : index
        %29 = arith.addi %arg4, %c1 : index
        %30 = arith.select %28, %29, %arg4 : index
        scf.yield %27, %30 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg3) = (%15#0) to (%11) step (%c1) {
        %16 = memref.load %2[%arg3] : memref<?xindex>
        %17 = arith.muli %arg2, %c256 : index
        %18 = arith.addi %17, %16 : index
        %19 = memref.load %3[%arg3] : memref<?xf32>
        memref.store %19, %7[%18] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg3) = (%15#1) to (%14) step (%c1) {
        %16 = memref.load %5[%arg3] : memref<?xindex>
        %17 = arith.muli %arg2, %c256 : index
        %18 = arith.addi %17, %16 : index
        %19 = memref.load %6[%arg3] : memref<?xf32>
        memref.store %19, %7[%18] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %8 = sparse_tensor.load %0 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %8 : tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After SparseTensorCodegen (sparse-tensor-codegen) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> (memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c128_0 = arith.constant 128 : index
    %c256_1 = arith.constant 256 : index
    %0 = arith.muli %c128_0, %c256_1 : index
    %alloc = memref.alloc(%0) : memref<?xf32>
    %1 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %c0_2 = arith.constant 0 : index
    %2 = sparse_tensor.storage_specifier.set %1  lvl_sz at 0 with %c128_0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %3 = sparse_tensor.storage_specifier.set %2  lvl_sz at 1 with %c256_1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %c1_3 = arith.constant 1 : index
    %c128_4 = arith.constant 128 : index
    %4 = arith.muli %c1_3, %c128_4 : index
    %c256_5 = arith.constant 256 : index
    %5 = arith.muli %4, %c256_5 : index
    %cst = arith.constant 0.000000e+00 : f32
    %6 = sparse_tensor.storage_specifier.get %3  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %outBuffer, %newSize = sparse_tensor.push_back %6, %alloc, %cst, %5 : index, memref<?xf32>, f32, index
    %7 = sparse_tensor.storage_specifier.set %3  val_mem_sz with %newSize : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %8 = builtin.unrealized_conversion_cast %outBuffer, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      %10 = memref.load %arg0[%arg8] : memref<?xindex>
      %11 = arith.addi %arg8, %c1 : index
      %12 = memref.load %arg0[%11] : memref<?xindex>
      %13 = memref.load %arg4[%arg8] : memref<?xindex>
      %14 = arith.addi %arg8, %c1 : index
      %15 = memref.load %arg4[%14] : memref<?xindex>
      %16:2 = scf.while (%arg9 = %10, %arg10 = %13) : (index, index) -> (index, index) {
        %17 = arith.cmpi ult, %arg9, %12 : index
        %18 = arith.cmpi ult, %arg10, %15 : index
        %19 = arith.andi %17, %18 : i1
        scf.condition(%19) %arg9, %arg10 : index, index
      } do {
      ^bb0(%arg9: index, %arg10: index):
        %17 = memref.load %arg1[%arg9] : memref<?xindex>
        %18 = memref.load %arg5[%arg10] : memref<?xindex>
        %19 = arith.cmpi ult, %18, %17 : index
        %20 = arith.select %19, %18, %17 : index
        %21 = arith.muli %arg8, %c256 : index
        %22 = arith.addi %21, %20 : index
        %23 = arith.cmpi eq, %17, %20 : index
        %24 = arith.cmpi eq, %18, %20 : index
        %25 = arith.andi %23, %24 : i1
        scf.if %25 {
          %32 = memref.load %arg2[%arg9] : memref<?xf32>
          %33 = memref.load %arg6[%arg10] : memref<?xf32>
          %34 = arith.addf %32, %33 : f32
          memref.store %34, %outBuffer[%22] : memref<?xf32>
        } else {
          %32 = arith.cmpi eq, %17, %20 : index
          scf.if %32 {
            %33 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %33, %outBuffer[%22] : memref<?xf32>
          } else {
            %33 = arith.cmpi eq, %18, %20 : index
            scf.if %33 {
              %34 = memref.load %arg6[%arg10] : memref<?xf32>
              memref.store %34, %outBuffer[%22] : memref<?xf32>
            } else {
            }
          }
        }
        %26 = arith.cmpi eq, %17, %20 : index
        %27 = arith.addi %arg9, %c1 : index
        %28 = arith.select %26, %27, %arg9 : index
        %29 = arith.cmpi eq, %18, %20 : index
        %30 = arith.addi %arg10, %c1 : index
        %31 = arith.select %29, %30, %arg10 : index
        scf.yield %28, %31 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%16#0) to (%12) step (%c1) {
        %17 = memref.load %arg1[%arg9] : memref<?xindex>
        %18 = arith.muli %arg8, %c256 : index
        %19 = arith.addi %18, %17 : index
        %20 = memref.load %arg2[%arg9] : memref<?xf32>
        memref.store %20, %outBuffer[%19] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%16#1) to (%15) step (%c1) {
        %17 = memref.load %arg5[%arg9] : memref<?xindex>
        %18 = arith.muli %arg8, %c256 : index
        %19 = arith.addi %18, %17 : index
        %20 = memref.load %arg6[%arg9] : memref<?xf32>
        memref.store %20, %outBuffer[%19] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %9 = builtin.unrealized_conversion_cast %outBuffer, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to tensor<128x256xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %outBuffer, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After SparseBufferRewrite (sparse-buffer-rewrite) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed" ] }>>) -> (memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) attributes {llvm.emit_c_interface} {
    %c32768 = arith.constant 32768 : index
    %c128 = arith.constant 128 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc(%c32768) : memref<?xf32>
    %0 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %1 = sparse_tensor.storage_specifier.set %0  lvl_sz at 0 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %2 = sparse_tensor.storage_specifier.set %1  lvl_sz at 1 with %c256 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %3 = sparse_tensor.storage_specifier.get %2  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %4 = arith.addi %3, %c32768 : index
    %5 = arith.cmpi ugt, %4, %c32768 : index
    %6 = scf.if %5 -> (memref<?xf32>) {
      %8 = scf.while (%arg8 = %c32768) : (index) -> index {
        %10 = arith.muli %arg8, %c2 : index
        %11 = arith.cmpi ugt, %4, %10 : index
        scf.condition(%11) %10 : index
      } do {
      ^bb0(%arg8: index):
        scf.yield %arg8 : index
      }
      %9 = memref.realloc %alloc(%8) : memref<?xf32> to memref<?xf32>
      scf.yield %9 : memref<?xf32>
    } else {
      scf.yield %alloc : memref<?xf32>
    }
    %subview = memref.subview %6[%3] [%c32768] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %7 = sparse_tensor.storage_specifier.set %2  val_mem_sz with %4 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      %8 = memref.load %arg0[%arg8] : memref<?xindex>
      %9 = arith.addi %arg8, %c1 : index
      %10 = memref.load %arg0[%9] : memref<?xindex>
      %11 = memref.load %arg4[%arg8] : memref<?xindex>
      %12 = arith.addi %arg8, %c1 : index
      %13 = memref.load %arg4[%12] : memref<?xindex>
      %14:2 = scf.while (%arg9 = %8, %arg10 = %11) : (index, index) -> (index, index) {
        %15 = arith.cmpi ult, %arg9, %10 : index
        %16 = arith.cmpi ult, %arg10, %13 : index
        %17 = arith.andi %15, %16 : i1
        scf.condition(%17) %arg9, %arg10 : index, index
      } do {
      ^bb0(%arg9: index, %arg10: index):
        %15 = memref.load %arg1[%arg9] : memref<?xindex>
        %16 = memref.load %arg5[%arg10] : memref<?xindex>
        %17 = arith.cmpi ult, %16, %15 : index
        %18 = arith.select %17, %16, %15 : index
        %19 = arith.muli %arg8, %c256 : index
        %20 = arith.addi %19, %18 : index
        %21 = arith.cmpi eq, %15, %18 : index
        %22 = arith.cmpi eq, %16, %18 : index
        %23 = arith.andi %21, %22 : i1
        scf.if %23 {
          %30 = memref.load %arg2[%arg9] : memref<?xf32>
          %31 = memref.load %arg6[%arg10] : memref<?xf32>
          %32 = arith.addf %30, %31 : f32
          memref.store %32, %6[%20] : memref<?xf32>
        } else {
          %30 = arith.cmpi eq, %15, %18 : index
          scf.if %30 {
            %31 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %31, %6[%20] : memref<?xf32>
          } else {
            %31 = arith.cmpi eq, %16, %18 : index
            scf.if %31 {
              %32 = memref.load %arg6[%arg10] : memref<?xf32>
              memref.store %32, %6[%20] : memref<?xf32>
            } else {
            }
          }
        }
        %24 = arith.cmpi eq, %15, %18 : index
        %25 = arith.addi %arg9, %c1 : index
        %26 = arith.select %24, %25, %arg9 : index
        %27 = arith.cmpi eq, %16, %18 : index
        %28 = arith.addi %arg10, %c1 : index
        %29 = arith.select %27, %28, %arg10 : index
        scf.yield %26, %29 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%14#0) to (%10) step (%c1) {
        %15 = memref.load %arg1[%arg9] : memref<?xindex>
        %16 = arith.muli %arg8, %c256 : index
        %17 = arith.addi %16, %15 : index
        %18 = memref.load %arg2[%arg9] : memref<?xf32>
        memref.store %18, %6[%17] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%14#1) to (%13) step (%c1) {
        %15 = memref.load %arg5[%arg9] : memref<?xindex>
        %16 = arith.muli %arg8, %c256 : index
        %17 = arith.addi %16, %15 : index
        %18 = memref.load %arg6[%arg9] : memref<?xf32>
        memref.store %18, %6[%17] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %6, %7 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After StorageSpecifierToLLVM (sparse-storage-specifier-to-llvm) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c32768 = arith.constant 32768 : index
    %c128 = arith.constant 128 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc(%c32768) : memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %c0_i64 = arith.constant 0 : i64
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = arith.index_cast %c128 : index to i64
    %3 = llvm.insertvalue %2, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %4 = arith.index_cast %c256 : index to i64
    %5 = llvm.insertvalue %4, %3[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %6 = llvm.extractvalue %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %7 = arith.index_cast %6 : i64 to index
    %8 = arith.addi %7, %c32768 : index
    %9 = arith.cmpi ugt, %8, %c32768 : index
    %10 = scf.if %9 -> (memref<?xf32>) {
      %13 = scf.while (%arg8 = %c32768) : (index) -> index {
        %15 = arith.muli %arg8, %c2 : index
        %16 = arith.cmpi ugt, %8, %15 : index
        scf.condition(%16) %15 : index
      } do {
      ^bb0(%arg8: index):
        scf.yield %arg8 : index
      }
      %14 = memref.realloc %alloc(%13) : memref<?xf32> to memref<?xf32>
      scf.yield %14 : memref<?xf32>
    } else {
      scf.yield %alloc : memref<?xf32>
    }
    %subview = memref.subview %10[%7] [%c32768] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %11 = arith.index_cast %8 : index to i64
    %12 = llvm.insertvalue %11, %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      %13 = memref.load %arg0[%arg8] : memref<?xindex>
      %14 = arith.addi %arg8, %c1 : index
      %15 = memref.load %arg0[%14] : memref<?xindex>
      %16 = memref.load %arg4[%arg8] : memref<?xindex>
      %17 = arith.addi %arg8, %c1 : index
      %18 = memref.load %arg4[%17] : memref<?xindex>
      %19:2 = scf.while (%arg9 = %13, %arg10 = %16) : (index, index) -> (index, index) {
        %20 = arith.cmpi ult, %arg9, %15 : index
        %21 = arith.cmpi ult, %arg10, %18 : index
        %22 = arith.andi %20, %21 : i1
        scf.condition(%22) %arg9, %arg10 : index, index
      } do {
      ^bb0(%arg9: index, %arg10: index):
        %20 = memref.load %arg1[%arg9] : memref<?xindex>
        %21 = memref.load %arg5[%arg10] : memref<?xindex>
        %22 = arith.cmpi ult, %21, %20 : index
        %23 = arith.select %22, %21, %20 : index
        %24 = arith.muli %arg8, %c256 : index
        %25 = arith.addi %24, %23 : index
        %26 = arith.cmpi eq, %20, %23 : index
        %27 = arith.cmpi eq, %21, %23 : index
        %28 = arith.andi %26, %27 : i1
        scf.if %28 {
          %35 = memref.load %arg2[%arg9] : memref<?xf32>
          %36 = memref.load %arg6[%arg10] : memref<?xf32>
          %37 = arith.addf %35, %36 : f32
          memref.store %37, %10[%25] : memref<?xf32>
        } else {
          %35 = arith.cmpi eq, %20, %23 : index
          scf.if %35 {
            %36 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %36, %10[%25] : memref<?xf32>
          } else {
            %36 = arith.cmpi eq, %21, %23 : index
            scf.if %36 {
              %37 = memref.load %arg6[%arg10] : memref<?xf32>
              memref.store %37, %10[%25] : memref<?xf32>
            } else {
            }
          }
        }
        %29 = arith.cmpi eq, %20, %23 : index
        %30 = arith.addi %arg9, %c1 : index
        %31 = arith.select %29, %30, %arg9 : index
        %32 = arith.cmpi eq, %21, %23 : index
        %33 = arith.addi %arg10, %c1 : index
        %34 = arith.select %32, %33, %arg10 : index
        scf.yield %31, %34 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%19#0) to (%15) step (%c1) {
        %20 = memref.load %arg1[%arg9] : memref<?xindex>
        %21 = arith.muli %arg8, %c256 : index
        %22 = arith.addi %21, %20 : index
        %23 = memref.load %arg2[%arg9] : memref<?xf32>
        memref.store %23, %10[%22] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%19#1) to (%18) step (%c1) {
        %20 = memref.load %arg5[%arg9] : memref<?xindex>
        %21 = arith.muli %arg8, %c256 : index
        %22 = arith.addi %21, %20 : index
        %23 = memref.load %arg6[%arg9] : memref<?xf32>
        memref.store %23, %10[%22] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %10, %12 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After mlir::sparse_tensor::SparsificationAndBufferizationPass () //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c32768 = arith.constant 32768 : index
    %c128 = arith.constant 128 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc(%c32768) : memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %c0_i64 = arith.constant 0 : i64
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = arith.index_cast %c128 : index to i64
    %3 = llvm.insertvalue %2, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %4 = arith.index_cast %c256 : index to i64
    %5 = llvm.insertvalue %4, %3[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %6 = llvm.extractvalue %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %7 = arith.index_cast %6 : i64 to index
    %8 = arith.addi %7, %c32768 : index
    %9 = arith.cmpi ugt, %8, %c32768 : index
    %10 = scf.if %9 -> (memref<?xf32>) {
      %13 = scf.while (%arg8 = %c32768) : (index) -> index {
        %15 = arith.muli %arg8, %c2 : index
        %16 = arith.cmpi ugt, %8, %15 : index
        scf.condition(%16) %15 : index
      } do {
      ^bb0(%arg8: index):
        scf.yield %arg8 : index
      }
      %14 = memref.realloc %alloc(%13) : memref<?xf32> to memref<?xf32>
      scf.yield %14 : memref<?xf32>
    } else {
      scf.yield %alloc : memref<?xf32>
    }
    %subview = memref.subview %10[%7] [%c32768] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %11 = arith.index_cast %8 : index to i64
    %12 = llvm.insertvalue %11, %5[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
      %13 = memref.load %arg0[%arg8] : memref<?xindex>
      %14 = arith.addi %arg8, %c1 : index
      %15 = memref.load %arg0[%14] : memref<?xindex>
      %16 = memref.load %arg4[%arg8] : memref<?xindex>
      %17 = arith.addi %arg8, %c1 : index
      %18 = memref.load %arg4[%17] : memref<?xindex>
      %19:2 = scf.while (%arg9 = %13, %arg10 = %16) : (index, index) -> (index, index) {
        %20 = arith.cmpi ult, %arg9, %15 : index
        %21 = arith.cmpi ult, %arg10, %18 : index
        %22 = arith.andi %20, %21 : i1
        scf.condition(%22) %arg9, %arg10 : index, index
      } do {
      ^bb0(%arg9: index, %arg10: index):
        %20 = memref.load %arg1[%arg9] : memref<?xindex>
        %21 = memref.load %arg5[%arg10] : memref<?xindex>
        %22 = arith.cmpi ult, %21, %20 : index
        %23 = arith.select %22, %21, %20 : index
        %24 = arith.muli %arg8, %c256 : index
        %25 = arith.addi %24, %23 : index
        %26 = arith.cmpi eq, %20, %23 : index
        %27 = arith.cmpi eq, %21, %23 : index
        %28 = arith.andi %26, %27 : i1
        scf.if %28 {
          %35 = memref.load %arg2[%arg9] : memref<?xf32>
          %36 = memref.load %arg6[%arg10] : memref<?xf32>
          %37 = arith.addf %35, %36 : f32
          memref.store %37, %10[%25] : memref<?xf32>
        } else {
          %35 = arith.cmpi eq, %20, %23 : index
          scf.if %35 {
            %36 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %36, %10[%25] : memref<?xf32>
          } else {
            %36 = arith.cmpi eq, %21, %23 : index
            scf.if %36 {
              %37 = memref.load %arg6[%arg10] : memref<?xf32>
              memref.store %37, %10[%25] : memref<?xf32>
            } else {
            }
          }
        }
        %29 = arith.cmpi eq, %20, %23 : index
        %30 = arith.addi %arg9, %c1 : index
        %31 = arith.select %29, %30, %arg9 : index
        %32 = arith.cmpi eq, %21, %23 : index
        %33 = arith.addi %arg10, %c1 : index
        %34 = arith.select %32, %33, %arg10 : index
        scf.yield %31, %34 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%19#0) to (%15) step (%c1) {
        %20 = memref.load %arg1[%arg9] : memref<?xindex>
        %21 = arith.muli %arg8, %c256 : index
        %22 = arith.addi %21, %20 : index
        %23 = memref.load %arg2[%arg9] : memref<?xf32>
        memref.store %23, %10[%22] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.parallel (%arg9) = (%19#1) to (%18) step (%c1) {
        %20 = memref.load %arg5[%arg9] : memref<?xindex>
        %21 = arith.muli %arg8, %c256 : index
        %22 = arith.addi %21, %20 : index
        %23 = memref.load %arg6[%arg9] : memref<?xf32>
        memref.store %23, %10[%22] : memref<?xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %10, %12 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c32768_i64 = arith.constant 32768 : i64
  %c0 = arith.constant 0 : index
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %alloc = memref.alloc() : memref<32768xf32>
  %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  linalg.fill ins(%cst : f32) outs(%alloc : memref<32768xf32>)
  %4 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
    %5 = memref.load %arg0[%arg8] : memref<?xindex>
    %6 = arith.addi %arg8, %c1 : index
    %7 = memref.load %arg0[%6] : memref<?xindex>
    %8 = memref.load %arg4[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg4[%9] : memref<?xindex>
    %11:2 = scf.while (%arg9 = %5, %arg10 = %8) : (index, index) -> (index, index) {
      %12 = arith.cmpi ult, %arg9, %7 : index
      %13 = arith.cmpi ult, %arg10, %10 : index
      %14 = arith.andi %12, %13 : i1
      scf.condition(%14) %arg9, %arg10 : index, index
    } do {
    ^bb0(%arg9: index, %arg10: index):
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = memref.load %arg5[%arg10] : memref<?xindex>
      %14 = arith.cmpi ult, %13, %12 : index
      %15 = arith.select %14, %13, %12 : index
      %16 = arith.muli %arg8, %c256 : index
      %17 = arith.addi %16, %15 : index
      %18 = arith.cmpi eq, %12, %15 : index
      %19 = arith.cmpi eq, %13, %15 : index
      %20 = arith.andi %18, %19 : i1
      scf.if %20 {
        %27 = memref.load %arg2[%arg9] : memref<?xf32>
        %28 = memref.load %arg6[%arg10] : memref<?xf32>
        %29 = arith.addf %27, %28 : f32
        memref.store %29, %alloc[%17] : memref<32768xf32>
      } else {
        %27 = arith.cmpi eq, %12, %15 : index
        scf.if %27 {
          %28 = memref.load %arg2[%arg9] : memref<?xf32>
          memref.store %28, %alloc[%17] : memref<32768xf32>
        } else {
          %28 = arith.cmpi eq, %13, %15 : index
          scf.if %28 {
            %29 = memref.load %arg6[%arg10] : memref<?xf32>
            memref.store %29, %alloc[%17] : memref<32768xf32>
          }
        }
      }
      %21 = arith.cmpi eq, %12, %15 : index
      %22 = arith.addi %arg9, %c1 : index
      %23 = arith.select %21, %22, %arg9 : index
      %24 = arith.cmpi eq, %13, %15 : index
      %25 = arith.addi %arg10, %c1 : index
      %26 = arith.select %24, %25, %arg10 : index
      scf.yield %23, %26 : index, index
    } attributes {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#0) to (%7) step (%c1) {
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg2[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#1) to (%10) step (%c1) {
      %12 = memref.load %arg5[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg6[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c32768_i64 = arith.constant 32768 : i64
  %c0 = arith.constant 0 : index
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %alloc = memref.alloc() : memref<32768xf32>
  %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  linalg.fill ins(%cst : f32) outs(%alloc : memref<32768xf32>)
  %4 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
    %5 = memref.load %arg0[%arg8] : memref<?xindex>
    %6 = arith.addi %arg8, %c1 : index
    %7 = memref.load %arg0[%6] : memref<?xindex>
    %8 = memref.load %arg4[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg4[%9] : memref<?xindex>
    %11:2 = scf.while (%arg9 = %5, %arg10 = %8) : (index, index) -> (index, index) {
      %12 = arith.cmpi ult, %arg9, %7 : index
      %13 = arith.cmpi ult, %arg10, %10 : index
      %14 = arith.andi %12, %13 : i1
      scf.condition(%14) %arg9, %arg10 : index, index
    } do {
    ^bb0(%arg9: index, %arg10: index):
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = memref.load %arg5[%arg10] : memref<?xindex>
      %14 = arith.cmpi ult, %13, %12 : index
      %15 = arith.select %14, %13, %12 : index
      %16 = arith.muli %arg8, %c256 : index
      %17 = arith.addi %16, %15 : index
      %18 = arith.cmpi eq, %12, %15 : index
      %19 = arith.cmpi eq, %13, %15 : index
      %20 = arith.andi %18, %19 : i1
      scf.if %20 {
        %27 = memref.load %arg2[%arg9] : memref<?xf32>
        %28 = memref.load %arg6[%arg10] : memref<?xf32>
        %29 = arith.addf %27, %28 : f32
        memref.store %29, %alloc[%17] : memref<32768xf32>
      } else {
        %27 = arith.cmpi eq, %12, %15 : index
        scf.if %27 {
          %28 = memref.load %arg2[%arg9] : memref<?xf32>
          memref.store %28, %alloc[%17] : memref<32768xf32>
        } else {
          %28 = arith.cmpi eq, %13, %15 : index
          scf.if %28 {
            %29 = memref.load %arg6[%arg10] : memref<?xf32>
            memref.store %29, %alloc[%17] : memref<32768xf32>
          }
        }
      }
      %21 = arith.cmpi eq, %12, %15 : index
      %22 = arith.addi %arg9, %c1 : index
      %23 = arith.select %21, %22, %arg9 : index
      %24 = arith.cmpi eq, %13, %15 : index
      %25 = arith.addi %arg10, %c1 : index
      %26 = arith.select %24, %25, %arg10 : index
      scf.yield %23, %26 : index, index
    } attributes {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#0) to (%7) step (%c1) {
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg2[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#1) to (%10) step (%c1) {
      %12 = memref.load %arg5[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg6[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %alloc = memref.alloc() : memref<32768xf32>
  %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg8 = %c0 to %c32768 step %c1 {
    memref.store %cst, %alloc[%arg8] : memref<32768xf32>
  }
  %4 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
    %5 = memref.load %arg0[%arg8] : memref<?xindex>
    %6 = arith.addi %arg8, %c1 : index
    %7 = memref.load %arg0[%6] : memref<?xindex>
    %8 = memref.load %arg4[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg4[%9] : memref<?xindex>
    %11:2 = scf.while (%arg9 = %5, %arg10 = %8) : (index, index) -> (index, index) {
      %12 = arith.cmpi ult, %arg9, %7 : index
      %13 = arith.cmpi ult, %arg10, %10 : index
      %14 = arith.andi %12, %13 : i1
      scf.condition(%14) %arg9, %arg10 : index, index
    } do {
    ^bb0(%arg9: index, %arg10: index):
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = memref.load %arg5[%arg10] : memref<?xindex>
      %14 = arith.cmpi ult, %13, %12 : index
      %15 = arith.select %14, %13, %12 : index
      %16 = arith.muli %arg8, %c256 : index
      %17 = arith.addi %16, %15 : index
      %18 = arith.cmpi eq, %12, %15 : index
      %19 = arith.cmpi eq, %13, %15 : index
      %20 = arith.andi %18, %19 : i1
      scf.if %20 {
        %27 = memref.load %arg2[%arg9] : memref<?xf32>
        %28 = memref.load %arg6[%arg10] : memref<?xf32>
        %29 = arith.addf %27, %28 : f32
        memref.store %29, %alloc[%17] : memref<32768xf32>
      } else {
        %27 = arith.cmpi eq, %12, %15 : index
        scf.if %27 {
          %28 = memref.load %arg2[%arg9] : memref<?xf32>
          memref.store %28, %alloc[%17] : memref<32768xf32>
        } else {
          %28 = arith.cmpi eq, %13, %15 : index
          scf.if %28 {
            %29 = memref.load %arg6[%arg10] : memref<?xf32>
            memref.store %29, %alloc[%17] : memref<32768xf32>
          }
        }
      }
      %21 = arith.cmpi eq, %12, %15 : index
      %22 = arith.addi %arg9, %c1 : index
      %23 = arith.select %21, %22, %arg9 : index
      %24 = arith.cmpi eq, %13, %15 : index
      %25 = arith.addi %arg10, %c1 : index
      %26 = arith.select %24, %25, %arg10 : index
      scf.yield %23, %26 : index, index
    } attributes {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#0) to (%7) step (%c1) {
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg2[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#1) to (%10) step (%c1) {
      %12 = memref.load %arg5[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg6[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %alloc = memref.alloc() : memref<32768xf32>
  %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg8 = %c0 to %c32768 step %c1 {
    memref.store %cst, %alloc[%arg8] : memref<32768xf32>
  }
  %4 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.parallel (%arg8) = (%c0) to (%c128) step (%c1) {
    %5 = memref.load %arg0[%arg8] : memref<?xindex>
    %6 = arith.addi %arg8, %c1 : index
    %7 = memref.load %arg0[%6] : memref<?xindex>
    %8 = memref.load %arg4[%arg8] : memref<?xindex>
    %9 = arith.addi %arg8, %c1 : index
    %10 = memref.load %arg4[%9] : memref<?xindex>
    %11:2 = scf.while (%arg9 = %5, %arg10 = %8) : (index, index) -> (index, index) {
      %12 = arith.cmpi ult, %arg9, %7 : index
      %13 = arith.cmpi ult, %arg10, %10 : index
      %14 = arith.andi %12, %13 : i1
      scf.condition(%14) %arg9, %arg10 : index, index
    } do {
    ^bb0(%arg9: index, %arg10: index):
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = memref.load %arg5[%arg10] : memref<?xindex>
      %14 = arith.cmpi ult, %13, %12 : index
      %15 = arith.select %14, %13, %12 : index
      %16 = arith.muli %arg8, %c256 : index
      %17 = arith.addi %16, %15 : index
      %18 = arith.cmpi eq, %12, %15 : index
      %19 = arith.cmpi eq, %13, %15 : index
      %20 = arith.andi %18, %19 : i1
      scf.if %20 {
        %27 = memref.load %arg2[%arg9] : memref<?xf32>
        %28 = memref.load %arg6[%arg10] : memref<?xf32>
        %29 = arith.addf %27, %28 : f32
        memref.store %29, %alloc[%17] : memref<32768xf32>
      } else {
        %27 = arith.cmpi eq, %12, %15 : index
        scf.if %27 {
          %28 = memref.load %arg2[%arg9] : memref<?xf32>
          memref.store %28, %alloc[%17] : memref<32768xf32>
        } else {
          %28 = arith.cmpi eq, %13, %15 : index
          scf.if %28 {
            %29 = memref.load %arg6[%arg10] : memref<?xf32>
            memref.store %29, %alloc[%17] : memref<32768xf32>
          }
        }
      }
      %21 = arith.cmpi eq, %12, %15 : index
      %22 = arith.addi %arg9, %c1 : index
      %23 = arith.select %21, %22, %arg9 : index
      %24 = arith.cmpi eq, %13, %15 : index
      %25 = arith.addi %arg10, %c1 : index
      %26 = arith.select %24, %25, %arg10 : index
      scf.yield %23, %26 : index, index
    } attributes {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#0) to (%7) step (%c1) {
      %12 = memref.load %arg1[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg2[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.parallel (%arg9) = (%11#1) to (%10) step (%c1) {
      %12 = memref.load %arg5[%arg9] : memref<?xindex>
      %13 = arith.muli %arg8, %c256 : index
      %14 = arith.addi %13, %12 : index
      %15 = memref.load %arg6[%arg9] : memref<?xf32>
      memref.store %15, %alloc[%14] : memref<32768xf32>
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertSCFToOpenMPPass (convert-scf-to-openmp) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %alloc = memref.alloc() : memref<32768xf32>
    %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.for %arg8 = %c0 to %c32768 step %c1 {
      memref.store %cst, %alloc[%arg8] : memref<32768xf32>
    }
    %4 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %5 = llvm.mlir.constant(1 : i64) : i64
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        memref.alloca_scope  {
          %6 = memref.load %arg0[%arg8] : memref<?xindex>
          %7 = arith.addi %arg8, %c1 : index
          %8 = memref.load %arg0[%7] : memref<?xindex>
          %9 = memref.load %arg4[%arg8] : memref<?xindex>
          %10 = arith.addi %arg8, %c1 : index
          %11 = memref.load %arg4[%10] : memref<?xindex>
          %12:2 = scf.while (%arg9 = %6, %arg10 = %9) : (index, index) -> (index, index) {
            %15 = arith.cmpi ult, %arg9, %8 : index
            %16 = arith.cmpi ult, %arg10, %11 : index
            %17 = arith.andi %15, %16 : i1
            scf.condition(%17) %arg9, %arg10 : index, index
          } do {
          ^bb0(%arg9: index, %arg10: index):
            %15 = memref.load %arg1[%arg9] : memref<?xindex>
            %16 = memref.load %arg5[%arg10] : memref<?xindex>
            %17 = arith.cmpi ult, %16, %15 : index
            %18 = arith.select %17, %16, %15 : index
            %19 = arith.muli %arg8, %c256 : index
            %20 = arith.addi %19, %18 : index
            %21 = arith.cmpi eq, %15, %18 : index
            %22 = arith.cmpi eq, %16, %18 : index
            %23 = arith.andi %21, %22 : i1
            scf.if %23 {
              %30 = memref.load %arg2[%arg9] : memref<?xf32>
              %31 = memref.load %arg6[%arg10] : memref<?xf32>
              %32 = arith.addf %30, %31 : f32
              memref.store %32, %alloc[%20] : memref<32768xf32>
            } else {
              %30 = arith.cmpi eq, %15, %18 : index
              scf.if %30 {
                %31 = memref.load %arg2[%arg9] : memref<?xf32>
                memref.store %31, %alloc[%20] : memref<32768xf32>
              } else {
                %31 = arith.cmpi eq, %16, %18 : index
                scf.if %31 {
                  %32 = memref.load %arg6[%arg10] : memref<?xf32>
                  memref.store %32, %alloc[%20] : memref<32768xf32>
                }
              }
            }
            %24 = arith.cmpi eq, %15, %18 : index
            %25 = arith.addi %arg9, %c1 : index
            %26 = arith.select %24, %25, %arg9 : index
            %27 = arith.cmpi eq, %16, %18 : index
            %28 = arith.addi %arg10, %c1 : index
            %29 = arith.select %27, %28, %arg10 : index
            scf.yield %26, %29 : index, index
          } attributes {"Emitted from" = "linalg.generic"}
          %13 = llvm.mlir.constant(1 : i64) : i64
          omp.parallel   {
            omp.wsloop   for  (%arg9) : index = (%12#0) to (%8) step (%c1) {
              memref.alloca_scope  {
                %15 = memref.load %arg1[%arg9] : memref<?xindex>
                %16 = arith.muli %arg8, %c256 : index
                %17 = arith.addi %16, %15 : index
                %18 = memref.load %arg2[%arg9] : memref<?xf32>
                memref.store %18, %alloc[%17] : memref<32768xf32>
              }
              omp.yield
            }
            omp.terminator
          }
          %14 = llvm.mlir.constant(1 : i64) : i64
          omp.parallel   {
            omp.wsloop   for  (%arg9) : index = (%12#1) to (%11) step (%c1) {
              memref.alloca_scope  {
                %15 = memref.load %arg5[%arg9] : memref<?xindex>
                %16 = arith.muli %arg8, %c256 : index
                %17 = arith.addi %16, %15 : index
                %18 = memref.load %arg6[%arg9] : memref<?xf32>
                memref.store %18, %alloc[%17] : memref<32768xf32>
              }
              omp.yield
            }
            omp.terminator
          }
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %alloc = memref.alloc() : memref<32768xf32>
  %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg8 = %c0 to %c32768 step %c1 {
    memref.store %cst, %alloc[%arg8] : memref<32768xf32>
  }
  %4 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
      %5 = memref.load %arg0[%arg8] : memref<?xindex>
      %6 = arith.addi %arg8, %c1 : index
      %7 = memref.load %arg0[%6] : memref<?xindex>
      %8 = memref.load %arg4[%arg8] : memref<?xindex>
      %9 = arith.addi %arg8, %c1 : index
      %10 = memref.load %arg4[%9] : memref<?xindex>
      %11:2 = scf.while (%arg9 = %5, %arg10 = %8) : (index, index) -> (index, index) {
        %12 = arith.cmpi ult, %arg9, %7 : index
        %13 = arith.cmpi ult, %arg10, %10 : index
        %14 = arith.andi %12, %13 : i1
        scf.condition(%14) %arg9, %arg10 : index, index
      } do {
      ^bb0(%arg9: index, %arg10: index):
        %12 = memref.load %arg1[%arg9] : memref<?xindex>
        %13 = memref.load %arg5[%arg10] : memref<?xindex>
        %14 = arith.cmpi ult, %13, %12 : index
        %15 = arith.select %14, %13, %12 : index
        %16 = arith.muli %arg8, %c256 : index
        %17 = arith.addi %16, %15 : index
        %18 = arith.cmpi eq, %12, %15 : index
        %19 = arith.cmpi eq, %13, %15 : index
        %20 = arith.andi %18, %19 : i1
        scf.if %20 {
          %27 = memref.load %arg2[%arg9] : memref<?xf32>
          %28 = memref.load %arg6[%arg10] : memref<?xf32>
          %29 = arith.addf %27, %28 : f32
          memref.store %29, %alloc[%17] : memref<32768xf32>
        } else {
          %27 = arith.cmpi eq, %12, %15 : index
          scf.if %27 {
            %28 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %28, %alloc[%17] : memref<32768xf32>
          } else {
            %28 = arith.cmpi eq, %13, %15 : index
            scf.if %28 {
              %29 = memref.load %arg6[%arg10] : memref<?xf32>
              memref.store %29, %alloc[%17] : memref<32768xf32>
            }
          }
        }
        %21 = arith.cmpi eq, %12, %15 : index
        %22 = arith.addi %arg9, %c1 : index
        %23 = arith.select %21, %22, %arg9 : index
        %24 = arith.cmpi eq, %13, %15 : index
        %25 = arith.addi %arg10, %c1 : index
        %26 = arith.select %24, %25, %arg10 : index
        scf.yield %23, %26 : index, index
      } attributes {"Emitted from" = "linalg.generic"}
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%11#0) to (%7) step (%c1) {
          %12 = memref.load %arg1[%arg9] : memref<?xindex>
          %13 = arith.muli %arg8, %c256 : index
          %14 = arith.addi %13, %12 : index
          %15 = memref.load %arg2[%arg9] : memref<?xf32>
          memref.store %15, %alloc[%14] : memref<32768xf32>
          omp.yield
        }
        omp.terminator
      }
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%11#1) to (%10) step (%c1) {
          %12 = memref.load %arg5[%arg9] : memref<?xindex>
          %13 = arith.muli %arg8, %c256 : index
          %14 = arith.addi %13, %12 : index
          %15 = memref.load %arg6[%arg9] : memref<?xf32>
          memref.store %15, %alloc[%14] : memref<32768xf32>
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %cast, %4 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %alloc = memref.alloc() : memref<32768xf32>
  %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
  %5 = arith.cmpi slt, %4, %c32768 : index
  cf.cond_br %5, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  memref.store %cst, %alloc[%4] : memref<32768xf32>
  %6 = arith.addi %4, %c1 : index
  cf.br ^bb1(%6 : index)
^bb3:  // pred: ^bb1
  %7 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
      %8 = memref.load %arg0[%arg8] : memref<?xindex>
      %9 = arith.addi %arg8, %c1 : index
      %10 = memref.load %arg0[%9] : memref<?xindex>
      %11 = memref.load %arg4[%arg8] : memref<?xindex>
      %12 = arith.addi %arg8, %c1 : index
      %13 = memref.load %arg4[%12] : memref<?xindex>
      cf.br ^bb1(%8, %11 : index, index)
    ^bb1(%14: index, %15: index):  // 2 preds: ^bb0, ^bb10
      %16 = arith.cmpi ult, %14, %10 : index
      %17 = arith.cmpi ult, %15, %13 : index
      %18 = arith.andi %16, %17 : i1
      cf.cond_br %18, ^bb2(%14, %15 : index, index), ^bb11
    ^bb2(%19: index, %20: index):  // pred: ^bb1
      %21 = memref.load %arg1[%19] : memref<?xindex>
      %22 = memref.load %arg5[%20] : memref<?xindex>
      %23 = arith.cmpi ult, %22, %21 : index
      %24 = arith.select %23, %22, %21 : index
      %25 = arith.muli %arg8, %c256 : index
      %26 = arith.addi %25, %24 : index
      %27 = arith.cmpi eq, %21, %24 : index
      %28 = arith.cmpi eq, %22, %24 : index
      %29 = arith.andi %27, %28 : i1
      cf.cond_br %29, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %30 = memref.load %arg2[%19] : memref<?xf32>
      %31 = memref.load %arg6[%20] : memref<?xf32>
      %32 = arith.addf %30, %31 : f32
      memref.store %32, %alloc[%26] : memref<32768xf32>
      cf.br ^bb10
    ^bb4:  // pred: ^bb2
      %33 = arith.cmpi eq, %21, %24 : index
      cf.cond_br %33, ^bb5, ^bb6
    ^bb5:  // pred: ^bb4
      %34 = memref.load %arg2[%19] : memref<?xf32>
      memref.store %34, %alloc[%26] : memref<32768xf32>
      cf.br ^bb9
    ^bb6:  // pred: ^bb4
      %35 = arith.cmpi eq, %22, %24 : index
      cf.cond_br %35, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %36 = memref.load %arg6[%20] : memref<?xf32>
      memref.store %36, %alloc[%26] : memref<32768xf32>
      cf.br ^bb8
    ^bb8:  // 2 preds: ^bb6, ^bb7
      cf.br ^bb9
    ^bb9:  // 2 preds: ^bb5, ^bb8
      cf.br ^bb10
    ^bb10:  // 2 preds: ^bb3, ^bb9
      %37 = arith.cmpi eq, %21, %24 : index
      %38 = arith.addi %19, %c1 : index
      %39 = arith.select %37, %38, %19 : index
      %40 = arith.cmpi eq, %22, %24 : index
      %41 = arith.addi %20, %c1 : index
      %42 = arith.select %40, %41, %20 : index
      cf.br ^bb1(%39, %42 : index, index)
    ^bb11:  // pred: ^bb1
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%14) to (%10) step (%c1) {
          %43 = memref.load %arg1[%arg9] : memref<?xindex>
          %44 = arith.muli %arg8, %c256 : index
          %45 = arith.addi %44, %43 : index
          %46 = memref.load %arg2[%arg9] : memref<?xf32>
          memref.store %46, %alloc[%45] : memref<32768xf32>
          omp.yield
        }
        omp.terminator
      }
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%15) to (%13) step (%c1) {
          %43 = memref.load %arg5[%arg9] : memref<?xindex>
          %44 = arith.muli %arg8, %c256 : index
          %45 = arith.addi %44, %43 : index
          %46 = memref.load %arg6[%arg9] : memref<?xf32>
          memref.store %46, %alloc[%45] : memref<32768xf32>
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ExpandStridedMetadata (expand-strided-metadata) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %alloc = memref.alloc() : memref<32768xf32>
    %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %c32768 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc[%4] : memref<32768xf32>
    %6 = arith.addi %4, %c1 : index
    cf.br ^bb1(%6 : index)
  ^bb3:  // pred: ^bb1
    %7 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %8 = memref.load %arg0[%arg8] : memref<?xindex>
        %9 = arith.addi %arg8, %c1 : index
        %10 = memref.load %arg0[%9] : memref<?xindex>
        %11 = memref.load %arg4[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg4[%12] : memref<?xindex>
        cf.br ^bb1(%8, %11 : index, index)
      ^bb1(%14: index, %15: index):  // 2 preds: ^bb0, ^bb10
        %16 = arith.cmpi ult, %14, %10 : index
        %17 = arith.cmpi ult, %15, %13 : index
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2(%14, %15 : index, index), ^bb11
      ^bb2(%19: index, %20: index):  // pred: ^bb1
        %21 = memref.load %arg1[%19] : memref<?xindex>
        %22 = memref.load %arg5[%20] : memref<?xindex>
        %23 = arith.cmpi ult, %22, %21 : index
        %24 = arith.select %23, %22, %21 : index
        %25 = arith.muli %arg8, %c256 : index
        %26 = arith.addi %25, %24 : index
        %27 = arith.cmpi eq, %21, %24 : index
        %28 = arith.cmpi eq, %22, %24 : index
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %30 = memref.load %arg2[%19] : memref<?xf32>
        %31 = memref.load %arg6[%20] : memref<?xf32>
        %32 = arith.addf %30, %31 : f32
        memref.store %32, %alloc[%26] : memref<32768xf32>
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %33 = arith.cmpi eq, %21, %24 : index
        cf.cond_br %33, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %34 = memref.load %arg2[%19] : memref<?xf32>
        memref.store %34, %alloc[%26] : memref<32768xf32>
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %35 = arith.cmpi eq, %22, %24 : index
        cf.cond_br %35, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %36 = memref.load %arg6[%20] : memref<?xf32>
        memref.store %36, %alloc[%26] : memref<32768xf32>
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %37 = arith.cmpi eq, %21, %24 : index
        %38 = arith.addi %19, %c1 : index
        %39 = arith.select %37, %38, %19 : index
        %40 = arith.cmpi eq, %22, %24 : index
        %41 = arith.addi %20, %c1 : index
        %42 = arith.select %40, %41, %20 : index
        cf.br ^bb1(%39, %42 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%14) to (%10) step (%c1) {
            %43 = memref.load %arg1[%arg9] : memref<?xindex>
            %44 = arith.muli %arg8, %c256 : index
            %45 = arith.addi %44, %43 : index
            %46 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %46, %alloc[%45] : memref<32768xf32>
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%15) to (%13) step (%c1) {
            %43 = memref.load %arg5[%arg9] : memref<?xindex>
            %44 = arith.muli %arg8, %c256 : index
            %45 = arith.addi %44, %43 : index
            %46 = memref.load %arg6[%arg9] : memref<?xf32>
            memref.store %46, %alloc[%45] : memref<32768xf32>
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertAffineToStandard (lower-affine) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %alloc = memref.alloc() : memref<32768xf32>
    %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %c32768 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc[%4] : memref<32768xf32>
    %6 = arith.addi %4, %c1 : index
    cf.br ^bb1(%6 : index)
  ^bb3:  // pred: ^bb1
    %7 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %8 = memref.load %arg0[%arg8] : memref<?xindex>
        %9 = arith.addi %arg8, %c1 : index
        %10 = memref.load %arg0[%9] : memref<?xindex>
        %11 = memref.load %arg4[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg4[%12] : memref<?xindex>
        cf.br ^bb1(%8, %11 : index, index)
      ^bb1(%14: index, %15: index):  // 2 preds: ^bb0, ^bb10
        %16 = arith.cmpi ult, %14, %10 : index
        %17 = arith.cmpi ult, %15, %13 : index
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2(%14, %15 : index, index), ^bb11
      ^bb2(%19: index, %20: index):  // pred: ^bb1
        %21 = memref.load %arg1[%19] : memref<?xindex>
        %22 = memref.load %arg5[%20] : memref<?xindex>
        %23 = arith.cmpi ult, %22, %21 : index
        %24 = arith.select %23, %22, %21 : index
        %25 = arith.muli %arg8, %c256 : index
        %26 = arith.addi %25, %24 : index
        %27 = arith.cmpi eq, %21, %24 : index
        %28 = arith.cmpi eq, %22, %24 : index
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %30 = memref.load %arg2[%19] : memref<?xf32>
        %31 = memref.load %arg6[%20] : memref<?xf32>
        %32 = arith.addf %30, %31 : f32
        memref.store %32, %alloc[%26] : memref<32768xf32>
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %33 = arith.cmpi eq, %21, %24 : index
        cf.cond_br %33, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %34 = memref.load %arg2[%19] : memref<?xf32>
        memref.store %34, %alloc[%26] : memref<32768xf32>
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %35 = arith.cmpi eq, %22, %24 : index
        cf.cond_br %35, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %36 = memref.load %arg6[%20] : memref<?xf32>
        memref.store %36, %alloc[%26] : memref<32768xf32>
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %37 = arith.cmpi eq, %21, %24 : index
        %38 = arith.addi %19, %c1 : index
        %39 = arith.select %37, %38, %19 : index
        %40 = arith.cmpi eq, %22, %24 : index
        %41 = arith.addi %20, %c1 : index
        %42 = arith.select %40, %41, %20 : index
        cf.br ^bb1(%39, %42 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%14) to (%10) step (%c1) {
            %43 = memref.load %arg1[%arg9] : memref<?xindex>
            %44 = arith.muli %arg8, %c256 : index
            %45 = arith.addi %44, %43 : index
            %46 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %46, %alloc[%45] : memref<32768xf32>
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%15) to (%13) step (%c1) {
            %43 = memref.load %arg5[%arg9] : memref<?xindex>
            %44 = arith.muli %arg8, %c256 : index
            %45 = arith.addi %44, %43 : index
            %46 = memref.load %arg6[%arg9] : memref<?xf32>
            memref.store %46, %alloc[%45] : memref<32768xf32>
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %alloc = memref.alloc() : memref<32768xf32>
    %cast = memref.cast %alloc : memref<32768xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %c128_i64, %1[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %c256_i64, %2[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %c32768 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc[%4] : memref<32768xf32>
    %6 = arith.addi %4, %c1 : index
    cf.br ^bb1(%6 : index)
  ^bb3:  // pred: ^bb1
    %7 = llvm.insertvalue %c32768_i64, %3[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %8 = memref.load %arg0[%arg8] : memref<?xindex>
        %9 = arith.addi %arg8, %c1 : index
        %10 = memref.load %arg0[%9] : memref<?xindex>
        %11 = memref.load %arg4[%arg8] : memref<?xindex>
        %12 = arith.addi %arg8, %c1 : index
        %13 = memref.load %arg4[%12] : memref<?xindex>
        cf.br ^bb1(%8, %11 : index, index)
      ^bb1(%14: index, %15: index):  // 2 preds: ^bb0, ^bb10
        %16 = arith.cmpi ult, %14, %10 : index
        %17 = arith.cmpi ult, %15, %13 : index
        %18 = arith.andi %16, %17 : i1
        cf.cond_br %18, ^bb2(%14, %15 : index, index), ^bb11
      ^bb2(%19: index, %20: index):  // pred: ^bb1
        %21 = memref.load %arg1[%19] : memref<?xindex>
        %22 = memref.load %arg5[%20] : memref<?xindex>
        %23 = arith.cmpi ult, %22, %21 : index
        %24 = arith.select %23, %22, %21 : index
        %25 = arith.muli %arg8, %c256 : index
        %26 = arith.addi %25, %24 : index
        %27 = arith.cmpi eq, %21, %24 : index
        %28 = arith.cmpi eq, %22, %24 : index
        %29 = arith.andi %27, %28 : i1
        cf.cond_br %29, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %30 = memref.load %arg2[%19] : memref<?xf32>
        %31 = memref.load %arg6[%20] : memref<?xf32>
        %32 = arith.addf %30, %31 : f32
        memref.store %32, %alloc[%26] : memref<32768xf32>
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %33 = arith.cmpi eq, %21, %24 : index
        cf.cond_br %33, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %34 = memref.load %arg2[%19] : memref<?xf32>
        memref.store %34, %alloc[%26] : memref<32768xf32>
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %35 = arith.cmpi eq, %22, %24 : index
        cf.cond_br %35, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %36 = memref.load %arg6[%20] : memref<?xf32>
        memref.store %36, %alloc[%26] : memref<32768xf32>
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %37 = arith.cmpi eq, %21, %24 : index
        %38 = arith.addi %19, %c1 : index
        %39 = arith.select %37, %38, %19 : index
        %40 = arith.cmpi eq, %22, %24 : index
        %41 = arith.addi %20, %c1 : index
        %42 = arith.select %40, %41, %20 : index
        cf.br ^bb1(%39, %42 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%14) to (%10) step (%c1) {
            %43 = memref.load %arg1[%arg9] : memref<?xindex>
            %44 = arith.muli %arg8, %c256 : index
            %45 = arith.addi %44, %43 : index
            %46 = memref.load %arg2[%arg9] : memref<?xf32>
            memref.store %46, %alloc[%45] : memref<32768xf32>
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%15) to (%13) step (%c1) {
            %43 = memref.load %arg5[%arg9] : memref<?xindex>
            %44 = arith.muli %arg8, %c256 : index
            %45 = arith.addi %44, %43 : index
            %46 = memref.load %arg6[%arg9] : memref<?xf32>
            memref.store %46, %alloc[%45] : memref<32768xf32>
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast, %7 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After FinalizeMemRefToLLVMConversionPass (finalize-memref-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %6 = llvm.mlir.constant(32768 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.null : !llvm.ptr
    %9 = llvm.getelementptr %8[%6] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
    %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c32768 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.getelementptr %27[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %28 : f32, !llvm.ptr
    %29 = arith.addi %24, %c1 : index
    cf.br ^bb1(%29 : index)
  ^bb3:  // pred: ^bb1
    %30 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %31 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %33 = llvm.getelementptr %32[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %34 = llvm.load %33 : !llvm.ptr -> i64
        %35 = builtin.unrealized_conversion_cast %34 : i64 to index
        %36 = arith.addi %arg8, %c1 : index
        %37 = builtin.unrealized_conversion_cast %36 : index to i64
        %38 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %39 = llvm.getelementptr %38[%37] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %40 = llvm.load %39 : !llvm.ptr -> i64
        %41 = builtin.unrealized_conversion_cast %40 : i64 to index
        %42 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %43 = llvm.getelementptr %42[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %44 = llvm.load %43 : !llvm.ptr -> i64
        %45 = builtin.unrealized_conversion_cast %44 : i64 to index
        %46 = arith.addi %arg8, %c1 : index
        %47 = builtin.unrealized_conversion_cast %46 : index to i64
        %48 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %49 = llvm.getelementptr %48[%47] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %50 = llvm.load %49 : !llvm.ptr -> i64
        %51 = builtin.unrealized_conversion_cast %50 : i64 to index
        cf.br ^bb1(%35, %45 : index, index)
      ^bb1(%52: index, %53: index):  // 2 preds: ^bb0, ^bb10
        %54 = arith.cmpi ult, %52, %41 : index
        %55 = arith.cmpi ult, %53, %51 : index
        %56 = arith.andi %54, %55 : i1
        cf.cond_br %56, ^bb2(%52, %53 : index, index), ^bb11
      ^bb2(%57: index, %58: index):  // pred: ^bb1
        %59 = builtin.unrealized_conversion_cast %57 : index to i64
        %60 = builtin.unrealized_conversion_cast %58 : index to i64
        %61 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %62 = llvm.getelementptr %61[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %63 = llvm.load %62 : !llvm.ptr -> i64
        %64 = builtin.unrealized_conversion_cast %63 : i64 to index
        %65 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %66 = llvm.getelementptr %65[%60] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %67 = llvm.load %66 : !llvm.ptr -> i64
        %68 = builtin.unrealized_conversion_cast %67 : i64 to index
        %69 = arith.cmpi ult, %68, %64 : index
        %70 = arith.select %69, %68, %64 : index
        %71 = arith.muli %arg8, %c256 : index
        %72 = arith.addi %71, %70 : index
        %73 = builtin.unrealized_conversion_cast %72 : index to i64
        %74 = arith.cmpi eq, %64, %70 : index
        %75 = arith.cmpi eq, %68, %70 : index
        %76 = arith.andi %74, %75 : i1
        cf.cond_br %76, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %77 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %78 = llvm.getelementptr %77[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %79 = llvm.load %78 : !llvm.ptr -> f32
        %80 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %81 = llvm.getelementptr %80[%60] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %82 = llvm.load %81 : !llvm.ptr -> f32
        %83 = arith.addf %79, %82 : f32
        %84 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %85 = llvm.getelementptr %84[%73] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %83, %85 : f32, !llvm.ptr
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %86 = arith.cmpi eq, %64, %70 : index
        cf.cond_br %86, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %87 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %88 = llvm.getelementptr %87[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %89 = llvm.load %88 : !llvm.ptr -> f32
        %90 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %91 = llvm.getelementptr %90[%73] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %89, %91 : f32, !llvm.ptr
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %92 = arith.cmpi eq, %68, %70 : index
        cf.cond_br %92, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %93 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %94 = llvm.getelementptr %93[%60] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %95 = llvm.load %94 : !llvm.ptr -> f32
        %96 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %97 = llvm.getelementptr %96[%73] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %95, %97 : f32, !llvm.ptr
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %98 = arith.cmpi eq, %64, %70 : index
        %99 = arith.addi %57, %c1 : index
        %100 = arith.select %98, %99, %57 : index
        %101 = arith.cmpi eq, %68, %70 : index
        %102 = arith.addi %58, %c1 : index
        %103 = arith.select %101, %102, %58 : index
        cf.br ^bb1(%100, %103 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%52) to (%41) step (%c1) {
            %104 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %105 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %106 = llvm.getelementptr %105[%104] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %107 = llvm.load %106 : !llvm.ptr -> i64
            %108 = builtin.unrealized_conversion_cast %107 : i64 to index
            %109 = arith.muli %arg8, %c256 : index
            %110 = arith.addi %109, %108 : index
            %111 = builtin.unrealized_conversion_cast %110 : index to i64
            %112 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %113 = llvm.getelementptr %112[%104] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %114 = llvm.load %113 : !llvm.ptr -> f32
            %115 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %116 = llvm.getelementptr %115[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %114, %116 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%53) to (%51) step (%c1) {
            %104 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %105 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %106 = llvm.getelementptr %105[%104] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %107 = llvm.load %106 : !llvm.ptr -> i64
            %108 = builtin.unrealized_conversion_cast %107 : i64 to index
            %109 = arith.muli %arg8, %c256 : index
            %110 = arith.addi %109, %108 : index
            %111 = builtin.unrealized_conversion_cast %110 : index to i64
            %112 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %113 = llvm.getelementptr %112[%104] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %114 = llvm.load %113 : !llvm.ptr -> f32
            %115 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %116 = llvm.getelementptr %115[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %114, %116 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %19, %30 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %6 = llvm.mlir.constant(32768 : index) : i64
  %7 = llvm.mlir.constant(1 : index) : i64
  %8 = llvm.mlir.null : !llvm.ptr
  %9 = llvm.getelementptr %8[32768] : (!llvm.ptr) -> !llvm.ptr, f32
  %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
  %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
  %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.mlir.constant(0 : index) : i64
  %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
  %25 = builtin.unrealized_conversion_cast %24 : index to i64
  %26 = arith.cmpi slt, %24, %c32768 : index
  cf.cond_br %26, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %27 : f32, !llvm.ptr
  %28 = arith.addi %24, %c1 : index
  cf.br ^bb1(%28 : index)
^bb3:  // pred: ^bb1
  %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
      %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
      %31 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %33 = llvm.load %32 : !llvm.ptr -> i64
      %34 = builtin.unrealized_conversion_cast %33 : i64 to index
      %35 = arith.addi %arg8, %c1 : index
      %36 = builtin.unrealized_conversion_cast %35 : index to i64
      %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %39 = llvm.load %38 : !llvm.ptr -> i64
      %40 = builtin.unrealized_conversion_cast %39 : i64 to index
      %41 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %43 = llvm.load %42 : !llvm.ptr -> i64
      %44 = builtin.unrealized_conversion_cast %43 : i64 to index
      %45 = arith.addi %arg8, %c1 : index
      %46 = builtin.unrealized_conversion_cast %45 : index to i64
      %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %49 = llvm.load %48 : !llvm.ptr -> i64
      %50 = builtin.unrealized_conversion_cast %49 : i64 to index
      cf.br ^bb1(%34, %44 : index, index)
    ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
      %53 = arith.cmpi ult, %51, %40 : index
      %54 = arith.cmpi ult, %52, %50 : index
      %55 = arith.andi %53, %54 : i1
      cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
    ^bb2(%56: index, %57: index):  // pred: ^bb1
      %58 = builtin.unrealized_conversion_cast %56 : index to i64
      %59 = builtin.unrealized_conversion_cast %57 : index to i64
      %60 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %62 = llvm.load %61 : !llvm.ptr -> i64
      %63 = builtin.unrealized_conversion_cast %62 : i64 to index
      %64 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %66 = llvm.load %65 : !llvm.ptr -> i64
      %67 = builtin.unrealized_conversion_cast %66 : i64 to index
      %68 = arith.cmpi ult, %67, %63 : index
      %69 = arith.select %68, %67, %63 : index
      %70 = arith.muli %arg8, %c256 : index
      %71 = arith.addi %70, %69 : index
      %72 = builtin.unrealized_conversion_cast %71 : index to i64
      %73 = arith.cmpi eq, %63, %69 : index
      %74 = arith.cmpi eq, %67, %69 : index
      %75 = arith.andi %73, %74 : i1
      cf.cond_br %75, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %76 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %78 = llvm.load %77 : !llvm.ptr -> f32
      %79 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %81 = llvm.load %80 : !llvm.ptr -> f32
      %82 = arith.addf %78, %81 : f32
      %83 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %82, %83 : f32, !llvm.ptr
      cf.br ^bb10
    ^bb4:  // pred: ^bb2
      %84 = arith.cmpi eq, %63, %69 : index
      cf.cond_br %84, ^bb5, ^bb6
    ^bb5:  // pred: ^bb4
      %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %87 = llvm.load %86 : !llvm.ptr -> f32
      %88 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %87, %88 : f32, !llvm.ptr
      cf.br ^bb9
    ^bb6:  // pred: ^bb4
      %89 = arith.cmpi eq, %67, %69 : index
      cf.cond_br %89, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %90 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %92 = llvm.load %91 : !llvm.ptr -> f32
      %93 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %92, %93 : f32, !llvm.ptr
      cf.br ^bb8
    ^bb8:  // 2 preds: ^bb6, ^bb7
      cf.br ^bb9
    ^bb9:  // 2 preds: ^bb5, ^bb8
      cf.br ^bb10
    ^bb10:  // 2 preds: ^bb3, ^bb9
      %94 = arith.cmpi eq, %63, %69 : index
      %95 = arith.addi %56, %c1 : index
      %96 = arith.select %94, %95, %56 : index
      %97 = arith.cmpi eq, %67, %69 : index
      %98 = arith.addi %57, %c1 : index
      %99 = arith.select %97, %98, %57 : index
      cf.br ^bb1(%96, %99 : index, index)
    ^bb11:  // pred: ^bb1
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
          %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %101 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %103 = llvm.load %102 : !llvm.ptr -> i64
          %104 = builtin.unrealized_conversion_cast %103 : i64 to index
          %105 = arith.muli %arg8, %c256 : index
          %106 = arith.addi %105, %104 : index
          %107 = builtin.unrealized_conversion_cast %106 : index to i64
          %108 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %110, %111 : f32, !llvm.ptr
          omp.yield
        }
        omp.terminator
      }
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
          %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %101 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %103 = llvm.load %102 : !llvm.ptr -> i64
          %104 = builtin.unrealized_conversion_cast %103 : i64 to index
          %105 = arith.muli %arg8, %c256 : index
          %106 = arith.addi %105, %104 : index
          %107 = builtin.unrealized_conversion_cast %106 : index to i64
          %108 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %110, %111 : f32, !llvm.ptr
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %6 = llvm.mlir.constant(32768 : index) : i64
  %7 = llvm.mlir.constant(1 : index) : i64
  %8 = llvm.mlir.null : !llvm.ptr
  %9 = llvm.getelementptr %8[32768] : (!llvm.ptr) -> !llvm.ptr, f32
  %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
  %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
  %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.mlir.constant(0 : index) : i64
  %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
  %25 = builtin.unrealized_conversion_cast %24 : index to i64
  %26 = arith.cmpi slt, %24, %c32768 : index
  cf.cond_br %26, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %27 : f32, !llvm.ptr
  %28 = arith.addi %24, %c1 : index
  cf.br ^bb1(%28 : index)
^bb3:  // pred: ^bb1
  %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
      %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
      %31 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %33 = llvm.load %32 : !llvm.ptr -> i64
      %34 = builtin.unrealized_conversion_cast %33 : i64 to index
      %35 = arith.addi %arg8, %c1 : index
      %36 = builtin.unrealized_conversion_cast %35 : index to i64
      %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %39 = llvm.load %38 : !llvm.ptr -> i64
      %40 = builtin.unrealized_conversion_cast %39 : i64 to index
      %41 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %43 = llvm.load %42 : !llvm.ptr -> i64
      %44 = builtin.unrealized_conversion_cast %43 : i64 to index
      %45 = arith.addi %arg8, %c1 : index
      %46 = builtin.unrealized_conversion_cast %45 : index to i64
      %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %49 = llvm.load %48 : !llvm.ptr -> i64
      %50 = builtin.unrealized_conversion_cast %49 : i64 to index
      cf.br ^bb1(%34, %44 : index, index)
    ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
      %53 = arith.cmpi ult, %51, %40 : index
      %54 = arith.cmpi ult, %52, %50 : index
      %55 = arith.andi %53, %54 : i1
      cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
    ^bb2(%56: index, %57: index):  // pred: ^bb1
      %58 = builtin.unrealized_conversion_cast %56 : index to i64
      %59 = builtin.unrealized_conversion_cast %57 : index to i64
      %60 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %62 = llvm.load %61 : !llvm.ptr -> i64
      %63 = builtin.unrealized_conversion_cast %62 : i64 to index
      %64 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %66 = llvm.load %65 : !llvm.ptr -> i64
      %67 = builtin.unrealized_conversion_cast %66 : i64 to index
      %68 = arith.cmpi ult, %67, %63 : index
      %69 = arith.select %68, %67, %63 : index
      %70 = arith.muli %arg8, %c256 : index
      %71 = arith.addi %70, %69 : index
      %72 = builtin.unrealized_conversion_cast %71 : index to i64
      %73 = arith.cmpi eq, %63, %69 : index
      %74 = arith.cmpi eq, %67, %69 : index
      %75 = arith.andi %73, %74 : i1
      cf.cond_br %75, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %76 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %78 = llvm.load %77 : !llvm.ptr -> f32
      %79 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %81 = llvm.load %80 : !llvm.ptr -> f32
      %82 = arith.addf %78, %81 : f32
      %83 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %82, %83 : f32, !llvm.ptr
      cf.br ^bb10
    ^bb4:  // pred: ^bb2
      %84 = arith.cmpi eq, %63, %69 : index
      cf.cond_br %84, ^bb5, ^bb6
    ^bb5:  // pred: ^bb4
      %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %87 = llvm.load %86 : !llvm.ptr -> f32
      %88 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %87, %88 : f32, !llvm.ptr
      cf.br ^bb9
    ^bb6:  // pred: ^bb4
      %89 = arith.cmpi eq, %67, %69 : index
      cf.cond_br %89, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %90 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %92 = llvm.load %91 : !llvm.ptr -> f32
      %93 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %92, %93 : f32, !llvm.ptr
      cf.br ^bb8
    ^bb8:  // 2 preds: ^bb6, ^bb7
      cf.br ^bb9
    ^bb9:  // 2 preds: ^bb5, ^bb8
      cf.br ^bb10
    ^bb10:  // 2 preds: ^bb3, ^bb9
      %94 = arith.cmpi eq, %63, %69 : index
      %95 = arith.addi %56, %c1 : index
      %96 = arith.select %94, %95, %56 : index
      %97 = arith.cmpi eq, %67, %69 : index
      %98 = arith.addi %57, %c1 : index
      %99 = arith.select %97, %98, %57 : index
      cf.br ^bb1(%96, %99 : index, index)
    ^bb11:  // pred: ^bb1
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
          %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %101 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %103 = llvm.load %102 : !llvm.ptr -> i64
          %104 = builtin.unrealized_conversion_cast %103 : i64 to index
          %105 = arith.muli %arg8, %c256 : index
          %106 = arith.addi %105, %104 : index
          %107 = builtin.unrealized_conversion_cast %106 : index to i64
          %108 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %110, %111 : f32, !llvm.ptr
          omp.yield
        }
        omp.terminator
      }
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
          %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %101 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %103 = llvm.load %102 : !llvm.ptr -> i64
          %104 = builtin.unrealized_conversion_cast %103 : i64 to index
          %105 = arith.muli %arg8, %c256 : index
          %106 = arith.addi %105, %104 : index
          %107 = builtin.unrealized_conversion_cast %106 : index to i64
          %108 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %110, %111 : f32, !llvm.ptr
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %c32768 = arith.constant 32768 : index
  %c1 = arith.constant 1 : index
  %c32768_i64 = arith.constant 32768 : i64
  %c256_i64 = arith.constant 256 : i64
  %c128_i64 = arith.constant 128 : i64
  %c0_i64 = arith.constant 0 : i64
  %c128 = arith.constant 128 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c256 = arith.constant 256 : index
  %6 = llvm.mlir.constant(32768 : index) : i64
  %7 = llvm.mlir.constant(1 : index) : i64
  %8 = llvm.mlir.null : !llvm.ptr
  %9 = llvm.getelementptr %8[32768] : (!llvm.ptr) -> !llvm.ptr, f32
  %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
  %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
  %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.mlir.constant(0 : index) : i64
  %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb1(%c0 : index)
^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
  %25 = builtin.unrealized_conversion_cast %24 : index to i64
  %26 = arith.cmpi slt, %24, %c32768 : index
  cf.cond_br %26, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %27 : f32, !llvm.ptr
  %28 = arith.addi %24, %c1 : index
  cf.br ^bb1(%28 : index)
^bb3:  // pred: ^bb1
  %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  omp.parallel   {
    omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
      %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
      %31 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %33 = llvm.load %32 : !llvm.ptr -> i64
      %34 = builtin.unrealized_conversion_cast %33 : i64 to index
      %35 = arith.addi %arg8, %c1 : index
      %36 = builtin.unrealized_conversion_cast %35 : index to i64
      %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %39 = llvm.load %38 : !llvm.ptr -> i64
      %40 = builtin.unrealized_conversion_cast %39 : i64 to index
      %41 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %43 = llvm.load %42 : !llvm.ptr -> i64
      %44 = builtin.unrealized_conversion_cast %43 : i64 to index
      %45 = arith.addi %arg8, %c1 : index
      %46 = builtin.unrealized_conversion_cast %45 : index to i64
      %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %49 = llvm.load %48 : !llvm.ptr -> i64
      %50 = builtin.unrealized_conversion_cast %49 : i64 to index
      cf.br ^bb1(%34, %44 : index, index)
    ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
      %53 = arith.cmpi ult, %51, %40 : index
      %54 = arith.cmpi ult, %52, %50 : index
      %55 = arith.andi %53, %54 : i1
      cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
    ^bb2(%56: index, %57: index):  // pred: ^bb1
      %58 = builtin.unrealized_conversion_cast %56 : index to i64
      %59 = builtin.unrealized_conversion_cast %57 : index to i64
      %60 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %62 = llvm.load %61 : !llvm.ptr -> i64
      %63 = builtin.unrealized_conversion_cast %62 : i64 to index
      %64 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %66 = llvm.load %65 : !llvm.ptr -> i64
      %67 = builtin.unrealized_conversion_cast %66 : i64 to index
      %68 = arith.cmpi ult, %67, %63 : index
      %69 = arith.select %68, %67, %63 : index
      %70 = arith.muli %arg8, %c256 : index
      %71 = arith.addi %70, %69 : index
      %72 = builtin.unrealized_conversion_cast %71 : index to i64
      %73 = arith.cmpi eq, %63, %69 : index
      %74 = arith.cmpi eq, %67, %69 : index
      %75 = arith.andi %73, %74 : i1
      cf.cond_br %75, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %76 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %78 = llvm.load %77 : !llvm.ptr -> f32
      %79 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %81 = llvm.load %80 : !llvm.ptr -> f32
      %82 = arith.addf %78, %81 : f32
      %83 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %82, %83 : f32, !llvm.ptr
      cf.br ^bb10
    ^bb4:  // pred: ^bb2
      %84 = arith.cmpi eq, %63, %69 : index
      cf.cond_br %84, ^bb5, ^bb6
    ^bb5:  // pred: ^bb4
      %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %87 = llvm.load %86 : !llvm.ptr -> f32
      %88 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %87, %88 : f32, !llvm.ptr
      cf.br ^bb9
    ^bb6:  // pred: ^bb4
      %89 = arith.cmpi eq, %67, %69 : index
      cf.cond_br %89, ^bb7, ^bb8
    ^bb7:  // pred: ^bb6
      %90 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      %92 = llvm.load %91 : !llvm.ptr -> f32
      %93 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
      llvm.store %92, %93 : f32, !llvm.ptr
      cf.br ^bb8
    ^bb8:  // 2 preds: ^bb6, ^bb7
      cf.br ^bb9
    ^bb9:  // 2 preds: ^bb5, ^bb8
      cf.br ^bb10
    ^bb10:  // 2 preds: ^bb3, ^bb9
      %94 = arith.cmpi eq, %63, %69 : index
      %95 = arith.addi %56, %c1 : index
      %96 = arith.select %94, %95, %56 : index
      %97 = arith.cmpi eq, %67, %69 : index
      %98 = arith.addi %57, %c1 : index
      %99 = arith.select %97, %98, %57 : index
      cf.br ^bb1(%96, %99 : index, index)
    ^bb11:  // pred: ^bb1
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
          %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %101 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %103 = llvm.load %102 : !llvm.ptr -> i64
          %104 = builtin.unrealized_conversion_cast %103 : i64 to index
          %105 = arith.muli %arg8, %c256 : index
          %106 = arith.addi %105, %104 : index
          %107 = builtin.unrealized_conversion_cast %106 : index to i64
          %108 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %110, %111 : f32, !llvm.ptr
          omp.yield
        }
        omp.terminator
      }
      omp.parallel   {
        omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
          %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
          %101 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %103 = llvm.load %102 : !llvm.ptr -> i64
          %104 = builtin.unrealized_conversion_cast %103 : i64 to index
          %105 = arith.muli %arg8, %c256 : index
          %106 = arith.addi %105, %104 : index
          %107 = builtin.unrealized_conversion_cast %106 : index to i64
          %108 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          %110 = llvm.load %109 : !llvm.ptr -> f32
          %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
          llvm.store %110, %111 : f32, !llvm.ptr
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertMathToLibm (convert-math-to-libm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %6 = llvm.mlir.constant(32768 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.null : !llvm.ptr
    %9 = llvm.getelementptr %8[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
    %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c32768 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %33 = llvm.load %32 : !llvm.ptr -> i64
        %34 = builtin.unrealized_conversion_cast %33 : i64 to index
        %35 = arith.addi %arg8, %c1 : index
        %36 = builtin.unrealized_conversion_cast %35 : index to i64
        %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %43 = llvm.load %42 : !llvm.ptr -> i64
        %44 = builtin.unrealized_conversion_cast %43 : i64 to index
        %45 = arith.addi %arg8, %c1 : index
        %46 = builtin.unrealized_conversion_cast %45 : index to i64
        %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        cf.br ^bb1(%34, %44 : index, index)
      ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
        %53 = arith.cmpi ult, %51, %40 : index
        %54 = arith.cmpi ult, %52, %50 : index
        %55 = arith.andi %53, %54 : i1
        cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
      ^bb2(%56: index, %57: index):  // pred: ^bb1
        %58 = builtin.unrealized_conversion_cast %56 : index to i64
        %59 = builtin.unrealized_conversion_cast %57 : index to i64
        %60 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %62 = llvm.load %61 : !llvm.ptr -> i64
        %63 = builtin.unrealized_conversion_cast %62 : i64 to index
        %64 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %66 = llvm.load %65 : !llvm.ptr -> i64
        %67 = builtin.unrealized_conversion_cast %66 : i64 to index
        %68 = arith.cmpi ult, %67, %63 : index
        %69 = arith.select %68, %67, %63 : index
        %70 = arith.muli %arg8, %c256 : index
        %71 = arith.addi %70, %69 : index
        %72 = builtin.unrealized_conversion_cast %71 : index to i64
        %73 = arith.cmpi eq, %63, %69 : index
        %74 = arith.cmpi eq, %67, %69 : index
        %75 = arith.andi %73, %74 : i1
        cf.cond_br %75, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %76 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %78 = llvm.load %77 : !llvm.ptr -> f32
        %79 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %81 = llvm.load %80 : !llvm.ptr -> f32
        %82 = arith.addf %78, %81 : f32
        %83 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %82, %83 : f32, !llvm.ptr
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %84 = arith.cmpi eq, %63, %69 : index
        cf.cond_br %84, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %87 = llvm.load %86 : !llvm.ptr -> f32
        %88 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %87, %88 : f32, !llvm.ptr
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %89 = arith.cmpi eq, %67, %69 : index
        cf.cond_br %89, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %90 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %92 = llvm.load %91 : !llvm.ptr -> f32
        %93 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %92, %93 : f32, !llvm.ptr
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %94 = arith.cmpi eq, %63, %69 : index
        %95 = arith.addi %56, %c1 : index
        %96 = arith.select %94, %95, %56 : index
        %97 = arith.cmpi eq, %67, %69 : index
        %98 = arith.addi %57, %c1 : index
        %99 = arith.select %97, %98, %57 : index
        cf.br ^bb1(%96, %99 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToLibm (convert-complex-to-libm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %c32768 = arith.constant 32768 : index
    %c1 = arith.constant 1 : index
    %c32768_i64 = arith.constant 32768 : i64
    %c256_i64 = arith.constant 256 : i64
    %c128_i64 = arith.constant 128 : i64
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %6 = llvm.mlir.constant(32768 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.null : !llvm.ptr
    %9 = llvm.getelementptr %8[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %10 = llvm.ptrtoint %9 : !llvm.ptr to i64
    %11 = llvm.call @malloc(%10) : (i64) -> !llvm.ptr
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %11, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.mlir.constant(0 : index) : i64
    %16 = llvm.insertvalue %15, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %6, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %7, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c32768 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %11[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %33 = llvm.load %32 : !llvm.ptr -> i64
        %34 = builtin.unrealized_conversion_cast %33 : i64 to index
        %35 = arith.addi %arg8, %c1 : index
        %36 = builtin.unrealized_conversion_cast %35 : index to i64
        %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %43 = llvm.load %42 : !llvm.ptr -> i64
        %44 = builtin.unrealized_conversion_cast %43 : i64 to index
        %45 = arith.addi %arg8, %c1 : index
        %46 = builtin.unrealized_conversion_cast %45 : index to i64
        %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        cf.br ^bb1(%34, %44 : index, index)
      ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
        %53 = arith.cmpi ult, %51, %40 : index
        %54 = arith.cmpi ult, %52, %50 : index
        %55 = arith.andi %53, %54 : i1
        cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
      ^bb2(%56: index, %57: index):  // pred: ^bb1
        %58 = builtin.unrealized_conversion_cast %56 : index to i64
        %59 = builtin.unrealized_conversion_cast %57 : index to i64
        %60 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %62 = llvm.load %61 : !llvm.ptr -> i64
        %63 = builtin.unrealized_conversion_cast %62 : i64 to index
        %64 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %66 = llvm.load %65 : !llvm.ptr -> i64
        %67 = builtin.unrealized_conversion_cast %66 : i64 to index
        %68 = arith.cmpi ult, %67, %63 : index
        %69 = arith.select %68, %67, %63 : index
        %70 = arith.muli %arg8, %c256 : index
        %71 = arith.addi %70, %69 : index
        %72 = builtin.unrealized_conversion_cast %71 : index to i64
        %73 = arith.cmpi eq, %63, %69 : index
        %74 = arith.cmpi eq, %67, %69 : index
        %75 = arith.andi %73, %74 : i1
        cf.cond_br %75, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %76 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %78 = llvm.load %77 : !llvm.ptr -> f32
        %79 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %81 = llvm.load %80 : !llvm.ptr -> f32
        %82 = arith.addf %78, %81 : f32
        %83 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %82, %83 : f32, !llvm.ptr
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %84 = arith.cmpi eq, %63, %69 : index
        cf.cond_br %84, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %87 = llvm.load %86 : !llvm.ptr -> f32
        %88 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %87, %88 : f32, !llvm.ptr
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %89 = arith.cmpi eq, %67, %69 : index
        cf.cond_br %89, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %90 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %92 = llvm.load %91 : !llvm.ptr -> f32
        %93 = llvm.getelementptr %11[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %92, %93 : f32, !llvm.ptr
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %94 = arith.cmpi eq, %63, %69 : index
        %95 = arith.addi %56, %c1 : index
        %96 = arith.select %94, %95, %56 : index
        %97 = arith.cmpi eq, %67, %69 : index
        %98 = arith.addi %57, %c1 : index
        %99 = arith.select %97, %98, %57 : index
        cf.br ^bb1(%96, %99 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %11[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(1 : index) : i64
    %2 = llvm.mlir.constant(32768 : index) : i64
    %c256 = arith.constant 256 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0_i64 = arith.constant 0 : i64
    %c128_i64 = arith.constant 128 : i64
    %c256_i64 = arith.constant 256 : i64
    %c32768_i64 = arith.constant 32768 : i64
    %c1 = arith.constant 1 : index
    %c32768 = arith.constant 32768 : index
    %c0 = arith.constant 0 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = llvm.mlir.null : !llvm.ptr
    %10 = llvm.getelementptr %9[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %11 = llvm.ptrtoint %10 : !llvm.ptr to i64
    %12 = llvm.call @malloc(%11) : (i64) -> !llvm.ptr
    %13 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %0, %15[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %2, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %1, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c32768 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %33 = llvm.load %32 : !llvm.ptr -> i64
        %34 = builtin.unrealized_conversion_cast %33 : i64 to index
        %35 = arith.addi %arg8, %c1 : index
        %36 = builtin.unrealized_conversion_cast %35 : index to i64
        %37 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %43 = llvm.load %42 : !llvm.ptr -> i64
        %44 = builtin.unrealized_conversion_cast %43 : i64 to index
        %45 = arith.addi %arg8, %c1 : index
        %46 = builtin.unrealized_conversion_cast %45 : index to i64
        %47 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        cf.br ^bb1(%34, %44 : index, index)
      ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
        %53 = arith.cmpi ult, %51, %40 : index
        %54 = arith.cmpi ult, %52, %50 : index
        %55 = arith.andi %53, %54 : i1
        cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
      ^bb2(%56: index, %57: index):  // pred: ^bb1
        %58 = builtin.unrealized_conversion_cast %56 : index to i64
        %59 = builtin.unrealized_conversion_cast %57 : index to i64
        %60 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %62 = llvm.load %61 : !llvm.ptr -> i64
        %63 = builtin.unrealized_conversion_cast %62 : i64 to index
        %64 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %66 = llvm.load %65 : !llvm.ptr -> i64
        %67 = builtin.unrealized_conversion_cast %66 : i64 to index
        %68 = arith.cmpi ult, %67, %63 : index
        %69 = arith.select %68, %67, %63 : index
        %70 = arith.muli %arg8, %c256 : index
        %71 = arith.addi %70, %69 : index
        %72 = builtin.unrealized_conversion_cast %71 : index to i64
        %73 = arith.cmpi eq, %63, %69 : index
        %74 = arith.cmpi eq, %67, %69 : index
        %75 = arith.andi %73, %74 : i1
        cf.cond_br %75, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %76 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %78 = llvm.load %77 : !llvm.ptr -> f32
        %79 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %81 = llvm.load %80 : !llvm.ptr -> f32
        %82 = arith.addf %78, %81 : f32
        %83 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %82, %83 : f32, !llvm.ptr
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %84 = arith.cmpi eq, %63, %69 : index
        cf.cond_br %84, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %85 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %87 = llvm.load %86 : !llvm.ptr -> f32
        %88 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %87, %88 : f32, !llvm.ptr
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %89 = arith.cmpi eq, %67, %69 : index
        cf.cond_br %89, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %90 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %92 = llvm.load %91 : !llvm.ptr -> f32
        %93 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %92, %93 : f32, !llvm.ptr
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %94 = arith.cmpi eq, %63, %69 : index
        %95 = arith.addi %56, %c1 : index
        %96 = arith.select %94, %95, %56 : index
        %97 = arith.cmpi eq, %67, %69 : index
        %98 = arith.addi %57, %c1 : index
        %99 = arith.select %97, %98, %57 : index
        cf.br ^bb1(%96, %99 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %12[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %12[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToLLVMPass (convert-complex-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(1 : index) : i64
    %2 = llvm.mlir.constant(32768 : index) : i64
    %c256 = arith.constant 256 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0_i64 = arith.constant 0 : i64
    %c128_i64 = arith.constant 128 : i64
    %c256_i64 = arith.constant 256 : i64
    %c32768_i64 = arith.constant 32768 : i64
    %c1 = arith.constant 1 : index
    %c32768 = arith.constant 32768 : index
    %c0 = arith.constant 0 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = llvm.mlir.null : !llvm.ptr
    %10 = llvm.getelementptr %9[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %11 = llvm.ptrtoint %10 : !llvm.ptr to i64
    %12 = llvm.call @malloc(%11) : (i64) -> !llvm.ptr
    %13 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %0, %15[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %2, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %1, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c32768 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %33 = llvm.load %32 : !llvm.ptr -> i64
        %34 = builtin.unrealized_conversion_cast %33 : i64 to index
        %35 = arith.addi %arg8, %c1 : index
        %36 = builtin.unrealized_conversion_cast %35 : index to i64
        %37 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %43 = llvm.load %42 : !llvm.ptr -> i64
        %44 = builtin.unrealized_conversion_cast %43 : i64 to index
        %45 = arith.addi %arg8, %c1 : index
        %46 = builtin.unrealized_conversion_cast %45 : index to i64
        %47 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        cf.br ^bb1(%34, %44 : index, index)
      ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
        %53 = arith.cmpi ult, %51, %40 : index
        %54 = arith.cmpi ult, %52, %50 : index
        %55 = arith.andi %53, %54 : i1
        cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
      ^bb2(%56: index, %57: index):  // pred: ^bb1
        %58 = builtin.unrealized_conversion_cast %56 : index to i64
        %59 = builtin.unrealized_conversion_cast %57 : index to i64
        %60 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %62 = llvm.load %61 : !llvm.ptr -> i64
        %63 = builtin.unrealized_conversion_cast %62 : i64 to index
        %64 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %66 = llvm.load %65 : !llvm.ptr -> i64
        %67 = builtin.unrealized_conversion_cast %66 : i64 to index
        %68 = arith.cmpi ult, %67, %63 : index
        %69 = arith.select %68, %67, %63 : index
        %70 = arith.muli %arg8, %c256 : index
        %71 = arith.addi %70, %69 : index
        %72 = builtin.unrealized_conversion_cast %71 : index to i64
        %73 = arith.cmpi eq, %63, %69 : index
        %74 = arith.cmpi eq, %67, %69 : index
        %75 = arith.andi %73, %74 : i1
        cf.cond_br %75, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %76 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %78 = llvm.load %77 : !llvm.ptr -> f32
        %79 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %81 = llvm.load %80 : !llvm.ptr -> f32
        %82 = arith.addf %78, %81 : f32
        %83 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %82, %83 : f32, !llvm.ptr
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %84 = arith.cmpi eq, %63, %69 : index
        cf.cond_br %84, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %85 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %87 = llvm.load %86 : !llvm.ptr -> f32
        %88 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %87, %88 : f32, !llvm.ptr
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %89 = arith.cmpi eq, %67, %69 : index
        cf.cond_br %89, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %90 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %92 = llvm.load %91 : !llvm.ptr -> f32
        %93 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %92, %93 : f32, !llvm.ptr
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %94 = arith.cmpi eq, %63, %69 : index
        %95 = arith.addi %56, %c1 : index
        %96 = arith.select %94, %95, %56 : index
        %97 = arith.cmpi eq, %67, %69 : index
        %98 = arith.addi %57, %c1 : index
        %99 = arith.select %97, %98, %57 : index
        cf.br ^bb1(%96, %99 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %12[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %12[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @SpMSpMAdd.Z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xf32>, %arg3: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(1 : index) : i64
    %2 = llvm.mlir.constant(32768 : index) : i64
    %c256 = arith.constant 256 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0_i64 = arith.constant 0 : i64
    %c128_i64 = arith.constant 128 : i64
    %c256_i64 = arith.constant 256 : i64
    %c32768_i64 = arith.constant 32768 : i64
    %c1 = arith.constant 1 : index
    %c32768 = arith.constant 32768 : index
    %c0 = arith.constant 0 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = llvm.mlir.null : !llvm.ptr
    %10 = llvm.getelementptr %9[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %11 = llvm.ptrtoint %10 : !llvm.ptr to i64
    %12 = llvm.call @malloc(%11) : (i64) -> !llvm.ptr
    %13 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = llvm.insertvalue %12, %13[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %12, %14[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %0, %15[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %2, %16[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %1, %17[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = builtin.unrealized_conversion_cast %18 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %20 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %c0_i64, %20[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c128_i64, %21[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %c256_i64, %22[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb1(%c0 : index)
  ^bb1(%24: index):  // 2 preds: ^bb0, ^bb2
    %25 = builtin.unrealized_conversion_cast %24 : index to i64
    %26 = arith.cmpi slt, %24, %c32768 : index
    cf.cond_br %26, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %27 = llvm.getelementptr %12[%25] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %27 : f32, !llvm.ptr
    %28 = arith.addi %24, %c1 : index
    cf.br ^bb1(%28 : index)
  ^bb3:  // pred: ^bb1
    %29 = llvm.insertvalue %c32768_i64, %23[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg8) : index = (%c0) to (%c128) step (%c1) {
        %30 = builtin.unrealized_conversion_cast %arg8 : index to i64
        %31 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %32 = llvm.getelementptr %31[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %33 = llvm.load %32 : !llvm.ptr -> i64
        %34 = builtin.unrealized_conversion_cast %33 : i64 to index
        %35 = arith.addi %arg8, %c1 : index
        %36 = builtin.unrealized_conversion_cast %35 : index to i64
        %37 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %38 = llvm.getelementptr %37[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %39 = llvm.load %38 : !llvm.ptr -> i64
        %40 = builtin.unrealized_conversion_cast %39 : i64 to index
        %41 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %42 = llvm.getelementptr %41[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %43 = llvm.load %42 : !llvm.ptr -> i64
        %44 = builtin.unrealized_conversion_cast %43 : i64 to index
        %45 = arith.addi %arg8, %c1 : index
        %46 = builtin.unrealized_conversion_cast %45 : index to i64
        %47 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %48 = llvm.getelementptr %47[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %49 = llvm.load %48 : !llvm.ptr -> i64
        %50 = builtin.unrealized_conversion_cast %49 : i64 to index
        cf.br ^bb1(%34, %44 : index, index)
      ^bb1(%51: index, %52: index):  // 2 preds: ^bb0, ^bb10
        %53 = arith.cmpi ult, %51, %40 : index
        %54 = arith.cmpi ult, %52, %50 : index
        %55 = arith.andi %53, %54 : i1
        cf.cond_br %55, ^bb2(%51, %52 : index, index), ^bb11
      ^bb2(%56: index, %57: index):  // pred: ^bb1
        %58 = builtin.unrealized_conversion_cast %56 : index to i64
        %59 = builtin.unrealized_conversion_cast %57 : index to i64
        %60 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %61 = llvm.getelementptr %60[%58] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %62 = llvm.load %61 : !llvm.ptr -> i64
        %63 = builtin.unrealized_conversion_cast %62 : i64 to index
        %64 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %65 = llvm.getelementptr %64[%59] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %66 = llvm.load %65 : !llvm.ptr -> i64
        %67 = builtin.unrealized_conversion_cast %66 : i64 to index
        %68 = arith.cmpi ult, %67, %63 : index
        %69 = arith.select %68, %67, %63 : index
        %70 = arith.muli %arg8, %c256 : index
        %71 = arith.addi %70, %69 : index
        %72 = builtin.unrealized_conversion_cast %71 : index to i64
        %73 = arith.cmpi eq, %63, %69 : index
        %74 = arith.cmpi eq, %67, %69 : index
        %75 = arith.andi %73, %74 : i1
        cf.cond_br %75, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %76 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %77 = llvm.getelementptr %76[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %78 = llvm.load %77 : !llvm.ptr -> f32
        %79 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %80 = llvm.getelementptr %79[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %81 = llvm.load %80 : !llvm.ptr -> f32
        %82 = arith.addf %78, %81 : f32
        %83 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %82, %83 : f32, !llvm.ptr
        cf.br ^bb10
      ^bb4:  // pred: ^bb2
        %84 = arith.cmpi eq, %63, %69 : index
        cf.cond_br %84, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %85 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %86 = llvm.getelementptr %85[%58] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %87 = llvm.load %86 : !llvm.ptr -> f32
        %88 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %87, %88 : f32, !llvm.ptr
        cf.br ^bb9
      ^bb6:  // pred: ^bb4
        %89 = arith.cmpi eq, %67, %69 : index
        cf.cond_br %89, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %90 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %91 = llvm.getelementptr %90[%59] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %92 = llvm.load %91 : !llvm.ptr -> f32
        %93 = llvm.getelementptr %12[%72] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %92, %93 : f32, !llvm.ptr
        cf.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        cf.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        cf.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %94 = arith.cmpi eq, %63, %69 : index
        %95 = arith.addi %56, %c1 : index
        %96 = arith.select %94, %95, %56 : index
        %97 = arith.cmpi eq, %67, %69 : index
        %98 = arith.addi %57, %c1 : index
        %99 = arith.select %97, %98, %57 : index
        cf.br ^bb1(%96, %99 : index, index)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%51) to (%40) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %12[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg9) : index = (%52) to (%50) step (%c1) {
            %100 = builtin.unrealized_conversion_cast %arg9 : index to i64
            %101 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %102 = llvm.getelementptr %101[%100] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %103 = llvm.load %102 : !llvm.ptr -> i64
            %104 = builtin.unrealized_conversion_cast %103 : i64 to index
            %105 = arith.muli %arg8, %c256 : index
            %106 = arith.addi %105, %104 : index
            %107 = builtin.unrealized_conversion_cast %106 : index to i64
            %108 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %109 = llvm.getelementptr %108[%100] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %110 = llvm.load %109 : !llvm.ptr -> f32
            %111 = llvm.getelementptr %12[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %110, %111 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %19, %29 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertOpenMPToLLVMPass (convert-openmp-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @SpMSpMAdd.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg16: !llvm.ptr, %arg17: !llvm.ptr, %arg18: i64, %arg19: i64, %arg20: i64, %arg21: !llvm.ptr, %arg22: !llvm.ptr, %arg23: i64, %arg24: i64, %arg25: i64, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg16, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg17, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg18, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg19, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg20, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg21, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg22, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg23, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg24, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg25, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg26, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg27, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg28, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg29, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg30, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %42 = llvm.mlir.constant(0 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.mlir.constant(32768 : index) : i64
    %45 = llvm.mlir.constant(256 : index) : i64
    %46 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %47 = llvm.mlir.constant(128 : index) : i64
    %48 = llvm.mlir.constant(0 : i64) : i64
    %49 = llvm.mlir.constant(128 : i64) : i64
    %50 = llvm.mlir.constant(256 : i64) : i64
    %51 = llvm.mlir.constant(32768 : i64) : i64
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.mlir.constant(32768 : index) : i64
    %54 = llvm.mlir.constant(0 : index) : i64
    %55 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %56 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %58 = builtin.unrealized_conversion_cast %34 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %59 = builtin.unrealized_conversion_cast %20 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %60 = builtin.unrealized_conversion_cast %41 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %61 = llvm.mlir.null : !llvm.ptr
    %62 = llvm.getelementptr %61[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %63 = llvm.ptrtoint %62 : !llvm.ptr to i64
    %64 = llvm.call @malloc(%63) : (i64) -> !llvm.ptr
    %65 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %66 = llvm.insertvalue %64, %65[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %64, %66[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %42, %67[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.insertvalue %44, %68[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.insertvalue %43, %69[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %71 = builtin.unrealized_conversion_cast %70 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %72 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %73 = llvm.insertvalue %48, %72[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %74 = llvm.insertvalue %49, %73[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %75 = llvm.insertvalue %50, %74[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%54 : i64)
  ^bb1(%76: i64):  // 2 preds: ^bb0, ^bb2
    %77 = builtin.unrealized_conversion_cast %76 : i64 to index
    %78 = builtin.unrealized_conversion_cast %77 : index to i64
    %79 = llvm.icmp "slt" %76, %53 : i64
    llvm.cond_br %79, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %80 = llvm.getelementptr %64[%78] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %46, %80 : f32, !llvm.ptr
    %81 = llvm.add %76, %52  : i64
    llvm.br ^bb1(%81 : i64)
  ^bb3:  // pred: ^bb1
    %82 = llvm.insertvalue %51, %75[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg32) : i64 = (%54) to (%47) step (%52) {
        %86 = builtin.unrealized_conversion_cast %arg32 : i64 to index
        %87 = builtin.unrealized_conversion_cast %86 : index to i64
        %88 = llvm.extractvalue %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %89 = llvm.getelementptr %88[%87] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %90 = llvm.load %89 : !llvm.ptr -> i64
        %91 = builtin.unrealized_conversion_cast %90 : i64 to index
        %92 = llvm.add %arg32, %52  : i64
        %93 = builtin.unrealized_conversion_cast %92 : i64 to index
        %94 = builtin.unrealized_conversion_cast %93 : index to i64
        %95 = llvm.extractvalue %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %97 = llvm.load %96 : !llvm.ptr -> i64
        %98 = builtin.unrealized_conversion_cast %97 : i64 to index
        %99 = llvm.extractvalue %56[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.getelementptr %99[%87] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %101 = llvm.load %100 : !llvm.ptr -> i64
        %102 = builtin.unrealized_conversion_cast %101 : i64 to index
        %103 = llvm.add %arg32, %52  : i64
        %104 = builtin.unrealized_conversion_cast %103 : i64 to index
        %105 = builtin.unrealized_conversion_cast %104 : index to i64
        %106 = llvm.extractvalue %56[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %107 = llvm.getelementptr %106[%105] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %108 = llvm.load %107 : !llvm.ptr -> i64
        %109 = builtin.unrealized_conversion_cast %108 : i64 to index
        llvm.br ^bb1(%90, %101 : i64, i64)
      ^bb1(%110: i64, %111: i64):  // 2 preds: ^bb0, ^bb10
        %112 = llvm.icmp "ult" %110, %97 : i64
        %113 = llvm.icmp "ult" %111, %108 : i64
        %114 = llvm.and %112, %113  : i1
        llvm.cond_br %114, ^bb2(%110, %111 : i64, i64), ^bb11
      ^bb2(%115: i64, %116: i64):  // pred: ^bb1
        %117 = builtin.unrealized_conversion_cast %116 : i64 to index
        %118 = builtin.unrealized_conversion_cast %115 : i64 to index
        %119 = builtin.unrealized_conversion_cast %118 : index to i64
        %120 = builtin.unrealized_conversion_cast %117 : index to i64
        %121 = llvm.extractvalue %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %122 = llvm.getelementptr %121[%119] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %123 = llvm.load %122 : !llvm.ptr -> i64
        %124 = builtin.unrealized_conversion_cast %123 : i64 to index
        %125 = llvm.extractvalue %58[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %126 = llvm.getelementptr %125[%120] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %127 = llvm.load %126 : !llvm.ptr -> i64
        %128 = builtin.unrealized_conversion_cast %127 : i64 to index
        %129 = llvm.icmp "ult" %127, %123 : i64
        %130 = llvm.select %129, %127, %123 : i1, i64
        %131 = llvm.mul %arg32, %45  : i64
        %132 = llvm.add %131, %130  : i64
        %133 = builtin.unrealized_conversion_cast %132 : i64 to index
        %134 = builtin.unrealized_conversion_cast %133 : index to i64
        %135 = llvm.icmp "eq" %123, %130 : i64
        %136 = llvm.icmp "eq" %127, %130 : i64
        %137 = llvm.and %135, %136  : i1
        llvm.cond_br %137, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %138 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %139 = llvm.getelementptr %138[%119] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %140 = llvm.load %139 : !llvm.ptr -> f32
        %141 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %142 = llvm.getelementptr %141[%120] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %143 = llvm.load %142 : !llvm.ptr -> f32
        %144 = llvm.fadd %140, %143  : f32
        %145 = llvm.getelementptr %64[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %144, %145 : f32, !llvm.ptr
        llvm.br ^bb10
      ^bb4:  // pred: ^bb2
        %146 = llvm.icmp "eq" %123, %130 : i64
        llvm.cond_br %146, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %147 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %148 = llvm.getelementptr %147[%119] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %149 = llvm.load %148 : !llvm.ptr -> f32
        %150 = llvm.getelementptr %64[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %149, %150 : f32, !llvm.ptr
        llvm.br ^bb9
      ^bb6:  // pred: ^bb4
        %151 = llvm.icmp "eq" %127, %130 : i64
        llvm.cond_br %151, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %152 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %153 = llvm.getelementptr %152[%120] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %154 = llvm.load %153 : !llvm.ptr -> f32
        %155 = llvm.getelementptr %64[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %154, %155 : f32, !llvm.ptr
        llvm.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        llvm.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        llvm.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %156 = llvm.icmp "eq" %123, %130 : i64
        %157 = llvm.add %115, %52  : i64
        %158 = llvm.select %156, %157, %115 : i1, i64
        %159 = llvm.icmp "eq" %127, %130 : i64
        %160 = llvm.add %116, %52  : i64
        %161 = llvm.select %159, %160, %116 : i1, i64
        llvm.br ^bb1(%158, %161 : i64, i64)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg33) : i64 = (%110) to (%97) step (%52) {
            %162 = builtin.unrealized_conversion_cast %arg33 : i64 to index
            %163 = builtin.unrealized_conversion_cast %162 : index to i64
            %164 = llvm.extractvalue %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %165 = llvm.getelementptr %164[%163] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %166 = llvm.load %165 : !llvm.ptr -> i64
            %167 = builtin.unrealized_conversion_cast %166 : i64 to index
            %168 = llvm.mul %arg32, %45  : i64
            %169 = llvm.add %168, %166  : i64
            %170 = builtin.unrealized_conversion_cast %169 : i64 to index
            %171 = builtin.unrealized_conversion_cast %170 : index to i64
            %172 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %173 = llvm.getelementptr %172[%163] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %174 = llvm.load %173 : !llvm.ptr -> f32
            %175 = llvm.getelementptr %64[%171] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %174, %175 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg33) : i64 = (%111) to (%108) step (%52) {
            %162 = builtin.unrealized_conversion_cast %arg33 : i64 to index
            %163 = builtin.unrealized_conversion_cast %162 : index to i64
            %164 = llvm.extractvalue %58[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %165 = llvm.getelementptr %164[%163] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %166 = llvm.load %165 : !llvm.ptr -> i64
            %167 = builtin.unrealized_conversion_cast %166 : i64 to index
            %168 = llvm.mul %arg32, %45  : i64
            %169 = llvm.add %168, %166  : i64
            %170 = builtin.unrealized_conversion_cast %169 : i64 to index
            %171 = builtin.unrealized_conversion_cast %170 : index to i64
            %172 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %173 = llvm.getelementptr %172[%163] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %174 = llvm.load %173 : !llvm.ptr -> f32
            %175 = llvm.getelementptr %64[%171] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %174, %175 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    %83 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %84 = llvm.insertvalue %70, %83[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %85 = llvm.insertvalue %82, %84[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %85 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_SpMSpMAdd.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @SpMSpMAdd.Z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %arg4, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %arg8) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %36, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ConvertFuncToLLVMPass (convert-func-to-llvm) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @SpMSpMAdd.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg16: !llvm.ptr, %arg17: !llvm.ptr, %arg18: i64, %arg19: i64, %arg20: i64, %arg21: !llvm.ptr, %arg22: !llvm.ptr, %arg23: i64, %arg24: i64, %arg25: i64, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg16, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg17, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg18, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg19, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg20, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg21, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg22, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg23, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg24, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg25, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg26, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg27, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg28, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg29, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg30, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %42 = llvm.mlir.constant(0 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = llvm.mlir.constant(32768 : index) : i64
    %45 = llvm.mlir.constant(256 : index) : i64
    %46 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %47 = llvm.mlir.constant(128 : index) : i64
    %48 = llvm.mlir.constant(0 : i64) : i64
    %49 = llvm.mlir.constant(128 : i64) : i64
    %50 = llvm.mlir.constant(256 : i64) : i64
    %51 = llvm.mlir.constant(32768 : i64) : i64
    %52 = llvm.mlir.constant(1 : index) : i64
    %53 = llvm.mlir.constant(32768 : index) : i64
    %54 = llvm.mlir.constant(0 : index) : i64
    %55 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %56 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %58 = builtin.unrealized_conversion_cast %34 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %59 = builtin.unrealized_conversion_cast %20 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %60 = builtin.unrealized_conversion_cast %41 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %61 = llvm.mlir.null : !llvm.ptr
    %62 = llvm.getelementptr %61[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %63 = llvm.ptrtoint %62 : !llvm.ptr to i64
    %64 = llvm.call @malloc(%63) : (i64) -> !llvm.ptr
    %65 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %66 = llvm.insertvalue %64, %65[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %64, %66[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %42, %67[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.insertvalue %44, %68[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.insertvalue %43, %69[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %71 = builtin.unrealized_conversion_cast %70 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %72 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %73 = llvm.insertvalue %48, %72[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %74 = llvm.insertvalue %49, %73[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %75 = llvm.insertvalue %50, %74[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%54 : i64)
  ^bb1(%76: i64):  // 2 preds: ^bb0, ^bb2
    %77 = builtin.unrealized_conversion_cast %76 : i64 to index
    %78 = builtin.unrealized_conversion_cast %77 : index to i64
    %79 = llvm.icmp "slt" %76, %53 : i64
    llvm.cond_br %79, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %80 = llvm.getelementptr %64[%78] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %46, %80 : f32, !llvm.ptr
    %81 = llvm.add %76, %52  : i64
    llvm.br ^bb1(%81 : i64)
  ^bb3:  // pred: ^bb1
    %82 = llvm.insertvalue %51, %75[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg32) : i64 = (%54) to (%47) step (%52) {
        %86 = builtin.unrealized_conversion_cast %arg32 : i64 to index
        %87 = builtin.unrealized_conversion_cast %86 : index to i64
        %88 = llvm.extractvalue %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %89 = llvm.getelementptr %88[%87] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %90 = llvm.load %89 : !llvm.ptr -> i64
        %91 = builtin.unrealized_conversion_cast %90 : i64 to index
        %92 = llvm.add %arg32, %52  : i64
        %93 = builtin.unrealized_conversion_cast %92 : i64 to index
        %94 = builtin.unrealized_conversion_cast %93 : index to i64
        %95 = llvm.extractvalue %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %97 = llvm.load %96 : !llvm.ptr -> i64
        %98 = builtin.unrealized_conversion_cast %97 : i64 to index
        %99 = llvm.extractvalue %56[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %100 = llvm.getelementptr %99[%87] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %101 = llvm.load %100 : !llvm.ptr -> i64
        %102 = builtin.unrealized_conversion_cast %101 : i64 to index
        %103 = llvm.add %arg32, %52  : i64
        %104 = builtin.unrealized_conversion_cast %103 : i64 to index
        %105 = builtin.unrealized_conversion_cast %104 : index to i64
        %106 = llvm.extractvalue %56[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %107 = llvm.getelementptr %106[%105] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %108 = llvm.load %107 : !llvm.ptr -> i64
        %109 = builtin.unrealized_conversion_cast %108 : i64 to index
        llvm.br ^bb1(%90, %101 : i64, i64)
      ^bb1(%110: i64, %111: i64):  // 2 preds: ^bb0, ^bb10
        %112 = llvm.icmp "ult" %110, %97 : i64
        %113 = llvm.icmp "ult" %111, %108 : i64
        %114 = llvm.and %112, %113  : i1
        llvm.cond_br %114, ^bb2(%110, %111 : i64, i64), ^bb11
      ^bb2(%115: i64, %116: i64):  // pred: ^bb1
        %117 = builtin.unrealized_conversion_cast %116 : i64 to index
        %118 = builtin.unrealized_conversion_cast %115 : i64 to index
        %119 = builtin.unrealized_conversion_cast %118 : index to i64
        %120 = builtin.unrealized_conversion_cast %117 : index to i64
        %121 = llvm.extractvalue %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %122 = llvm.getelementptr %121[%119] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %123 = llvm.load %122 : !llvm.ptr -> i64
        %124 = builtin.unrealized_conversion_cast %123 : i64 to index
        %125 = llvm.extractvalue %58[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %126 = llvm.getelementptr %125[%120] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %127 = llvm.load %126 : !llvm.ptr -> i64
        %128 = builtin.unrealized_conversion_cast %127 : i64 to index
        %129 = llvm.icmp "ult" %127, %123 : i64
        %130 = llvm.select %129, %127, %123 : i1, i64
        %131 = llvm.mul %arg32, %45  : i64
        %132 = llvm.add %131, %130  : i64
        %133 = builtin.unrealized_conversion_cast %132 : i64 to index
        %134 = builtin.unrealized_conversion_cast %133 : index to i64
        %135 = llvm.icmp "eq" %123, %130 : i64
        %136 = llvm.icmp "eq" %127, %130 : i64
        %137 = llvm.and %135, %136  : i1
        llvm.cond_br %137, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %138 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %139 = llvm.getelementptr %138[%119] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %140 = llvm.load %139 : !llvm.ptr -> f32
        %141 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %142 = llvm.getelementptr %141[%120] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %143 = llvm.load %142 : !llvm.ptr -> f32
        %144 = llvm.fadd %140, %143  : f32
        %145 = llvm.getelementptr %64[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %144, %145 : f32, !llvm.ptr
        llvm.br ^bb10
      ^bb4:  // pred: ^bb2
        %146 = llvm.icmp "eq" %123, %130 : i64
        llvm.cond_br %146, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %147 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %148 = llvm.getelementptr %147[%119] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %149 = llvm.load %148 : !llvm.ptr -> f32
        %150 = llvm.getelementptr %64[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %149, %150 : f32, !llvm.ptr
        llvm.br ^bb9
      ^bb6:  // pred: ^bb4
        %151 = llvm.icmp "eq" %127, %130 : i64
        llvm.cond_br %151, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %152 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %153 = llvm.getelementptr %152[%120] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %154 = llvm.load %153 : !llvm.ptr -> f32
        %155 = llvm.getelementptr %64[%134] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %154, %155 : f32, !llvm.ptr
        llvm.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        llvm.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        llvm.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %156 = llvm.icmp "eq" %123, %130 : i64
        %157 = llvm.add %115, %52  : i64
        %158 = llvm.select %156, %157, %115 : i1, i64
        %159 = llvm.icmp "eq" %127, %130 : i64
        %160 = llvm.add %116, %52  : i64
        %161 = llvm.select %159, %160, %116 : i1, i64
        llvm.br ^bb1(%158, %161 : i64, i64)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg33) : i64 = (%110) to (%97) step (%52) {
            %162 = builtin.unrealized_conversion_cast %arg33 : i64 to index
            %163 = builtin.unrealized_conversion_cast %162 : index to i64
            %164 = llvm.extractvalue %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %165 = llvm.getelementptr %164[%163] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %166 = llvm.load %165 : !llvm.ptr -> i64
            %167 = builtin.unrealized_conversion_cast %166 : i64 to index
            %168 = llvm.mul %arg32, %45  : i64
            %169 = llvm.add %168, %166  : i64
            %170 = builtin.unrealized_conversion_cast %169 : i64 to index
            %171 = builtin.unrealized_conversion_cast %170 : index to i64
            %172 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %173 = llvm.getelementptr %172[%163] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %174 = llvm.load %173 : !llvm.ptr -> f32
            %175 = llvm.getelementptr %64[%171] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %174, %175 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg33) : i64 = (%111) to (%108) step (%52) {
            %162 = builtin.unrealized_conversion_cast %arg33 : i64 to index
            %163 = builtin.unrealized_conversion_cast %162 : index to i64
            %164 = llvm.extractvalue %58[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %165 = llvm.getelementptr %164[%163] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %166 = llvm.load %165 : !llvm.ptr -> i64
            %167 = builtin.unrealized_conversion_cast %166 : i64 to index
            %168 = llvm.mul %arg32, %45  : i64
            %169 = llvm.add %168, %166  : i64
            %170 = builtin.unrealized_conversion_cast %169 : i64 to index
            %171 = builtin.unrealized_conversion_cast %170 : index to i64
            %172 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %173 = llvm.getelementptr %172[%163] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %174 = llvm.load %173 : !llvm.ptr -> f32
            %175 = llvm.getelementptr %64[%171] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %174, %175 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    %83 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %84 = llvm.insertvalue %70, %83[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %85 = llvm.insertvalue %82, %84[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %85 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_SpMSpMAdd.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @SpMSpMAdd.Z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %arg4, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %arg8) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %36, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ReconcileUnrealizedCasts (reconcile-unrealized-casts) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @SpMSpMAdd.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg16: !llvm.ptr, %arg17: !llvm.ptr, %arg18: i64, %arg19: i64, %arg20: i64, %arg21: !llvm.ptr, %arg22: !llvm.ptr, %arg23: i64, %arg24: i64, %arg25: i64, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.insertvalue %arg5, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.insertvalue %arg6, %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg7, %8[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg8, %9[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg9, %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %arg12, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg13, %15[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg14, %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.insertvalue %arg16, %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg17, %19[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg18, %20[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %arg19, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg20, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.insertvalue %arg21, %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg22, %25[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg23, %26[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg24, %27[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.insertvalue %arg25, %28[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.insertvalue %arg26, %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg27, %31[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg28, %32[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %arg29, %33[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %arg30, %34[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.mlir.constant(0 : index) : i64
    %37 = llvm.mlir.constant(1 : index) : i64
    %38 = llvm.mlir.constant(32768 : index) : i64
    %39 = llvm.mlir.constant(256 : index) : i64
    %40 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %41 = llvm.mlir.constant(128 : index) : i64
    %42 = llvm.mlir.constant(0 : i64) : i64
    %43 = llvm.mlir.constant(128 : i64) : i64
    %44 = llvm.mlir.constant(256 : i64) : i64
    %45 = llvm.mlir.constant(32768 : i64) : i64
    %46 = llvm.mlir.constant(1 : index) : i64
    %47 = llvm.mlir.constant(32768 : index) : i64
    %48 = llvm.mlir.constant(0 : index) : i64
    %49 = llvm.mlir.null : !llvm.ptr
    %50 = llvm.getelementptr %49[32768] : (!llvm.ptr) -> !llvm.ptr, f32
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %54 = llvm.insertvalue %52, %53[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %52, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.insertvalue %36, %55[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.insertvalue %38, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %37, %57[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %60 = llvm.insertvalue %42, %59[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %43, %60[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %62 = llvm.insertvalue %44, %61[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%48 : i64)
  ^bb1(%63: i64):  // 2 preds: ^bb0, ^bb2
    %64 = llvm.icmp "slt" %63, %47 : i64
    llvm.cond_br %64, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %65 = llvm.getelementptr %52[%63] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %40, %65 : f32, !llvm.ptr
    %66 = llvm.add %63, %46  : i64
    llvm.br ^bb1(%66 : i64)
  ^bb3:  // pred: ^bb1
    %67 = llvm.insertvalue %45, %62[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    omp.parallel   {
      omp.wsloop   for  (%arg32) : i64 = (%48) to (%41) step (%46) {
        %71 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %72 = llvm.getelementptr %71[%arg32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %73 = llvm.load %72 : !llvm.ptr -> i64
        %74 = llvm.add %arg32, %46  : i64
        %75 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %76 = llvm.getelementptr %75[%74] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %77 = llvm.load %76 : !llvm.ptr -> i64
        %78 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %79 = llvm.getelementptr %78[%arg32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %80 = llvm.load %79 : !llvm.ptr -> i64
        %81 = llvm.add %arg32, %46  : i64
        %82 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %83 = llvm.getelementptr %82[%81] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %84 = llvm.load %83 : !llvm.ptr -> i64
        llvm.br ^bb1(%73, %80 : i64, i64)
      ^bb1(%85: i64, %86: i64):  // 2 preds: ^bb0, ^bb10
        %87 = llvm.icmp "ult" %85, %77 : i64
        %88 = llvm.icmp "ult" %86, %84 : i64
        %89 = llvm.and %87, %88  : i1
        llvm.cond_br %89, ^bb2(%85, %86 : i64, i64), ^bb11
      ^bb2(%90: i64, %91: i64):  // pred: ^bb1
        %92 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %93 = llvm.getelementptr %92[%90] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %94 = llvm.load %93 : !llvm.ptr -> i64
        %95 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %96 = llvm.getelementptr %95[%91] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %97 = llvm.load %96 : !llvm.ptr -> i64
        %98 = llvm.icmp "ult" %97, %94 : i64
        %99 = llvm.select %98, %97, %94 : i1, i64
        %100 = llvm.mul %arg32, %39  : i64
        %101 = llvm.add %100, %99  : i64
        %102 = llvm.icmp "eq" %94, %99 : i64
        %103 = llvm.icmp "eq" %97, %99 : i64
        %104 = llvm.and %102, %103  : i1
        llvm.cond_br %104, ^bb3, ^bb4
      ^bb3:  // pred: ^bb2
        %105 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %106 = llvm.getelementptr %105[%90] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %107 = llvm.load %106 : !llvm.ptr -> f32
        %108 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %109 = llvm.getelementptr %108[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %110 = llvm.load %109 : !llvm.ptr -> f32
        %111 = llvm.fadd %107, %110  : f32
        %112 = llvm.getelementptr %52[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %111, %112 : f32, !llvm.ptr
        llvm.br ^bb10
      ^bb4:  // pred: ^bb2
        %113 = llvm.icmp "eq" %94, %99 : i64
        llvm.cond_br %113, ^bb5, ^bb6
      ^bb5:  // pred: ^bb4
        %114 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %115 = llvm.getelementptr %114[%90] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %116 = llvm.load %115 : !llvm.ptr -> f32
        %117 = llvm.getelementptr %52[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %116, %117 : f32, !llvm.ptr
        llvm.br ^bb9
      ^bb6:  // pred: ^bb4
        %118 = llvm.icmp "eq" %97, %99 : i64
        llvm.cond_br %118, ^bb7, ^bb8
      ^bb7:  // pred: ^bb6
        %119 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %120 = llvm.getelementptr %119[%91] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        %121 = llvm.load %120 : !llvm.ptr -> f32
        %122 = llvm.getelementptr %52[%101] : (!llvm.ptr, i64) -> !llvm.ptr, f32
        llvm.store %121, %122 : f32, !llvm.ptr
        llvm.br ^bb8
      ^bb8:  // 2 preds: ^bb6, ^bb7
        llvm.br ^bb9
      ^bb9:  // 2 preds: ^bb5, ^bb8
        llvm.br ^bb10
      ^bb10:  // 2 preds: ^bb3, ^bb9
        %123 = llvm.icmp "eq" %94, %99 : i64
        %124 = llvm.add %90, %46  : i64
        %125 = llvm.select %123, %124, %90 : i1, i64
        %126 = llvm.icmp "eq" %97, %99 : i64
        %127 = llvm.add %91, %46  : i64
        %128 = llvm.select %126, %127, %91 : i1, i64
        llvm.br ^bb1(%125, %128 : i64, i64)
      ^bb11:  // pred: ^bb1
        omp.parallel   {
          omp.wsloop   for  (%arg33) : i64 = (%85) to (%77) step (%46) {
            %129 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %130 = llvm.getelementptr %129[%arg33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %131 = llvm.load %130 : !llvm.ptr -> i64
            %132 = llvm.mul %arg32, %39  : i64
            %133 = llvm.add %132, %131  : i64
            %134 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %135 = llvm.getelementptr %134[%arg33] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %136 = llvm.load %135 : !llvm.ptr -> f32
            %137 = llvm.getelementptr %52[%133] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %136, %137 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.parallel   {
          omp.wsloop   for  (%arg33) : i64 = (%86) to (%84) step (%46) {
            %129 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %130 = llvm.getelementptr %129[%arg33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %131 = llvm.load %130 : !llvm.ptr -> i64
            %132 = llvm.mul %arg32, %39  : i64
            %133 = llvm.add %132, %131  : i64
            %134 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %135 = llvm.getelementptr %134[%arg33] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            %136 = llvm.load %135 : !llvm.ptr -> f32
            %137 = llvm.getelementptr %52[%133] : (!llvm.ptr, i64) -> !llvm.ptr, f32
            llvm.store %136, %137 : f32, !llvm.ptr
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    %68 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %69 = llvm.insertvalue %58, %68[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %70 = llvm.insertvalue %67, %69[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %70 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_SpMSpMAdd.Z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.struct<(array<2 x i64>, array<3 x i64>)>, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<2 x i64>, array<3 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @SpMSpMAdd.Z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %arg4, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %arg8) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<3 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %36, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


