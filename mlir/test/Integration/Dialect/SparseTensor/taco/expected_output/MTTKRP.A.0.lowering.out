// -----// IR Dump After LinalgGeneralization (linalg-generalize-named-ops) //----- //
func.func @MTTKRP.A.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg1: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg2: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
  %0 = bufferization.alloc_tensor() : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
  %1 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3) -> (d0, d2, d3)>, affine_map<(d0, d1, d2, d3) -> (d3, d1)>, affine_map<(d0, d1, d2, d3) -> (d0, d2, d1)>], iterator_types = ["parallel", "parallel", "parallel", "reduction"]} ins(%arg0, %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) outs(%0 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %4 = arith.mulf %in, %in_0 : f32
    %5 = arith.addf %out, %4 : f32
    linalg.yield %5 : f32
  } -> tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
  %2 = bufferization.alloc_tensor() : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  %3 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2, d1)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"]} ins(%1, %arg2 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) outs(%2 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %4 = arith.mulf %in, %in_0 : f32
    %5 = arith.addf %out, %4 : f32
    linalg.yield %5 : f32
  } -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  return %3 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
}

// -----// IR Dump After PreSparsificationRewrite (pre-sparsification-rewrite) //----- //
#map = affine_map<(d0, d1, d2, d3) -> (d0, d2, d3)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d3, d1)>
#map2 = affine_map<(d0, d1, d2, d3) -> (d0, d2, d1)>
#map3 = affine_map<(d0, d1, d2) -> (d0, d2, d1)>
#map4 = affine_map<(d0, d1, d2) -> (d2, d1)>
#map5 = affine_map<(d0, d1, d2) -> (d0, d1)>
module {
  func.func @MTTKRP.A.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg1: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg2: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %0 = bufferization.alloc_tensor() : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %1 = linalg.generic {indexing_maps = [#map, #map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "reduction"]} ins(%arg0, %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) outs(%0 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %4 = arith.mulf %in, %in_0 : f32
      %5 = arith.addf %out, %4 : f32
      linalg.yield %5 : f32
    } -> tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %2 = bufferization.alloc_tensor() : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %3 = linalg.generic {indexing_maps = [#map3, #map4, #map5], iterator_types = ["parallel", "parallel", "reduction"]} ins(%1, %arg2 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) outs(%2 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %4 = arith.mulf %in, %in_0 : f32
      %5 = arith.addf %out, %4 : f32
      linalg.yield %5 : f32
    } -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %3 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After EmptyTensorToAllocTensor (empty-tensor-to-alloc-tensor) //----- //
func.func @MTTKRP.A.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg1: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg2: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
  %0 = bufferization.alloc_tensor() : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
  %1 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2, d3) -> (d0, d2, d3)>, affine_map<(d0, d1, d2, d3) -> (d3, d1)>, affine_map<(d0, d1, d2, d3) -> (d0, d2, d1)>], iterator_types = ["parallel", "parallel", "parallel", "reduction"]} ins(%arg0, %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) outs(%0 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %4 = arith.mulf %in, %in_0 : f32
    %5 = arith.addf %out, %4 : f32
    linalg.yield %5 : f32
  } -> tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
  %2 = bufferization.alloc_tensor() : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  %3 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2, d1)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>], iterator_types = ["parallel", "parallel", "reduction"]} ins(%1, %arg2 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) outs(%2 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %4 = arith.mulf %in, %in_0 : f32
    %5 = arith.addf %out, %4 : f32
    linalg.yield %5 : f32
  } -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  return %3 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
}

// -----// IR Dump After SparsificationPass (sparsification) //----- //
module {
  func.func @MTTKRP.A.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg1: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg2: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %false = arith.constant false
    %true = arith.constant true
    %0 = bufferization.alloc_tensor() {bufferization.escape = [false]} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %1 = sparse_tensor.positions %arg0 {level = 0 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %2 = sparse_tensor.coordinates %arg0 {level = 0 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %4 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %5 = sparse_tensor.positions %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %6 = sparse_tensor.coordinates %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %7 = sparse_tensor.values %arg0 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xf32>
    %8 = sparse_tensor.values %arg1 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    %9 = memref.load %1[%c0] : memref<?xindex>
    %10 = memref.load %1[%c1] : memref<?xindex>
    %11 = scf.for %arg3 = %9 to %10 step %c1 iter_args(%arg4 = %0) -> (tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
      %24 = memref.load %2[%arg3] : memref<?xindex>
      %25 = memref.load %3[%arg3] : memref<?xindex>
      %26 = arith.addi %arg3, %c1 : index
      %27 = memref.load %3[%26] : memref<?xindex>
      %28 = scf.for %arg5 = %25 to %27 step %c1 iter_args(%arg6 = %arg4) -> (tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
        %29 = memref.load %4[%arg5] : memref<?xindex>
        %values, %filled, %added, %count = sparse_tensor.expand %0 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xf32>, memref<?xi1>, memref<?xindex>
        %30 = memref.load %5[%arg5] : memref<?xindex>
        %31 = arith.addi %arg5, %c1 : index
        %32 = memref.load %5[%31] : memref<?xindex>
        %33 = scf.for %arg7 = %30 to %32 step %c1 iter_args(%arg8 = %count) -> (index) {
          %35 = memref.load %6[%arg7] : memref<?xindex>
          %36 = memref.load %7[%arg7] : memref<?xf32>
          %37 = scf.for %arg9 = %c0 to %c32 step %c1 iter_args(%arg10 = %arg8) -> (index) {
            %38 = arith.muli %35, %c32 : index
            %39 = arith.addi %38, %arg9 : index
            %40 = memref.load %values[%arg9] : memref<?xf32>
            %41 = memref.load %8[%39] : memref<?xf32>
            %42 = arith.mulf %36, %41 : f32
            %43 = arith.addf %40, %42 : f32
            %44 = memref.load %filled[%arg9] : memref<?xi1>
            %45 = arith.cmpi eq, %44, %false : i1
            %46 = scf.if %45 -> (index) {
              memref.store %true, %filled[%arg9] : memref<?xi1>
              memref.store %arg9, %added[%arg10] : memref<?xindex>
              %47 = arith.addi %arg10, %c1 : index
              scf.yield %47 : index
            } else {
              scf.yield %arg10 : index
            }
            memref.store %43, %values[%arg9] : memref<?xf32>
            scf.yield %46 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %37 : index
        } {"Emitted from" = "linalg.generic"}
        %34 = sparse_tensor.compress %values, %filled, %added, %33 into %arg6[%24, %29] : memref<?xf32>, memref<?xi1>, memref<?xindex>, tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
        scf.yield %34 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      } {"Emitted from" = "linalg.generic"}
      scf.yield %28 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    } {"Emitted from" = "linalg.generic"}
    %12 = sparse_tensor.load %11 hasInserts : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %13 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %14 = sparse_tensor.positions %12 {level = 0 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %15 = sparse_tensor.coordinates %12 {level = 0 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %16 = sparse_tensor.positions %12 {level = 1 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %17 = sparse_tensor.coordinates %12 {level = 1 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %18 = sparse_tensor.values %12 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xf32>
    %19 = sparse_tensor.values %arg2 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    %20 = sparse_tensor.values %13 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    %21 = memref.load %14[%c0] : memref<?xindex>
    %22 = memref.load %14[%c1] : memref<?xindex>
    scf.parallel (%arg3) = (%21) to (%22) step (%c1) {
      %24 = memref.load %15[%arg3] : memref<?xindex>
      %25 = memref.load %16[%arg3] : memref<?xindex>
      %26 = arith.addi %arg3, %c1 : index
      %27 = memref.load %16[%26] : memref<?xindex>
      scf.parallel (%arg4) = (%25) to (%27) step (%c1) {
        %28 = memref.load %17[%arg4] : memref<?xindex>
        scf.parallel (%arg5) = (%c0) to (%c32) step (%c1) {
          %29 = arith.muli %arg4, %c32 : index
          %30 = arith.addi %29, %arg5 : index
          %31 = arith.muli %28, %c32 : index
          %32 = arith.addi %31, %arg5 : index
          %33 = arith.muli %24, %c32 : index
          %34 = arith.addi %33, %arg5 : index
          %35 = memref.load %20[%34] : memref<?xf32>
          %36 = memref.load %18[%30] : memref<?xf32>
          %37 = memref.load %19[%32] : memref<?xf32>
          %38 = arith.mulf %36, %37 : f32
          %39 = arith.addf %35, %38 : f32
          memref.store %39, %20[%34] : memref<?xf32>
          scf.yield
        } {"Emitted from" = "linalg.generic"}
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %23 = sparse_tensor.load %13 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %23 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After PostSparsificationRewrite (post-sparsification-rewrite) //----- //
module {
  func.func @MTTKRP.A.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg1: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg2: tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> attributes {llvm.emit_c_interface} {
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %false = arith.constant false
    %true = arith.constant true
    %0 = bufferization.alloc_tensor() {bufferization.escape = [false]} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %1 = sparse_tensor.positions %arg0 {level = 0 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %2 = sparse_tensor.coordinates %arg0 {level = 0 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %4 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %5 = sparse_tensor.positions %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %6 = sparse_tensor.coordinates %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xindex>
    %7 = sparse_tensor.values %arg0 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>> to memref<?xf32>
    %8 = sparse_tensor.values %arg1 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    %9 = memref.load %1[%c0] : memref<?xindex>
    %10 = memref.load %1[%c1] : memref<?xindex>
    %11 = scf.for %arg3 = %9 to %10 step %c1 iter_args(%arg4 = %0) -> (tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
      %24 = memref.load %2[%arg3] : memref<?xindex>
      %25 = memref.load %3[%arg3] : memref<?xindex>
      %26 = arith.addi %arg3, %c1 : index
      %27 = memref.load %3[%26] : memref<?xindex>
      %28 = scf.for %arg5 = %25 to %27 step %c1 iter_args(%arg6 = %arg4) -> (tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
        %29 = memref.load %4[%arg5] : memref<?xindex>
        %values, %filled, %added, %count = sparse_tensor.expand %0 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xf32>, memref<?xi1>, memref<?xindex>
        %30 = memref.load %5[%arg5] : memref<?xindex>
        %31 = arith.addi %arg5, %c1 : index
        %32 = memref.load %5[%31] : memref<?xindex>
        %33 = scf.for %arg7 = %30 to %32 step %c1 iter_args(%arg8 = %count) -> (index) {
          %35 = memref.load %6[%arg7] : memref<?xindex>
          %36 = memref.load %7[%arg7] : memref<?xf32>
          %37 = scf.for %arg9 = %c0 to %c32 step %c1 iter_args(%arg10 = %arg8) -> (index) {
            %38 = arith.muli %35, %c32 : index
            %39 = arith.addi %38, %arg9 : index
            %40 = memref.load %values[%arg9] : memref<?xf32>
            %41 = memref.load %8[%39] : memref<?xf32>
            %42 = arith.mulf %36, %41 : f32
            %43 = arith.addf %40, %42 : f32
            %44 = memref.load %filled[%arg9] : memref<?xi1>
            %45 = arith.cmpi eq, %44, %false : i1
            %46 = scf.if %45 -> (index) {
              memref.store %true, %filled[%arg9] : memref<?xi1>
              memref.store %arg9, %added[%arg10] : memref<?xindex>
              %47 = arith.addi %arg10, %c1 : index
              scf.yield %47 : index
            } else {
              scf.yield %arg10 : index
            }
            memref.store %43, %values[%arg9] : memref<?xf32>
            scf.yield %46 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %37 : index
        } {"Emitted from" = "linalg.generic"}
        %34 = sparse_tensor.compress %values, %filled, %added, %33 into %arg6[%24, %29] : memref<?xf32>, memref<?xi1>, memref<?xindex>, tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
        scf.yield %34 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      } {"Emitted from" = "linalg.generic"}
      scf.yield %28 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    } {"Emitted from" = "linalg.generic"}
    %12 = sparse_tensor.load %11 hasInserts : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %13 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %14 = sparse_tensor.positions %12 {level = 0 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %15 = sparse_tensor.coordinates %12 {level = 0 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %16 = sparse_tensor.positions %12 {level = 1 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %17 = sparse_tensor.coordinates %12 {level = 1 : index} : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xindex>
    %18 = sparse_tensor.values %12 : tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to memref<?xf32>
    %19 = sparse_tensor.values %arg2 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    %20 = sparse_tensor.values %13 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to memref<?xf32>
    %21 = memref.load %14[%c0] : memref<?xindex>
    %22 = memref.load %14[%c1] : memref<?xindex>
    scf.parallel (%arg3) = (%21) to (%22) step (%c1) {
      %24 = memref.load %15[%arg3] : memref<?xindex>
      %25 = memref.load %16[%arg3] : memref<?xindex>
      %26 = arith.addi %arg3, %c1 : index
      %27 = memref.load %16[%26] : memref<?xindex>
      scf.parallel (%arg4) = (%25) to (%27) step (%c1) {
        %28 = memref.load %17[%arg4] : memref<?xindex>
        scf.parallel (%arg5) = (%c0) to (%c32) step (%c1) {
          %29 = arith.muli %arg4, %c32 : index
          %30 = arith.addi %29, %arg5 : index
          %31 = arith.muli %28, %c32 : index
          %32 = arith.addi %31, %arg5 : index
          %33 = arith.muli %24, %c32 : index
          %34 = arith.addi %33, %arg5 : index
          %35 = memref.load %20[%34] : memref<?xf32>
          %36 = memref.load %18[%30] : memref<?xf32>
          %37 = memref.load %19[%32] : memref<?xf32>
          %38 = arith.mulf %36, %37 : f32
          %39 = arith.addf %35, %38 : f32
          memref.store %39, %20[%34] : memref<?xf32>
          scf.yield
        } {"Emitted from" = "linalg.generic"}
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %23 = sparse_tensor.load %13 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %23 : tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After SparseTensorCodegen (sparse-tensor-codegen) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = arith.addi %c0, %c1 : index
    %1 = memref.load %arg0[%c0] : memref<?xindex>
    %2 = memref.load %arg0[%0] : memref<?xindex>
    %3 = sparse_tensor.storage_specifier.get %arg5  crd_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %4 = arith.subi %2, %c1 : index
    %5 = arith.cmpi ult, %1, %2 : index
    %6 = scf.if %5 -> (i1) {
      %18 = memref.load %arg1[%4] : memref<?xindex>
      %19 = arith.cmpi eq, %18, %arg6 : index
      scf.yield %19 : i1
    } else {
      %false = arith.constant false
      scf.yield %false : i1
    }
    %7:7 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index) {
      scf.yield %arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %4 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    } else {
      %18 = arith.addi %3, %c1 : index
      memref.store %18, %arg0[%0] : memref<?xindex>
      %19 = sparse_tensor.storage_specifier.get %arg5  crd_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %outBuffer, %newSize = sparse_tensor.push_back %19, %arg1, %arg6 : index, memref<?xindex>, index
      %20 = sparse_tensor.storage_specifier.set %arg5  crd_mem_sz at 0 with %newSize : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %c1_1 = arith.constant 1 : index
      %c0_2 = arith.constant 0 : index
      %21 = sparse_tensor.storage_specifier.get %20  pos_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %outBuffer_3, %newSize_4 = sparse_tensor.push_back %21, %arg2, %c0_2, %c1_1 : index, memref<?xindex>, index, index
      %22 = sparse_tensor.storage_specifier.set %20  pos_mem_sz at 1 with %newSize_4 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      scf.yield %arg0, %outBuffer, %outBuffer_3, %arg3, %arg4, %22, %3 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    }
    %c1_0 = arith.constant 1 : index
    %8 = arith.addi %7#6, %c1_0 : index
    %9 = memref.load %7#2[%7#6] : memref<?xindex>
    %10 = memref.load %7#2[%8] : memref<?xindex>
    %11 = sparse_tensor.storage_specifier.get %7#5  crd_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %12 = arith.subi %10, %c1_0 : index
    %13 = arith.cmpi ult, %9, %10 : index
    %14 = scf.if %13 -> (i1) {
      %18 = memref.load %7#3[%12] : memref<?xindex>
      %19 = arith.cmpi eq, %18, %arg7 : index
      scf.yield %19 : i1
    } else {
      memref.store %11, %7#2[%7#6] : memref<?xindex>
      %false = arith.constant false
      scf.yield %false : i1
    }
    %15:7 = scf.if %14 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index) {
      scf.yield %7#0, %7#1, %7#2, %7#3, %7#4, %7#5, %12 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    } else {
      %18 = arith.addi %11, %c1_0 : index
      memref.store %18, %7#2[%8] : memref<?xindex>
      %19 = sparse_tensor.storage_specifier.get %7#5  crd_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %outBuffer, %newSize = sparse_tensor.push_back %19, %7#3, %arg7 : index, memref<?xindex>, index
      %20 = sparse_tensor.storage_specifier.set %7#5  crd_mem_sz at 1 with %newSize : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %c1_1 = arith.constant 1 : index
      %c32_2 = arith.constant 32 : index
      %21 = arith.muli %c1_1, %c32_2 : index
      %cst = arith.constant 0.000000e+00 : f32
      %22 = sparse_tensor.storage_specifier.get %20  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %outBuffer_3, %newSize_4 = sparse_tensor.push_back %22, %7#4, %cst, %21 : index, memref<?xf32>, f32, index
      %23 = sparse_tensor.storage_specifier.set %20  val_mem_sz with %newSize_4 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      scf.yield %7#0, %7#1, %7#2, %outBuffer, %outBuffer_3, %23, %11 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    }
    %c32 = arith.constant 32 : index
    %16 = arith.muli %c32, %15#6 : index
    %17 = arith.addi %16, %arg8 : index
    memref.store %arg9, %15#4[%17] : memref<?xf32>
    return %15#0, %15#1, %15#2, %15#3, %15#4, %15#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg8: memref<?xf32>, %arg9: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg10: memref<?xf32>, %arg11: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> (memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) attributes {llvm.emit_c_interface} {
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %false = arith.constant false
    %true = arith.constant true
    %c128 = arith.constant 128 : index
    %c128_0 = arith.constant 128 : index
    %c32_1 = arith.constant 32 : index
    %c16 = arith.constant 16 : index
    %alloc = memref.alloc(%c16) : memref<?xindex>
    %alloc_2 = memref.alloc(%c16) : memref<?xindex>
    %alloc_3 = memref.alloc(%c16) : memref<?xindex>
    %alloc_4 = memref.alloc(%c16) : memref<?xindex>
    %alloc_5 = memref.alloc(%c16) : memref<?xf32>
    %0 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %c0_6 = arith.constant 0 : index
    %1 = sparse_tensor.storage_specifier.set %0  lvl_sz at 0 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %2 = sparse_tensor.storage_specifier.get %1  pos_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %outBuffer, %newSize = sparse_tensor.push_back %2, %alloc, %c0_6 : index, memref<?xindex>, index
    %3 = sparse_tensor.storage_specifier.set %1  pos_mem_sz at 0 with %newSize : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %4 = sparse_tensor.storage_specifier.set %3  lvl_sz at 1 with %c128_0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %5 = sparse_tensor.storage_specifier.get %4  pos_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %outBuffer_7, %newSize_8 = sparse_tensor.push_back %5, %alloc_3, %c0_6 : index, memref<?xindex>, index
    %6 = sparse_tensor.storage_specifier.set %4  pos_mem_sz at 1 with %newSize_8 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %7 = sparse_tensor.storage_specifier.set %6  lvl_sz at 2 with %c32_1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %c1_9 = arith.constant 1 : index
    %c0_10 = arith.constant 0 : index
    %8 = sparse_tensor.storage_specifier.get %7  pos_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %outBuffer_11, %newSize_12 = sparse_tensor.push_back %8, %outBuffer, %c0_10, %c1_9 : index, memref<?xindex>, index, index
    %9 = sparse_tensor.storage_specifier.set %7  pos_mem_sz at 0 with %newSize_12 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %10 = builtin.unrealized_conversion_cast %outBuffer_11, %alloc_2, %outBuffer_7, %alloc_4, %alloc_5, %9 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %c32_13 = arith.constant 32 : index
    %alloc_14 = memref.alloc(%c32_13) : memref<?xf32>
    %alloc_15 = memref.alloc(%c32_13) : memref<?xi1>
    %alloc_16 = memref.alloc(%c32_13) : memref<?xindex>
    %c0_17 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    linalg.fill ins(%cst : f32) outs(%alloc_14 : memref<?xf32>)
    %false_18 = arith.constant false
    linalg.fill ins(%false_18 : i1) outs(%alloc_15 : memref<?xi1>)
    %11 = memref.load %arg0[%c0] : memref<?xindex>
    %12 = memref.load %arg0[%c1] : memref<?xindex>
    %13:6 = scf.for %arg12 = %11 to %12 step %c1 iter_args(%arg13 = %outBuffer_11, %arg14 = %alloc_2, %arg15 = %outBuffer_7, %arg16 = %alloc_4, %arg17 = %alloc_5, %arg18 = %9) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
      %31 = memref.load %arg1[%arg12] : memref<?xindex>
      %32 = memref.load %arg2[%arg12] : memref<?xindex>
      %33 = arith.addi %arg12, %c1 : index
      %34 = memref.load %arg2[%33] : memref<?xindex>
      %35:6 = scf.for %arg19 = %32 to %34 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
        %37 = memref.load %arg3[%arg19] : memref<?xindex>
        %38 = memref.load %arg4[%arg19] : memref<?xindex>
        %39 = arith.addi %arg19, %c1 : index
        %40 = memref.load %arg4[%39] : memref<?xindex>
        %41 = scf.for %arg26 = %38 to %40 step %c1 iter_args(%arg27 = %c0_17) -> (index) {
          %44 = memref.load %arg5[%arg26] : memref<?xindex>
          %45 = memref.load %arg6[%arg26] : memref<?xf32>
          %46 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
            %47 = arith.muli %44, %c32 : index
            %48 = arith.addi %47, %arg28 : index
            %49 = memref.load %alloc_14[%arg28] : memref<?xf32>
            %50 = memref.load %arg8[%48] : memref<?xf32>
            %51 = arith.mulf %45, %50 : f32
            %52 = arith.addf %49, %51 : f32
            %53 = memref.load %alloc_15[%arg28] : memref<?xi1>
            %54 = arith.cmpi eq, %53, %false : i1
            %55 = scf.if %54 -> (index) {
              memref.store %true, %alloc_15[%arg28] : memref<?xi1>
              memref.store %arg28, %alloc_16[%arg29] : memref<?xindex>
              %56 = arith.addi %arg29, %c1 : index
              scf.yield %56 : index
            } else {
              scf.yield %arg29 : index
            }
            memref.store %52, %alloc_14[%arg28] : memref<?xf32>
            scf.yield %55 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %46 : index
        } {"Emitted from" = "linalg.generic"}
        sparse_tensor.sort  hybrid_quick_sort %41, %alloc_16 : memref<?xindex>
        %c0_32 = arith.constant 0 : index
        %c1_33 = arith.constant 1 : index
        %42:6 = scf.for %arg26 = %c0_32 to %41 step %c1_33 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
          %44 = memref.load %alloc_16[%arg26] : memref<?xindex>
          %45 = memref.load %alloc_14[%44] : memref<?xf32>
          %46:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %31, %37, %44, %45) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>)
          %cst_34 = arith.constant 0.000000e+00 : f32
          memref.store %cst_34, %alloc_14[%44] : memref<?xf32>
          %false_35 = arith.constant false
          memref.store %false_35, %alloc_15[%44] : memref<?xi1>
          scf.yield %46#0, %46#1, %46#2, %46#3, %46#4, %46#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
        }
        %43 = builtin.unrealized_conversion_cast %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
        scf.yield %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      } {"Emitted from" = "linalg.generic"}
      %36 = builtin.unrealized_conversion_cast %35#0, %35#1, %35#2, %35#3, %35#4, %35#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      scf.yield %35#0, %35#1, %35#2, %35#3, %35#4, %35#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    } {"Emitted from" = "linalg.generic"}
    memref.dealloc %alloc_14 : memref<?xf32>
    memref.dealloc %alloc_15 : memref<?xi1>
    memref.dealloc %alloc_16 : memref<?xindex>
    %14 = builtin.unrealized_conversion_cast %13#0, %13#1, %13#2, %13#3, %13#4, %13#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %15 = sparse_tensor.storage_specifier.get %13#5  pos_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %c0_19 = arith.constant 0 : index
    %c1_20 = arith.constant 1 : index
    %16 = memref.load %13#2[%c0_19] : memref<?xindex>
    %c1_21 = arith.constant 1 : index
    %17 = scf.for %arg12 = %c1_20 to %15 step %c1_21 iter_args(%arg13 = %16) -> (index) {
      %31 = memref.load %13#2[%arg12] : memref<?xindex>
      %c0_32 = arith.constant 0 : index
      %32 = arith.cmpi eq, %31, %c0_32 : index
      %33 = scf.if %32 -> (index) {
        memref.store %arg13, %13#2[%arg12] : memref<?xindex>
        scf.yield %arg13 : index
      } else {
        scf.yield %31 : index
      }
      scf.yield %33 : index
    }
    %18 = builtin.unrealized_conversion_cast %13#0, %13#1, %13#2, %13#3, %13#4, %13#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>> to tensor<128x128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %c128_22 = arith.constant 128 : index
    %c32_23 = arith.constant 32 : index
    %19 = arith.muli %c128_22, %c32_23 : index
    %alloc_24 = memref.alloc(%19) : memref<?xf32>
    %20 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %c0_25 = arith.constant 0 : index
    %21 = sparse_tensor.storage_specifier.set %20  lvl_sz at 0 with %c128_22 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %22 = sparse_tensor.storage_specifier.set %21  lvl_sz at 1 with %c32_23 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %c1_26 = arith.constant 1 : index
    %c128_27 = arith.constant 128 : index
    %23 = arith.muli %c1_26, %c128_27 : index
    %c32_28 = arith.constant 32 : index
    %24 = arith.muli %23, %c32_28 : index
    %cst_29 = arith.constant 0.000000e+00 : f32
    %25 = sparse_tensor.storage_specifier.get %22  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %outBuffer_30, %newSize_31 = sparse_tensor.push_back %25, %alloc_24, %cst_29, %24 : index, memref<?xf32>, f32, index
    %26 = sparse_tensor.storage_specifier.set %22  val_mem_sz with %newSize_31 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %27 = builtin.unrealized_conversion_cast %outBuffer_30, %26 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %28 = memref.load %13#0[%c0] : memref<?xindex>
    %29 = memref.load %13#0[%c1] : memref<?xindex>
    scf.parallel (%arg12) = (%28) to (%29) step (%c1) {
      %31 = memref.load %13#1[%arg12] : memref<?xindex>
      %32 = memref.load %13#2[%arg12] : memref<?xindex>
      %33 = arith.addi %arg12, %c1 : index
      %34 = memref.load %13#2[%33] : memref<?xindex>
      scf.parallel (%arg13) = (%32) to (%34) step (%c1) {
        %35 = memref.load %13#3[%arg13] : memref<?xindex>
        scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
          %36 = arith.muli %arg13, %c32 : index
          %37 = arith.addi %36, %arg14 : index
          %38 = arith.muli %35, %c32 : index
          %39 = arith.addi %38, %arg14 : index
          %40 = arith.muli %31, %c32 : index
          %41 = arith.addi %40, %arg14 : index
          %42 = memref.load %outBuffer_30[%41] : memref<?xf32>
          %43 = memref.load %13#4[%37] : memref<?xf32>
          %44 = memref.load %arg10[%39] : memref<?xf32>
          %45 = arith.mulf %43, %44 : f32
          %46 = arith.addf %42, %45 : f32
          memref.store %46, %outBuffer_30[%41] : memref<?xf32>
          scf.yield
        } {"Emitted from" = "linalg.generic"}
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    %30 = builtin.unrealized_conversion_cast %outBuffer_30, %26 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>> to tensor<128x32xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    return %outBuffer_30, %26 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After SparseBufferRewrite (sparse-buffer-rewrite) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = sparse_tensor.storage_specifier.get %arg5  crd_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %3 = arith.subi %1, %c1 : index
    %4 = arith.cmpi ult, %0, %1 : index
    %5 = scf.if %4 -> (i1) {
      %17 = memref.load %arg1[%3] : memref<?xindex>
      %18 = arith.cmpi eq, %17, %arg6 : index
      scf.yield %18 : i1
    } else {
      scf.yield %false : i1
    }
    %6:7 = scf.if %5 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index) {
      scf.yield %arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %3 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    } else {
      %17 = arith.addi %2, %c1 : index
      memref.store %17, %arg0[%c1] : memref<?xindex>
      %18 = sparse_tensor.storage_specifier.get %arg5  crd_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %dim = memref.dim %arg1, %c0 : memref<?xindex>
      %19 = arith.addi %18, %c1 : index
      %20 = arith.cmpi ugt, %19, %dim : index
      %21 = scf.if %20 -> (memref<?xindex>) {
        %28 = arith.muli %dim, %c2 : index
        %29 = memref.realloc %arg1(%28) : memref<?xindex> to memref<?xindex>
        scf.yield %29 : memref<?xindex>
      } else {
        scf.yield %arg1 : memref<?xindex>
      }
      memref.store %arg6, %21[%18] : memref<?xindex>
      %22 = sparse_tensor.storage_specifier.set %arg5  crd_mem_sz at 0 with %19 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %23 = sparse_tensor.storage_specifier.get %22  pos_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
      %24 = arith.addi %23, %c1 : index
      %25 = arith.cmpi ugt, %24, %dim_0 : index
      %26 = scf.if %25 -> (memref<?xindex>) {
        %28 = arith.muli %dim_0, %c2 : index
        %29 = memref.realloc %arg2(%28) : memref<?xindex> to memref<?xindex>
        scf.yield %29 : memref<?xindex>
      } else {
        scf.yield %arg2 : memref<?xindex>
      }
      memref.store %c0, %26[%23] : memref<?xindex>
      %27 = sparse_tensor.storage_specifier.set %22  pos_mem_sz at 1 with %24 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      scf.yield %arg0, %21, %26, %arg3, %arg4, %27, %2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    }
    %7 = arith.addi %6#6, %c1 : index
    %8 = memref.load %6#2[%6#6] : memref<?xindex>
    %9 = memref.load %6#2[%7] : memref<?xindex>
    %10 = sparse_tensor.storage_specifier.get %6#5  crd_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %11 = arith.subi %9, %c1 : index
    %12 = arith.cmpi ult, %8, %9 : index
    %13 = scf.if %12 -> (i1) {
      %17 = memref.load %6#3[%11] : memref<?xindex>
      %18 = arith.cmpi eq, %17, %arg7 : index
      scf.yield %18 : i1
    } else {
      memref.store %10, %6#2[%6#6] : memref<?xindex>
      scf.yield %false : i1
    }
    %14:7 = scf.if %13 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index) {
      scf.yield %6#0, %6#1, %6#2, %6#3, %6#4, %6#5, %11 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    } else {
      %17 = arith.addi %10, %c1 : index
      memref.store %17, %6#2[%7] : memref<?xindex>
      %18 = sparse_tensor.storage_specifier.get %6#5  crd_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %dim = memref.dim %6#3, %c0 : memref<?xindex>
      %19 = arith.addi %18, %c1 : index
      %20 = arith.cmpi ugt, %19, %dim : index
      %21 = scf.if %20 -> (memref<?xindex>) {
        %28 = arith.muli %dim, %c2 : index
        %29 = memref.realloc %6#3(%28) : memref<?xindex> to memref<?xindex>
        scf.yield %29 : memref<?xindex>
      } else {
        scf.yield %6#3 : memref<?xindex>
      }
      memref.store %arg7, %21[%18] : memref<?xindex>
      %22 = sparse_tensor.storage_specifier.set %6#5  crd_mem_sz at 1 with %19 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %23 = sparse_tensor.storage_specifier.get %22  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      %dim_0 = memref.dim %6#4, %c0 : memref<?xf32>
      %24 = arith.addi %23, %c32 : index
      %25 = arith.cmpi ugt, %24, %dim_0 : index
      %26 = scf.if %25 -> (memref<?xf32>) {
        %28 = scf.while (%arg10 = %dim_0) : (index) -> index {
          %30 = arith.muli %arg10, %c2 : index
          %31 = arith.cmpi ugt, %24, %30 : index
          scf.condition(%31) %30 : index
        } do {
        ^bb0(%arg10: index):
          scf.yield %arg10 : index
        }
        %29 = memref.realloc %6#4(%28) : memref<?xf32> to memref<?xf32>
        scf.yield %29 : memref<?xf32>
      } else {
        scf.yield %6#4 : memref<?xf32>
      }
      %subview = memref.subview %26[%23] [%c32] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
      linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
      %27 = sparse_tensor.storage_specifier.set %22  val_mem_sz with %24 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      scf.yield %6#0, %6#1, %6#2, %21, %26, %27, %10 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index
    }
    %15 = arith.muli %14#6, %c32 : index
    %16 = arith.addi %15, %arg8 : index
    memref.store %arg9, %14#4[%16] : memref<?xf32>
    return %14#0, %14#1, %14#2, %14#3, %14#4, %14#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%1) %arg3, %arg4 : index, index
    } do {
    ^bb0(%arg3: index, %arg4: index):
      %1 = arith.addi %arg3, %arg4 : index
      %2 = arith.shrui %1, %c1 : index
      %3 = arith.addi %2, %c1 : index
      %4 = memref.load %arg2[%arg1] : memref<?xindex>
      %5 = memref.load %arg2[%2] : memref<?xindex>
      %6 = arith.cmpi ult, %4, %5 : index
      %7 = arith.select %6, %arg3, %3 : index
      %8 = arith.select %6, %2, %arg4 : index
      scf.yield %7, %8 : index, index
    }
    return %0#0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    scf.for %arg3 = %0 to %arg1 step %c1 {
      %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
      %2 = memref.load %arg2[%arg3] : memref<?xindex>
      %3 = arith.subi %arg3, %1 : index
      scf.for %arg4 = %c0 to %3 step %c1 {
        %4 = arith.subi %arg3, %arg4 : index
        %5 = arith.subi %4, %c1 : index
        %6 = memref.load %arg2[%5] : memref<?xindex>
        memref.store %6, %arg2[%4] : memref<?xindex>
      }
      memref.store %2, %arg2[%1] : memref<?xindex>
    }
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    scf.if %0 {
      %1 = arith.subi %arg1, %arg0 : index
      %2 = arith.subi %arg3, %c2 : index
      %3 = arith.shrui %2, %c1 : index
      %4 = arith.cmpi uge, %3, %1 : index
      scf.if %4 {
        %5 = arith.shli %1, %c1 : index
        %6 = arith.addi %5, %c1 : index
        %7 = arith.addi %6, %arg0 : index
        %8 = arith.addi %6, %c1 : index
        %9 = arith.cmpi ult, %8, %arg3 : index
        %10:2 = scf.if %9 -> (index, index) {
          %12 = arith.addi %8, %arg0 : index
          %13 = memref.load %arg2[%7] : memref<?xindex>
          %14 = memref.load %arg2[%12] : memref<?xindex>
          %15 = arith.cmpi ult, %13, %14 : index
          %16:2 = scf.if %15 -> (index, index) {
            scf.yield %8, %12 : index, index
          } else {
            scf.yield %6, %7 : index, index
          }
          scf.yield %16#0, %16#1 : index, index
        } else {
          scf.yield %6, %7 : index, index
        }
        %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi ult, %12, %13 : index
          scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
        } do {
        ^bb0(%arg4: index, %arg5: index, %arg6: index):
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          memref.store %13, %arg2[%arg4] : memref<?xindex>
          memref.store %12, %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi uge, %3, %arg5 : index
          %15:2 = scf.if %14 -> (index, index) {
            %16 = arith.shli %arg5, %c1 : index
            %17 = arith.addi %16, %c1 : index
            %18 = arith.addi %17, %arg0 : index
            %19 = arith.addi %17, %c1 : index
            %20 = arith.cmpi ult, %19, %arg3 : index
            %21:2 = scf.if %20 -> (index, index) {
              %22 = arith.addi %19, %arg0 : index
              %23 = memref.load %arg2[%18] : memref<?xindex>
              %24 = memref.load %arg2[%22] : memref<?xindex>
              %25 = arith.cmpi ult, %23, %24 : index
              %26:2 = scf.if %25 -> (index, index) {
                scf.yield %19, %22 : index, index
              } else {
                scf.yield %17, %18 : index, index
              }
              scf.yield %26#0, %26#1 : index, index
            } else {
              scf.yield %17, %18 : index, index
            }
            scf.yield %21#0, %21#1 : index, index
          } else {
            scf.yield %arg5, %arg6 : index, index
          }
          scf.yield %arg6, %15#0, %15#1 : index, index, index
        }
      }
    }
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    scf.for %arg3 = %c0 to %3 step %c1 {
      %5 = arith.subi %2, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    }
    %4 = arith.subi %0, %c1 : index
    scf.for %arg3 = %c0 to %4 step %c1 {
      %5 = arith.subi %0, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      %7 = arith.subi %6, %c1 : index
      %8 = memref.load %arg2[%arg0] : memref<?xindex>
      %9 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %9, %arg2[%arg0] : memref<?xindex>
      memref.store %8, %arg2[%7] : memref<?xindex>
      %10 = arith.subi %5, %c1 : index
      func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
    }
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    scf.if %4 {
      %6 = memref.load %arg2[%1] : memref<?xindex>
      %7 = memref.load %arg2[%arg0] : memref<?xindex>
      %8 = arith.cmpi ult, %6, %7 : index
      scf.if %8 {
        %12 = memref.load %arg2[%1] : memref<?xindex>
        %13 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %13, %arg2[%1] : memref<?xindex>
        memref.store %12, %arg2[%arg0] : memref<?xindex>
      }
      %9 = memref.load %arg2[%2] : memref<?xindex>
      %10 = memref.load %arg2[%1] : memref<?xindex>
      %11 = arith.cmpi ult, %9, %10 : index
      scf.if %11 {
        %12 = memref.load %arg2[%2] : memref<?xindex>
        %13 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %13, %arg2[%2] : memref<?xindex>
        memref.store %12, %arg2[%1] : memref<?xindex>
        %14 = memref.load %arg2[%1] : memref<?xindex>
        %15 = memref.load %arg2[%arg0] : memref<?xindex>
        %16 = arith.cmpi ult, %14, %15 : index
        scf.if %16 {
          %17 = memref.load %arg2[%1] : memref<?xindex>
          %18 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %18, %arg2[%1] : memref<?xindex>
          memref.store %17, %arg2[%arg0] : memref<?xindex>
        }
      }
    } else {
      %6 = arith.addi %arg0, %arg1 : index
      %7 = arith.shrui %6, %c1 : index
      %8 = arith.addi %1, %arg1 : index
      %9 = arith.shrui %8, %c1 : index
      %10 = memref.load %arg2[%7] : memref<?xindex>
      %11 = memref.load %arg2[%arg0] : memref<?xindex>
      %12 = arith.cmpi ult, %10, %11 : index
      scf.if %12 {
        %22 = memref.load %arg2[%7] : memref<?xindex>
        %23 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %23, %arg2[%7] : memref<?xindex>
        memref.store %22, %arg2[%arg0] : memref<?xindex>
      }
      %13 = memref.load %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%7] : memref<?xindex>
      %15 = arith.cmpi ult, %13, %14 : index
      scf.if %15 {
        %22 = memref.load %arg2[%1] : memref<?xindex>
        %23 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %23, %arg2[%1] : memref<?xindex>
        memref.store %22, %arg2[%7] : memref<?xindex>
        %24 = memref.load %arg2[%7] : memref<?xindex>
        %25 = memref.load %arg2[%arg0] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%7] : memref<?xindex>
          %28 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %28, %arg2[%7] : memref<?xindex>
          memref.store %27, %arg2[%arg0] : memref<?xindex>
        }
      }
      %16 = memref.load %arg2[%9] : memref<?xindex>
      %17 = memref.load %arg2[%1] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.if %18 {
        %22 = memref.load %arg2[%9] : memref<?xindex>
        %23 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %23, %arg2[%9] : memref<?xindex>
        memref.store %22, %arg2[%1] : memref<?xindex>
        %24 = memref.load %arg2[%1] : memref<?xindex>
        %25 = memref.load %arg2[%7] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%1] : memref<?xindex>
          %28 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %28, %arg2[%1] : memref<?xindex>
          memref.store %27, %arg2[%7] : memref<?xindex>
          %29 = memref.load %arg2[%7] : memref<?xindex>
          %30 = memref.load %arg2[%arg0] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%7] : memref<?xindex>
            %33 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %33, %arg2[%7] : memref<?xindex>
            memref.store %32, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
      %19 = memref.load %arg2[%2] : memref<?xindex>
      %20 = memref.load %arg2[%9] : memref<?xindex>
      %21 = arith.cmpi ult, %19, %20 : index
      scf.if %21 {
        %22 = memref.load %arg2[%2] : memref<?xindex>
        %23 = memref.load %arg2[%9] : memref<?xindex>
        memref.store %23, %arg2[%2] : memref<?xindex>
        memref.store %22, %arg2[%9] : memref<?xindex>
        %24 = memref.load %arg2[%9] : memref<?xindex>
        %25 = memref.load %arg2[%1] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%9] : memref<?xindex>
          %28 = memref.load %arg2[%1] : memref<?xindex>
          memref.store %28, %arg2[%9] : memref<?xindex>
          memref.store %27, %arg2[%1] : memref<?xindex>
          %29 = memref.load %arg2[%1] : memref<?xindex>
          %30 = memref.load %arg2[%7] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%1] : memref<?xindex>
            %33 = memref.load %arg2[%7] : memref<?xindex>
            memref.store %33, %arg2[%1] : memref<?xindex>
            memref.store %32, %arg2[%7] : memref<?xindex>
            %34 = memref.load %arg2[%7] : memref<?xindex>
            %35 = memref.load %arg2[%arg0] : memref<?xindex>
            %36 = arith.cmpi ult, %34, %35 : index
            scf.if %36 {
              %37 = memref.load %arg2[%7] : memref<?xindex>
              %38 = memref.load %arg2[%arg0] : memref<?xindex>
              memref.store %38, %arg2[%7] : memref<?xindex>
              memref.store %37, %arg2[%arg0] : memref<?xindex>
            }
          }
        }
      }
    }
    %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
      %6 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
    } do {
    ^bb0(%arg3: index, %arg4: index, %arg5: index):
      %6 = scf.while (%arg6 = %arg3) : (index) -> index {
        %16 = memref.load %arg2[%arg6] : memref<?xindex>
        %17 = memref.load %arg2[%arg5] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c1 : index
        scf.yield %16 : index
      }
      %7 = memref.load %arg2[%6] : memref<?xindex>
      %8 = memref.load %arg2[%arg5] : memref<?xindex>
      %9 = arith.cmpi eq, %7, %8 : index
      %10 = scf.while (%arg6 = %arg4) : (index) -> index {
        %16 = memref.load %arg2[%arg5] : memref<?xindex>
        %17 = memref.load %arg2[%arg6] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c-1 : index
        scf.yield %16 : index
      }
      %11 = memref.load %arg2[%10] : memref<?xindex>
      %12 = memref.load %arg2[%arg5] : memref<?xindex>
      %13 = arith.cmpi eq, %11, %12 : index
      %14 = arith.cmpi ult, %6, %10 : index
      %15:3 = scf.if %14 -> (index, index, index) {
        %16 = memref.load %arg2[%6] : memref<?xindex>
        %17 = memref.load %arg2[%10] : memref<?xindex>
        memref.store %17, %arg2[%6] : memref<?xindex>
        memref.store %16, %arg2[%10] : memref<?xindex>
        %18 = arith.cmpi eq, %6, %arg5 : index
        %19 = scf.if %18 -> (index) {
          scf.yield %10 : index
        } else {
          %22 = arith.cmpi eq, %10, %arg5 : index
          %23 = scf.if %22 -> (index) {
            scf.yield %6 : index
          } else {
            scf.yield %arg5 : index
          }
          scf.yield %23 : index
        }
        %20 = arith.andi %9, %13 : i1
        %21:2 = scf.if %20 -> (index, index) {
          %22 = arith.addi %6, %c1 : index
          %23 = arith.subi %10, %c1 : index
          scf.yield %22, %23 : index, index
        } else {
          scf.yield %6, %10 : index, index
        }
        scf.yield %21#0, %21#1, %19 : index, index, index
      } else {
        scf.yield %6, %10, %arg5 : index, index, index
      }
      scf.yield %15#0, %15#1, %15#2 : index, index, index
    }
    return %5#2 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.addi %arg4, %c1 : index
      %2 = arith.cmpi ult, %1, %arg5 : index
      scf.condition(%2) %arg4, %arg5 : index, index
    } do {
    ^bb0(%arg4: index, %arg5: index):
      %1 = arith.subi %arg5, %arg4 : index
      %2 = arith.cmpi ule, %1, %c30 : index
      %3:2 = scf.if %2 -> (index, index) {
        func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %4 = arith.subi %arg3, %c1_i64 : i64
        %5 = arith.cmpi ule, %4, %c0_i64 : i64
        %6:2 = scf.if %5 -> (index, index) {
          func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
          scf.yield %arg4, %arg4 : index, index
        } else {
          %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
          %8 = arith.addi %7, %c1 : index
          %9 = arith.subi %7, %arg4 : index
          %10 = arith.subi %arg5, %7 : index
          %11 = arith.cmpi ule, %9, %10 : index
          %12:2 = scf.if %11 -> (index, index) {
            %13 = arith.cmpi ne, %9, %c0 : index
            scf.if %13 {
              func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
            scf.yield %8, %arg5 : index, index
          } else {
            %13 = arith.cmpi ne, %10, %c0 : index
            scf.if %13 {
              func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
            scf.yield %arg4, %7 : index, index
          }
          scf.yield %12#0, %12#1 : index, index
        }
        scf.yield %6#0, %6#1 : index, index
      }
      scf.yield %3#0, %3#1 : index, index
    }
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "compressed" ] }>>, %arg8: memref<?xf32>, %arg9: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>, %arg10: memref<?xf32>, %arg11: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) -> (memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>) attributes {llvm.emit_c_interface} {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %c0 = arith.constant 0 : index
    %c64_i64 = arith.constant 64 : i64
    %c4096 = arith.constant 4096 : index
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %true = arith.constant true
    %c16 = arith.constant 16 : index
    %alloc = memref.alloc(%c16) : memref<?xindex>
    %alloc_0 = memref.alloc(%c16) : memref<?xindex>
    %alloc_1 = memref.alloc(%c16) : memref<?xindex>
    %alloc_2 = memref.alloc(%c16) : memref<?xindex>
    %alloc_3 = memref.alloc(%c16) : memref<?xf32>
    %0 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %1 = sparse_tensor.storage_specifier.set %0  lvl_sz at 0 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %2 = sparse_tensor.storage_specifier.get %1  pos_mem_sz at 0 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %3 = arith.addi %2, %c1 : index
    %4 = arith.cmpi ugt, %3, %c16 : index
    %5 = scf.if %4 -> (memref<?xindex>) {
      %34 = memref.realloc %alloc(%c32) : memref<?xindex> to memref<?xindex>
      scf.yield %34 : memref<?xindex>
    } else {
      scf.yield %alloc : memref<?xindex>
    }
    memref.store %c0, %5[%2] : memref<?xindex>
    %6 = sparse_tensor.storage_specifier.set %1  pos_mem_sz at 0 with %3 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %7 = sparse_tensor.storage_specifier.set %6  lvl_sz at 1 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %8 = sparse_tensor.storage_specifier.get %7  pos_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %9 = arith.addi %8, %c1 : index
    %10 = arith.cmpi ugt, %9, %c16 : index
    %11 = scf.if %10 -> (memref<?xindex>) {
      %34 = memref.realloc %alloc_1(%c32) : memref<?xindex> to memref<?xindex>
      scf.yield %34 : memref<?xindex>
    } else {
      scf.yield %alloc_1 : memref<?xindex>
    }
    memref.store %c0, %11[%8] : memref<?xindex>
    %12 = sparse_tensor.storage_specifier.set %7  pos_mem_sz at 1 with %9 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %13 = sparse_tensor.storage_specifier.set %12  lvl_sz at 2 with %c32 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %dim = memref.dim %5, %c0 : memref<?xindex>
    %14 = arith.addi %3, %c1 : index
    %15 = arith.cmpi ugt, %14, %dim : index
    %16 = scf.if %15 -> (memref<?xindex>) {
      %34 = arith.muli %dim, %c2 : index
      %35 = memref.realloc %5(%34) : memref<?xindex> to memref<?xindex>
      scf.yield %35 : memref<?xindex>
    } else {
      scf.yield %5 : memref<?xindex>
    }
    memref.store %c0, %16[%3] : memref<?xindex>
    %17 = sparse_tensor.storage_specifier.set %13  pos_mem_sz at 0 with %14 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %alloc_4 = memref.alloc(%c32) : memref<?xf32>
    %alloc_5 = memref.alloc(%c32) : memref<?xi1>
    %alloc_6 = memref.alloc(%c32) : memref<?xindex>
    linalg.fill ins(%cst : f32) outs(%alloc_4 : memref<?xf32>)
    linalg.fill ins(%false : i1) outs(%alloc_5 : memref<?xi1>)
    %18 = memref.load %arg0[%c0] : memref<?xindex>
    %19 = memref.load %arg0[%c1] : memref<?xindex>
    %20:6 = scf.for %arg12 = %18 to %19 step %c1 iter_args(%arg13 = %16, %arg14 = %alloc_0, %arg15 = %11, %arg16 = %alloc_2, %arg17 = %alloc_3, %arg18 = %17) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
      %34 = memref.load %arg1[%arg12] : memref<?xindex>
      %35 = memref.load %arg2[%arg12] : memref<?xindex>
      %36 = arith.addi %arg12, %c1 : index
      %37 = memref.load %arg2[%36] : memref<?xindex>
      %38:6 = scf.for %arg19 = %35 to %37 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
        %39 = memref.load %arg3[%arg19] : memref<?xindex>
        %40 = memref.load %arg4[%arg19] : memref<?xindex>
        %41 = arith.addi %arg19, %c1 : index
        %42 = memref.load %arg4[%41] : memref<?xindex>
        %43 = scf.for %arg26 = %40 to %42 step %c1 iter_args(%arg27 = %c0) -> (index) {
          %48 = memref.load %arg5[%arg26] : memref<?xindex>
          %49 = memref.load %arg6[%arg26] : memref<?xf32>
          %50 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
            %51 = arith.muli %48, %c32 : index
            %52 = arith.addi %51, %arg28 : index
            %53 = memref.load %alloc_4[%arg28] : memref<?xf32>
            %54 = memref.load %arg8[%52] : memref<?xf32>
            %55 = arith.mulf %49, %54 : f32
            %56 = arith.addf %53, %55 : f32
            %57 = memref.load %alloc_5[%arg28] : memref<?xi1>
            %58 = arith.cmpi eq, %57, %false : i1
            %59 = scf.if %58 -> (index) {
              memref.store %true, %alloc_5[%arg28] : memref<?xi1>
              memref.store %arg28, %alloc_6[%arg29] : memref<?xindex>
              %60 = arith.addi %arg29, %c1 : index
              scf.yield %60 : index
            } else {
              scf.yield %arg29 : index
            }
            memref.store %56, %alloc_4[%arg28] : memref<?xf32>
            scf.yield %59 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %50 : index
        } {"Emitted from" = "linalg.generic"}
        %44 = arith.index_cast %43 : index to i64
        %45 = math.ctlz %44 : i64
        %46 = arith.subi %c64_i64, %45 : i64
        func.call @_sparse_hybrid_qsort_1_index(%c0, %43, %alloc_6, %46) : (index, index, memref<?xindex>, i64) -> ()
        %47:6 = scf.for %arg26 = %c0 to %43 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>) {
          %48 = memref.load %alloc_6[%arg26] : memref<?xindex>
          %49 = memref.load %alloc_4[%48] : memref<?xf32>
          %50:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %34, %39, %48, %49) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>)
          memref.store %cst, %alloc_4[%48] : memref<?xf32>
          memref.store %false, %alloc_5[%48] : memref<?xi1>
          scf.yield %50#0, %50#1, %50#2, %50#3, %50#4, %50#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
        }
        scf.yield %47#0, %47#1, %47#2, %47#3, %47#4, %47#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
      } {"Emitted from" = "linalg.generic"}
      scf.yield %38#0, %38#1, %38#2, %38#3, %38#4, %38#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    } {"Emitted from" = "linalg.generic"}
    memref.dealloc %alloc_4 : memref<?xf32>
    memref.dealloc %alloc_5 : memref<?xi1>
    memref.dealloc %alloc_6 : memref<?xindex>
    %21 = sparse_tensor.storage_specifier.get %20#5  pos_mem_sz at 1 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "compressed", "compressed", "dense" ] }>>
    %22 = memref.load %20#2[%c0] : memref<?xindex>
    %23 = scf.for %arg12 = %c1 to %21 step %c1 iter_args(%arg13 = %22) -> (index) {
      %34 = memref.load %20#2[%arg12] : memref<?xindex>
      %35 = arith.cmpi eq, %34, %c0 : index
      %36 = scf.if %35 -> (index) {
        memref.store %arg13, %20#2[%arg12] : memref<?xindex>
        scf.yield %arg13 : index
      } else {
        scf.yield %34 : index
      }
      scf.yield %36 : index
    }
    %alloc_7 = memref.alloc(%c4096) : memref<?xf32>
    %24 = sparse_tensor.storage_specifier.init : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %25 = sparse_tensor.storage_specifier.set %24  lvl_sz at 0 with %c128 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %26 = sparse_tensor.storage_specifier.set %25  lvl_sz at 1 with %c32 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %27 = sparse_tensor.storage_specifier.get %26  val_mem_sz : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %28 = arith.addi %27, %c4096 : index
    %29 = arith.cmpi ugt, %28, %c4096 : index
    %30 = scf.if %29 -> (memref<?xf32>) {
      %34 = scf.while (%arg12 = %c4096) : (index) -> index {
        %36 = arith.muli %arg12, %c2 : index
        %37 = arith.cmpi ugt, %28, %36 : index
        scf.condition(%37) %36 : index
      } do {
      ^bb0(%arg12: index):
        scf.yield %arg12 : index
      }
      %35 = memref.realloc %alloc_7(%34) : memref<?xf32> to memref<?xf32>
      scf.yield %35 : memref<?xf32>
    } else {
      scf.yield %alloc_7 : memref<?xf32>
    }
    %subview = memref.subview %30[%27] [%c4096] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %31 = sparse_tensor.storage_specifier.set %26  val_mem_sz with %28 : !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
    %32 = memref.load %20#0[%c0] : memref<?xindex>
    %33 = memref.load %20#0[%c1] : memref<?xindex>
    scf.parallel (%arg12) = (%32) to (%33) step (%c1) {
      %34 = memref.load %20#1[%arg12] : memref<?xindex>
      %35 = memref.load %20#2[%arg12] : memref<?xindex>
      %36 = arith.addi %arg12, %c1 : index
      %37 = memref.load %20#2[%36] : memref<?xindex>
      scf.parallel (%arg13) = (%35) to (%37) step (%c1) {
        %38 = memref.load %20#3[%arg13] : memref<?xindex>
        scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
          %39 = arith.muli %arg13, %c32 : index
          %40 = arith.addi %39, %arg14 : index
          %41 = arith.muli %38, %c32 : index
          %42 = arith.addi %41, %arg14 : index
          %43 = arith.muli %34, %c32 : index
          %44 = arith.addi %43, %arg14 : index
          %45 = memref.load %30[%44] : memref<?xf32>
          %46 = memref.load %20#4[%40] : memref<?xf32>
          %47 = memref.load %arg10[%42] : memref<?xf32>
          %48 = arith.mulf %46, %47 : f32
          %49 = arith.addf %45, %48 : f32
          memref.store %49, %30[%44] : memref<?xf32>
          scf.yield
        } {"Emitted from" = "linalg.generic"}
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %30, %31 : memref<?xf32>, !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "dense" ] }>>
  }
}


// -----// IR Dump After StorageSpecifierToLLVM (sparse-storage-specifier-to-llvm) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.subi %1, %c1 : index
    %5 = arith.cmpi ult, %0, %1 : index
    %6 = scf.if %5 -> (i1) {
      %19 = memref.load %arg1[%4] : memref<?xindex>
      %20 = arith.cmpi eq, %19, %arg6 : index
      scf.yield %20 : i1
    } else {
      scf.yield %false : i1
    }
    %7:7 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index) {
      scf.yield %arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %4 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    } else {
      %19 = arith.addi %3, %c1 : index
      memref.store %19, %arg0[%c1] : memref<?xindex>
      %20 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %21 = arith.index_cast %20 : i64 to index
      %dim = memref.dim %arg1, %c0 : memref<?xindex>
      %22 = arith.addi %21, %c1 : index
      %23 = arith.cmpi ugt, %22, %dim : index
      %24 = scf.if %23 -> (memref<?xindex>) {
        %34 = arith.muli %dim, %c2 : index
        %35 = memref.realloc %arg1(%34) : memref<?xindex> to memref<?xindex>
        scf.yield %35 : memref<?xindex>
      } else {
        scf.yield %arg1 : memref<?xindex>
      }
      memref.store %arg6, %24[%21] : memref<?xindex>
      %25 = arith.index_cast %22 : index to i64
      %26 = llvm.insertvalue %25, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %27 = llvm.extractvalue %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %28 = arith.index_cast %27 : i64 to index
      %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
      %29 = arith.addi %28, %c1 : index
      %30 = arith.cmpi ugt, %29, %dim_0 : index
      %31 = scf.if %30 -> (memref<?xindex>) {
        %34 = arith.muli %dim_0, %c2 : index
        %35 = memref.realloc %arg2(%34) : memref<?xindex> to memref<?xindex>
        scf.yield %35 : memref<?xindex>
      } else {
        scf.yield %arg2 : memref<?xindex>
      }
      memref.store %c0, %31[%28] : memref<?xindex>
      %32 = arith.index_cast %29 : index to i64
      %33 = llvm.insertvalue %32, %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      scf.yield %arg0, %24, %31, %arg3, %arg4, %33, %3 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    }
    %8 = arith.addi %7#6, %c1 : index
    %9 = memref.load %7#2[%7#6] : memref<?xindex>
    %10 = memref.load %7#2[%8] : memref<?xindex>
    %11 = llvm.extractvalue %7#5[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %12 = arith.index_cast %11 : i64 to index
    %13 = arith.subi %10, %c1 : index
    %14 = arith.cmpi ult, %9, %10 : index
    %15 = scf.if %14 -> (i1) {
      %19 = memref.load %7#3[%13] : memref<?xindex>
      %20 = arith.cmpi eq, %19, %arg7 : index
      scf.yield %20 : i1
    } else {
      memref.store %12, %7#2[%7#6] : memref<?xindex>
      scf.yield %false : i1
    }
    %16:7 = scf.if %15 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index) {
      scf.yield %7#0, %7#1, %7#2, %7#3, %7#4, %7#5, %13 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    } else {
      %19 = arith.addi %12, %c1 : index
      memref.store %19, %7#2[%8] : memref<?xindex>
      %20 = llvm.extractvalue %7#5[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %21 = arith.index_cast %20 : i64 to index
      %dim = memref.dim %7#3, %c0 : memref<?xindex>
      %22 = arith.addi %21, %c1 : index
      %23 = arith.cmpi ugt, %22, %dim : index
      %24 = scf.if %23 -> (memref<?xindex>) {
        %34 = arith.muli %dim, %c2 : index
        %35 = memref.realloc %7#3(%34) : memref<?xindex> to memref<?xindex>
        scf.yield %35 : memref<?xindex>
      } else {
        scf.yield %7#3 : memref<?xindex>
      }
      memref.store %arg7, %24[%21] : memref<?xindex>
      %25 = arith.index_cast %22 : index to i64
      %26 = llvm.insertvalue %25, %7#5[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %27 = llvm.extractvalue %26[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %28 = arith.index_cast %27 : i64 to index
      %dim_0 = memref.dim %7#4, %c0 : memref<?xf32>
      %29 = arith.addi %28, %c32 : index
      %30 = arith.cmpi ugt, %29, %dim_0 : index
      %31 = scf.if %30 -> (memref<?xf32>) {
        %34 = scf.while (%arg10 = %dim_0) : (index) -> index {
          %36 = arith.muli %arg10, %c2 : index
          %37 = arith.cmpi ugt, %29, %36 : index
          scf.condition(%37) %36 : index
        } do {
        ^bb0(%arg10: index):
          scf.yield %arg10 : index
        }
        %35 = memref.realloc %7#4(%34) : memref<?xf32> to memref<?xf32>
        scf.yield %35 : memref<?xf32>
      } else {
        scf.yield %7#4 : memref<?xf32>
      }
      %subview = memref.subview %31[%28] [%c32] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
      linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
      %32 = arith.index_cast %29 : index to i64
      %33 = llvm.insertvalue %32, %26[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      scf.yield %7#0, %7#1, %7#2, %24, %31, %33, %12 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    }
    %17 = arith.muli %16#6, %c32 : index
    %18 = arith.addi %17, %arg8 : index
    memref.store %arg9, %16#4[%18] : memref<?xf32>
    return %16#0, %16#1, %16#2, %16#3, %16#4, %16#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%1) %arg3, %arg4 : index, index
    } do {
    ^bb0(%arg3: index, %arg4: index):
      %1 = arith.addi %arg3, %arg4 : index
      %2 = arith.shrui %1, %c1 : index
      %3 = arith.addi %2, %c1 : index
      %4 = memref.load %arg2[%arg1] : memref<?xindex>
      %5 = memref.load %arg2[%2] : memref<?xindex>
      %6 = arith.cmpi ult, %4, %5 : index
      %7 = arith.select %6, %arg3, %3 : index
      %8 = arith.select %6, %2, %arg4 : index
      scf.yield %7, %8 : index, index
    }
    return %0#0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    scf.for %arg3 = %0 to %arg1 step %c1 {
      %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
      %2 = memref.load %arg2[%arg3] : memref<?xindex>
      %3 = arith.subi %arg3, %1 : index
      scf.for %arg4 = %c0 to %3 step %c1 {
        %4 = arith.subi %arg3, %arg4 : index
        %5 = arith.subi %4, %c1 : index
        %6 = memref.load %arg2[%5] : memref<?xindex>
        memref.store %6, %arg2[%4] : memref<?xindex>
      }
      memref.store %2, %arg2[%1] : memref<?xindex>
    }
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    scf.if %0 {
      %1 = arith.subi %arg1, %arg0 : index
      %2 = arith.subi %arg3, %c2 : index
      %3 = arith.shrui %2, %c1 : index
      %4 = arith.cmpi uge, %3, %1 : index
      scf.if %4 {
        %5 = arith.shli %1, %c1 : index
        %6 = arith.addi %5, %c1 : index
        %7 = arith.addi %6, %arg0 : index
        %8 = arith.addi %6, %c1 : index
        %9 = arith.cmpi ult, %8, %arg3 : index
        %10:2 = scf.if %9 -> (index, index) {
          %12 = arith.addi %8, %arg0 : index
          %13 = memref.load %arg2[%7] : memref<?xindex>
          %14 = memref.load %arg2[%12] : memref<?xindex>
          %15 = arith.cmpi ult, %13, %14 : index
          %16:2 = scf.if %15 -> (index, index) {
            scf.yield %8, %12 : index, index
          } else {
            scf.yield %6, %7 : index, index
          }
          scf.yield %16#0, %16#1 : index, index
        } else {
          scf.yield %6, %7 : index, index
        }
        %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi ult, %12, %13 : index
          scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
        } do {
        ^bb0(%arg4: index, %arg5: index, %arg6: index):
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          memref.store %13, %arg2[%arg4] : memref<?xindex>
          memref.store %12, %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi uge, %3, %arg5 : index
          %15:2 = scf.if %14 -> (index, index) {
            %16 = arith.shli %arg5, %c1 : index
            %17 = arith.addi %16, %c1 : index
            %18 = arith.addi %17, %arg0 : index
            %19 = arith.addi %17, %c1 : index
            %20 = arith.cmpi ult, %19, %arg3 : index
            %21:2 = scf.if %20 -> (index, index) {
              %22 = arith.addi %19, %arg0 : index
              %23 = memref.load %arg2[%18] : memref<?xindex>
              %24 = memref.load %arg2[%22] : memref<?xindex>
              %25 = arith.cmpi ult, %23, %24 : index
              %26:2 = scf.if %25 -> (index, index) {
                scf.yield %19, %22 : index, index
              } else {
                scf.yield %17, %18 : index, index
              }
              scf.yield %26#0, %26#1 : index, index
            } else {
              scf.yield %17, %18 : index, index
            }
            scf.yield %21#0, %21#1 : index, index
          } else {
            scf.yield %arg5, %arg6 : index, index
          }
          scf.yield %arg6, %15#0, %15#1 : index, index, index
        }
      }
    }
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    scf.for %arg3 = %c0 to %3 step %c1 {
      %5 = arith.subi %2, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    }
    %4 = arith.subi %0, %c1 : index
    scf.for %arg3 = %c0 to %4 step %c1 {
      %5 = arith.subi %0, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      %7 = arith.subi %6, %c1 : index
      %8 = memref.load %arg2[%arg0] : memref<?xindex>
      %9 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %9, %arg2[%arg0] : memref<?xindex>
      memref.store %8, %arg2[%7] : memref<?xindex>
      %10 = arith.subi %5, %c1 : index
      func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
    }
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    scf.if %4 {
      %6 = memref.load %arg2[%1] : memref<?xindex>
      %7 = memref.load %arg2[%arg0] : memref<?xindex>
      %8 = arith.cmpi ult, %6, %7 : index
      scf.if %8 {
        %12 = memref.load %arg2[%1] : memref<?xindex>
        %13 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %13, %arg2[%1] : memref<?xindex>
        memref.store %12, %arg2[%arg0] : memref<?xindex>
      }
      %9 = memref.load %arg2[%2] : memref<?xindex>
      %10 = memref.load %arg2[%1] : memref<?xindex>
      %11 = arith.cmpi ult, %9, %10 : index
      scf.if %11 {
        %12 = memref.load %arg2[%2] : memref<?xindex>
        %13 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %13, %arg2[%2] : memref<?xindex>
        memref.store %12, %arg2[%1] : memref<?xindex>
        %14 = memref.load %arg2[%1] : memref<?xindex>
        %15 = memref.load %arg2[%arg0] : memref<?xindex>
        %16 = arith.cmpi ult, %14, %15 : index
        scf.if %16 {
          %17 = memref.load %arg2[%1] : memref<?xindex>
          %18 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %18, %arg2[%1] : memref<?xindex>
          memref.store %17, %arg2[%arg0] : memref<?xindex>
        }
      }
    } else {
      %6 = arith.addi %arg0, %arg1 : index
      %7 = arith.shrui %6, %c1 : index
      %8 = arith.addi %1, %arg1 : index
      %9 = arith.shrui %8, %c1 : index
      %10 = memref.load %arg2[%7] : memref<?xindex>
      %11 = memref.load %arg2[%arg0] : memref<?xindex>
      %12 = arith.cmpi ult, %10, %11 : index
      scf.if %12 {
        %22 = memref.load %arg2[%7] : memref<?xindex>
        %23 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %23, %arg2[%7] : memref<?xindex>
        memref.store %22, %arg2[%arg0] : memref<?xindex>
      }
      %13 = memref.load %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%7] : memref<?xindex>
      %15 = arith.cmpi ult, %13, %14 : index
      scf.if %15 {
        %22 = memref.load %arg2[%1] : memref<?xindex>
        %23 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %23, %arg2[%1] : memref<?xindex>
        memref.store %22, %arg2[%7] : memref<?xindex>
        %24 = memref.load %arg2[%7] : memref<?xindex>
        %25 = memref.load %arg2[%arg0] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%7] : memref<?xindex>
          %28 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %28, %arg2[%7] : memref<?xindex>
          memref.store %27, %arg2[%arg0] : memref<?xindex>
        }
      }
      %16 = memref.load %arg2[%9] : memref<?xindex>
      %17 = memref.load %arg2[%1] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.if %18 {
        %22 = memref.load %arg2[%9] : memref<?xindex>
        %23 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %23, %arg2[%9] : memref<?xindex>
        memref.store %22, %arg2[%1] : memref<?xindex>
        %24 = memref.load %arg2[%1] : memref<?xindex>
        %25 = memref.load %arg2[%7] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%1] : memref<?xindex>
          %28 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %28, %arg2[%1] : memref<?xindex>
          memref.store %27, %arg2[%7] : memref<?xindex>
          %29 = memref.load %arg2[%7] : memref<?xindex>
          %30 = memref.load %arg2[%arg0] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%7] : memref<?xindex>
            %33 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %33, %arg2[%7] : memref<?xindex>
            memref.store %32, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
      %19 = memref.load %arg2[%2] : memref<?xindex>
      %20 = memref.load %arg2[%9] : memref<?xindex>
      %21 = arith.cmpi ult, %19, %20 : index
      scf.if %21 {
        %22 = memref.load %arg2[%2] : memref<?xindex>
        %23 = memref.load %arg2[%9] : memref<?xindex>
        memref.store %23, %arg2[%2] : memref<?xindex>
        memref.store %22, %arg2[%9] : memref<?xindex>
        %24 = memref.load %arg2[%9] : memref<?xindex>
        %25 = memref.load %arg2[%1] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%9] : memref<?xindex>
          %28 = memref.load %arg2[%1] : memref<?xindex>
          memref.store %28, %arg2[%9] : memref<?xindex>
          memref.store %27, %arg2[%1] : memref<?xindex>
          %29 = memref.load %arg2[%1] : memref<?xindex>
          %30 = memref.load %arg2[%7] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%1] : memref<?xindex>
            %33 = memref.load %arg2[%7] : memref<?xindex>
            memref.store %33, %arg2[%1] : memref<?xindex>
            memref.store %32, %arg2[%7] : memref<?xindex>
            %34 = memref.load %arg2[%7] : memref<?xindex>
            %35 = memref.load %arg2[%arg0] : memref<?xindex>
            %36 = arith.cmpi ult, %34, %35 : index
            scf.if %36 {
              %37 = memref.load %arg2[%7] : memref<?xindex>
              %38 = memref.load %arg2[%arg0] : memref<?xindex>
              memref.store %38, %arg2[%7] : memref<?xindex>
              memref.store %37, %arg2[%arg0] : memref<?xindex>
            }
          }
        }
      }
    }
    %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
      %6 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
    } do {
    ^bb0(%arg3: index, %arg4: index, %arg5: index):
      %6 = scf.while (%arg6 = %arg3) : (index) -> index {
        %16 = memref.load %arg2[%arg6] : memref<?xindex>
        %17 = memref.load %arg2[%arg5] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c1 : index
        scf.yield %16 : index
      }
      %7 = memref.load %arg2[%6] : memref<?xindex>
      %8 = memref.load %arg2[%arg5] : memref<?xindex>
      %9 = arith.cmpi eq, %7, %8 : index
      %10 = scf.while (%arg6 = %arg4) : (index) -> index {
        %16 = memref.load %arg2[%arg5] : memref<?xindex>
        %17 = memref.load %arg2[%arg6] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c-1 : index
        scf.yield %16 : index
      }
      %11 = memref.load %arg2[%10] : memref<?xindex>
      %12 = memref.load %arg2[%arg5] : memref<?xindex>
      %13 = arith.cmpi eq, %11, %12 : index
      %14 = arith.cmpi ult, %6, %10 : index
      %15:3 = scf.if %14 -> (index, index, index) {
        %16 = memref.load %arg2[%6] : memref<?xindex>
        %17 = memref.load %arg2[%10] : memref<?xindex>
        memref.store %17, %arg2[%6] : memref<?xindex>
        memref.store %16, %arg2[%10] : memref<?xindex>
        %18 = arith.cmpi eq, %6, %arg5 : index
        %19 = scf.if %18 -> (index) {
          scf.yield %10 : index
        } else {
          %22 = arith.cmpi eq, %10, %arg5 : index
          %23 = scf.if %22 -> (index) {
            scf.yield %6 : index
          } else {
            scf.yield %arg5 : index
          }
          scf.yield %23 : index
        }
        %20 = arith.andi %9, %13 : i1
        %21:2 = scf.if %20 -> (index, index) {
          %22 = arith.addi %6, %c1 : index
          %23 = arith.subi %10, %c1 : index
          scf.yield %22, %23 : index, index
        } else {
          scf.yield %6, %10 : index, index
        }
        scf.yield %21#0, %21#1, %19 : index, index, index
      } else {
        scf.yield %6, %10, %arg5 : index, index, index
      }
      scf.yield %15#0, %15#1, %15#2 : index, index, index
    }
    return %5#2 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.addi %arg4, %c1 : index
      %2 = arith.cmpi ult, %1, %arg5 : index
      scf.condition(%2) %arg4, %arg5 : index, index
    } do {
    ^bb0(%arg4: index, %arg5: index):
      %1 = arith.subi %arg5, %arg4 : index
      %2 = arith.cmpi ule, %1, %c30 : index
      %3:2 = scf.if %2 -> (index, index) {
        func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %4 = arith.subi %arg3, %c1_i64 : i64
        %5 = arith.cmpi ule, %4, %c0_i64 : i64
        %6:2 = scf.if %5 -> (index, index) {
          func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
          scf.yield %arg4, %arg4 : index, index
        } else {
          %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
          %8 = arith.addi %7, %c1 : index
          %9 = arith.subi %7, %arg4 : index
          %10 = arith.subi %arg5, %7 : index
          %11 = arith.cmpi ule, %9, %10 : index
          %12:2 = scf.if %11 -> (index, index) {
            %13 = arith.cmpi ne, %9, %c0 : index
            scf.if %13 {
              func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
            scf.yield %8, %arg5 : index, index
          } else {
            %13 = arith.cmpi ne, %10, %c0 : index
            scf.if %13 {
              func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
            scf.yield %arg4, %7 : index, index
          }
          scf.yield %12#0, %12#1 : index, index
        }
        scf.yield %6#0, %6#1 : index, index
      }
      scf.yield %3#0, %3#1 : index, index
    }
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %c0 = arith.constant 0 : index
    %c64_i64 = arith.constant 64 : i64
    %c4096 = arith.constant 4096 : index
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %true = arith.constant true
    %c16 = arith.constant 16 : index
    %alloc = memref.alloc(%c16) : memref<?xindex>
    %alloc_0 = memref.alloc(%c16) : memref<?xindex>
    %alloc_1 = memref.alloc(%c16) : memref<?xindex>
    %alloc_2 = memref.alloc(%c16) : memref<?xindex>
    %alloc_3 = memref.alloc(%c16) : memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %c0_i64 = arith.constant 0 : i64
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %6 = arith.index_cast %c128 : index to i64
    %7 = llvm.insertvalue %6, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %8 = llvm.extractvalue %7[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %9 = arith.index_cast %8 : i64 to index
    %10 = arith.addi %9, %c1 : index
    %11 = arith.cmpi ugt, %10, %c16 : index
    %12 = scf.if %11 -> (memref<?xindex>) {
      %53 = memref.realloc %alloc(%c32) : memref<?xindex> to memref<?xindex>
      scf.yield %53 : memref<?xindex>
    } else {
      scf.yield %alloc : memref<?xindex>
    }
    memref.store %c0, %12[%9] : memref<?xindex>
    %13 = arith.index_cast %10 : index to i64
    %14 = llvm.insertvalue %13, %7[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %15 = arith.index_cast %c128 : index to i64
    %16 = llvm.insertvalue %15, %14[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %17 = llvm.extractvalue %16[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.addi %18, %c1 : index
    %20 = arith.cmpi ugt, %19, %c16 : index
    %21 = scf.if %20 -> (memref<?xindex>) {
      %53 = memref.realloc %alloc_1(%c32) : memref<?xindex> to memref<?xindex>
      scf.yield %53 : memref<?xindex>
    } else {
      scf.yield %alloc_1 : memref<?xindex>
    }
    memref.store %c0, %21[%18] : memref<?xindex>
    %22 = arith.index_cast %19 : index to i64
    %23 = llvm.insertvalue %22, %16[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %24 = arith.index_cast %c32 : index to i64
    %25 = llvm.insertvalue %24, %23[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %dim = memref.dim %12, %c0 : memref<?xindex>
    %26 = arith.addi %10, %c1 : index
    %27 = arith.cmpi ugt, %26, %dim : index
    %28 = scf.if %27 -> (memref<?xindex>) {
      %53 = arith.muli %dim, %c2 : index
      %54 = memref.realloc %12(%53) : memref<?xindex> to memref<?xindex>
      scf.yield %54 : memref<?xindex>
    } else {
      scf.yield %12 : memref<?xindex>
    }
    memref.store %c0, %28[%10] : memref<?xindex>
    %29 = arith.index_cast %26 : index to i64
    %30 = llvm.insertvalue %29, %25[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %alloc_4 = memref.alloc(%c32) : memref<?xf32>
    %alloc_5 = memref.alloc(%c32) : memref<?xi1>
    %alloc_6 = memref.alloc(%c32) : memref<?xindex>
    linalg.fill ins(%cst : f32) outs(%alloc_4 : memref<?xf32>)
    linalg.fill ins(%false : i1) outs(%alloc_5 : memref<?xi1>)
    %31 = memref.load %arg0[%c0] : memref<?xindex>
    %32 = memref.load %arg0[%c1] : memref<?xindex>
    %33:6 = scf.for %arg12 = %31 to %32 step %c1 iter_args(%arg13 = %28, %arg14 = %alloc_0, %arg15 = %21, %arg16 = %alloc_2, %arg17 = %alloc_3, %arg18 = %30) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %53 = memref.load %arg1[%arg12] : memref<?xindex>
      %54 = memref.load %arg2[%arg12] : memref<?xindex>
      %55 = arith.addi %arg12, %c1 : index
      %56 = memref.load %arg2[%55] : memref<?xindex>
      %57:6 = scf.for %arg19 = %54 to %56 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %58 = memref.load %arg3[%arg19] : memref<?xindex>
        %59 = memref.load %arg4[%arg19] : memref<?xindex>
        %60 = arith.addi %arg19, %c1 : index
        %61 = memref.load %arg4[%60] : memref<?xindex>
        %62 = scf.for %arg26 = %59 to %61 step %c1 iter_args(%arg27 = %c0) -> (index) {
          %67 = memref.load %arg5[%arg26] : memref<?xindex>
          %68 = memref.load %arg6[%arg26] : memref<?xf32>
          %69 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
            %70 = arith.muli %67, %c32 : index
            %71 = arith.addi %70, %arg28 : index
            %72 = memref.load %alloc_4[%arg28] : memref<?xf32>
            %73 = memref.load %arg8[%71] : memref<?xf32>
            %74 = arith.mulf %68, %73 : f32
            %75 = arith.addf %72, %74 : f32
            %76 = memref.load %alloc_5[%arg28] : memref<?xi1>
            %77 = arith.cmpi eq, %76, %false : i1
            %78 = scf.if %77 -> (index) {
              memref.store %true, %alloc_5[%arg28] : memref<?xi1>
              memref.store %arg28, %alloc_6[%arg29] : memref<?xindex>
              %79 = arith.addi %arg29, %c1 : index
              scf.yield %79 : index
            } else {
              scf.yield %arg29 : index
            }
            memref.store %75, %alloc_4[%arg28] : memref<?xf32>
            scf.yield %78 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %69 : index
        } {"Emitted from" = "linalg.generic"}
        %63 = arith.index_cast %62 : index to i64
        %64 = math.ctlz %63 : i64
        %65 = arith.subi %c64_i64, %64 : i64
        func.call @_sparse_hybrid_qsort_1_index(%c0, %62, %alloc_6, %65) : (index, index, memref<?xindex>, i64) -> ()
        %66:6 = scf.for %arg26 = %c0 to %62 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
          %67 = memref.load %alloc_6[%arg26] : memref<?xindex>
          %68 = memref.load %alloc_4[%67] : memref<?xf32>
          %69:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %53, %58, %67, %68) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
          memref.store %cst, %alloc_4[%67] : memref<?xf32>
          memref.store %false, %alloc_5[%67] : memref<?xi1>
          scf.yield %69#0, %69#1, %69#2, %69#3, %69#4, %69#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
        }
        scf.yield %66#0, %66#1, %66#2, %66#3, %66#4, %66#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      } {"Emitted from" = "linalg.generic"}
      scf.yield %57#0, %57#1, %57#2, %57#3, %57#4, %57#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    memref.dealloc %alloc_4 : memref<?xf32>
    memref.dealloc %alloc_5 : memref<?xi1>
    memref.dealloc %alloc_6 : memref<?xindex>
    %34 = llvm.extractvalue %33#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = memref.load %33#2[%c0] : memref<?xindex>
    %37 = scf.for %arg12 = %c1 to %35 step %c1 iter_args(%arg13 = %36) -> (index) {
      %53 = memref.load %33#2[%arg12] : memref<?xindex>
      %54 = arith.cmpi eq, %53, %c0 : index
      %55 = scf.if %54 -> (index) {
        memref.store %arg13, %33#2[%arg12] : memref<?xindex>
        scf.yield %arg13 : index
      } else {
        scf.yield %53 : index
      }
      scf.yield %55 : index
    }
    %alloc_7 = memref.alloc(%c4096) : memref<?xf32>
    %38 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %c0_i64_8 = arith.constant 0 : i64
    %39 = llvm.insertvalue %c0_i64_8, %38[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %40 = arith.index_cast %c128 : index to i64
    %41 = llvm.insertvalue %40, %39[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %42 = arith.index_cast %c32 : index to i64
    %43 = llvm.insertvalue %42, %41[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %43[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %45 = arith.index_cast %44 : i64 to index
    %46 = arith.addi %45, %c4096 : index
    %47 = arith.cmpi ugt, %46, %c4096 : index
    %48 = scf.if %47 -> (memref<?xf32>) {
      %53 = scf.while (%arg12 = %c4096) : (index) -> index {
        %55 = arith.muli %arg12, %c2 : index
        %56 = arith.cmpi ugt, %46, %55 : index
        scf.condition(%56) %55 : index
      } do {
      ^bb0(%arg12: index):
        scf.yield %arg12 : index
      }
      %54 = memref.realloc %alloc_7(%53) : memref<?xf32> to memref<?xf32>
      scf.yield %54 : memref<?xf32>
    } else {
      scf.yield %alloc_7 : memref<?xf32>
    }
    %subview = memref.subview %48[%45] [%c4096] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %49 = arith.index_cast %46 : index to i64
    %50 = llvm.insertvalue %49, %43[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %51 = memref.load %33#0[%c0] : memref<?xindex>
    %52 = memref.load %33#0[%c1] : memref<?xindex>
    scf.parallel (%arg12) = (%51) to (%52) step (%c1) {
      %53 = memref.load %33#1[%arg12] : memref<?xindex>
      %54 = memref.load %33#2[%arg12] : memref<?xindex>
      %55 = arith.addi %arg12, %c1 : index
      %56 = memref.load %33#2[%55] : memref<?xindex>
      scf.parallel (%arg13) = (%54) to (%56) step (%c1) {
        %57 = memref.load %33#3[%arg13] : memref<?xindex>
        scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
          %58 = arith.muli %arg13, %c32 : index
          %59 = arith.addi %58, %arg14 : index
          %60 = arith.muli %57, %c32 : index
          %61 = arith.addi %60, %arg14 : index
          %62 = arith.muli %53, %c32 : index
          %63 = arith.addi %62, %arg14 : index
          %64 = memref.load %48[%63] : memref<?xf32>
          %65 = memref.load %33#4[%59] : memref<?xf32>
          %66 = memref.load %arg10[%61] : memref<?xf32>
          %67 = arith.mulf %65, %66 : f32
          %68 = arith.addf %64, %67 : f32
          memref.store %68, %48[%63] : memref<?xf32>
          scf.yield
        } {"Emitted from" = "linalg.generic"}
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %48, %50 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After mlir::sparse_tensor::SparsificationAndBufferizationPass () //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.subi %1, %c1 : index
    %5 = arith.cmpi ult, %0, %1 : index
    %6 = scf.if %5 -> (i1) {
      %19 = memref.load %arg1[%4] : memref<?xindex>
      %20 = arith.cmpi eq, %19, %arg6 : index
      scf.yield %20 : i1
    } else {
      scf.yield %false : i1
    }
    %7:7 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index) {
      scf.yield %arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %4 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    } else {
      %19 = arith.addi %3, %c1 : index
      memref.store %19, %arg0[%c1] : memref<?xindex>
      %20 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %21 = arith.index_cast %20 : i64 to index
      %dim = memref.dim %arg1, %c0 : memref<?xindex>
      %22 = arith.addi %21, %c1 : index
      %23 = arith.cmpi ugt, %22, %dim : index
      %24 = scf.if %23 -> (memref<?xindex>) {
        %34 = arith.muli %dim, %c2 : index
        %35 = memref.realloc %arg1(%34) : memref<?xindex> to memref<?xindex>
        scf.yield %35 : memref<?xindex>
      } else {
        scf.yield %arg1 : memref<?xindex>
      }
      memref.store %arg6, %24[%21] : memref<?xindex>
      %25 = arith.index_cast %22 : index to i64
      %26 = llvm.insertvalue %25, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %27 = llvm.extractvalue %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %28 = arith.index_cast %27 : i64 to index
      %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
      %29 = arith.addi %28, %c1 : index
      %30 = arith.cmpi ugt, %29, %dim_0 : index
      %31 = scf.if %30 -> (memref<?xindex>) {
        %34 = arith.muli %dim_0, %c2 : index
        %35 = memref.realloc %arg2(%34) : memref<?xindex> to memref<?xindex>
        scf.yield %35 : memref<?xindex>
      } else {
        scf.yield %arg2 : memref<?xindex>
      }
      memref.store %c0, %31[%28] : memref<?xindex>
      %32 = arith.index_cast %29 : index to i64
      %33 = llvm.insertvalue %32, %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      scf.yield %arg0, %24, %31, %arg3, %arg4, %33, %3 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    }
    %8 = arith.addi %7#6, %c1 : index
    %9 = memref.load %7#2[%7#6] : memref<?xindex>
    %10 = memref.load %7#2[%8] : memref<?xindex>
    %11 = llvm.extractvalue %7#5[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %12 = arith.index_cast %11 : i64 to index
    %13 = arith.subi %10, %c1 : index
    %14 = arith.cmpi ult, %9, %10 : index
    %15 = scf.if %14 -> (i1) {
      %19 = memref.load %7#3[%13] : memref<?xindex>
      %20 = arith.cmpi eq, %19, %arg7 : index
      scf.yield %20 : i1
    } else {
      memref.store %12, %7#2[%7#6] : memref<?xindex>
      scf.yield %false : i1
    }
    %16:7 = scf.if %15 -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index) {
      scf.yield %7#0, %7#1, %7#2, %7#3, %7#4, %7#5, %13 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    } else {
      %19 = arith.addi %12, %c1 : index
      memref.store %19, %7#2[%8] : memref<?xindex>
      %20 = llvm.extractvalue %7#5[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %21 = arith.index_cast %20 : i64 to index
      %dim = memref.dim %7#3, %c0 : memref<?xindex>
      %22 = arith.addi %21, %c1 : index
      %23 = arith.cmpi ugt, %22, %dim : index
      %24 = scf.if %23 -> (memref<?xindex>) {
        %34 = arith.muli %dim, %c2 : index
        %35 = memref.realloc %7#3(%34) : memref<?xindex> to memref<?xindex>
        scf.yield %35 : memref<?xindex>
      } else {
        scf.yield %7#3 : memref<?xindex>
      }
      memref.store %arg7, %24[%21] : memref<?xindex>
      %25 = arith.index_cast %22 : index to i64
      %26 = llvm.insertvalue %25, %7#5[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %27 = llvm.extractvalue %26[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %28 = arith.index_cast %27 : i64 to index
      %dim_0 = memref.dim %7#4, %c0 : memref<?xf32>
      %29 = arith.addi %28, %c32 : index
      %30 = arith.cmpi ugt, %29, %dim_0 : index
      %31 = scf.if %30 -> (memref<?xf32>) {
        %34 = scf.while (%arg10 = %dim_0) : (index) -> index {
          %36 = arith.muli %arg10, %c2 : index
          %37 = arith.cmpi ugt, %29, %36 : index
          scf.condition(%37) %36 : index
        } do {
        ^bb0(%arg10: index):
          scf.yield %arg10 : index
        }
        %35 = memref.realloc %7#4(%34) : memref<?xf32> to memref<?xf32>
        scf.yield %35 : memref<?xf32>
      } else {
        scf.yield %7#4 : memref<?xf32>
      }
      %subview = memref.subview %31[%28] [%c32] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
      linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
      %32 = arith.index_cast %29 : index to i64
      %33 = llvm.insertvalue %32, %26[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      scf.yield %7#0, %7#1, %7#2, %24, %31, %33, %12 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index
    }
    %17 = arith.muli %16#6, %c32 : index
    %18 = arith.addi %17, %arg8 : index
    memref.store %arg9, %16#4[%18] : memref<?xf32>
    return %16#0, %16#1, %16#2, %16#3, %16#4, %16#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%1) %arg3, %arg4 : index, index
    } do {
    ^bb0(%arg3: index, %arg4: index):
      %1 = arith.addi %arg3, %arg4 : index
      %2 = arith.shrui %1, %c1 : index
      %3 = arith.addi %2, %c1 : index
      %4 = memref.load %arg2[%arg1] : memref<?xindex>
      %5 = memref.load %arg2[%2] : memref<?xindex>
      %6 = arith.cmpi ult, %4, %5 : index
      %7 = arith.select %6, %arg3, %3 : index
      %8 = arith.select %6, %2, %arg4 : index
      scf.yield %7, %8 : index, index
    }
    return %0#0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    scf.for %arg3 = %0 to %arg1 step %c1 {
      %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
      %2 = memref.load %arg2[%arg3] : memref<?xindex>
      %3 = arith.subi %arg3, %1 : index
      scf.for %arg4 = %c0 to %3 step %c1 {
        %4 = arith.subi %arg3, %arg4 : index
        %5 = arith.subi %4, %c1 : index
        %6 = memref.load %arg2[%5] : memref<?xindex>
        memref.store %6, %arg2[%4] : memref<?xindex>
      }
      memref.store %2, %arg2[%1] : memref<?xindex>
    }
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    scf.if %0 {
      %1 = arith.subi %arg1, %arg0 : index
      %2 = arith.subi %arg3, %c2 : index
      %3 = arith.shrui %2, %c1 : index
      %4 = arith.cmpi uge, %3, %1 : index
      scf.if %4 {
        %5 = arith.shli %1, %c1 : index
        %6 = arith.addi %5, %c1 : index
        %7 = arith.addi %6, %arg0 : index
        %8 = arith.addi %6, %c1 : index
        %9 = arith.cmpi ult, %8, %arg3 : index
        %10:2 = scf.if %9 -> (index, index) {
          %12 = arith.addi %8, %arg0 : index
          %13 = memref.load %arg2[%7] : memref<?xindex>
          %14 = memref.load %arg2[%12] : memref<?xindex>
          %15 = arith.cmpi ult, %13, %14 : index
          %16:2 = scf.if %15 -> (index, index) {
            scf.yield %8, %12 : index, index
          } else {
            scf.yield %6, %7 : index, index
          }
          scf.yield %16#0, %16#1 : index, index
        } else {
          scf.yield %6, %7 : index, index
        }
        %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi ult, %12, %13 : index
          scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
        } do {
        ^bb0(%arg4: index, %arg5: index, %arg6: index):
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          memref.store %13, %arg2[%arg4] : memref<?xindex>
          memref.store %12, %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi uge, %3, %arg5 : index
          %15:2 = scf.if %14 -> (index, index) {
            %16 = arith.shli %arg5, %c1 : index
            %17 = arith.addi %16, %c1 : index
            %18 = arith.addi %17, %arg0 : index
            %19 = arith.addi %17, %c1 : index
            %20 = arith.cmpi ult, %19, %arg3 : index
            %21:2 = scf.if %20 -> (index, index) {
              %22 = arith.addi %19, %arg0 : index
              %23 = memref.load %arg2[%18] : memref<?xindex>
              %24 = memref.load %arg2[%22] : memref<?xindex>
              %25 = arith.cmpi ult, %23, %24 : index
              %26:2 = scf.if %25 -> (index, index) {
                scf.yield %19, %22 : index, index
              } else {
                scf.yield %17, %18 : index, index
              }
              scf.yield %26#0, %26#1 : index, index
            } else {
              scf.yield %17, %18 : index, index
            }
            scf.yield %21#0, %21#1 : index, index
          } else {
            scf.yield %arg5, %arg6 : index, index
          }
          scf.yield %arg6, %15#0, %15#1 : index, index, index
        }
      }
    }
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    scf.for %arg3 = %c0 to %3 step %c1 {
      %5 = arith.subi %2, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    }
    %4 = arith.subi %0, %c1 : index
    scf.for %arg3 = %c0 to %4 step %c1 {
      %5 = arith.subi %0, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      %7 = arith.subi %6, %c1 : index
      %8 = memref.load %arg2[%arg0] : memref<?xindex>
      %9 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %9, %arg2[%arg0] : memref<?xindex>
      memref.store %8, %arg2[%7] : memref<?xindex>
      %10 = arith.subi %5, %c1 : index
      func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
    }
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    scf.if %4 {
      %6 = memref.load %arg2[%1] : memref<?xindex>
      %7 = memref.load %arg2[%arg0] : memref<?xindex>
      %8 = arith.cmpi ult, %6, %7 : index
      scf.if %8 {
        %12 = memref.load %arg2[%1] : memref<?xindex>
        %13 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %13, %arg2[%1] : memref<?xindex>
        memref.store %12, %arg2[%arg0] : memref<?xindex>
      }
      %9 = memref.load %arg2[%2] : memref<?xindex>
      %10 = memref.load %arg2[%1] : memref<?xindex>
      %11 = arith.cmpi ult, %9, %10 : index
      scf.if %11 {
        %12 = memref.load %arg2[%2] : memref<?xindex>
        %13 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %13, %arg2[%2] : memref<?xindex>
        memref.store %12, %arg2[%1] : memref<?xindex>
        %14 = memref.load %arg2[%1] : memref<?xindex>
        %15 = memref.load %arg2[%arg0] : memref<?xindex>
        %16 = arith.cmpi ult, %14, %15 : index
        scf.if %16 {
          %17 = memref.load %arg2[%1] : memref<?xindex>
          %18 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %18, %arg2[%1] : memref<?xindex>
          memref.store %17, %arg2[%arg0] : memref<?xindex>
        }
      }
    } else {
      %6 = arith.addi %arg0, %arg1 : index
      %7 = arith.shrui %6, %c1 : index
      %8 = arith.addi %1, %arg1 : index
      %9 = arith.shrui %8, %c1 : index
      %10 = memref.load %arg2[%7] : memref<?xindex>
      %11 = memref.load %arg2[%arg0] : memref<?xindex>
      %12 = arith.cmpi ult, %10, %11 : index
      scf.if %12 {
        %22 = memref.load %arg2[%7] : memref<?xindex>
        %23 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %23, %arg2[%7] : memref<?xindex>
        memref.store %22, %arg2[%arg0] : memref<?xindex>
      }
      %13 = memref.load %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%7] : memref<?xindex>
      %15 = arith.cmpi ult, %13, %14 : index
      scf.if %15 {
        %22 = memref.load %arg2[%1] : memref<?xindex>
        %23 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %23, %arg2[%1] : memref<?xindex>
        memref.store %22, %arg2[%7] : memref<?xindex>
        %24 = memref.load %arg2[%7] : memref<?xindex>
        %25 = memref.load %arg2[%arg0] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%7] : memref<?xindex>
          %28 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %28, %arg2[%7] : memref<?xindex>
          memref.store %27, %arg2[%arg0] : memref<?xindex>
        }
      }
      %16 = memref.load %arg2[%9] : memref<?xindex>
      %17 = memref.load %arg2[%1] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.if %18 {
        %22 = memref.load %arg2[%9] : memref<?xindex>
        %23 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %23, %arg2[%9] : memref<?xindex>
        memref.store %22, %arg2[%1] : memref<?xindex>
        %24 = memref.load %arg2[%1] : memref<?xindex>
        %25 = memref.load %arg2[%7] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%1] : memref<?xindex>
          %28 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %28, %arg2[%1] : memref<?xindex>
          memref.store %27, %arg2[%7] : memref<?xindex>
          %29 = memref.load %arg2[%7] : memref<?xindex>
          %30 = memref.load %arg2[%arg0] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%7] : memref<?xindex>
            %33 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %33, %arg2[%7] : memref<?xindex>
            memref.store %32, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
      %19 = memref.load %arg2[%2] : memref<?xindex>
      %20 = memref.load %arg2[%9] : memref<?xindex>
      %21 = arith.cmpi ult, %19, %20 : index
      scf.if %21 {
        %22 = memref.load %arg2[%2] : memref<?xindex>
        %23 = memref.load %arg2[%9] : memref<?xindex>
        memref.store %23, %arg2[%2] : memref<?xindex>
        memref.store %22, %arg2[%9] : memref<?xindex>
        %24 = memref.load %arg2[%9] : memref<?xindex>
        %25 = memref.load %arg2[%1] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%9] : memref<?xindex>
          %28 = memref.load %arg2[%1] : memref<?xindex>
          memref.store %28, %arg2[%9] : memref<?xindex>
          memref.store %27, %arg2[%1] : memref<?xindex>
          %29 = memref.load %arg2[%1] : memref<?xindex>
          %30 = memref.load %arg2[%7] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%1] : memref<?xindex>
            %33 = memref.load %arg2[%7] : memref<?xindex>
            memref.store %33, %arg2[%1] : memref<?xindex>
            memref.store %32, %arg2[%7] : memref<?xindex>
            %34 = memref.load %arg2[%7] : memref<?xindex>
            %35 = memref.load %arg2[%arg0] : memref<?xindex>
            %36 = arith.cmpi ult, %34, %35 : index
            scf.if %36 {
              %37 = memref.load %arg2[%7] : memref<?xindex>
              %38 = memref.load %arg2[%arg0] : memref<?xindex>
              memref.store %38, %arg2[%7] : memref<?xindex>
              memref.store %37, %arg2[%arg0] : memref<?xindex>
            }
          }
        }
      }
    }
    %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
      %6 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
    } do {
    ^bb0(%arg3: index, %arg4: index, %arg5: index):
      %6 = scf.while (%arg6 = %arg3) : (index) -> index {
        %16 = memref.load %arg2[%arg6] : memref<?xindex>
        %17 = memref.load %arg2[%arg5] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c1 : index
        scf.yield %16 : index
      }
      %7 = memref.load %arg2[%6] : memref<?xindex>
      %8 = memref.load %arg2[%arg5] : memref<?xindex>
      %9 = arith.cmpi eq, %7, %8 : index
      %10 = scf.while (%arg6 = %arg4) : (index) -> index {
        %16 = memref.load %arg2[%arg5] : memref<?xindex>
        %17 = memref.load %arg2[%arg6] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c-1 : index
        scf.yield %16 : index
      }
      %11 = memref.load %arg2[%10] : memref<?xindex>
      %12 = memref.load %arg2[%arg5] : memref<?xindex>
      %13 = arith.cmpi eq, %11, %12 : index
      %14 = arith.cmpi ult, %6, %10 : index
      %15:3 = scf.if %14 -> (index, index, index) {
        %16 = memref.load %arg2[%6] : memref<?xindex>
        %17 = memref.load %arg2[%10] : memref<?xindex>
        memref.store %17, %arg2[%6] : memref<?xindex>
        memref.store %16, %arg2[%10] : memref<?xindex>
        %18 = arith.cmpi eq, %6, %arg5 : index
        %19 = scf.if %18 -> (index) {
          scf.yield %10 : index
        } else {
          %22 = arith.cmpi eq, %10, %arg5 : index
          %23 = scf.if %22 -> (index) {
            scf.yield %6 : index
          } else {
            scf.yield %arg5 : index
          }
          scf.yield %23 : index
        }
        %20 = arith.andi %9, %13 : i1
        %21:2 = scf.if %20 -> (index, index) {
          %22 = arith.addi %6, %c1 : index
          %23 = arith.subi %10, %c1 : index
          scf.yield %22, %23 : index, index
        } else {
          scf.yield %6, %10 : index, index
        }
        scf.yield %21#0, %21#1, %19 : index, index, index
      } else {
        scf.yield %6, %10, %arg5 : index, index, index
      }
      scf.yield %15#0, %15#1, %15#2 : index, index, index
    }
    return %5#2 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.addi %arg4, %c1 : index
      %2 = arith.cmpi ult, %1, %arg5 : index
      scf.condition(%2) %arg4, %arg5 : index, index
    } do {
    ^bb0(%arg4: index, %arg5: index):
      %1 = arith.subi %arg5, %arg4 : index
      %2 = arith.cmpi ule, %1, %c30 : index
      %3:2 = scf.if %2 -> (index, index) {
        func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %4 = arith.subi %arg3, %c1_i64 : i64
        %5 = arith.cmpi ule, %4, %c0_i64 : i64
        %6:2 = scf.if %5 -> (index, index) {
          func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
          scf.yield %arg4, %arg4 : index, index
        } else {
          %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
          %8 = arith.addi %7, %c1 : index
          %9 = arith.subi %7, %arg4 : index
          %10 = arith.subi %arg5, %7 : index
          %11 = arith.cmpi ule, %9, %10 : index
          %12:2 = scf.if %11 -> (index, index) {
            %13 = arith.cmpi ne, %9, %c0 : index
            scf.if %13 {
              func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
            scf.yield %8, %arg5 : index, index
          } else {
            %13 = arith.cmpi ne, %10, %c0 : index
            scf.if %13 {
              func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
            scf.yield %arg4, %7 : index, index
          }
          scf.yield %12#0, %12#1 : index, index
        }
        scf.yield %6#0, %6#1 : index, index
      }
      scf.yield %3#0, %3#1 : index, index
    }
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %c0 = arith.constant 0 : index
    %c64_i64 = arith.constant 64 : i64
    %c4096 = arith.constant 4096 : index
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %true = arith.constant true
    %c16 = arith.constant 16 : index
    %alloc = memref.alloc(%c16) : memref<?xindex>
    %alloc_0 = memref.alloc(%c16) : memref<?xindex>
    %alloc_1 = memref.alloc(%c16) : memref<?xindex>
    %alloc_2 = memref.alloc(%c16) : memref<?xindex>
    %alloc_3 = memref.alloc(%c16) : memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %c0_i64 = arith.constant 0 : i64
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %6 = arith.index_cast %c128 : index to i64
    %7 = llvm.insertvalue %6, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %8 = llvm.extractvalue %7[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %9 = arith.index_cast %8 : i64 to index
    %10 = arith.addi %9, %c1 : index
    %11 = arith.cmpi ugt, %10, %c16 : index
    %12 = scf.if %11 -> (memref<?xindex>) {
      %53 = memref.realloc %alloc(%c32) : memref<?xindex> to memref<?xindex>
      scf.yield %53 : memref<?xindex>
    } else {
      scf.yield %alloc : memref<?xindex>
    }
    memref.store %c0, %12[%9] : memref<?xindex>
    %13 = arith.index_cast %10 : index to i64
    %14 = llvm.insertvalue %13, %7[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %15 = arith.index_cast %c128 : index to i64
    %16 = llvm.insertvalue %15, %14[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %17 = llvm.extractvalue %16[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.addi %18, %c1 : index
    %20 = arith.cmpi ugt, %19, %c16 : index
    %21 = scf.if %20 -> (memref<?xindex>) {
      %53 = memref.realloc %alloc_1(%c32) : memref<?xindex> to memref<?xindex>
      scf.yield %53 : memref<?xindex>
    } else {
      scf.yield %alloc_1 : memref<?xindex>
    }
    memref.store %c0, %21[%18] : memref<?xindex>
    %22 = arith.index_cast %19 : index to i64
    %23 = llvm.insertvalue %22, %16[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %24 = arith.index_cast %c32 : index to i64
    %25 = llvm.insertvalue %24, %23[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %dim = memref.dim %12, %c0 : memref<?xindex>
    %26 = arith.addi %10, %c1 : index
    %27 = arith.cmpi ugt, %26, %dim : index
    %28 = scf.if %27 -> (memref<?xindex>) {
      %53 = arith.muli %dim, %c2 : index
      %54 = memref.realloc %12(%53) : memref<?xindex> to memref<?xindex>
      scf.yield %54 : memref<?xindex>
    } else {
      scf.yield %12 : memref<?xindex>
    }
    memref.store %c0, %28[%10] : memref<?xindex>
    %29 = arith.index_cast %26 : index to i64
    %30 = llvm.insertvalue %29, %25[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %alloc_4 = memref.alloc(%c32) : memref<?xf32>
    %alloc_5 = memref.alloc(%c32) : memref<?xi1>
    %alloc_6 = memref.alloc(%c32) : memref<?xindex>
    linalg.fill ins(%cst : f32) outs(%alloc_4 : memref<?xf32>)
    linalg.fill ins(%false : i1) outs(%alloc_5 : memref<?xi1>)
    %31 = memref.load %arg0[%c0] : memref<?xindex>
    %32 = memref.load %arg0[%c1] : memref<?xindex>
    %33:6 = scf.for %arg12 = %31 to %32 step %c1 iter_args(%arg13 = %28, %arg14 = %alloc_0, %arg15 = %21, %arg16 = %alloc_2, %arg17 = %alloc_3, %arg18 = %30) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %53 = memref.load %arg1[%arg12] : memref<?xindex>
      %54 = memref.load %arg2[%arg12] : memref<?xindex>
      %55 = arith.addi %arg12, %c1 : index
      %56 = memref.load %arg2[%55] : memref<?xindex>
      %57:6 = scf.for %arg19 = %54 to %56 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %58 = memref.load %arg3[%arg19] : memref<?xindex>
        %59 = memref.load %arg4[%arg19] : memref<?xindex>
        %60 = arith.addi %arg19, %c1 : index
        %61 = memref.load %arg4[%60] : memref<?xindex>
        %62 = scf.for %arg26 = %59 to %61 step %c1 iter_args(%arg27 = %c0) -> (index) {
          %67 = memref.load %arg5[%arg26] : memref<?xindex>
          %68 = memref.load %arg6[%arg26] : memref<?xf32>
          %69 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
            %70 = arith.muli %67, %c32 : index
            %71 = arith.addi %70, %arg28 : index
            %72 = memref.load %alloc_4[%arg28] : memref<?xf32>
            %73 = memref.load %arg8[%71] : memref<?xf32>
            %74 = arith.mulf %68, %73 : f32
            %75 = arith.addf %72, %74 : f32
            %76 = memref.load %alloc_5[%arg28] : memref<?xi1>
            %77 = arith.cmpi eq, %76, %false : i1
            %78 = scf.if %77 -> (index) {
              memref.store %true, %alloc_5[%arg28] : memref<?xi1>
              memref.store %arg28, %alloc_6[%arg29] : memref<?xindex>
              %79 = arith.addi %arg29, %c1 : index
              scf.yield %79 : index
            } else {
              scf.yield %arg29 : index
            }
            memref.store %75, %alloc_4[%arg28] : memref<?xf32>
            scf.yield %78 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %69 : index
        } {"Emitted from" = "linalg.generic"}
        %63 = arith.index_cast %62 : index to i64
        %64 = math.ctlz %63 : i64
        %65 = arith.subi %c64_i64, %64 : i64
        func.call @_sparse_hybrid_qsort_1_index(%c0, %62, %alloc_6, %65) : (index, index, memref<?xindex>, i64) -> ()
        %66:6 = scf.for %arg26 = %c0 to %62 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
          %67 = memref.load %alloc_6[%arg26] : memref<?xindex>
          %68 = memref.load %alloc_4[%67] : memref<?xf32>
          %69:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %53, %58, %67, %68) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
          memref.store %cst, %alloc_4[%67] : memref<?xf32>
          memref.store %false, %alloc_5[%67] : memref<?xi1>
          scf.yield %69#0, %69#1, %69#2, %69#3, %69#4, %69#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
        }
        scf.yield %66#0, %66#1, %66#2, %66#3, %66#4, %66#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      } {"Emitted from" = "linalg.generic"}
      scf.yield %57#0, %57#1, %57#2, %57#3, %57#4, %57#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    memref.dealloc %alloc_4 : memref<?xf32>
    memref.dealloc %alloc_5 : memref<?xi1>
    memref.dealloc %alloc_6 : memref<?xindex>
    %34 = llvm.extractvalue %33#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = memref.load %33#2[%c0] : memref<?xindex>
    %37 = scf.for %arg12 = %c1 to %35 step %c1 iter_args(%arg13 = %36) -> (index) {
      %53 = memref.load %33#2[%arg12] : memref<?xindex>
      %54 = arith.cmpi eq, %53, %c0 : index
      %55 = scf.if %54 -> (index) {
        memref.store %arg13, %33#2[%arg12] : memref<?xindex>
        scf.yield %arg13 : index
      } else {
        scf.yield %53 : index
      }
      scf.yield %55 : index
    }
    %alloc_7 = memref.alloc(%c4096) : memref<?xf32>
    %38 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %c0_i64_8 = arith.constant 0 : i64
    %39 = llvm.insertvalue %c0_i64_8, %38[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %40 = arith.index_cast %c128 : index to i64
    %41 = llvm.insertvalue %40, %39[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %42 = arith.index_cast %c32 : index to i64
    %43 = llvm.insertvalue %42, %41[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %43[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %45 = arith.index_cast %44 : i64 to index
    %46 = arith.addi %45, %c4096 : index
    %47 = arith.cmpi ugt, %46, %c4096 : index
    %48 = scf.if %47 -> (memref<?xf32>) {
      %53 = scf.while (%arg12 = %c4096) : (index) -> index {
        %55 = arith.muli %arg12, %c2 : index
        %56 = arith.cmpi ugt, %46, %55 : index
        scf.condition(%56) %55 : index
      } do {
      ^bb0(%arg12: index):
        scf.yield %arg12 : index
      }
      %54 = memref.realloc %alloc_7(%53) : memref<?xf32> to memref<?xf32>
      scf.yield %54 : memref<?xf32>
    } else {
      scf.yield %alloc_7 : memref<?xf32>
    }
    %subview = memref.subview %48[%45] [%c4096] [%c1] : memref<?xf32> to memref<?xf32, strided<[?], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<?xf32, strided<[?], offset: ?>>)
    %49 = arith.index_cast %46 : index to i64
    %50 = llvm.insertvalue %49, %43[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %51 = memref.load %33#0[%c0] : memref<?xindex>
    %52 = memref.load %33#0[%c1] : memref<?xindex>
    scf.parallel (%arg12) = (%51) to (%52) step (%c1) {
      %53 = memref.load %33#1[%arg12] : memref<?xindex>
      %54 = memref.load %33#2[%arg12] : memref<?xindex>
      %55 = arith.addi %arg12, %c1 : index
      %56 = memref.load %33#2[%55] : memref<?xindex>
      scf.parallel (%arg13) = (%54) to (%56) step (%c1) {
        %57 = memref.load %33#3[%arg13] : memref<?xindex>
        scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
          %58 = arith.muli %arg13, %c32 : index
          %59 = arith.addi %58, %arg14 : index
          %60 = arith.muli %57, %c32 : index
          %61 = arith.addi %60, %arg14 : index
          %62 = arith.muli %53, %c32 : index
          %63 = arith.addi %62, %arg14 : index
          %64 = memref.load %48[%63] : memref<?xf32>
          %65 = memref.load %33#4[%59] : memref<?xf32>
          %66 = memref.load %arg10[%61] : memref<?xf32>
          %67 = arith.mulf %65, %66 : f32
          %68 = arith.addf %64, %67 : f32
          memref.store %68, %48[%63] : memref<?xf32>
          scf.yield
        } {"Emitted from" = "linalg.generic"}
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    return %48, %50 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%1) %arg3, %arg4 : index, index
  } do {
  ^bb0(%arg3: index, %arg4: index):
    %1 = arith.addi %arg3, %arg4 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    %4 = memref.load %arg2[%arg1] : memref<?xindex>
    %5 = memref.load %arg2[%2] : memref<?xindex>
    %6 = arith.cmpi ult, %4, %5 : index
    %7 = arith.select %6, %arg3, %3 : index
    %8 = arith.select %6, %2, %arg4 : index
    scf.yield %7, %8 : index, index
  }
  return %0#0 : index
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0 = arith.addi %arg0, %c1 : index
  scf.for %arg3 = %0 to %arg1 step %c1 {
    %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
    %2 = memref.load %arg2[%arg3] : memref<?xindex>
    %3 = arith.subi %arg3, %1 : index
    scf.for %arg4 = %c0 to %3 step %c1 {
      %4 = arith.subi %arg3, %arg4 : index
      %5 = arith.subi %4, %c1 : index
      %6 = memref.load %arg2[%5] : memref<?xindex>
      memref.store %6, %arg2[%4] : memref<?xindex>
    }
    memref.store %2, %arg2[%1] : memref<?xindex>
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %0 = arith.subi %arg1, %arg0 : index
  %1 = arith.subi %0, %c2 : index
  %2 = arith.shrui %1, %c1 : index
  %3 = arith.addi %2, %c1 : index
  scf.for %arg3 = %c0 to %3 step %c1 {
    %5 = arith.subi %2, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
  }
  %4 = arith.subi %0, %c1 : index
  scf.for %arg3 = %c0 to %4 step %c1 {
    %5 = arith.subi %0, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    %7 = arith.subi %6, %c1 : index
    %8 = memref.load %arg2[%arg0] : memref<?xindex>
    %9 = memref.load %arg2[%7] : memref<?xindex>
    memref.store %9, %arg2[%arg0] : memref<?xindex>
    memref.store %8, %arg2[%7] : memref<?xindex>
    %10 = arith.subi %5, %c1 : index
    func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.addi %arg4, %c1 : index
    %2 = arith.cmpi ult, %1, %arg5 : index
    scf.condition(%2) %arg4, %arg5 : index, index
  } do {
  ^bb0(%arg4: index, %arg5: index):
    %1 = arith.subi %arg5, %arg4 : index
    %2 = arith.cmpi ule, %1, %c30 : index
    %3:2 = scf.if %2 -> (index, index) {
      func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
      scf.yield %arg4, %arg4 : index, index
    } else {
      %4 = arith.subi %arg3, %c1_i64 : i64
      %5 = arith.cmpi ule, %4, %c0_i64 : i64
      %6:2 = scf.if %5 -> (index, index) {
        func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
        %8 = arith.addi %7, %c1 : index
        %9 = arith.subi %7, %arg4 : index
        %10 = arith.subi %arg5, %7 : index
        %11 = arith.cmpi ule, %9, %10 : index
        %12 = arith.select %11, %8, %arg4 : index
        %13 = arith.select %11, %arg5, %7 : index
        scf.if %11 {
          %14 = arith.cmpi ne, %9, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        } else {
          %14 = arith.cmpi ne, %10, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        }
        scf.yield %12, %13 : index, index
      }
      scf.yield %6#0, %6#1 : index, index
    }
    scf.yield %3#0, %3#1 : index, index
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %0 = arith.cmpi uge, %arg3, %c2 : index
  scf.if %0 {
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    scf.if %4 {
      %5 = arith.shli %1, %c1 : index
      %6 = arith.addi %5, %c1 : index
      %7 = arith.addi %6, %arg0 : index
      %8 = arith.addi %5, %c2 : index
      %9 = arith.cmpi ult, %8, %arg3 : index
      %10:2 = scf.if %9 -> (index, index) {
        %12 = arith.addi %8, %arg0 : index
        %13 = memref.load %arg2[%7] : memref<?xindex>
        %14 = memref.load %arg2[%12] : memref<?xindex>
        %15 = arith.cmpi ult, %13, %14 : index
        %16 = arith.select %15, %8, %6 : index
        %17 = arith.select %15, %12, %7 : index
        scf.yield %16, %17 : index, index
      } else {
        scf.yield %6, %7 : index, index
      }
      %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi ult, %12, %13 : index
        scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: index):
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        memref.store %13, %arg2[%arg4] : memref<?xindex>
        memref.store %12, %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi uge, %3, %arg5 : index
        %15:2 = scf.if %14 -> (index, index) {
          %16 = arith.shli %arg5, %c1 : index
          %17 = arith.addi %16, %c1 : index
          %18 = arith.addi %17, %arg0 : index
          %19 = arith.addi %16, %c2 : index
          %20 = arith.cmpi ult, %19, %arg3 : index
          %21:2 = scf.if %20 -> (index, index) {
            %22 = arith.addi %19, %arg0 : index
            %23 = memref.load %arg2[%18] : memref<?xindex>
            %24 = memref.load %arg2[%22] : memref<?xindex>
            %25 = arith.cmpi ult, %23, %24 : index
            %26 = arith.select %25, %19, %17 : index
            %27 = arith.select %25, %22, %18 : index
            scf.yield %26, %27 : index, index
          } else {
            scf.yield %17, %18 : index, index
          }
          scf.yield %21#0, %21#1 : index, index
        } else {
          scf.yield %arg5, %arg6 : index, index
        }
        scf.yield %arg6, %15#0, %15#1 : index, index, index
      }
    }
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %0 = memref.load %arg0[%c0] : memref<?xindex>
  %1 = memref.load %arg0[%c1] : memref<?xindex>
  %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = arith.index_cast %2 : i64 to index
  %4 = arith.subi %1, %c1 : index
  %5 = arith.cmpi ult, %0, %1 : index
  %6 = scf.if %5 -> (i1) {
    %21 = memref.load %arg1[%4] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg6 : index
    scf.yield %22 : i1
  } else {
    scf.yield %false : i1
  }
  %7 = arith.select %6, %4, %3 : index
  %8:3 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %3, %c1 : index
    memref.store %21, %arg0[%c1] : memref<?xindex>
    %22 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg1(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg1 : memref<?xindex>
    }
    memref.store %arg6, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %31 = arith.addi %30, %c1 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xindex>) {
      %36 = arith.muli %dim_0, %c2 : index
      %37 = memref.realloc %arg2(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg2 : memref<?xindex>
    }
    memref.store %c0, %33[%30] : memref<?xindex>
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %9 = arith.addi %7, %c1 : index
  %10 = memref.load %8#1[%7] : memref<?xindex>
  %11 = memref.load %8#1[%9] : memref<?xindex>
  %12 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %13 = arith.index_cast %12 : i64 to index
  %14 = arith.subi %11, %c1 : index
  %15 = arith.cmpi ult, %10, %11 : index
  %16 = scf.if %15 -> (i1) {
    %21 = memref.load %arg3[%14] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg7 : index
    scf.yield %22 : i1
  } else {
    memref.store %13, %8#1[%7] : memref<?xindex>
    scf.yield %false : i1
  }
  %17 = arith.select %16, %14, %13 : index
  %18:3 = scf.if %16 -> (memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg3, %arg4, %8#2 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %13, %c1 : index
    memref.store %21, %8#1[%9] : memref<?xindex>
    %22 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg3, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg3(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg3 : memref<?xindex>
    }
    memref.store %arg7, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %8#2[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg4, %c0 : memref<?xf32>
    %31 = arith.addi %30, %c32 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xf32>) {
      %36 = scf.while (%arg10 = %dim_0) : (index) -> index {
        %38 = arith.muli %arg10, %c2 : index
        %39 = arith.cmpi ugt, %31, %38 : index
        scf.condition(%39) %38 : index
      } do {
      ^bb0(%arg10: index):
        scf.yield %arg10 : index
      }
      %37 = memref.realloc %arg4(%36) : memref<?xf32> to memref<?xf32>
      scf.yield %37 : memref<?xf32>
    } else {
      scf.yield %arg4 : memref<?xf32>
    }
    %subview = memref.subview %33[%30] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<32xf32, strided<[1], offset: ?>>)
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %19 = arith.muli %17, %c32 : index
  %20 = arith.addi %19, %arg8 : index
  memref.store %arg9, %18#1[%20] : memref<?xf32>
  return %arg0, %8#0, %8#1, %18#0, %18#1, %18#2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%1) %arg3, %arg4 : index, index
  } do {
  ^bb0(%arg3: index, %arg4: index):
    %1 = arith.addi %arg3, %arg4 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    %4 = memref.load %arg2[%arg1] : memref<?xindex>
    %5 = memref.load %arg2[%2] : memref<?xindex>
    %6 = arith.cmpi ult, %4, %5 : index
    %7 = arith.select %6, %arg3, %3 : index
    %8 = arith.select %6, %2, %arg4 : index
    scf.yield %7, %8 : index, index
  }
  return %0#0 : index
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %0 = arith.addi %arg0, %arg1 : index
  %1 = arith.shrui %0, %c1 : index
  %2 = arith.subi %arg1, %c1 : index
  %3 = arith.subi %arg1, %arg0 : index
  %4 = arith.cmpi ult, %3, %c1000 : index
  scf.if %4 {
    %6 = memref.load %arg2[%1] : memref<?xindex>
    %7 = memref.load %arg2[%arg0] : memref<?xindex>
    %8 = arith.cmpi ult, %6, %7 : index
    scf.if %8 {
      %12 = memref.load %arg2[%1] : memref<?xindex>
      %13 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %13, %arg2[%1] : memref<?xindex>
      memref.store %12, %arg2[%arg0] : memref<?xindex>
    }
    %9 = memref.load %arg2[%2] : memref<?xindex>
    %10 = memref.load %arg2[%1] : memref<?xindex>
    %11 = arith.cmpi ult, %9, %10 : index
    scf.if %11 {
      %12 = memref.load %arg2[%2] : memref<?xindex>
      %13 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %13, %arg2[%2] : memref<?xindex>
      memref.store %12, %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%1] : memref<?xindex>
      %15 = memref.load %arg2[%arg0] : memref<?xindex>
      %16 = arith.cmpi ult, %14, %15 : index
      scf.if %16 {
        %17 = memref.load %arg2[%1] : memref<?xindex>
        %18 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %18, %arg2[%1] : memref<?xindex>
        memref.store %17, %arg2[%arg0] : memref<?xindex>
      }
    }
  } else {
    %6 = arith.addi %arg0, %arg1 : index
    %7 = arith.shrui %6, %c1 : index
    %8 = arith.addi %1, %arg1 : index
    %9 = arith.shrui %8, %c1 : index
    %10 = memref.load %arg2[%7] : memref<?xindex>
    %11 = memref.load %arg2[%arg0] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    scf.if %12 {
      %22 = memref.load %arg2[%7] : memref<?xindex>
      %23 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %23, %arg2[%7] : memref<?xindex>
      memref.store %22, %arg2[%arg0] : memref<?xindex>
    }
    %13 = memref.load %arg2[%1] : memref<?xindex>
    %14 = memref.load %arg2[%7] : memref<?xindex>
    %15 = arith.cmpi ult, %13, %14 : index
    scf.if %15 {
      %22 = memref.load %arg2[%1] : memref<?xindex>
      %23 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %23, %arg2[%1] : memref<?xindex>
      memref.store %22, %arg2[%7] : memref<?xindex>
      %24 = memref.load %arg2[%7] : memref<?xindex>
      %25 = memref.load %arg2[%arg0] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%7] : memref<?xindex>
        %28 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %28, %arg2[%7] : memref<?xindex>
        memref.store %27, %arg2[%arg0] : memref<?xindex>
      }
    }
    %16 = memref.load %arg2[%9] : memref<?xindex>
    %17 = memref.load %arg2[%1] : memref<?xindex>
    %18 = arith.cmpi ult, %16, %17 : index
    scf.if %18 {
      %22 = memref.load %arg2[%9] : memref<?xindex>
      %23 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %23, %arg2[%9] : memref<?xindex>
      memref.store %22, %arg2[%1] : memref<?xindex>
      %24 = memref.load %arg2[%1] : memref<?xindex>
      %25 = memref.load %arg2[%7] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%1] : memref<?xindex>
        %28 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %28, %arg2[%1] : memref<?xindex>
        memref.store %27, %arg2[%7] : memref<?xindex>
        %29 = memref.load %arg2[%7] : memref<?xindex>
        %30 = memref.load %arg2[%arg0] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%7] : memref<?xindex>
          %33 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %33, %arg2[%7] : memref<?xindex>
          memref.store %32, %arg2[%arg0] : memref<?xindex>
        }
      }
    }
    %19 = memref.load %arg2[%2] : memref<?xindex>
    %20 = memref.load %arg2[%9] : memref<?xindex>
    %21 = arith.cmpi ult, %19, %20 : index
    scf.if %21 {
      %22 = memref.load %arg2[%2] : memref<?xindex>
      %23 = memref.load %arg2[%9] : memref<?xindex>
      memref.store %23, %arg2[%2] : memref<?xindex>
      memref.store %22, %arg2[%9] : memref<?xindex>
      %24 = memref.load %arg2[%9] : memref<?xindex>
      %25 = memref.load %arg2[%1] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%9] : memref<?xindex>
        %28 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %28, %arg2[%9] : memref<?xindex>
        memref.store %27, %arg2[%1] : memref<?xindex>
        %29 = memref.load %arg2[%1] : memref<?xindex>
        %30 = memref.load %arg2[%7] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%1] : memref<?xindex>
          %33 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %33, %arg2[%1] : memref<?xindex>
          memref.store %32, %arg2[%7] : memref<?xindex>
          %34 = memref.load %arg2[%7] : memref<?xindex>
          %35 = memref.load %arg2[%arg0] : memref<?xindex>
          %36 = arith.cmpi ult, %34, %35 : index
          scf.if %36 {
            %37 = memref.load %arg2[%7] : memref<?xindex>
            %38 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %38, %arg2[%7] : memref<?xindex>
            memref.store %37, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
    }
  }
  %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
    %6 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
  } do {
  ^bb0(%arg3: index, %arg4: index, %arg5: index):
    %6 = scf.while (%arg6 = %arg3) : (index) -> index {
      %16 = memref.load %arg2[%arg6] : memref<?xindex>
      %17 = memref.load %arg2[%arg5] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c1 : index
      scf.yield %16 : index
    }
    %7 = memref.load %arg2[%6] : memref<?xindex>
    %8 = memref.load %arg2[%arg5] : memref<?xindex>
    %9 = arith.cmpi eq, %7, %8 : index
    %10 = scf.while (%arg6 = %arg4) : (index) -> index {
      %16 = memref.load %arg2[%arg5] : memref<?xindex>
      %17 = memref.load %arg2[%arg6] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c-1 : index
      scf.yield %16 : index
    }
    %11 = memref.load %arg2[%10] : memref<?xindex>
    %12 = memref.load %arg2[%arg5] : memref<?xindex>
    %13 = arith.cmpi eq, %11, %12 : index
    %14 = arith.cmpi ult, %6, %10 : index
    %15:3 = scf.if %14 -> (index, index, index) {
      %16 = memref.load %arg2[%6] : memref<?xindex>
      %17 = memref.load %arg2[%10] : memref<?xindex>
      memref.store %17, %arg2[%6] : memref<?xindex>
      memref.store %16, %arg2[%10] : memref<?xindex>
      %18 = arith.cmpi eq, %6, %arg5 : index
      %19 = scf.if %18 -> (index) {
        scf.yield %10 : index
      } else {
        %22 = arith.cmpi eq, %10, %arg5 : index
        %23 = arith.select %22, %6, %arg5 : index
        scf.yield %23 : index
      }
      %20 = arith.andi %9, %13 : i1
      %21:2 = scf.if %20 -> (index, index) {
        %22 = arith.addi %6, %c1 : index
        %23 = arith.subi %10, %c1 : index
        scf.yield %22, %23 : index, index
      } else {
        scf.yield %6, %10 : index, index
      }
      scf.yield %21#0, %21#1, %19 : index, index, index
    } else {
      scf.yield %6, %10, %arg5 : index, index, index
    }
    scf.yield %15#0, %15#1, %15#2 : index, index, index
  }
  return %5#2 : index
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c1 = arith.constant 1 : index
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %true = arith.constant true
  %alloc = memref.alloc() : memref<16xindex>
  %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
  %alloc_0 = memref.alloc() : memref<16xindex>
  %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
  %alloc_2 = memref.alloc() : memref<16xindex>
  %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
  %alloc_4 = memref.alloc() : memref<16xindex>
  %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
  %alloc_6 = memref.alloc() : memref<16xf32>
  %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c0] : memref<16xindex>
  %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc_2[%c0] : memref<16xindex>
  %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c1] : memref<16xindex>
  %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %alloc_8 = memref.alloc() : memref<32xf32>
  %alloc_9 = memref.alloc() : memref<32xi1>
  %alloc_10 = memref.alloc() : memref<32xindex>
  %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
  linalg.fill ins(%cst : f32) outs(%alloc_8 : memref<32xf32>)
  linalg.fill ins(%false : i1) outs(%alloc_9 : memref<32xi1>)
  %12 = memref.load %arg0[%c0] : memref<?xindex>
  %13 = memref.load %arg0[%c1] : memref<?xindex>
  %14:6 = scf.for %arg12 = %12 to %13 step %c1 iter_args(%arg13 = %cast, %arg14 = %cast_1, %arg15 = %cast_3, %arg16 = %cast_5, %arg17 = %cast_7, %arg18 = %11) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %26 = memref.load %arg1[%arg12] : memref<?xindex>
    %27 = memref.load %arg2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %arg2[%28] : memref<?xindex>
    %30:6 = scf.for %arg19 = %27 to %29 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %31 = memref.load %arg3[%arg19] : memref<?xindex>
      %32 = memref.load %arg4[%arg19] : memref<?xindex>
      %33 = arith.addi %arg19, %c1 : index
      %34 = memref.load %arg4[%33] : memref<?xindex>
      %35 = scf.for %arg26 = %32 to %34 step %c1 iter_args(%arg27 = %c0) -> (index) {
        %40 = memref.load %arg5[%arg26] : memref<?xindex>
        %41 = memref.load %arg6[%arg26] : memref<?xf32>
        %42 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
          %43 = arith.muli %40, %c32 : index
          %44 = arith.addi %43, %arg28 : index
          %45 = memref.load %alloc_8[%arg28] : memref<32xf32>
          %46 = memref.load %arg8[%44] : memref<?xf32>
          %47 = arith.mulf %41, %46 : f32
          %48 = arith.addf %45, %47 : f32
          %49 = memref.load %alloc_9[%arg28] : memref<32xi1>
          %50 = arith.cmpi eq, %49, %false : i1
          %51 = scf.if %50 -> (index) {
            memref.store %true, %alloc_9[%arg28] : memref<32xi1>
            memref.store %arg28, %alloc_10[%arg29] : memref<32xindex>
            %52 = arith.addi %arg29, %c1 : index
            scf.yield %52 : index
          } else {
            scf.yield %arg29 : index
          }
          memref.store %48, %alloc_8[%arg28] : memref<32xf32>
          scf.yield %51 : index
        } {"Emitted from" = "linalg.generic"}
        scf.yield %42 : index
      } {"Emitted from" = "linalg.generic"}
      %36 = arith.index_cast %35 : index to i64
      %37 = math.ctlz %36 : i64
      %38 = arith.subi %c64_i64, %37 : i64
      func.call @_sparse_hybrid_qsort_1_index(%c0, %35, %cast_11, %38) : (index, index, memref<?xindex>, i64) -> ()
      %39:6 = scf.for %arg26 = %c0 to %35 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %40 = memref.load %alloc_10[%arg26] : memref<32xindex>
        %41 = memref.load %alloc_8[%40] : memref<32xf32>
        %42:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %26, %31, %40, %41) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
        memref.store %cst, %alloc_8[%40] : memref<32xf32>
        memref.store %false, %alloc_9[%40] : memref<32xi1>
        scf.yield %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      }
      scf.yield %39#0, %39#1, %39#2, %39#3, %39#4, %39#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    scf.yield %30#0, %30#1, %30#2, %30#3, %30#4, %30#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } {"Emitted from" = "linalg.generic"}
  memref.dealloc %alloc_8 : memref<32xf32>
  memref.dealloc %alloc_9 : memref<32xi1>
  memref.dealloc %alloc_10 : memref<32xindex>
  %15 = llvm.extractvalue %14#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %16 = arith.index_cast %15 : i64 to index
  %17 = memref.load %14#2[%c0] : memref<?xindex>
  %18 = scf.for %arg12 = %c1 to %16 step %c1 iter_args(%arg13 = %17) -> (index) {
    %26 = memref.load %14#2[%arg12] : memref<?xindex>
    %27 = arith.cmpi eq, %26, %c0 : index
    %28 = arith.select %27, %arg13, %26 : index
    scf.if %27 {
      memref.store %arg13, %14#2[%arg12] : memref<?xindex>
    }
    scf.yield %28 : index
  }
  %alloc_12 = memref.alloc() : memref<4096xf32>
  %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
  %19 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %20 = llvm.insertvalue %c0_i64, %19[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %21 = llvm.insertvalue %c128_i64, %20[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c32_i64, %21[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  linalg.fill ins(%cst : f32) outs(%alloc_12 : memref<4096xf32>)
  %23 = llvm.insertvalue %c4096_i64, %22[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %24 = memref.load %14#0[%c0] : memref<?xindex>
  %25 = memref.load %14#0[%c1] : memref<?xindex>
  scf.parallel (%arg12) = (%24) to (%25) step (%c1) {
    %26 = memref.load %14#1[%arg12] : memref<?xindex>
    %27 = memref.load %14#2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %14#2[%28] : memref<?xindex>
    scf.parallel (%arg13) = (%27) to (%29) step (%c1) {
      %30 = memref.load %14#3[%arg13] : memref<?xindex>
      scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
        %31 = arith.muli %arg13, %c32 : index
        %32 = arith.addi %31, %arg14 : index
        %33 = arith.muli %30, %c32 : index
        %34 = arith.addi %33, %arg14 : index
        %35 = arith.muli %26, %c32 : index
        %36 = arith.addi %35, %arg14 : index
        %37 = memref.load %alloc_12[%36] : memref<4096xf32>
        %38 = memref.load %14#4[%32] : memref<?xf32>
        %39 = memref.load %arg10[%34] : memref<?xf32>
        %40 = arith.mulf %38, %39 : f32
        %41 = arith.addf %37, %40 : f32
        memref.store %41, %alloc_12[%36] : memref<4096xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast_13, %23 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0 = arith.addi %arg0, %c1 : index
  scf.for %arg3 = %0 to %arg1 step %c1 {
    %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
    %2 = memref.load %arg2[%arg3] : memref<?xindex>
    %3 = arith.subi %arg3, %1 : index
    scf.for %arg4 = %c0 to %3 step %c1 {
      %4 = arith.subi %arg3, %arg4 : index
      %5 = arith.subi %4, %c1 : index
      %6 = memref.load %arg2[%5] : memref<?xindex>
      memref.store %6, %arg2[%4] : memref<?xindex>
    }
    memref.store %2, %arg2[%1] : memref<?xindex>
  }
  return
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %0 = arith.subi %arg1, %arg0 : index
  %1 = arith.subi %0, %c2 : index
  %2 = arith.shrui %1, %c1 : index
  %3 = arith.addi %2, %c1 : index
  scf.for %arg3 = %c0 to %3 step %c1 {
    %5 = arith.subi %2, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
  }
  %4 = arith.subi %0, %c1 : index
  scf.for %arg3 = %c0 to %4 step %c1 {
    %5 = arith.subi %0, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    %7 = arith.subi %6, %c1 : index
    %8 = memref.load %arg2[%arg0] : memref<?xindex>
    %9 = memref.load %arg2[%7] : memref<?xindex>
    memref.store %9, %arg2[%arg0] : memref<?xindex>
    memref.store %8, %arg2[%7] : memref<?xindex>
    %10 = arith.subi %5, %c1 : index
    func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
  }
  return
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.addi %arg4, %c1 : index
    %2 = arith.cmpi ult, %1, %arg5 : index
    scf.condition(%2) %arg4, %arg5 : index, index
  } do {
  ^bb0(%arg4: index, %arg5: index):
    %1 = arith.subi %arg5, %arg4 : index
    %2 = arith.cmpi ule, %1, %c30 : index
    %3:2 = scf.if %2 -> (index, index) {
      func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
      scf.yield %arg4, %arg4 : index, index
    } else {
      %4 = arith.subi %arg3, %c1_i64 : i64
      %5 = arith.cmpi ule, %4, %c0_i64 : i64
      %6:2 = scf.if %5 -> (index, index) {
        func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
        %8 = arith.addi %7, %c1 : index
        %9 = arith.subi %7, %arg4 : index
        %10 = arith.subi %arg5, %7 : index
        %11 = arith.cmpi ule, %9, %10 : index
        %12 = arith.select %11, %8, %arg4 : index
        %13 = arith.select %11, %arg5, %7 : index
        scf.if %11 {
          %14 = arith.cmpi ne, %9, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        } else {
          %14 = arith.cmpi ne, %10, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        }
        scf.yield %12, %13 : index, index
      }
      scf.yield %6#0, %6#1 : index, index
    }
    scf.yield %3#0, %3#1 : index, index
  }
  return
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %0 = arith.cmpi uge, %arg3, %c2 : index
  scf.if %0 {
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    scf.if %4 {
      %5 = arith.shli %1, %c1 : index
      %6 = arith.addi %5, %c1 : index
      %7 = arith.addi %6, %arg0 : index
      %8 = arith.addi %5, %c2 : index
      %9 = arith.cmpi ult, %8, %arg3 : index
      %10:2 = scf.if %9 -> (index, index) {
        %12 = arith.addi %8, %arg0 : index
        %13 = memref.load %arg2[%7] : memref<?xindex>
        %14 = memref.load %arg2[%12] : memref<?xindex>
        %15 = arith.cmpi ult, %13, %14 : index
        %16 = arith.select %15, %8, %6 : index
        %17 = arith.select %15, %12, %7 : index
        scf.yield %16, %17 : index, index
      } else {
        scf.yield %6, %7 : index, index
      }
      %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi ult, %12, %13 : index
        scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: index):
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        memref.store %13, %arg2[%arg4] : memref<?xindex>
        memref.store %12, %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi uge, %3, %arg5 : index
        %15:2 = scf.if %14 -> (index, index) {
          %16 = arith.shli %arg5, %c1 : index
          %17 = arith.addi %16, %c1 : index
          %18 = arith.addi %17, %arg0 : index
          %19 = arith.addi %16, %c2 : index
          %20 = arith.cmpi ult, %19, %arg3 : index
          %21:2 = scf.if %20 -> (index, index) {
            %22 = arith.addi %19, %arg0 : index
            %23 = memref.load %arg2[%18] : memref<?xindex>
            %24 = memref.load %arg2[%22] : memref<?xindex>
            %25 = arith.cmpi ult, %23, %24 : index
            %26 = arith.select %25, %19, %17 : index
            %27 = arith.select %25, %22, %18 : index
            scf.yield %26, %27 : index, index
          } else {
            scf.yield %17, %18 : index, index
          }
          scf.yield %21#0, %21#1 : index, index
        } else {
          scf.yield %arg5, %arg6 : index, index
        }
        scf.yield %arg6, %15#0, %15#1 : index, index, index
      }
    }
  }
  return
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %0 = memref.load %arg0[%c0] : memref<?xindex>
  %1 = memref.load %arg0[%c1] : memref<?xindex>
  %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = arith.index_cast %2 : i64 to index
  %4 = arith.subi %1, %c1 : index
  %5 = arith.cmpi ult, %0, %1 : index
  %6 = scf.if %5 -> (i1) {
    %21 = memref.load %arg1[%4] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg6 : index
    scf.yield %22 : i1
  } else {
    scf.yield %false : i1
  }
  %7 = arith.select %6, %4, %3 : index
  %8:3 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %3, %c1 : index
    memref.store %21, %arg0[%c1] : memref<?xindex>
    %22 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg1(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg1 : memref<?xindex>
    }
    memref.store %arg6, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %31 = arith.addi %30, %c1 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xindex>) {
      %36 = arith.muli %dim_0, %c2 : index
      %37 = memref.realloc %arg2(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg2 : memref<?xindex>
    }
    memref.store %c0, %33[%30] : memref<?xindex>
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %9 = arith.addi %7, %c1 : index
  %10 = memref.load %8#1[%7] : memref<?xindex>
  %11 = memref.load %8#1[%9] : memref<?xindex>
  %12 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %13 = arith.index_cast %12 : i64 to index
  %14 = arith.subi %11, %c1 : index
  %15 = arith.cmpi ult, %10, %11 : index
  %16 = scf.if %15 -> (i1) {
    %21 = memref.load %arg3[%14] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg7 : index
    scf.yield %22 : i1
  } else {
    memref.store %13, %8#1[%7] : memref<?xindex>
    scf.yield %false : i1
  }
  %17 = arith.select %16, %14, %13 : index
  %18:3 = scf.if %16 -> (memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg3, %arg4, %8#2 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %13, %c1 : index
    memref.store %21, %8#1[%9] : memref<?xindex>
    %22 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg3, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg3(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg3 : memref<?xindex>
    }
    memref.store %arg7, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %8#2[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg4, %c0 : memref<?xf32>
    %31 = arith.addi %30, %c32 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xf32>) {
      %36 = scf.while (%arg10 = %dim_0) : (index) -> index {
        %38 = arith.muli %arg10, %c2 : index
        %39 = arith.cmpi ugt, %31, %38 : index
        scf.condition(%39) %38 : index
      } do {
      ^bb0(%arg10: index):
        scf.yield %arg10 : index
      }
      %37 = memref.realloc %arg4(%36) : memref<?xf32> to memref<?xf32>
      scf.yield %37 : memref<?xf32>
    } else {
      scf.yield %arg4 : memref<?xf32>
    }
    %subview = memref.subview %33[%30] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
    linalg.fill ins(%cst : f32) outs(%subview : memref<32xf32, strided<[1], offset: ?>>)
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %19 = arith.muli %17, %c32 : index
  %20 = arith.addi %19, %arg8 : index
  memref.store %arg9, %18#1[%20] : memref<?xf32>
  return %arg0, %8#0, %8#1, %18#0, %18#1, %18#2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%1) %arg3, %arg4 : index, index
  } do {
  ^bb0(%arg3: index, %arg4: index):
    %1 = arith.addi %arg3, %arg4 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    %4 = memref.load %arg2[%arg1] : memref<?xindex>
    %5 = memref.load %arg2[%2] : memref<?xindex>
    %6 = arith.cmpi ult, %4, %5 : index
    %7 = arith.select %6, %arg3, %3 : index
    %8 = arith.select %6, %2, %arg4 : index
    scf.yield %7, %8 : index, index
  }
  return %0#0 : index
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %0 = arith.addi %arg0, %arg1 : index
  %1 = arith.shrui %0, %c1 : index
  %2 = arith.subi %arg1, %c1 : index
  %3 = arith.subi %arg1, %arg0 : index
  %4 = arith.cmpi ult, %3, %c1000 : index
  scf.if %4 {
    %6 = memref.load %arg2[%1] : memref<?xindex>
    %7 = memref.load %arg2[%arg0] : memref<?xindex>
    %8 = arith.cmpi ult, %6, %7 : index
    scf.if %8 {
      %12 = memref.load %arg2[%1] : memref<?xindex>
      %13 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %13, %arg2[%1] : memref<?xindex>
      memref.store %12, %arg2[%arg0] : memref<?xindex>
    }
    %9 = memref.load %arg2[%2] : memref<?xindex>
    %10 = memref.load %arg2[%1] : memref<?xindex>
    %11 = arith.cmpi ult, %9, %10 : index
    scf.if %11 {
      %12 = memref.load %arg2[%2] : memref<?xindex>
      %13 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %13, %arg2[%2] : memref<?xindex>
      memref.store %12, %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%1] : memref<?xindex>
      %15 = memref.load %arg2[%arg0] : memref<?xindex>
      %16 = arith.cmpi ult, %14, %15 : index
      scf.if %16 {
        %17 = memref.load %arg2[%1] : memref<?xindex>
        %18 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %18, %arg2[%1] : memref<?xindex>
        memref.store %17, %arg2[%arg0] : memref<?xindex>
      }
    }
  } else {
    %6 = arith.addi %arg0, %arg1 : index
    %7 = arith.shrui %6, %c1 : index
    %8 = arith.addi %1, %arg1 : index
    %9 = arith.shrui %8, %c1 : index
    %10 = memref.load %arg2[%7] : memref<?xindex>
    %11 = memref.load %arg2[%arg0] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    scf.if %12 {
      %22 = memref.load %arg2[%7] : memref<?xindex>
      %23 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %23, %arg2[%7] : memref<?xindex>
      memref.store %22, %arg2[%arg0] : memref<?xindex>
    }
    %13 = memref.load %arg2[%1] : memref<?xindex>
    %14 = memref.load %arg2[%7] : memref<?xindex>
    %15 = arith.cmpi ult, %13, %14 : index
    scf.if %15 {
      %22 = memref.load %arg2[%1] : memref<?xindex>
      %23 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %23, %arg2[%1] : memref<?xindex>
      memref.store %22, %arg2[%7] : memref<?xindex>
      %24 = memref.load %arg2[%7] : memref<?xindex>
      %25 = memref.load %arg2[%arg0] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%7] : memref<?xindex>
        %28 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %28, %arg2[%7] : memref<?xindex>
        memref.store %27, %arg2[%arg0] : memref<?xindex>
      }
    }
    %16 = memref.load %arg2[%9] : memref<?xindex>
    %17 = memref.load %arg2[%1] : memref<?xindex>
    %18 = arith.cmpi ult, %16, %17 : index
    scf.if %18 {
      %22 = memref.load %arg2[%9] : memref<?xindex>
      %23 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %23, %arg2[%9] : memref<?xindex>
      memref.store %22, %arg2[%1] : memref<?xindex>
      %24 = memref.load %arg2[%1] : memref<?xindex>
      %25 = memref.load %arg2[%7] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%1] : memref<?xindex>
        %28 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %28, %arg2[%1] : memref<?xindex>
        memref.store %27, %arg2[%7] : memref<?xindex>
        %29 = memref.load %arg2[%7] : memref<?xindex>
        %30 = memref.load %arg2[%arg0] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%7] : memref<?xindex>
          %33 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %33, %arg2[%7] : memref<?xindex>
          memref.store %32, %arg2[%arg0] : memref<?xindex>
        }
      }
    }
    %19 = memref.load %arg2[%2] : memref<?xindex>
    %20 = memref.load %arg2[%9] : memref<?xindex>
    %21 = arith.cmpi ult, %19, %20 : index
    scf.if %21 {
      %22 = memref.load %arg2[%2] : memref<?xindex>
      %23 = memref.load %arg2[%9] : memref<?xindex>
      memref.store %23, %arg2[%2] : memref<?xindex>
      memref.store %22, %arg2[%9] : memref<?xindex>
      %24 = memref.load %arg2[%9] : memref<?xindex>
      %25 = memref.load %arg2[%1] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%9] : memref<?xindex>
        %28 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %28, %arg2[%9] : memref<?xindex>
        memref.store %27, %arg2[%1] : memref<?xindex>
        %29 = memref.load %arg2[%1] : memref<?xindex>
        %30 = memref.load %arg2[%7] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%1] : memref<?xindex>
          %33 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %33, %arg2[%1] : memref<?xindex>
          memref.store %32, %arg2[%7] : memref<?xindex>
          %34 = memref.load %arg2[%7] : memref<?xindex>
          %35 = memref.load %arg2[%arg0] : memref<?xindex>
          %36 = arith.cmpi ult, %34, %35 : index
          scf.if %36 {
            %37 = memref.load %arg2[%7] : memref<?xindex>
            %38 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %38, %arg2[%7] : memref<?xindex>
            memref.store %37, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
    }
  }
  %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
    %6 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
  } do {
  ^bb0(%arg3: index, %arg4: index, %arg5: index):
    %6 = scf.while (%arg6 = %arg3) : (index) -> index {
      %16 = memref.load %arg2[%arg6] : memref<?xindex>
      %17 = memref.load %arg2[%arg5] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c1 : index
      scf.yield %16 : index
    }
    %7 = memref.load %arg2[%6] : memref<?xindex>
    %8 = memref.load %arg2[%arg5] : memref<?xindex>
    %9 = arith.cmpi eq, %7, %8 : index
    %10 = scf.while (%arg6 = %arg4) : (index) -> index {
      %16 = memref.load %arg2[%arg5] : memref<?xindex>
      %17 = memref.load %arg2[%arg6] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c-1 : index
      scf.yield %16 : index
    }
    %11 = memref.load %arg2[%10] : memref<?xindex>
    %12 = memref.load %arg2[%arg5] : memref<?xindex>
    %13 = arith.cmpi eq, %11, %12 : index
    %14 = arith.cmpi ult, %6, %10 : index
    %15:3 = scf.if %14 -> (index, index, index) {
      %16 = memref.load %arg2[%6] : memref<?xindex>
      %17 = memref.load %arg2[%10] : memref<?xindex>
      memref.store %17, %arg2[%6] : memref<?xindex>
      memref.store %16, %arg2[%10] : memref<?xindex>
      %18 = arith.cmpi eq, %6, %arg5 : index
      %19 = scf.if %18 -> (index) {
        scf.yield %10 : index
      } else {
        %22 = arith.cmpi eq, %10, %arg5 : index
        %23 = arith.select %22, %6, %arg5 : index
        scf.yield %23 : index
      }
      %20 = arith.andi %9, %13 : i1
      %21:2 = scf.if %20 -> (index, index) {
        %22 = arith.addi %6, %c1 : index
        %23 = arith.subi %10, %c1 : index
        scf.yield %22, %23 : index, index
      } else {
        scf.yield %6, %10 : index, index
      }
      scf.yield %21#0, %21#1, %19 : index, index, index
    } else {
      scf.yield %6, %10, %arg5 : index, index, index
    }
    scf.yield %15#0, %15#1, %15#2 : index, index, index
  }
  return %5#2 : index
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c1 = arith.constant 1 : index
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %true = arith.constant true
  %alloc = memref.alloc() : memref<16xindex>
  %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
  %alloc_0 = memref.alloc() : memref<16xindex>
  %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
  %alloc_2 = memref.alloc() : memref<16xindex>
  %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
  %alloc_4 = memref.alloc() : memref<16xindex>
  %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
  %alloc_6 = memref.alloc() : memref<16xf32>
  %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c0] : memref<16xindex>
  %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc_2[%c0] : memref<16xindex>
  %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c1] : memref<16xindex>
  %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %alloc_8 = memref.alloc() : memref<32xf32>
  %alloc_9 = memref.alloc() : memref<32xi1>
  %alloc_10 = memref.alloc() : memref<32xindex>
  %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
  linalg.fill ins(%cst : f32) outs(%alloc_8 : memref<32xf32>)
  linalg.fill ins(%false : i1) outs(%alloc_9 : memref<32xi1>)
  %12 = memref.load %arg0[%c0] : memref<?xindex>
  %13 = memref.load %arg0[%c1] : memref<?xindex>
  %14:6 = scf.for %arg12 = %12 to %13 step %c1 iter_args(%arg13 = %cast, %arg14 = %cast_1, %arg15 = %cast_3, %arg16 = %cast_5, %arg17 = %cast_7, %arg18 = %11) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %26 = memref.load %arg1[%arg12] : memref<?xindex>
    %27 = memref.load %arg2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %arg2[%28] : memref<?xindex>
    %30:6 = scf.for %arg19 = %27 to %29 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %31 = memref.load %arg3[%arg19] : memref<?xindex>
      %32 = memref.load %arg4[%arg19] : memref<?xindex>
      %33 = arith.addi %arg19, %c1 : index
      %34 = memref.load %arg4[%33] : memref<?xindex>
      %35 = scf.for %arg26 = %32 to %34 step %c1 iter_args(%arg27 = %c0) -> (index) {
        %40 = memref.load %arg5[%arg26] : memref<?xindex>
        %41 = memref.load %arg6[%arg26] : memref<?xf32>
        %42 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
          %43 = arith.muli %40, %c32 : index
          %44 = arith.addi %43, %arg28 : index
          %45 = memref.load %alloc_8[%arg28] : memref<32xf32>
          %46 = memref.load %arg8[%44] : memref<?xf32>
          %47 = arith.mulf %41, %46 : f32
          %48 = arith.addf %45, %47 : f32
          %49 = memref.load %alloc_9[%arg28] : memref<32xi1>
          %50 = arith.cmpi eq, %49, %false : i1
          %51 = scf.if %50 -> (index) {
            memref.store %true, %alloc_9[%arg28] : memref<32xi1>
            memref.store %arg28, %alloc_10[%arg29] : memref<32xindex>
            %52 = arith.addi %arg29, %c1 : index
            scf.yield %52 : index
          } else {
            scf.yield %arg29 : index
          }
          memref.store %48, %alloc_8[%arg28] : memref<32xf32>
          scf.yield %51 : index
        } {"Emitted from" = "linalg.generic"}
        scf.yield %42 : index
      } {"Emitted from" = "linalg.generic"}
      %36 = arith.index_cast %35 : index to i64
      %37 = math.ctlz %36 : i64
      %38 = arith.subi %c64_i64, %37 : i64
      func.call @_sparse_hybrid_qsort_1_index(%c0, %35, %cast_11, %38) : (index, index, memref<?xindex>, i64) -> ()
      %39:6 = scf.for %arg26 = %c0 to %35 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %40 = memref.load %alloc_10[%arg26] : memref<32xindex>
        %41 = memref.load %alloc_8[%40] : memref<32xf32>
        %42:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %26, %31, %40, %41) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
        memref.store %cst, %alloc_8[%40] : memref<32xf32>
        memref.store %false, %alloc_9[%40] : memref<32xi1>
        scf.yield %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      }
      scf.yield %39#0, %39#1, %39#2, %39#3, %39#4, %39#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    scf.yield %30#0, %30#1, %30#2, %30#3, %30#4, %30#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } {"Emitted from" = "linalg.generic"}
  memref.dealloc %alloc_8 : memref<32xf32>
  memref.dealloc %alloc_9 : memref<32xi1>
  memref.dealloc %alloc_10 : memref<32xindex>
  %15 = llvm.extractvalue %14#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %16 = arith.index_cast %15 : i64 to index
  %17 = memref.load %14#2[%c0] : memref<?xindex>
  %18 = scf.for %arg12 = %c1 to %16 step %c1 iter_args(%arg13 = %17) -> (index) {
    %26 = memref.load %14#2[%arg12] : memref<?xindex>
    %27 = arith.cmpi eq, %26, %c0 : index
    %28 = arith.select %27, %arg13, %26 : index
    scf.if %27 {
      memref.store %arg13, %14#2[%arg12] : memref<?xindex>
    }
    scf.yield %28 : index
  }
  %alloc_12 = memref.alloc() : memref<4096xf32>
  %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
  %19 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %20 = llvm.insertvalue %c0_i64, %19[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %21 = llvm.insertvalue %c128_i64, %20[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c32_i64, %21[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  linalg.fill ins(%cst : f32) outs(%alloc_12 : memref<4096xf32>)
  %23 = llvm.insertvalue %c4096_i64, %22[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %24 = memref.load %14#0[%c0] : memref<?xindex>
  %25 = memref.load %14#0[%c1] : memref<?xindex>
  scf.parallel (%arg12) = (%24) to (%25) step (%c1) {
    %26 = memref.load %14#1[%arg12] : memref<?xindex>
    %27 = memref.load %14#2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %14#2[%28] : memref<?xindex>
    scf.parallel (%arg13) = (%27) to (%29) step (%c1) {
      %30 = memref.load %14#3[%arg13] : memref<?xindex>
      scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
        %31 = arith.muli %arg13, %c32 : index
        %32 = arith.addi %31, %arg14 : index
        %33 = arith.muli %30, %c32 : index
        %34 = arith.addi %33, %arg14 : index
        %35 = arith.muli %26, %c32 : index
        %36 = arith.addi %35, %arg14 : index
        %37 = memref.load %alloc_12[%36] : memref<4096xf32>
        %38 = memref.load %14#4[%32] : memref<?xf32>
        %39 = memref.load %arg10[%34] : memref<?xf32>
        %40 = arith.mulf %38, %39 : f32
        %41 = arith.addf %37, %40 : f32
        memref.store %41, %alloc_12[%36] : memref<4096xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast_13, %23 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0 = arith.addi %arg0, %c1 : index
  scf.for %arg3 = %0 to %arg1 step %c1 {
    %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
    %2 = memref.load %arg2[%arg3] : memref<?xindex>
    %3 = arith.subi %arg3, %1 : index
    scf.for %arg4 = %c0 to %3 step %c1 {
      %4 = arith.subi %arg3, %arg4 : index
      %5 = arith.subi %4, %c1 : index
      %6 = memref.load %arg2[%5] : memref<?xindex>
      memref.store %6, %arg2[%4] : memref<?xindex>
    }
    memref.store %2, %arg2[%1] : memref<?xindex>
  }
  return
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %0 = arith.subi %arg1, %arg0 : index
  %1 = arith.subi %0, %c2 : index
  %2 = arith.shrui %1, %c1 : index
  %3 = arith.addi %2, %c1 : index
  scf.for %arg3 = %c0 to %3 step %c1 {
    %5 = arith.subi %2, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
  }
  %4 = arith.subi %0, %c1 : index
  scf.for %arg3 = %c0 to %4 step %c1 {
    %5 = arith.subi %0, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    %7 = arith.subi %6, %c1 : index
    %8 = memref.load %arg2[%arg0] : memref<?xindex>
    %9 = memref.load %arg2[%7] : memref<?xindex>
    memref.store %9, %arg2[%arg0] : memref<?xindex>
    memref.store %8, %arg2[%7] : memref<?xindex>
    %10 = arith.subi %5, %c1 : index
    func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
  }
  return
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.addi %arg4, %c1 : index
    %2 = arith.cmpi ult, %1, %arg5 : index
    scf.condition(%2) %arg4, %arg5 : index, index
  } do {
  ^bb0(%arg4: index, %arg5: index):
    %1 = arith.subi %arg5, %arg4 : index
    %2 = arith.cmpi ule, %1, %c30 : index
    %3:2 = scf.if %2 -> (index, index) {
      func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
      scf.yield %arg4, %arg4 : index, index
    } else {
      %4 = arith.subi %arg3, %c1_i64 : i64
      %5 = arith.cmpi ule, %4, %c0_i64 : i64
      %6:2 = scf.if %5 -> (index, index) {
        func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
        %8 = arith.addi %7, %c1 : index
        %9 = arith.subi %7, %arg4 : index
        %10 = arith.subi %arg5, %7 : index
        %11 = arith.cmpi ule, %9, %10 : index
        %12 = arith.select %11, %8, %arg4 : index
        %13 = arith.select %11, %arg5, %7 : index
        scf.if %11 {
          %14 = arith.cmpi ne, %9, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        } else {
          %14 = arith.cmpi ne, %10, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        }
        scf.yield %12, %13 : index, index
      }
      scf.yield %6#0, %6#1 : index, index
    }
    scf.yield %3#0, %3#1 : index, index
  }
  return
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %0 = arith.cmpi uge, %arg3, %c2 : index
  scf.if %0 {
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    scf.if %4 {
      %5 = arith.shli %1, %c1 : index
      %6 = arith.addi %5, %c1 : index
      %7 = arith.addi %6, %arg0 : index
      %8 = arith.addi %5, %c2 : index
      %9 = arith.cmpi ult, %8, %arg3 : index
      %10:2 = scf.if %9 -> (index, index) {
        %12 = arith.addi %8, %arg0 : index
        %13 = memref.load %arg2[%7] : memref<?xindex>
        %14 = memref.load %arg2[%12] : memref<?xindex>
        %15 = arith.cmpi ult, %13, %14 : index
        %16 = arith.select %15, %8, %6 : index
        %17 = arith.select %15, %12, %7 : index
        scf.yield %16, %17 : index, index
      } else {
        scf.yield %6, %7 : index, index
      }
      %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi ult, %12, %13 : index
        scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: index):
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        memref.store %13, %arg2[%arg4] : memref<?xindex>
        memref.store %12, %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi uge, %3, %arg5 : index
        %15:2 = scf.if %14 -> (index, index) {
          %16 = arith.shli %arg5, %c1 : index
          %17 = arith.addi %16, %c1 : index
          %18 = arith.addi %17, %arg0 : index
          %19 = arith.addi %16, %c2 : index
          %20 = arith.cmpi ult, %19, %arg3 : index
          %21:2 = scf.if %20 -> (index, index) {
            %22 = arith.addi %19, %arg0 : index
            %23 = memref.load %arg2[%18] : memref<?xindex>
            %24 = memref.load %arg2[%22] : memref<?xindex>
            %25 = arith.cmpi ult, %23, %24 : index
            %26 = arith.select %25, %19, %17 : index
            %27 = arith.select %25, %22, %18 : index
            scf.yield %26, %27 : index, index
          } else {
            scf.yield %17, %18 : index, index
          }
          scf.yield %21#0, %21#1 : index, index
        } else {
          scf.yield %arg5, %arg6 : index, index
        }
        scf.yield %arg6, %15#0, %15#1 : index, index, index
      }
    }
  }
  return
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %0 = memref.load %arg0[%c0] : memref<?xindex>
  %1 = memref.load %arg0[%c1] : memref<?xindex>
  %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = arith.index_cast %2 : i64 to index
  %4 = arith.subi %1, %c1 : index
  %5 = arith.cmpi ult, %0, %1 : index
  %6 = scf.if %5 -> (i1) {
    %21 = memref.load %arg1[%4] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg6 : index
    scf.yield %22 : i1
  } else {
    scf.yield %false : i1
  }
  %7 = arith.select %6, %4, %3 : index
  %8:3 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %3, %c1 : index
    memref.store %21, %arg0[%c1] : memref<?xindex>
    %22 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg1(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg1 : memref<?xindex>
    }
    memref.store %arg6, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %31 = arith.addi %30, %c1 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xindex>) {
      %36 = arith.muli %dim_0, %c2 : index
      %37 = memref.realloc %arg2(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg2 : memref<?xindex>
    }
    memref.store %c0, %33[%30] : memref<?xindex>
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %9 = arith.addi %7, %c1 : index
  %10 = memref.load %8#1[%7] : memref<?xindex>
  %11 = memref.load %8#1[%9] : memref<?xindex>
  %12 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %13 = arith.index_cast %12 : i64 to index
  %14 = arith.subi %11, %c1 : index
  %15 = arith.cmpi ult, %10, %11 : index
  %16 = scf.if %15 -> (i1) {
    %21 = memref.load %arg3[%14] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg7 : index
    scf.yield %22 : i1
  } else {
    memref.store %13, %8#1[%7] : memref<?xindex>
    scf.yield %false : i1
  }
  %17 = arith.select %16, %14, %13 : index
  %18:3 = scf.if %16 -> (memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg3, %arg4, %8#2 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %13, %c1 : index
    memref.store %21, %8#1[%9] : memref<?xindex>
    %22 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg3, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg3(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg3 : memref<?xindex>
    }
    memref.store %arg7, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %8#2[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg4, %c0 : memref<?xf32>
    %31 = arith.addi %30, %c32 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xf32>) {
      %36 = scf.while (%arg10 = %dim_0) : (index) -> index {
        %38 = arith.muli %arg10, %c2 : index
        %39 = arith.cmpi ugt, %31, %38 : index
        scf.condition(%39) %38 : index
      } do {
      ^bb0(%arg10: index):
        scf.yield %arg10 : index
      }
      %37 = memref.realloc %arg4(%36) : memref<?xf32> to memref<?xf32>
      scf.yield %37 : memref<?xf32>
    } else {
      scf.yield %arg4 : memref<?xf32>
    }
    %subview = memref.subview %33[%30] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
    scf.for %arg10 = %c0 to %c32 step %c1 {
      memref.store %cst, %subview[%arg10] : memref<32xf32, strided<[1], offset: ?>>
    }
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %19 = arith.muli %17, %c32 : index
  %20 = arith.addi %19, %arg8 : index
  memref.store %arg9, %18#1[%20] : memref<?xf32>
  return %arg0, %8#0, %8#1, %18#0, %18#1, %18#2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%1) %arg3, %arg4 : index, index
  } do {
  ^bb0(%arg3: index, %arg4: index):
    %1 = arith.addi %arg3, %arg4 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    %4 = memref.load %arg2[%arg1] : memref<?xindex>
    %5 = memref.load %arg2[%2] : memref<?xindex>
    %6 = arith.cmpi ult, %4, %5 : index
    %7 = arith.select %6, %arg3, %3 : index
    %8 = arith.select %6, %2, %arg4 : index
    scf.yield %7, %8 : index, index
  }
  return %0#0 : index
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %0 = arith.addi %arg0, %arg1 : index
  %1 = arith.shrui %0, %c1 : index
  %2 = arith.subi %arg1, %c1 : index
  %3 = arith.subi %arg1, %arg0 : index
  %4 = arith.cmpi ult, %3, %c1000 : index
  scf.if %4 {
    %6 = memref.load %arg2[%1] : memref<?xindex>
    %7 = memref.load %arg2[%arg0] : memref<?xindex>
    %8 = arith.cmpi ult, %6, %7 : index
    scf.if %8 {
      %12 = memref.load %arg2[%1] : memref<?xindex>
      %13 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %13, %arg2[%1] : memref<?xindex>
      memref.store %12, %arg2[%arg0] : memref<?xindex>
    }
    %9 = memref.load %arg2[%2] : memref<?xindex>
    %10 = memref.load %arg2[%1] : memref<?xindex>
    %11 = arith.cmpi ult, %9, %10 : index
    scf.if %11 {
      %12 = memref.load %arg2[%2] : memref<?xindex>
      %13 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %13, %arg2[%2] : memref<?xindex>
      memref.store %12, %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%1] : memref<?xindex>
      %15 = memref.load %arg2[%arg0] : memref<?xindex>
      %16 = arith.cmpi ult, %14, %15 : index
      scf.if %16 {
        %17 = memref.load %arg2[%1] : memref<?xindex>
        %18 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %18, %arg2[%1] : memref<?xindex>
        memref.store %17, %arg2[%arg0] : memref<?xindex>
      }
    }
  } else {
    %6 = arith.addi %arg0, %arg1 : index
    %7 = arith.shrui %6, %c1 : index
    %8 = arith.addi %1, %arg1 : index
    %9 = arith.shrui %8, %c1 : index
    %10 = memref.load %arg2[%7] : memref<?xindex>
    %11 = memref.load %arg2[%arg0] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    scf.if %12 {
      %22 = memref.load %arg2[%7] : memref<?xindex>
      %23 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %23, %arg2[%7] : memref<?xindex>
      memref.store %22, %arg2[%arg0] : memref<?xindex>
    }
    %13 = memref.load %arg2[%1] : memref<?xindex>
    %14 = memref.load %arg2[%7] : memref<?xindex>
    %15 = arith.cmpi ult, %13, %14 : index
    scf.if %15 {
      %22 = memref.load %arg2[%1] : memref<?xindex>
      %23 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %23, %arg2[%1] : memref<?xindex>
      memref.store %22, %arg2[%7] : memref<?xindex>
      %24 = memref.load %arg2[%7] : memref<?xindex>
      %25 = memref.load %arg2[%arg0] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%7] : memref<?xindex>
        %28 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %28, %arg2[%7] : memref<?xindex>
        memref.store %27, %arg2[%arg0] : memref<?xindex>
      }
    }
    %16 = memref.load %arg2[%9] : memref<?xindex>
    %17 = memref.load %arg2[%1] : memref<?xindex>
    %18 = arith.cmpi ult, %16, %17 : index
    scf.if %18 {
      %22 = memref.load %arg2[%9] : memref<?xindex>
      %23 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %23, %arg2[%9] : memref<?xindex>
      memref.store %22, %arg2[%1] : memref<?xindex>
      %24 = memref.load %arg2[%1] : memref<?xindex>
      %25 = memref.load %arg2[%7] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%1] : memref<?xindex>
        %28 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %28, %arg2[%1] : memref<?xindex>
        memref.store %27, %arg2[%7] : memref<?xindex>
        %29 = memref.load %arg2[%7] : memref<?xindex>
        %30 = memref.load %arg2[%arg0] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%7] : memref<?xindex>
          %33 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %33, %arg2[%7] : memref<?xindex>
          memref.store %32, %arg2[%arg0] : memref<?xindex>
        }
      }
    }
    %19 = memref.load %arg2[%2] : memref<?xindex>
    %20 = memref.load %arg2[%9] : memref<?xindex>
    %21 = arith.cmpi ult, %19, %20 : index
    scf.if %21 {
      %22 = memref.load %arg2[%2] : memref<?xindex>
      %23 = memref.load %arg2[%9] : memref<?xindex>
      memref.store %23, %arg2[%2] : memref<?xindex>
      memref.store %22, %arg2[%9] : memref<?xindex>
      %24 = memref.load %arg2[%9] : memref<?xindex>
      %25 = memref.load %arg2[%1] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%9] : memref<?xindex>
        %28 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %28, %arg2[%9] : memref<?xindex>
        memref.store %27, %arg2[%1] : memref<?xindex>
        %29 = memref.load %arg2[%1] : memref<?xindex>
        %30 = memref.load %arg2[%7] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%1] : memref<?xindex>
          %33 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %33, %arg2[%1] : memref<?xindex>
          memref.store %32, %arg2[%7] : memref<?xindex>
          %34 = memref.load %arg2[%7] : memref<?xindex>
          %35 = memref.load %arg2[%arg0] : memref<?xindex>
          %36 = arith.cmpi ult, %34, %35 : index
          scf.if %36 {
            %37 = memref.load %arg2[%7] : memref<?xindex>
            %38 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %38, %arg2[%7] : memref<?xindex>
            memref.store %37, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
    }
  }
  %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
    %6 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
  } do {
  ^bb0(%arg3: index, %arg4: index, %arg5: index):
    %6 = scf.while (%arg6 = %arg3) : (index) -> index {
      %16 = memref.load %arg2[%arg6] : memref<?xindex>
      %17 = memref.load %arg2[%arg5] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c1 : index
      scf.yield %16 : index
    }
    %7 = memref.load %arg2[%6] : memref<?xindex>
    %8 = memref.load %arg2[%arg5] : memref<?xindex>
    %9 = arith.cmpi eq, %7, %8 : index
    %10 = scf.while (%arg6 = %arg4) : (index) -> index {
      %16 = memref.load %arg2[%arg5] : memref<?xindex>
      %17 = memref.load %arg2[%arg6] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c-1 : index
      scf.yield %16 : index
    }
    %11 = memref.load %arg2[%10] : memref<?xindex>
    %12 = memref.load %arg2[%arg5] : memref<?xindex>
    %13 = arith.cmpi eq, %11, %12 : index
    %14 = arith.cmpi ult, %6, %10 : index
    %15:3 = scf.if %14 -> (index, index, index) {
      %16 = memref.load %arg2[%6] : memref<?xindex>
      %17 = memref.load %arg2[%10] : memref<?xindex>
      memref.store %17, %arg2[%6] : memref<?xindex>
      memref.store %16, %arg2[%10] : memref<?xindex>
      %18 = arith.cmpi eq, %6, %arg5 : index
      %19 = scf.if %18 -> (index) {
        scf.yield %10 : index
      } else {
        %22 = arith.cmpi eq, %10, %arg5 : index
        %23 = arith.select %22, %6, %arg5 : index
        scf.yield %23 : index
      }
      %20 = arith.andi %9, %13 : i1
      %21:2 = scf.if %20 -> (index, index) {
        %22 = arith.addi %6, %c1 : index
        %23 = arith.subi %10, %c1 : index
        scf.yield %22, %23 : index, index
      } else {
        scf.yield %6, %10 : index, index
      }
      scf.yield %21#0, %21#1, %19 : index, index, index
    } else {
      scf.yield %6, %10, %arg5 : index, index, index
    }
    scf.yield %15#0, %15#1, %15#2 : index, index, index
  }
  return %5#2 : index
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %alloc = memref.alloc() : memref<16xindex>
  %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
  %alloc_0 = memref.alloc() : memref<16xindex>
  %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
  %alloc_2 = memref.alloc() : memref<16xindex>
  %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
  %alloc_4 = memref.alloc() : memref<16xindex>
  %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
  %alloc_6 = memref.alloc() : memref<16xf32>
  %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c0] : memref<16xindex>
  %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc_2[%c0] : memref<16xindex>
  %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c1] : memref<16xindex>
  %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %alloc_8 = memref.alloc() : memref<32xf32>
  %alloc_9 = memref.alloc() : memref<32xi1>
  %alloc_10 = memref.alloc() : memref<32xindex>
  %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
  scf.for %arg12 = %c0 to %c32 step %c1 {
    memref.store %cst, %alloc_8[%arg12] : memref<32xf32>
  }
  scf.for %arg12 = %c0 to %c32 step %c1 {
    memref.store %false, %alloc_9[%arg12] : memref<32xi1>
  }
  %12 = memref.load %arg0[%c0] : memref<?xindex>
  %13 = memref.load %arg0[%c1] : memref<?xindex>
  %14:6 = scf.for %arg12 = %12 to %13 step %c1 iter_args(%arg13 = %cast, %arg14 = %cast_1, %arg15 = %cast_3, %arg16 = %cast_5, %arg17 = %cast_7, %arg18 = %11) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %26 = memref.load %arg1[%arg12] : memref<?xindex>
    %27 = memref.load %arg2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %arg2[%28] : memref<?xindex>
    %30:6 = scf.for %arg19 = %27 to %29 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %31 = memref.load %arg3[%arg19] : memref<?xindex>
      %32 = memref.load %arg4[%arg19] : memref<?xindex>
      %33 = arith.addi %arg19, %c1 : index
      %34 = memref.load %arg4[%33] : memref<?xindex>
      %35 = scf.for %arg26 = %32 to %34 step %c1 iter_args(%arg27 = %c0) -> (index) {
        %40 = memref.load %arg5[%arg26] : memref<?xindex>
        %41 = memref.load %arg6[%arg26] : memref<?xf32>
        %42 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
          %43 = arith.muli %40, %c32 : index
          %44 = arith.addi %43, %arg28 : index
          %45 = memref.load %alloc_8[%arg28] : memref<32xf32>
          %46 = memref.load %arg8[%44] : memref<?xf32>
          %47 = arith.mulf %41, %46 : f32
          %48 = arith.addf %45, %47 : f32
          %49 = memref.load %alloc_9[%arg28] : memref<32xi1>
          %50 = arith.cmpi eq, %49, %false : i1
          %51 = scf.if %50 -> (index) {
            memref.store %true, %alloc_9[%arg28] : memref<32xi1>
            memref.store %arg28, %alloc_10[%arg29] : memref<32xindex>
            %52 = arith.addi %arg29, %c1 : index
            scf.yield %52 : index
          } else {
            scf.yield %arg29 : index
          }
          memref.store %48, %alloc_8[%arg28] : memref<32xf32>
          scf.yield %51 : index
        } {"Emitted from" = "linalg.generic"}
        scf.yield %42 : index
      } {"Emitted from" = "linalg.generic"}
      %36 = arith.index_cast %35 : index to i64
      %37 = math.ctlz %36 : i64
      %38 = arith.subi %c64_i64, %37 : i64
      func.call @_sparse_hybrid_qsort_1_index(%c0, %35, %cast_11, %38) : (index, index, memref<?xindex>, i64) -> ()
      %39:6 = scf.for %arg26 = %c0 to %35 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %40 = memref.load %alloc_10[%arg26] : memref<32xindex>
        %41 = memref.load %alloc_8[%40] : memref<32xf32>
        %42:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %26, %31, %40, %41) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
        memref.store %cst, %alloc_8[%40] : memref<32xf32>
        memref.store %false, %alloc_9[%40] : memref<32xi1>
        scf.yield %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      }
      scf.yield %39#0, %39#1, %39#2, %39#3, %39#4, %39#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    scf.yield %30#0, %30#1, %30#2, %30#3, %30#4, %30#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } {"Emitted from" = "linalg.generic"}
  memref.dealloc %alloc_8 : memref<32xf32>
  memref.dealloc %alloc_9 : memref<32xi1>
  memref.dealloc %alloc_10 : memref<32xindex>
  %15 = llvm.extractvalue %14#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %16 = arith.index_cast %15 : i64 to index
  %17 = memref.load %14#2[%c0] : memref<?xindex>
  %18 = scf.for %arg12 = %c1 to %16 step %c1 iter_args(%arg13 = %17) -> (index) {
    %26 = memref.load %14#2[%arg12] : memref<?xindex>
    %27 = arith.cmpi eq, %26, %c0 : index
    %28 = arith.select %27, %arg13, %26 : index
    scf.if %27 {
      memref.store %arg13, %14#2[%arg12] : memref<?xindex>
    }
    scf.yield %28 : index
  }
  %alloc_12 = memref.alloc() : memref<4096xf32>
  %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
  %19 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %20 = llvm.insertvalue %c0_i64, %19[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %21 = llvm.insertvalue %c128_i64, %20[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c32_i64, %21[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg12 = %c0 to %c4096 step %c1 {
    memref.store %cst, %alloc_12[%arg12] : memref<4096xf32>
  }
  %23 = llvm.insertvalue %c4096_i64, %22[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %24 = memref.load %14#0[%c0] : memref<?xindex>
  %25 = memref.load %14#0[%c1] : memref<?xindex>
  scf.parallel (%arg12) = (%24) to (%25) step (%c1) {
    %26 = memref.load %14#1[%arg12] : memref<?xindex>
    %27 = memref.load %14#2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %14#2[%28] : memref<?xindex>
    scf.parallel (%arg13) = (%27) to (%29) step (%c1) {
      %30 = memref.load %14#3[%arg13] : memref<?xindex>
      scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
        %31 = arith.muli %arg13, %c32 : index
        %32 = arith.addi %31, %arg14 : index
        %33 = arith.muli %30, %c32 : index
        %34 = arith.addi %33, %arg14 : index
        %35 = arith.muli %26, %c32 : index
        %36 = arith.addi %35, %arg14 : index
        %37 = memref.load %alloc_12[%36] : memref<4096xf32>
        %38 = memref.load %14#4[%32] : memref<?xf32>
        %39 = memref.load %arg10[%34] : memref<?xf32>
        %40 = arith.mulf %38, %39 : f32
        %41 = arith.addf %37, %40 : f32
        memref.store %41, %alloc_12[%36] : memref<4096xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast_13, %23 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0 = arith.addi %arg0, %c1 : index
  scf.for %arg3 = %0 to %arg1 step %c1 {
    %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
    %2 = memref.load %arg2[%arg3] : memref<?xindex>
    %3 = arith.subi %arg3, %1 : index
    scf.for %arg4 = %c0 to %3 step %c1 {
      %4 = arith.subi %arg3, %arg4 : index
      %5 = arith.subi %4, %c1 : index
      %6 = memref.load %arg2[%5] : memref<?xindex>
      memref.store %6, %arg2[%4] : memref<?xindex>
    }
    memref.store %2, %arg2[%1] : memref<?xindex>
  }
  return
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %0 = arith.subi %arg1, %arg0 : index
  %1 = arith.subi %0, %c2 : index
  %2 = arith.shrui %1, %c1 : index
  %3 = arith.addi %2, %c1 : index
  scf.for %arg3 = %c0 to %3 step %c1 {
    %5 = arith.subi %2, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
  }
  %4 = arith.subi %0, %c1 : index
  scf.for %arg3 = %c0 to %4 step %c1 {
    %5 = arith.subi %0, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    %7 = arith.subi %6, %c1 : index
    %8 = memref.load %arg2[%arg0] : memref<?xindex>
    %9 = memref.load %arg2[%7] : memref<?xindex>
    memref.store %9, %arg2[%arg0] : memref<?xindex>
    memref.store %8, %arg2[%7] : memref<?xindex>
    %10 = arith.subi %5, %c1 : index
    func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
  }
  return
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.addi %arg4, %c1 : index
    %2 = arith.cmpi ult, %1, %arg5 : index
    scf.condition(%2) %arg4, %arg5 : index, index
  } do {
  ^bb0(%arg4: index, %arg5: index):
    %1 = arith.subi %arg5, %arg4 : index
    %2 = arith.cmpi ule, %1, %c30 : index
    %3:2 = scf.if %2 -> (index, index) {
      func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
      scf.yield %arg4, %arg4 : index, index
    } else {
      %4 = arith.subi %arg3, %c1_i64 : i64
      %5 = arith.cmpi ule, %4, %c0_i64 : i64
      %6:2 = scf.if %5 -> (index, index) {
        func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
        %8 = arith.addi %7, %c1 : index
        %9 = arith.subi %7, %arg4 : index
        %10 = arith.subi %arg5, %7 : index
        %11 = arith.cmpi ule, %9, %10 : index
        %12 = arith.select %11, %8, %arg4 : index
        %13 = arith.select %11, %arg5, %7 : index
        scf.if %11 {
          %14 = arith.cmpi ne, %9, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        } else {
          %14 = arith.cmpi ne, %10, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        }
        scf.yield %12, %13 : index, index
      }
      scf.yield %6#0, %6#1 : index, index
    }
    scf.yield %3#0, %3#1 : index, index
  }
  return
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %0 = arith.cmpi uge, %arg3, %c2 : index
  scf.if %0 {
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    scf.if %4 {
      %5 = arith.shli %1, %c1 : index
      %6 = arith.addi %5, %c1 : index
      %7 = arith.addi %6, %arg0 : index
      %8 = arith.addi %5, %c2 : index
      %9 = arith.cmpi ult, %8, %arg3 : index
      %10:2 = scf.if %9 -> (index, index) {
        %12 = arith.addi %8, %arg0 : index
        %13 = memref.load %arg2[%7] : memref<?xindex>
        %14 = memref.load %arg2[%12] : memref<?xindex>
        %15 = arith.cmpi ult, %13, %14 : index
        %16 = arith.select %15, %8, %6 : index
        %17 = arith.select %15, %12, %7 : index
        scf.yield %16, %17 : index, index
      } else {
        scf.yield %6, %7 : index, index
      }
      %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi ult, %12, %13 : index
        scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: index):
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        memref.store %13, %arg2[%arg4] : memref<?xindex>
        memref.store %12, %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi uge, %3, %arg5 : index
        %15:2 = scf.if %14 -> (index, index) {
          %16 = arith.shli %arg5, %c1 : index
          %17 = arith.addi %16, %c1 : index
          %18 = arith.addi %17, %arg0 : index
          %19 = arith.addi %16, %c2 : index
          %20 = arith.cmpi ult, %19, %arg3 : index
          %21:2 = scf.if %20 -> (index, index) {
            %22 = arith.addi %19, %arg0 : index
            %23 = memref.load %arg2[%18] : memref<?xindex>
            %24 = memref.load %arg2[%22] : memref<?xindex>
            %25 = arith.cmpi ult, %23, %24 : index
            %26 = arith.select %25, %19, %17 : index
            %27 = arith.select %25, %22, %18 : index
            scf.yield %26, %27 : index, index
          } else {
            scf.yield %17, %18 : index, index
          }
          scf.yield %21#0, %21#1 : index, index
        } else {
          scf.yield %arg5, %arg6 : index, index
        }
        scf.yield %arg6, %15#0, %15#1 : index, index, index
      }
    }
  }
  return
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %0 = memref.load %arg0[%c0] : memref<?xindex>
  %1 = memref.load %arg0[%c1] : memref<?xindex>
  %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = arith.index_cast %2 : i64 to index
  %4 = arith.subi %1, %c1 : index
  %5 = arith.cmpi ult, %0, %1 : index
  %6 = scf.if %5 -> (i1) {
    %21 = memref.load %arg1[%4] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg6 : index
    scf.yield %22 : i1
  } else {
    scf.yield %false : i1
  }
  %7 = arith.select %6, %4, %3 : index
  %8:3 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %3, %c1 : index
    memref.store %21, %arg0[%c1] : memref<?xindex>
    %22 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg1(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg1 : memref<?xindex>
    }
    memref.store %arg6, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %31 = arith.addi %30, %c1 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xindex>) {
      %36 = arith.muli %dim_0, %c2 : index
      %37 = memref.realloc %arg2(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg2 : memref<?xindex>
    }
    memref.store %c0, %33[%30] : memref<?xindex>
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %9 = arith.addi %7, %c1 : index
  %10 = memref.load %8#1[%7] : memref<?xindex>
  %11 = memref.load %8#1[%9] : memref<?xindex>
  %12 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %13 = arith.index_cast %12 : i64 to index
  %14 = arith.subi %11, %c1 : index
  %15 = arith.cmpi ult, %10, %11 : index
  %16 = scf.if %15 -> (i1) {
    %21 = memref.load %arg3[%14] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg7 : index
    scf.yield %22 : i1
  } else {
    memref.store %13, %8#1[%7] : memref<?xindex>
    scf.yield %false : i1
  }
  %17 = arith.select %16, %14, %13 : index
  %18:3 = scf.if %16 -> (memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg3, %arg4, %8#2 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %13, %c1 : index
    memref.store %21, %8#1[%9] : memref<?xindex>
    %22 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg3, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg3(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg3 : memref<?xindex>
    }
    memref.store %arg7, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %8#2[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg4, %c0 : memref<?xf32>
    %31 = arith.addi %30, %c32 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xf32>) {
      %36 = scf.while (%arg10 = %dim_0) : (index) -> index {
        %38 = arith.muli %arg10, %c2 : index
        %39 = arith.cmpi ugt, %31, %38 : index
        scf.condition(%39) %38 : index
      } do {
      ^bb0(%arg10: index):
        scf.yield %arg10 : index
      }
      %37 = memref.realloc %arg4(%36) : memref<?xf32> to memref<?xf32>
      scf.yield %37 : memref<?xf32>
    } else {
      scf.yield %arg4 : memref<?xf32>
    }
    %subview = memref.subview %33[%30] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
    scf.for %arg10 = %c0 to %c32 step %c1 {
      memref.store %cst, %subview[%arg10] : memref<32xf32, strided<[1], offset: ?>>
    }
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %19 = arith.muli %17, %c32 : index
  %20 = arith.addi %19, %arg8 : index
  memref.store %arg9, %18#1[%20] : memref<?xf32>
  return %arg0, %8#0, %8#1, %18#0, %18#1, %18#2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %0 = arith.addi %arg0, %arg1 : index
  %1 = arith.shrui %0, %c1 : index
  %2 = arith.subi %arg1, %c1 : index
  %3 = arith.subi %arg1, %arg0 : index
  %4 = arith.cmpi ult, %3, %c1000 : index
  scf.if %4 {
    %6 = memref.load %arg2[%1] : memref<?xindex>
    %7 = memref.load %arg2[%arg0] : memref<?xindex>
    %8 = arith.cmpi ult, %6, %7 : index
    scf.if %8 {
      %12 = memref.load %arg2[%1] : memref<?xindex>
      %13 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %13, %arg2[%1] : memref<?xindex>
      memref.store %12, %arg2[%arg0] : memref<?xindex>
    }
    %9 = memref.load %arg2[%2] : memref<?xindex>
    %10 = memref.load %arg2[%1] : memref<?xindex>
    %11 = arith.cmpi ult, %9, %10 : index
    scf.if %11 {
      %12 = memref.load %arg2[%2] : memref<?xindex>
      %13 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %13, %arg2[%2] : memref<?xindex>
      memref.store %12, %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%1] : memref<?xindex>
      %15 = memref.load %arg2[%arg0] : memref<?xindex>
      %16 = arith.cmpi ult, %14, %15 : index
      scf.if %16 {
        %17 = memref.load %arg2[%1] : memref<?xindex>
        %18 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %18, %arg2[%1] : memref<?xindex>
        memref.store %17, %arg2[%arg0] : memref<?xindex>
      }
    }
  } else {
    %6 = arith.addi %arg0, %arg1 : index
    %7 = arith.shrui %6, %c1 : index
    %8 = arith.addi %1, %arg1 : index
    %9 = arith.shrui %8, %c1 : index
    %10 = memref.load %arg2[%7] : memref<?xindex>
    %11 = memref.load %arg2[%arg0] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    scf.if %12 {
      %22 = memref.load %arg2[%7] : memref<?xindex>
      %23 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %23, %arg2[%7] : memref<?xindex>
      memref.store %22, %arg2[%arg0] : memref<?xindex>
    }
    %13 = memref.load %arg2[%1] : memref<?xindex>
    %14 = memref.load %arg2[%7] : memref<?xindex>
    %15 = arith.cmpi ult, %13, %14 : index
    scf.if %15 {
      %22 = memref.load %arg2[%1] : memref<?xindex>
      %23 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %23, %arg2[%1] : memref<?xindex>
      memref.store %22, %arg2[%7] : memref<?xindex>
      %24 = memref.load %arg2[%7] : memref<?xindex>
      %25 = memref.load %arg2[%arg0] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%7] : memref<?xindex>
        %28 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %28, %arg2[%7] : memref<?xindex>
        memref.store %27, %arg2[%arg0] : memref<?xindex>
      }
    }
    %16 = memref.load %arg2[%9] : memref<?xindex>
    %17 = memref.load %arg2[%1] : memref<?xindex>
    %18 = arith.cmpi ult, %16, %17 : index
    scf.if %18 {
      %22 = memref.load %arg2[%9] : memref<?xindex>
      %23 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %23, %arg2[%9] : memref<?xindex>
      memref.store %22, %arg2[%1] : memref<?xindex>
      %24 = memref.load %arg2[%1] : memref<?xindex>
      %25 = memref.load %arg2[%7] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%1] : memref<?xindex>
        %28 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %28, %arg2[%1] : memref<?xindex>
        memref.store %27, %arg2[%7] : memref<?xindex>
        %29 = memref.load %arg2[%7] : memref<?xindex>
        %30 = memref.load %arg2[%arg0] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%7] : memref<?xindex>
          %33 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %33, %arg2[%7] : memref<?xindex>
          memref.store %32, %arg2[%arg0] : memref<?xindex>
        }
      }
    }
    %19 = memref.load %arg2[%2] : memref<?xindex>
    %20 = memref.load %arg2[%9] : memref<?xindex>
    %21 = arith.cmpi ult, %19, %20 : index
    scf.if %21 {
      %22 = memref.load %arg2[%2] : memref<?xindex>
      %23 = memref.load %arg2[%9] : memref<?xindex>
      memref.store %23, %arg2[%2] : memref<?xindex>
      memref.store %22, %arg2[%9] : memref<?xindex>
      %24 = memref.load %arg2[%9] : memref<?xindex>
      %25 = memref.load %arg2[%1] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%9] : memref<?xindex>
        %28 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %28, %arg2[%9] : memref<?xindex>
        memref.store %27, %arg2[%1] : memref<?xindex>
        %29 = memref.load %arg2[%1] : memref<?xindex>
        %30 = memref.load %arg2[%7] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%1] : memref<?xindex>
          %33 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %33, %arg2[%1] : memref<?xindex>
          memref.store %32, %arg2[%7] : memref<?xindex>
          %34 = memref.load %arg2[%7] : memref<?xindex>
          %35 = memref.load %arg2[%arg0] : memref<?xindex>
          %36 = arith.cmpi ult, %34, %35 : index
          scf.if %36 {
            %37 = memref.load %arg2[%7] : memref<?xindex>
            %38 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %38, %arg2[%7] : memref<?xindex>
            memref.store %37, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
    }
  }
  %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
    %6 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
  } do {
  ^bb0(%arg3: index, %arg4: index, %arg5: index):
    %6 = scf.while (%arg6 = %arg3) : (index) -> index {
      %16 = memref.load %arg2[%arg6] : memref<?xindex>
      %17 = memref.load %arg2[%arg5] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c1 : index
      scf.yield %16 : index
    }
    %7 = memref.load %arg2[%6] : memref<?xindex>
    %8 = memref.load %arg2[%arg5] : memref<?xindex>
    %9 = arith.cmpi eq, %7, %8 : index
    %10 = scf.while (%arg6 = %arg4) : (index) -> index {
      %16 = memref.load %arg2[%arg5] : memref<?xindex>
      %17 = memref.load %arg2[%arg6] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c-1 : index
      scf.yield %16 : index
    }
    %11 = memref.load %arg2[%10] : memref<?xindex>
    %12 = memref.load %arg2[%arg5] : memref<?xindex>
    %13 = arith.cmpi eq, %11, %12 : index
    %14 = arith.cmpi ult, %6, %10 : index
    %15:3 = scf.if %14 -> (index, index, index) {
      %16 = memref.load %arg2[%6] : memref<?xindex>
      %17 = memref.load %arg2[%10] : memref<?xindex>
      memref.store %17, %arg2[%6] : memref<?xindex>
      memref.store %16, %arg2[%10] : memref<?xindex>
      %18 = arith.cmpi eq, %6, %arg5 : index
      %19 = scf.if %18 -> (index) {
        scf.yield %10 : index
      } else {
        %22 = arith.cmpi eq, %10, %arg5 : index
        %23 = arith.select %22, %6, %arg5 : index
        scf.yield %23 : index
      }
      %20 = arith.andi %9, %13 : i1
      %21:2 = scf.if %20 -> (index, index) {
        %22 = arith.addi %6, %c1 : index
        %23 = arith.subi %10, %c1 : index
        scf.yield %22, %23 : index, index
      } else {
        scf.yield %6, %10 : index, index
      }
      scf.yield %21#0, %21#1, %19 : index, index, index
    } else {
      scf.yield %6, %10, %arg5 : index, index, index
    }
    scf.yield %15#0, %15#1, %15#2 : index, index, index
  }
  return %5#2 : index
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %alloc = memref.alloc() : memref<16xindex>
  %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
  %alloc_0 = memref.alloc() : memref<16xindex>
  %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
  %alloc_2 = memref.alloc() : memref<16xindex>
  %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
  %alloc_4 = memref.alloc() : memref<16xindex>
  %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
  %alloc_6 = memref.alloc() : memref<16xf32>
  %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c0] : memref<16xindex>
  %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc_2[%c0] : memref<16xindex>
  %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c1] : memref<16xindex>
  %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %alloc_8 = memref.alloc() : memref<32xf32>
  %alloc_9 = memref.alloc() : memref<32xi1>
  %alloc_10 = memref.alloc() : memref<32xindex>
  %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
  scf.for %arg12 = %c0 to %c32 step %c1 {
    memref.store %cst, %alloc_8[%arg12] : memref<32xf32>
  }
  scf.for %arg12 = %c0 to %c32 step %c1 {
    memref.store %false, %alloc_9[%arg12] : memref<32xi1>
  }
  %12 = memref.load %arg0[%c0] : memref<?xindex>
  %13 = memref.load %arg0[%c1] : memref<?xindex>
  %14:6 = scf.for %arg12 = %12 to %13 step %c1 iter_args(%arg13 = %cast, %arg14 = %cast_1, %arg15 = %cast_3, %arg16 = %cast_5, %arg17 = %cast_7, %arg18 = %11) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %26 = memref.load %arg1[%arg12] : memref<?xindex>
    %27 = memref.load %arg2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %arg2[%28] : memref<?xindex>
    %30:6 = scf.for %arg19 = %27 to %29 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %31 = memref.load %arg3[%arg19] : memref<?xindex>
      %32 = memref.load %arg4[%arg19] : memref<?xindex>
      %33 = arith.addi %arg19, %c1 : index
      %34 = memref.load %arg4[%33] : memref<?xindex>
      %35 = scf.for %arg26 = %32 to %34 step %c1 iter_args(%arg27 = %c0) -> (index) {
        %40 = memref.load %arg5[%arg26] : memref<?xindex>
        %41 = memref.load %arg6[%arg26] : memref<?xf32>
        %42 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
          %43 = arith.muli %40, %c32 : index
          %44 = arith.addi %43, %arg28 : index
          %45 = memref.load %alloc_8[%arg28] : memref<32xf32>
          %46 = memref.load %arg8[%44] : memref<?xf32>
          %47 = arith.mulf %41, %46 : f32
          %48 = arith.addf %45, %47 : f32
          %49 = memref.load %alloc_9[%arg28] : memref<32xi1>
          %50 = arith.cmpi eq, %49, %false : i1
          %51 = scf.if %50 -> (index) {
            memref.store %true, %alloc_9[%arg28] : memref<32xi1>
            memref.store %arg28, %alloc_10[%arg29] : memref<32xindex>
            %52 = arith.addi %arg29, %c1 : index
            scf.yield %52 : index
          } else {
            scf.yield %arg29 : index
          }
          memref.store %48, %alloc_8[%arg28] : memref<32xf32>
          scf.yield %51 : index
        } {"Emitted from" = "linalg.generic"}
        scf.yield %42 : index
      } {"Emitted from" = "linalg.generic"}
      %36 = arith.index_cast %35 : index to i64
      %37 = math.ctlz %36 : i64
      %38 = arith.subi %c64_i64, %37 : i64
      func.call @_sparse_hybrid_qsort_1_index(%c0, %35, %cast_11, %38) : (index, index, memref<?xindex>, i64) -> ()
      %39:6 = scf.for %arg26 = %c0 to %35 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %40 = memref.load %alloc_10[%arg26] : memref<32xindex>
        %41 = memref.load %alloc_8[%40] : memref<32xf32>
        %42:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %26, %31, %40, %41) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
        memref.store %cst, %alloc_8[%40] : memref<32xf32>
        memref.store %false, %alloc_9[%40] : memref<32xi1>
        scf.yield %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      }
      scf.yield %39#0, %39#1, %39#2, %39#3, %39#4, %39#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    scf.yield %30#0, %30#1, %30#2, %30#3, %30#4, %30#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } {"Emitted from" = "linalg.generic"}
  memref.dealloc %alloc_8 : memref<32xf32>
  memref.dealloc %alloc_9 : memref<32xi1>
  memref.dealloc %alloc_10 : memref<32xindex>
  %15 = llvm.extractvalue %14#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %16 = arith.index_cast %15 : i64 to index
  %17 = memref.load %14#2[%c0] : memref<?xindex>
  %18 = scf.for %arg12 = %c1 to %16 step %c1 iter_args(%arg13 = %17) -> (index) {
    %26 = memref.load %14#2[%arg12] : memref<?xindex>
    %27 = arith.cmpi eq, %26, %c0 : index
    %28 = arith.select %27, %arg13, %26 : index
    scf.if %27 {
      memref.store %arg13, %14#2[%arg12] : memref<?xindex>
    }
    scf.yield %28 : index
  }
  %alloc_12 = memref.alloc() : memref<4096xf32>
  %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
  %19 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %20 = llvm.insertvalue %c0_i64, %19[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %21 = llvm.insertvalue %c128_i64, %20[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c32_i64, %21[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg12 = %c0 to %c4096 step %c1 {
    memref.store %cst, %alloc_12[%arg12] : memref<4096xf32>
  }
  %23 = llvm.insertvalue %c4096_i64, %22[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %24 = memref.load %14#0[%c0] : memref<?xindex>
  %25 = memref.load %14#0[%c1] : memref<?xindex>
  scf.parallel (%arg12) = (%24) to (%25) step (%c1) {
    %26 = memref.load %14#1[%arg12] : memref<?xindex>
    %27 = memref.load %14#2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %14#2[%28] : memref<?xindex>
    scf.parallel (%arg13) = (%27) to (%29) step (%c1) {
      %30 = memref.load %14#3[%arg13] : memref<?xindex>
      scf.parallel (%arg14) = (%c0) to (%c32) step (%c1) {
        %31 = arith.muli %arg13, %c32 : index
        %32 = arith.addi %31, %arg14 : index
        %33 = arith.muli %30, %c32 : index
        %34 = arith.addi %33, %arg14 : index
        %35 = arith.muli %26, %c32 : index
        %36 = arith.addi %35, %arg14 : index
        %37 = memref.load %alloc_12[%36] : memref<4096xf32>
        %38 = memref.load %14#4[%32] : memref<?xf32>
        %39 = memref.load %arg10[%34] : memref<?xf32>
        %40 = arith.mulf %38, %39 : f32
        %41 = arith.addf %37, %40 : f32
        memref.store %41, %alloc_12[%36] : memref<4096xf32>
        scf.yield
      } {"Emitted from" = "linalg.generic"}
      scf.yield
    } {"Emitted from" = "linalg.generic"}
    scf.yield
  } {"Emitted from" = "linalg.generic"}
  return %cast_13, %23 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertSCFToOpenMPPass (convert-scf-to-openmp) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.subi %1, %c1 : index
    %5 = arith.cmpi ult, %0, %1 : index
    %6 = scf.if %5 -> (i1) {
      %21 = memref.load %arg1[%4] : memref<?xindex>
      %22 = arith.cmpi eq, %21, %arg6 : index
      scf.yield %22 : i1
    } else {
      scf.yield %false : i1
    }
    %7 = arith.select %6, %4, %3 : index
    %8:3 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      scf.yield %arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } else {
      %21 = arith.addi %3, %c1 : index
      memref.store %21, %arg0[%c1] : memref<?xindex>
      %22 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %23 = arith.index_cast %22 : i64 to index
      %dim = memref.dim %arg1, %c0 : memref<?xindex>
      %24 = arith.addi %23, %c1 : index
      %25 = arith.cmpi ugt, %24, %dim : index
      %26 = scf.if %25 -> (memref<?xindex>) {
        %36 = arith.muli %dim, %c2 : index
        %37 = memref.realloc %arg1(%36) : memref<?xindex> to memref<?xindex>
        scf.yield %37 : memref<?xindex>
      } else {
        scf.yield %arg1 : memref<?xindex>
      }
      memref.store %arg6, %26[%23] : memref<?xindex>
      %27 = arith.index_cast %24 : index to i64
      %28 = llvm.insertvalue %27, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %29 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %30 = arith.index_cast %29 : i64 to index
      %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
      %31 = arith.addi %30, %c1 : index
      %32 = arith.cmpi ugt, %31, %dim_0 : index
      %33 = scf.if %32 -> (memref<?xindex>) {
        %36 = arith.muli %dim_0, %c2 : index
        %37 = memref.realloc %arg2(%36) : memref<?xindex> to memref<?xindex>
        scf.yield %37 : memref<?xindex>
      } else {
        scf.yield %arg2 : memref<?xindex>
      }
      memref.store %c0, %33[%30] : memref<?xindex>
      %34 = arith.index_cast %31 : index to i64
      %35 = llvm.insertvalue %34, %28[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      scf.yield %26, %33, %35 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    }
    %9 = arith.addi %7, %c1 : index
    %10 = memref.load %8#1[%7] : memref<?xindex>
    %11 = memref.load %8#1[%9] : memref<?xindex>
    %12 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %13 = arith.index_cast %12 : i64 to index
    %14 = arith.subi %11, %c1 : index
    %15 = arith.cmpi ult, %10, %11 : index
    %16 = scf.if %15 -> (i1) {
      %21 = memref.load %arg3[%14] : memref<?xindex>
      %22 = arith.cmpi eq, %21, %arg7 : index
      scf.yield %22 : i1
    } else {
      memref.store %13, %8#1[%7] : memref<?xindex>
      scf.yield %false : i1
    }
    %17 = arith.select %16, %14, %13 : index
    %18:3 = scf.if %16 -> (memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      scf.yield %arg3, %arg4, %8#2 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } else {
      %21 = arith.addi %13, %c1 : index
      memref.store %21, %8#1[%9] : memref<?xindex>
      %22 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %23 = arith.index_cast %22 : i64 to index
      %dim = memref.dim %arg3, %c0 : memref<?xindex>
      %24 = arith.addi %23, %c1 : index
      %25 = arith.cmpi ugt, %24, %dim : index
      %26 = scf.if %25 -> (memref<?xindex>) {
        %36 = arith.muli %dim, %c2 : index
        %37 = memref.realloc %arg3(%36) : memref<?xindex> to memref<?xindex>
        scf.yield %37 : memref<?xindex>
      } else {
        scf.yield %arg3 : memref<?xindex>
      }
      memref.store %arg7, %26[%23] : memref<?xindex>
      %27 = arith.index_cast %24 : index to i64
      %28 = llvm.insertvalue %27, %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %29 = llvm.extractvalue %8#2[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      %30 = arith.index_cast %29 : i64 to index
      %dim_0 = memref.dim %arg4, %c0 : memref<?xf32>
      %31 = arith.addi %30, %c32 : index
      %32 = arith.cmpi ugt, %31, %dim_0 : index
      %33 = scf.if %32 -> (memref<?xf32>) {
        %36 = scf.while (%arg10 = %dim_0) : (index) -> index {
          %38 = arith.muli %arg10, %c2 : index
          %39 = arith.cmpi ugt, %31, %38 : index
          scf.condition(%39) %38 : index
        } do {
        ^bb0(%arg10: index):
          scf.yield %arg10 : index
        }
        %37 = memref.realloc %arg4(%36) : memref<?xf32> to memref<?xf32>
        scf.yield %37 : memref<?xf32>
      } else {
        scf.yield %arg4 : memref<?xf32>
      }
      %subview = memref.subview %33[%30] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
      scf.for %arg10 = %c0 to %c32 step %c1 {
        memref.store %cst, %subview[%arg10] : memref<32xf32, strided<[1], offset: ?>>
      }
      %34 = arith.index_cast %31 : index to i64
      %35 = llvm.insertvalue %34, %28[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
      scf.yield %26, %33, %35 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    }
    %19 = arith.muli %17, %c32 : index
    %20 = arith.addi %19, %arg8 : index
    memref.store %arg9, %18#1[%20] : memref<?xf32>
    return %arg0, %8#0, %8#1, %18#0, %18#1, %18#2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%1) %arg3, %arg4 : index, index
    } do {
    ^bb0(%arg3: index, %arg4: index):
      %1 = arith.addi %arg3, %arg4 : index
      %2 = arith.shrui %1, %c1 : index
      %3 = arith.addi %2, %c1 : index
      %4 = memref.load %arg2[%arg1] : memref<?xindex>
      %5 = memref.load %arg2[%2] : memref<?xindex>
      %6 = arith.cmpi ult, %4, %5 : index
      %7 = arith.select %6, %arg3, %3 : index
      %8 = arith.select %6, %2, %arg4 : index
      scf.yield %7, %8 : index, index
    }
    return %0#0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    scf.for %arg3 = %0 to %arg1 step %c1 {
      %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
      %2 = memref.load %arg2[%arg3] : memref<?xindex>
      %3 = arith.subi %arg3, %1 : index
      scf.for %arg4 = %c0 to %3 step %c1 {
        %4 = arith.subi %arg3, %arg4 : index
        %5 = arith.subi %4, %c1 : index
        %6 = memref.load %arg2[%5] : memref<?xindex>
        memref.store %6, %arg2[%4] : memref<?xindex>
      }
      memref.store %2, %arg2[%1] : memref<?xindex>
    }
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    scf.if %0 {
      %1 = arith.subi %arg1, %arg0 : index
      %2 = arith.subi %arg3, %c2 : index
      %3 = arith.shrui %2, %c1 : index
      %4 = arith.cmpi uge, %3, %1 : index
      scf.if %4 {
        %5 = arith.shli %1, %c1 : index
        %6 = arith.addi %5, %c1 : index
        %7 = arith.addi %6, %arg0 : index
        %8 = arith.addi %5, %c2 : index
        %9 = arith.cmpi ult, %8, %arg3 : index
        %10:2 = scf.if %9 -> (index, index) {
          %12 = arith.addi %8, %arg0 : index
          %13 = memref.load %arg2[%7] : memref<?xindex>
          %14 = memref.load %arg2[%12] : memref<?xindex>
          %15 = arith.cmpi ult, %13, %14 : index
          %16 = arith.select %15, %8, %6 : index
          %17 = arith.select %15, %12, %7 : index
          scf.yield %16, %17 : index, index
        } else {
          scf.yield %6, %7 : index, index
        }
        %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi ult, %12, %13 : index
          scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
        } do {
        ^bb0(%arg4: index, %arg5: index, %arg6: index):
          %12 = memref.load %arg2[%arg4] : memref<?xindex>
          %13 = memref.load %arg2[%arg6] : memref<?xindex>
          memref.store %13, %arg2[%arg4] : memref<?xindex>
          memref.store %12, %arg2[%arg6] : memref<?xindex>
          %14 = arith.cmpi uge, %3, %arg5 : index
          %15:2 = scf.if %14 -> (index, index) {
            %16 = arith.shli %arg5, %c1 : index
            %17 = arith.addi %16, %c1 : index
            %18 = arith.addi %17, %arg0 : index
            %19 = arith.addi %16, %c2 : index
            %20 = arith.cmpi ult, %19, %arg3 : index
            %21:2 = scf.if %20 -> (index, index) {
              %22 = arith.addi %19, %arg0 : index
              %23 = memref.load %arg2[%18] : memref<?xindex>
              %24 = memref.load %arg2[%22] : memref<?xindex>
              %25 = arith.cmpi ult, %23, %24 : index
              %26 = arith.select %25, %19, %17 : index
              %27 = arith.select %25, %22, %18 : index
              scf.yield %26, %27 : index, index
            } else {
              scf.yield %17, %18 : index, index
            }
            scf.yield %21#0, %21#1 : index, index
          } else {
            scf.yield %arg5, %arg6 : index, index
          }
          scf.yield %arg6, %15#0, %15#1 : index, index, index
        }
      }
    }
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    scf.for %arg3 = %c0 to %3 step %c1 {
      %5 = arith.subi %2, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    }
    %4 = arith.subi %0, %c1 : index
    scf.for %arg3 = %c0 to %4 step %c1 {
      %5 = arith.subi %0, %arg3 : index
      %6 = arith.addi %arg0, %5 : index
      %7 = arith.subi %6, %c1 : index
      %8 = memref.load %arg2[%arg0] : memref<?xindex>
      %9 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %9, %arg2[%arg0] : memref<?xindex>
      memref.store %8, %arg2[%7] : memref<?xindex>
      %10 = arith.subi %5, %c1 : index
      func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
    }
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    scf.if %4 {
      %6 = memref.load %arg2[%1] : memref<?xindex>
      %7 = memref.load %arg2[%arg0] : memref<?xindex>
      %8 = arith.cmpi ult, %6, %7 : index
      scf.if %8 {
        %12 = memref.load %arg2[%1] : memref<?xindex>
        %13 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %13, %arg2[%1] : memref<?xindex>
        memref.store %12, %arg2[%arg0] : memref<?xindex>
      }
      %9 = memref.load %arg2[%2] : memref<?xindex>
      %10 = memref.load %arg2[%1] : memref<?xindex>
      %11 = arith.cmpi ult, %9, %10 : index
      scf.if %11 {
        %12 = memref.load %arg2[%2] : memref<?xindex>
        %13 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %13, %arg2[%2] : memref<?xindex>
        memref.store %12, %arg2[%1] : memref<?xindex>
        %14 = memref.load %arg2[%1] : memref<?xindex>
        %15 = memref.load %arg2[%arg0] : memref<?xindex>
        %16 = arith.cmpi ult, %14, %15 : index
        scf.if %16 {
          %17 = memref.load %arg2[%1] : memref<?xindex>
          %18 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %18, %arg2[%1] : memref<?xindex>
          memref.store %17, %arg2[%arg0] : memref<?xindex>
        }
      }
    } else {
      %6 = arith.addi %arg0, %arg1 : index
      %7 = arith.shrui %6, %c1 : index
      %8 = arith.addi %1, %arg1 : index
      %9 = arith.shrui %8, %c1 : index
      %10 = memref.load %arg2[%7] : memref<?xindex>
      %11 = memref.load %arg2[%arg0] : memref<?xindex>
      %12 = arith.cmpi ult, %10, %11 : index
      scf.if %12 {
        %22 = memref.load %arg2[%7] : memref<?xindex>
        %23 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %23, %arg2[%7] : memref<?xindex>
        memref.store %22, %arg2[%arg0] : memref<?xindex>
      }
      %13 = memref.load %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%7] : memref<?xindex>
      %15 = arith.cmpi ult, %13, %14 : index
      scf.if %15 {
        %22 = memref.load %arg2[%1] : memref<?xindex>
        %23 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %23, %arg2[%1] : memref<?xindex>
        memref.store %22, %arg2[%7] : memref<?xindex>
        %24 = memref.load %arg2[%7] : memref<?xindex>
        %25 = memref.load %arg2[%arg0] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%7] : memref<?xindex>
          %28 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %28, %arg2[%7] : memref<?xindex>
          memref.store %27, %arg2[%arg0] : memref<?xindex>
        }
      }
      %16 = memref.load %arg2[%9] : memref<?xindex>
      %17 = memref.load %arg2[%1] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.if %18 {
        %22 = memref.load %arg2[%9] : memref<?xindex>
        %23 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %23, %arg2[%9] : memref<?xindex>
        memref.store %22, %arg2[%1] : memref<?xindex>
        %24 = memref.load %arg2[%1] : memref<?xindex>
        %25 = memref.load %arg2[%7] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%1] : memref<?xindex>
          %28 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %28, %arg2[%1] : memref<?xindex>
          memref.store %27, %arg2[%7] : memref<?xindex>
          %29 = memref.load %arg2[%7] : memref<?xindex>
          %30 = memref.load %arg2[%arg0] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%7] : memref<?xindex>
            %33 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %33, %arg2[%7] : memref<?xindex>
            memref.store %32, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
      %19 = memref.load %arg2[%2] : memref<?xindex>
      %20 = memref.load %arg2[%9] : memref<?xindex>
      %21 = arith.cmpi ult, %19, %20 : index
      scf.if %21 {
        %22 = memref.load %arg2[%2] : memref<?xindex>
        %23 = memref.load %arg2[%9] : memref<?xindex>
        memref.store %23, %arg2[%2] : memref<?xindex>
        memref.store %22, %arg2[%9] : memref<?xindex>
        %24 = memref.load %arg2[%9] : memref<?xindex>
        %25 = memref.load %arg2[%1] : memref<?xindex>
        %26 = arith.cmpi ult, %24, %25 : index
        scf.if %26 {
          %27 = memref.load %arg2[%9] : memref<?xindex>
          %28 = memref.load %arg2[%1] : memref<?xindex>
          memref.store %28, %arg2[%9] : memref<?xindex>
          memref.store %27, %arg2[%1] : memref<?xindex>
          %29 = memref.load %arg2[%1] : memref<?xindex>
          %30 = memref.load %arg2[%7] : memref<?xindex>
          %31 = arith.cmpi ult, %29, %30 : index
          scf.if %31 {
            %32 = memref.load %arg2[%1] : memref<?xindex>
            %33 = memref.load %arg2[%7] : memref<?xindex>
            memref.store %33, %arg2[%1] : memref<?xindex>
            memref.store %32, %arg2[%7] : memref<?xindex>
            %34 = memref.load %arg2[%7] : memref<?xindex>
            %35 = memref.load %arg2[%arg0] : memref<?xindex>
            %36 = arith.cmpi ult, %34, %35 : index
            scf.if %36 {
              %37 = memref.load %arg2[%7] : memref<?xindex>
              %38 = memref.load %arg2[%arg0] : memref<?xindex>
              memref.store %38, %arg2[%7] : memref<?xindex>
              memref.store %37, %arg2[%arg0] : memref<?xindex>
            }
          }
        }
      }
    }
    %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
      %6 = arith.cmpi ult, %arg3, %arg4 : index
      scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
    } do {
    ^bb0(%arg3: index, %arg4: index, %arg5: index):
      %6 = scf.while (%arg6 = %arg3) : (index) -> index {
        %16 = memref.load %arg2[%arg6] : memref<?xindex>
        %17 = memref.load %arg2[%arg5] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c1 : index
        scf.yield %16 : index
      }
      %7 = memref.load %arg2[%6] : memref<?xindex>
      %8 = memref.load %arg2[%arg5] : memref<?xindex>
      %9 = arith.cmpi eq, %7, %8 : index
      %10 = scf.while (%arg6 = %arg4) : (index) -> index {
        %16 = memref.load %arg2[%arg5] : memref<?xindex>
        %17 = memref.load %arg2[%arg6] : memref<?xindex>
        %18 = arith.cmpi ult, %16, %17 : index
        scf.condition(%18) %arg6 : index
      } do {
      ^bb0(%arg6: index):
        %16 = arith.addi %arg6, %c-1 : index
        scf.yield %16 : index
      }
      %11 = memref.load %arg2[%10] : memref<?xindex>
      %12 = memref.load %arg2[%arg5] : memref<?xindex>
      %13 = arith.cmpi eq, %11, %12 : index
      %14 = arith.cmpi ult, %6, %10 : index
      %15:3 = scf.if %14 -> (index, index, index) {
        %16 = memref.load %arg2[%6] : memref<?xindex>
        %17 = memref.load %arg2[%10] : memref<?xindex>
        memref.store %17, %arg2[%6] : memref<?xindex>
        memref.store %16, %arg2[%10] : memref<?xindex>
        %18 = arith.cmpi eq, %6, %arg5 : index
        %19 = scf.if %18 -> (index) {
          scf.yield %10 : index
        } else {
          %22 = arith.cmpi eq, %10, %arg5 : index
          %23 = arith.select %22, %6, %arg5 : index
          scf.yield %23 : index
        }
        %20 = arith.andi %9, %13 : i1
        %21:2 = scf.if %20 -> (index, index) {
          %22 = arith.addi %6, %c1 : index
          %23 = arith.subi %10, %c1 : index
          scf.yield %22, %23 : index, index
        } else {
          scf.yield %6, %10 : index, index
        }
        scf.yield %21#0, %21#1, %19 : index, index, index
      } else {
        scf.yield %6, %10, %arg5 : index, index, index
      }
      scf.yield %15#0, %15#1, %15#2 : index, index, index
    }
    return %5#2 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
      %1 = arith.addi %arg4, %c1 : index
      %2 = arith.cmpi ult, %1, %arg5 : index
      scf.condition(%2) %arg4, %arg5 : index, index
    } do {
    ^bb0(%arg4: index, %arg5: index):
      %1 = arith.subi %arg5, %arg4 : index
      %2 = arith.cmpi ule, %1, %c30 : index
      %3:2 = scf.if %2 -> (index, index) {
        func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %4 = arith.subi %arg3, %c1_i64 : i64
        %5 = arith.cmpi ule, %4, %c0_i64 : i64
        %6:2 = scf.if %5 -> (index, index) {
          func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
          scf.yield %arg4, %arg4 : index, index
        } else {
          %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
          %8 = arith.addi %7, %c1 : index
          %9 = arith.subi %7, %arg4 : index
          %10 = arith.subi %arg5, %7 : index
          %11 = arith.cmpi ule, %9, %10 : index
          %12 = arith.select %11, %8, %arg4 : index
          %13 = arith.select %11, %arg5, %7 : index
          scf.if %11 {
            %14 = arith.cmpi ne, %9, %c0 : index
            scf.if %14 {
              func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
          } else {
            %14 = arith.cmpi ne, %10, %c0 : index
            scf.if %14 {
              func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
            }
          }
          scf.yield %12, %13 : index, index
        }
        scf.yield %6#0, %6#1 : index, index
      }
      scf.yield %3#0, %3#1 : index, index
    }
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %alloc = memref.alloc() : memref<16xindex>
    %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
    %alloc_0 = memref.alloc() : memref<16xindex>
    %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
    %alloc_2 = memref.alloc() : memref<16xindex>
    %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
    %alloc_4 = memref.alloc() : memref<16xindex>
    %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
    %alloc_6 = memref.alloc() : memref<16xf32>
    %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c0] : memref<16xindex>
    %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc_2[%c0] : memref<16xindex>
    %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c1] : memref<16xindex>
    %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %alloc_8 = memref.alloc() : memref<32xf32>
    %alloc_9 = memref.alloc() : memref<32xi1>
    %alloc_10 = memref.alloc() : memref<32xindex>
    %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
    scf.for %arg12 = %c0 to %c32 step %c1 {
      memref.store %cst, %alloc_8[%arg12] : memref<32xf32>
    }
    scf.for %arg12 = %c0 to %c32 step %c1 {
      memref.store %false, %alloc_9[%arg12] : memref<32xi1>
    }
    %12 = memref.load %arg0[%c0] : memref<?xindex>
    %13 = memref.load %arg0[%c1] : memref<?xindex>
    %14:6 = scf.for %arg12 = %12 to %13 step %c1 iter_args(%arg13 = %cast, %arg14 = %cast_1, %arg15 = %cast_3, %arg16 = %cast_5, %arg17 = %cast_7, %arg18 = %11) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %27 = memref.load %arg1[%arg12] : memref<?xindex>
      %28 = memref.load %arg2[%arg12] : memref<?xindex>
      %29 = arith.addi %arg12, %c1 : index
      %30 = memref.load %arg2[%29] : memref<?xindex>
      %31:6 = scf.for %arg19 = %28 to %30 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %32 = memref.load %arg3[%arg19] : memref<?xindex>
        %33 = memref.load %arg4[%arg19] : memref<?xindex>
        %34 = arith.addi %arg19, %c1 : index
        %35 = memref.load %arg4[%34] : memref<?xindex>
        %36 = scf.for %arg26 = %33 to %35 step %c1 iter_args(%arg27 = %c0) -> (index) {
          %41 = memref.load %arg5[%arg26] : memref<?xindex>
          %42 = memref.load %arg6[%arg26] : memref<?xf32>
          %43 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
            %44 = arith.muli %41, %c32 : index
            %45 = arith.addi %44, %arg28 : index
            %46 = memref.load %alloc_8[%arg28] : memref<32xf32>
            %47 = memref.load %arg8[%45] : memref<?xf32>
            %48 = arith.mulf %42, %47 : f32
            %49 = arith.addf %46, %48 : f32
            %50 = memref.load %alloc_9[%arg28] : memref<32xi1>
            %51 = arith.cmpi eq, %50, %false : i1
            %52 = scf.if %51 -> (index) {
              memref.store %true, %alloc_9[%arg28] : memref<32xi1>
              memref.store %arg28, %alloc_10[%arg29] : memref<32xindex>
              %53 = arith.addi %arg29, %c1 : index
              scf.yield %53 : index
            } else {
              scf.yield %arg29 : index
            }
            memref.store %49, %alloc_8[%arg28] : memref<32xf32>
            scf.yield %52 : index
          } {"Emitted from" = "linalg.generic"}
          scf.yield %43 : index
        } {"Emitted from" = "linalg.generic"}
        %37 = arith.index_cast %36 : index to i64
        %38 = math.ctlz %37 : i64
        %39 = arith.subi %c64_i64, %38 : i64
        func.call @_sparse_hybrid_qsort_1_index(%c0, %36, %cast_11, %39) : (index, index, memref<?xindex>, i64) -> ()
        %40:6 = scf.for %arg26 = %c0 to %36 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
          %41 = memref.load %alloc_10[%arg26] : memref<32xindex>
          %42 = memref.load %alloc_8[%41] : memref<32xf32>
          %43:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %27, %32, %41, %42) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
          memref.store %cst, %alloc_8[%41] : memref<32xf32>
          memref.store %false, %alloc_9[%41] : memref<32xi1>
          scf.yield %43#0, %43#1, %43#2, %43#3, %43#4, %43#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
        }
        scf.yield %40#0, %40#1, %40#2, %40#3, %40#4, %40#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      } {"Emitted from" = "linalg.generic"}
      scf.yield %31#0, %31#1, %31#2, %31#3, %31#4, %31#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    memref.dealloc %alloc_8 : memref<32xf32>
    memref.dealloc %alloc_9 : memref<32xi1>
    memref.dealloc %alloc_10 : memref<32xindex>
    %15 = llvm.extractvalue %14#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %16 = arith.index_cast %15 : i64 to index
    %17 = memref.load %14#2[%c0] : memref<?xindex>
    %18 = scf.for %arg12 = %c1 to %16 step %c1 iter_args(%arg13 = %17) -> (index) {
      %27 = memref.load %14#2[%arg12] : memref<?xindex>
      %28 = arith.cmpi eq, %27, %c0 : index
      %29 = arith.select %28, %arg13, %27 : index
      scf.if %28 {
        memref.store %arg13, %14#2[%arg12] : memref<?xindex>
      }
      scf.yield %29 : index
    }
    %alloc_12 = memref.alloc() : memref<4096xf32>
    %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
    %19 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %20 = llvm.insertvalue %c0_i64, %19[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %c128_i64, %20[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %c32_i64, %21[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    scf.for %arg12 = %c0 to %c4096 step %c1 {
      memref.store %cst, %alloc_12[%arg12] : memref<4096xf32>
    }
    %23 = llvm.insertvalue %c4096_i64, %22[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %24 = memref.load %14#0[%c0] : memref<?xindex>
    %25 = memref.load %14#0[%c1] : memref<?xindex>
    %26 = llvm.mlir.constant(1 : i64) : i64
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%24) to (%25) step (%c1) {
        memref.alloca_scope  {
          %27 = memref.load %14#1[%arg12] : memref<?xindex>
          %28 = memref.load %14#2[%arg12] : memref<?xindex>
          %29 = arith.addi %arg12, %c1 : index
          %30 = memref.load %14#2[%29] : memref<?xindex>
          %31 = llvm.mlir.constant(1 : i64) : i64
          omp.parallel   {
            omp.wsloop   for  (%arg13) : index = (%28) to (%30) step (%c1) {
              memref.alloca_scope  {
                %32 = memref.load %14#3[%arg13] : memref<?xindex>
                %33 = llvm.mlir.constant(1 : i64) : i64
                omp.parallel   {
                  omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                    memref.alloca_scope  {
                      %34 = arith.muli %arg13, %c32 : index
                      %35 = arith.addi %34, %arg14 : index
                      %36 = arith.muli %32, %c32 : index
                      %37 = arith.addi %36, %arg14 : index
                      %38 = arith.muli %27, %c32 : index
                      %39 = arith.addi %38, %arg14 : index
                      %40 = memref.load %alloc_12[%39] : memref<4096xf32>
                      %41 = memref.load %14#4[%35] : memref<?xf32>
                      %42 = memref.load %arg10[%37] : memref<?xf32>
                      %43 = arith.mulf %41, %42 : f32
                      %44 = arith.addf %40, %43 : f32
                      memref.store %44, %alloc_12[%39] : memref<4096xf32>
                    }
                    omp.yield
                  }
                  omp.terminator
                }
              }
              omp.yield
            }
            omp.terminator
          }
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast_13, %23 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0 = arith.addi %arg0, %c1 : index
  scf.for %arg3 = %0 to %arg1 step %c1 {
    %1 = func.call @_sparse_binary_search_1_index(%arg0, %arg3, %arg2) : (index, index, memref<?xindex>) -> index
    %2 = memref.load %arg2[%arg3] : memref<?xindex>
    %3 = arith.subi %arg3, %1 : index
    scf.for %arg4 = %c0 to %3 step %c1 {
      %4 = arith.subi %arg3, %arg4 : index
      %5 = arith.subi %4, %c1 : index
      %6 = memref.load %arg2[%5] : memref<?xindex>
      memref.store %6, %arg2[%4] : memref<?xindex>
    }
    memref.store %2, %arg2[%1] : memref<?xindex>
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %0 = arith.addi %arg0, %arg1 : index
  %1 = arith.shrui %0, %c1 : index
  %2 = arith.subi %arg1, %c1 : index
  %3 = arith.subi %arg1, %arg0 : index
  %4 = arith.cmpi ult, %3, %c1000 : index
  scf.if %4 {
    %6 = memref.load %arg2[%1] : memref<?xindex>
    %7 = memref.load %arg2[%arg0] : memref<?xindex>
    %8 = arith.cmpi ult, %6, %7 : index
    scf.if %8 {
      %12 = memref.load %arg2[%1] : memref<?xindex>
      %13 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %13, %arg2[%1] : memref<?xindex>
      memref.store %12, %arg2[%arg0] : memref<?xindex>
    }
    %9 = memref.load %arg2[%2] : memref<?xindex>
    %10 = memref.load %arg2[%1] : memref<?xindex>
    %11 = arith.cmpi ult, %9, %10 : index
    scf.if %11 {
      %12 = memref.load %arg2[%2] : memref<?xindex>
      %13 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %13, %arg2[%2] : memref<?xindex>
      memref.store %12, %arg2[%1] : memref<?xindex>
      %14 = memref.load %arg2[%1] : memref<?xindex>
      %15 = memref.load %arg2[%arg0] : memref<?xindex>
      %16 = arith.cmpi ult, %14, %15 : index
      scf.if %16 {
        %17 = memref.load %arg2[%1] : memref<?xindex>
        %18 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %18, %arg2[%1] : memref<?xindex>
        memref.store %17, %arg2[%arg0] : memref<?xindex>
      }
    }
  } else {
    %6 = arith.addi %arg0, %arg1 : index
    %7 = arith.shrui %6, %c1 : index
    %8 = arith.addi %1, %arg1 : index
    %9 = arith.shrui %8, %c1 : index
    %10 = memref.load %arg2[%7] : memref<?xindex>
    %11 = memref.load %arg2[%arg0] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    scf.if %12 {
      %22 = memref.load %arg2[%7] : memref<?xindex>
      %23 = memref.load %arg2[%arg0] : memref<?xindex>
      memref.store %23, %arg2[%7] : memref<?xindex>
      memref.store %22, %arg2[%arg0] : memref<?xindex>
    }
    %13 = memref.load %arg2[%1] : memref<?xindex>
    %14 = memref.load %arg2[%7] : memref<?xindex>
    %15 = arith.cmpi ult, %13, %14 : index
    scf.if %15 {
      %22 = memref.load %arg2[%1] : memref<?xindex>
      %23 = memref.load %arg2[%7] : memref<?xindex>
      memref.store %23, %arg2[%1] : memref<?xindex>
      memref.store %22, %arg2[%7] : memref<?xindex>
      %24 = memref.load %arg2[%7] : memref<?xindex>
      %25 = memref.load %arg2[%arg0] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%7] : memref<?xindex>
        %28 = memref.load %arg2[%arg0] : memref<?xindex>
        memref.store %28, %arg2[%7] : memref<?xindex>
        memref.store %27, %arg2[%arg0] : memref<?xindex>
      }
    }
    %16 = memref.load %arg2[%9] : memref<?xindex>
    %17 = memref.load %arg2[%1] : memref<?xindex>
    %18 = arith.cmpi ult, %16, %17 : index
    scf.if %18 {
      %22 = memref.load %arg2[%9] : memref<?xindex>
      %23 = memref.load %arg2[%1] : memref<?xindex>
      memref.store %23, %arg2[%9] : memref<?xindex>
      memref.store %22, %arg2[%1] : memref<?xindex>
      %24 = memref.load %arg2[%1] : memref<?xindex>
      %25 = memref.load %arg2[%7] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%1] : memref<?xindex>
        %28 = memref.load %arg2[%7] : memref<?xindex>
        memref.store %28, %arg2[%1] : memref<?xindex>
        memref.store %27, %arg2[%7] : memref<?xindex>
        %29 = memref.load %arg2[%7] : memref<?xindex>
        %30 = memref.load %arg2[%arg0] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%7] : memref<?xindex>
          %33 = memref.load %arg2[%arg0] : memref<?xindex>
          memref.store %33, %arg2[%7] : memref<?xindex>
          memref.store %32, %arg2[%arg0] : memref<?xindex>
        }
      }
    }
    %19 = memref.load %arg2[%2] : memref<?xindex>
    %20 = memref.load %arg2[%9] : memref<?xindex>
    %21 = arith.cmpi ult, %19, %20 : index
    scf.if %21 {
      %22 = memref.load %arg2[%2] : memref<?xindex>
      %23 = memref.load %arg2[%9] : memref<?xindex>
      memref.store %23, %arg2[%2] : memref<?xindex>
      memref.store %22, %arg2[%9] : memref<?xindex>
      %24 = memref.load %arg2[%9] : memref<?xindex>
      %25 = memref.load %arg2[%1] : memref<?xindex>
      %26 = arith.cmpi ult, %24, %25 : index
      scf.if %26 {
        %27 = memref.load %arg2[%9] : memref<?xindex>
        %28 = memref.load %arg2[%1] : memref<?xindex>
        memref.store %28, %arg2[%9] : memref<?xindex>
        memref.store %27, %arg2[%1] : memref<?xindex>
        %29 = memref.load %arg2[%1] : memref<?xindex>
        %30 = memref.load %arg2[%7] : memref<?xindex>
        %31 = arith.cmpi ult, %29, %30 : index
        scf.if %31 {
          %32 = memref.load %arg2[%1] : memref<?xindex>
          %33 = memref.load %arg2[%7] : memref<?xindex>
          memref.store %33, %arg2[%1] : memref<?xindex>
          memref.store %32, %arg2[%7] : memref<?xindex>
          %34 = memref.load %arg2[%7] : memref<?xindex>
          %35 = memref.load %arg2[%arg0] : memref<?xindex>
          %36 = arith.cmpi ult, %34, %35 : index
          scf.if %36 {
            %37 = memref.load %arg2[%7] : memref<?xindex>
            %38 = memref.load %arg2[%arg0] : memref<?xindex>
            memref.store %38, %arg2[%7] : memref<?xindex>
            memref.store %37, %arg2[%arg0] : memref<?xindex>
          }
        }
      }
    }
  }
  %5:3 = scf.while (%arg3 = %arg0, %arg4 = %2, %arg5 = %1) : (index, index, index) -> (index, index, index) {
    %6 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%6) %arg3, %arg4, %arg5 : index, index, index
  } do {
  ^bb0(%arg3: index, %arg4: index, %arg5: index):
    %6 = scf.while (%arg6 = %arg3) : (index) -> index {
      %16 = memref.load %arg2[%arg6] : memref<?xindex>
      %17 = memref.load %arg2[%arg5] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c1 : index
      scf.yield %16 : index
    }
    %7 = memref.load %arg2[%6] : memref<?xindex>
    %8 = memref.load %arg2[%arg5] : memref<?xindex>
    %9 = arith.cmpi eq, %7, %8 : index
    %10 = scf.while (%arg6 = %arg4) : (index) -> index {
      %16 = memref.load %arg2[%arg5] : memref<?xindex>
      %17 = memref.load %arg2[%arg6] : memref<?xindex>
      %18 = arith.cmpi ult, %16, %17 : index
      scf.condition(%18) %arg6 : index
    } do {
    ^bb0(%arg6: index):
      %16 = arith.addi %arg6, %c-1 : index
      scf.yield %16 : index
    }
    %11 = memref.load %arg2[%10] : memref<?xindex>
    %12 = memref.load %arg2[%arg5] : memref<?xindex>
    %13 = arith.cmpi eq, %11, %12 : index
    %14 = arith.cmpi ult, %6, %10 : index
    %15:3 = scf.if %14 -> (index, index, index) {
      %16 = memref.load %arg2[%6] : memref<?xindex>
      %17 = memref.load %arg2[%10] : memref<?xindex>
      memref.store %17, %arg2[%6] : memref<?xindex>
      memref.store %16, %arg2[%10] : memref<?xindex>
      %18 = arith.cmpi eq, %6, %arg5 : index
      %19 = scf.if %18 -> (index) {
        scf.yield %10 : index
      } else {
        %22 = arith.cmpi eq, %10, %arg5 : index
        %23 = arith.select %22, %6, %arg5 : index
        scf.yield %23 : index
      }
      %20 = arith.andi %9, %13 : i1
      %21:2 = scf.if %20 -> (index, index) {
        %22 = arith.addi %6, %c1 : index
        %23 = arith.subi %10, %c1 : index
        scf.yield %22, %23 : index, index
      } else {
        scf.yield %6, %10 : index, index
      }
      scf.yield %21#0, %21#1, %19 : index, index, index
    } else {
      scf.yield %6, %10, %arg5 : index, index, index
    }
    scf.yield %15#0, %15#1, %15#2 : index, index, index
  }
  return %5#2 : index
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %0:2 = scf.while (%arg3 = %arg0, %arg4 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.cmpi ult, %arg3, %arg4 : index
    scf.condition(%1) %arg3, %arg4 : index, index
  } do {
  ^bb0(%arg3: index, %arg4: index):
    %1 = arith.addi %arg3, %arg4 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    %4 = memref.load %arg2[%arg1] : memref<?xindex>
    %5 = memref.load %arg2[%2] : memref<?xindex>
    %6 = arith.cmpi ult, %4, %5 : index
    %7 = arith.select %6, %arg3, %3 : index
    %8 = arith.select %6, %2, %arg4 : index
    scf.yield %7, %8 : index, index
  }
  return %0#0 : index
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %0 = arith.cmpi uge, %arg3, %c2 : index
  scf.if %0 {
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    scf.if %4 {
      %5 = arith.shli %1, %c1 : index
      %6 = arith.addi %5, %c1 : index
      %7 = arith.addi %6, %arg0 : index
      %8 = arith.addi %5, %c2 : index
      %9 = arith.cmpi ult, %8, %arg3 : index
      %10:2 = scf.if %9 -> (index, index) {
        %12 = arith.addi %8, %arg0 : index
        %13 = memref.load %arg2[%7] : memref<?xindex>
        %14 = memref.load %arg2[%12] : memref<?xindex>
        %15 = arith.cmpi ult, %13, %14 : index
        %16 = arith.select %15, %8, %6 : index
        %17 = arith.select %15, %12, %7 : index
        scf.yield %16, %17 : index, index
      } else {
        scf.yield %6, %7 : index, index
      }
      %11:3 = scf.while (%arg4 = %arg1, %arg5 = %10#0, %arg6 = %10#1) : (index, index, index) -> (index, index, index) {
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi ult, %12, %13 : index
        scf.condition(%14) %arg4, %arg5, %arg6 : index, index, index
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: index):
        %12 = memref.load %arg2[%arg4] : memref<?xindex>
        %13 = memref.load %arg2[%arg6] : memref<?xindex>
        memref.store %13, %arg2[%arg4] : memref<?xindex>
        memref.store %12, %arg2[%arg6] : memref<?xindex>
        %14 = arith.cmpi uge, %3, %arg5 : index
        %15:2 = scf.if %14 -> (index, index) {
          %16 = arith.shli %arg5, %c1 : index
          %17 = arith.addi %16, %c1 : index
          %18 = arith.addi %17, %arg0 : index
          %19 = arith.addi %16, %c2 : index
          %20 = arith.cmpi ult, %19, %arg3 : index
          %21:2 = scf.if %20 -> (index, index) {
            %22 = arith.addi %19, %arg0 : index
            %23 = memref.load %arg2[%18] : memref<?xindex>
            %24 = memref.load %arg2[%22] : memref<?xindex>
            %25 = arith.cmpi ult, %23, %24 : index
            %26 = arith.select %25, %19, %17 : index
            %27 = arith.select %25, %22, %18 : index
            scf.yield %26, %27 : index, index
          } else {
            scf.yield %17, %18 : index, index
          }
          scf.yield %21#0, %21#1 : index, index
        } else {
          scf.yield %arg5, %arg6 : index, index
        }
        scf.yield %arg6, %15#0, %15#1 : index, index, index
      }
    }
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0:2 = scf.while (%arg4 = %arg0, %arg5 = %arg1) : (index, index) -> (index, index) {
    %1 = arith.addi %arg4, %c1 : index
    %2 = arith.cmpi ult, %1, %arg5 : index
    scf.condition(%2) %arg4, %arg5 : index, index
  } do {
  ^bb0(%arg4: index, %arg5: index):
    %1 = arith.subi %arg5, %arg4 : index
    %2 = arith.cmpi ule, %1, %c30 : index
    %3:2 = scf.if %2 -> (index, index) {
      func.call @_sparse_sort_stable_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
      scf.yield %arg4, %arg4 : index, index
    } else {
      %4 = arith.subi %arg3, %c1_i64 : i64
      %5 = arith.cmpi ule, %4, %c0_i64 : i64
      %6:2 = scf.if %5 -> (index, index) {
        func.call @_sparse_heap_sort_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> ()
        scf.yield %arg4, %arg4 : index, index
      } else {
        %7 = func.call @_sparse_partition_1_index(%arg4, %arg5, %arg2) : (index, index, memref<?xindex>) -> index
        %8 = arith.addi %7, %c1 : index
        %9 = arith.subi %7, %arg4 : index
        %10 = arith.subi %arg5, %7 : index
        %11 = arith.cmpi ule, %9, %10 : index
        %12 = arith.select %11, %8, %arg4 : index
        %13 = arith.select %11, %arg5, %7 : index
        scf.if %11 {
          %14 = arith.cmpi ne, %9, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%arg4, %7, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        } else {
          %14 = arith.cmpi ne, %10, %c0 : index
          scf.if %14 {
            func.call @_sparse_hybrid_qsort_1_index(%8, %arg5, %arg2, %4) : (index, index, memref<?xindex>, i64) -> ()
          }
        }
        scf.yield %12, %13 : index, index
      }
      scf.yield %6#0, %6#1 : index, index
    }
    scf.yield %3#0, %3#1 : index, index
  }
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %0 = memref.load %arg0[%c0] : memref<?xindex>
  %1 = memref.load %arg0[%c1] : memref<?xindex>
  %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = arith.index_cast %2 : i64 to index
  %4 = arith.subi %1, %c1 : index
  %5 = arith.cmpi ult, %0, %1 : index
  %6 = scf.if %5 -> (i1) {
    %21 = memref.load %arg1[%4] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg6 : index
    scf.yield %22 : i1
  } else {
    scf.yield %false : i1
  }
  %7 = arith.select %6, %4, %3 : index
  %8:3 = scf.if %6 -> (memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %3, %c1 : index
    memref.store %21, %arg0[%c1] : memref<?xindex>
    %22 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg1(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg1 : memref<?xindex>
    }
    memref.store %arg6, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %31 = arith.addi %30, %c1 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xindex>) {
      %36 = arith.muli %dim_0, %c2 : index
      %37 = memref.realloc %arg2(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg2 : memref<?xindex>
    }
    memref.store %c0, %33[%30] : memref<?xindex>
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %9 = arith.addi %7, %c1 : index
  %10 = memref.load %8#1[%7] : memref<?xindex>
  %11 = memref.load %8#1[%9] : memref<?xindex>
  %12 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %13 = arith.index_cast %12 : i64 to index
  %14 = arith.subi %11, %c1 : index
  %15 = arith.cmpi ult, %10, %11 : index
  %16 = scf.if %15 -> (i1) {
    %21 = memref.load %arg3[%14] : memref<?xindex>
    %22 = arith.cmpi eq, %21, %arg7 : index
    scf.yield %22 : i1
  } else {
    memref.store %13, %8#1[%7] : memref<?xindex>
    scf.yield %false : i1
  }
  %17 = arith.select %16, %14, %13 : index
  %18:3 = scf.if %16 -> (memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    scf.yield %arg3, %arg4, %8#2 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } else {
    %21 = arith.addi %13, %c1 : index
    memref.store %21, %8#1[%9] : memref<?xindex>
    %22 = llvm.extractvalue %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %23 = arith.index_cast %22 : i64 to index
    %dim = memref.dim %arg3, %c0 : memref<?xindex>
    %24 = arith.addi %23, %c1 : index
    %25 = arith.cmpi ugt, %24, %dim : index
    %26 = scf.if %25 -> (memref<?xindex>) {
      %36 = arith.muli %dim, %c2 : index
      %37 = memref.realloc %arg3(%36) : memref<?xindex> to memref<?xindex>
      scf.yield %37 : memref<?xindex>
    } else {
      scf.yield %arg3 : memref<?xindex>
    }
    memref.store %arg7, %26[%23] : memref<?xindex>
    %27 = arith.index_cast %24 : index to i64
    %28 = llvm.insertvalue %27, %8#2[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %29 = llvm.extractvalue %8#2[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %30 = arith.index_cast %29 : i64 to index
    %dim_0 = memref.dim %arg4, %c0 : memref<?xf32>
    %31 = arith.addi %30, %c32 : index
    %32 = arith.cmpi ugt, %31, %dim_0 : index
    %33 = scf.if %32 -> (memref<?xf32>) {
      %36 = scf.while (%arg10 = %dim_0) : (index) -> index {
        %38 = arith.muli %arg10, %c2 : index
        %39 = arith.cmpi ugt, %31, %38 : index
        scf.condition(%39) %38 : index
      } do {
      ^bb0(%arg10: index):
        scf.yield %arg10 : index
      }
      %37 = memref.realloc %arg4(%36) : memref<?xf32> to memref<?xf32>
      scf.yield %37 : memref<?xf32>
    } else {
      scf.yield %arg4 : memref<?xf32>
    }
    %subview = memref.subview %33[%30] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
    scf.for %arg10 = %c0 to %c32 step %c1 {
      memref.store %cst, %subview[%arg10] : memref<32xf32, strided<[1], offset: ?>>
    }
    %34 = arith.index_cast %31 : index to i64
    %35 = llvm.insertvalue %34, %28[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    scf.yield %26, %33, %35 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  %19 = arith.muli %17, %c32 : index
  %20 = arith.addi %19, %arg8 : index
  memref.store %arg9, %18#1[%20] : memref<?xf32>
  return %arg0, %8#0, %8#1, %18#0, %18#1, %18#2 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %0 = arith.subi %arg1, %arg0 : index
  %1 = arith.subi %0, %c2 : index
  %2 = arith.shrui %1, %c1 : index
  %3 = arith.addi %2, %c1 : index
  scf.for %arg3 = %c0 to %3 step %c1 {
    %5 = arith.subi %2, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    func.call @_sparse_shift_down_1_index(%arg0, %6, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
  }
  %4 = arith.subi %0, %c1 : index
  scf.for %arg3 = %c0 to %4 step %c1 {
    %5 = arith.subi %0, %arg3 : index
    %6 = arith.addi %arg0, %5 : index
    %7 = arith.subi %6, %c1 : index
    %8 = memref.load %arg2[%arg0] : memref<?xindex>
    %9 = memref.load %arg2[%7] : memref<?xindex>
    memref.store %9, %arg2[%arg0] : memref<?xindex>
    memref.store %8, %arg2[%7] : memref<?xindex>
    %10 = arith.subi %5, %c1 : index
    func.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %10) : (index, index, memref<?xindex>, index) -> ()
  }
  return
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %0 = arith.addi %arg0, %c1 : index
  cf.br ^bb1(%0 : index)
^bb1(%1: index):  // 2 preds: ^bb0, ^bb5
  %2 = arith.cmpi slt, %1, %arg1 : index
  cf.cond_br %2, ^bb2, ^bb6
^bb2:  // pred: ^bb1
  %3 = call @_sparse_binary_search_1_index(%arg0, %1, %arg2) : (index, index, memref<?xindex>) -> index
  %4 = memref.load %arg2[%1] : memref<?xindex>
  %5 = arith.subi %1, %3 : index
  cf.br ^bb3(%c0 : index)
^bb3(%6: index):  // 2 preds: ^bb2, ^bb4
  %7 = arith.cmpi slt, %6, %5 : index
  cf.cond_br %7, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %8 = arith.subi %1, %6 : index
  %9 = arith.subi %8, %c1 : index
  %10 = memref.load %arg2[%9] : memref<?xindex>
  memref.store %10, %arg2[%8] : memref<?xindex>
  %11 = arith.addi %6, %c1 : index
  cf.br ^bb3(%11 : index)
^bb5:  // pred: ^bb3
  memref.store %4, %arg2[%3] : memref<?xindex>
  %12 = arith.addi %1, %c1 : index
  cf.br ^bb1(%12 : index)
^bb6:  // pred: ^bb1
  return
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %alloc = memref.alloc() : memref<16xindex>
  %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
  %alloc_0 = memref.alloc() : memref<16xindex>
  %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
  %alloc_2 = memref.alloc() : memref<16xindex>
  %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
  %alloc_4 = memref.alloc() : memref<16xindex>
  %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
  %alloc_6 = memref.alloc() : memref<16xf32>
  %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c0] : memref<16xindex>
  %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc_2[%c0] : memref<16xindex>
  %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c1] : memref<16xindex>
  %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %alloc_8 = memref.alloc() : memref<32xf32>
  %alloc_9 = memref.alloc() : memref<32xi1>
  %alloc_10 = memref.alloc() : memref<32xindex>
  %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
  scf.for %arg12 = %c0 to %c32 step %c1 {
    memref.store %cst, %alloc_8[%arg12] : memref<32xf32>
  }
  scf.for %arg12 = %c0 to %c32 step %c1 {
    memref.store %false, %alloc_9[%arg12] : memref<32xi1>
  }
  %12 = memref.load %arg0[%c0] : memref<?xindex>
  %13 = memref.load %arg0[%c1] : memref<?xindex>
  %14:6 = scf.for %arg12 = %12 to %13 step %c1 iter_args(%arg13 = %cast, %arg14 = %cast_1, %arg15 = %cast_3, %arg16 = %cast_5, %arg17 = %cast_7, %arg18 = %11) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %26 = memref.load %arg1[%arg12] : memref<?xindex>
    %27 = memref.load %arg2[%arg12] : memref<?xindex>
    %28 = arith.addi %arg12, %c1 : index
    %29 = memref.load %arg2[%28] : memref<?xindex>
    %30:6 = scf.for %arg19 = %27 to %29 step %c1 iter_args(%arg20 = %arg13, %arg21 = %arg14, %arg22 = %arg15, %arg23 = %arg16, %arg24 = %arg17, %arg25 = %arg18) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
      %31 = memref.load %arg3[%arg19] : memref<?xindex>
      %32 = memref.load %arg4[%arg19] : memref<?xindex>
      %33 = arith.addi %arg19, %c1 : index
      %34 = memref.load %arg4[%33] : memref<?xindex>
      %35 = scf.for %arg26 = %32 to %34 step %c1 iter_args(%arg27 = %c0) -> (index) {
        %40 = memref.load %arg5[%arg26] : memref<?xindex>
        %41 = memref.load %arg6[%arg26] : memref<?xf32>
        %42 = scf.for %arg28 = %c0 to %c32 step %c1 iter_args(%arg29 = %arg27) -> (index) {
          %43 = arith.muli %40, %c32 : index
          %44 = arith.addi %43, %arg28 : index
          %45 = memref.load %alloc_8[%arg28] : memref<32xf32>
          %46 = memref.load %arg8[%44] : memref<?xf32>
          %47 = arith.mulf %41, %46 : f32
          %48 = arith.addf %45, %47 : f32
          %49 = memref.load %alloc_9[%arg28] : memref<32xi1>
          %50 = arith.cmpi eq, %49, %false : i1
          %51 = scf.if %50 -> (index) {
            memref.store %true, %alloc_9[%arg28] : memref<32xi1>
            memref.store %arg28, %alloc_10[%arg29] : memref<32xindex>
            %52 = arith.addi %arg29, %c1 : index
            scf.yield %52 : index
          } else {
            scf.yield %arg29 : index
          }
          memref.store %48, %alloc_8[%arg28] : memref<32xf32>
          scf.yield %51 : index
        } {"Emitted from" = "linalg.generic"}
        scf.yield %42 : index
      } {"Emitted from" = "linalg.generic"}
      %36 = arith.index_cast %35 : index to i64
      %37 = math.ctlz %36 : i64
      %38 = arith.subi %c64_i64, %37 : i64
      func.call @_sparse_hybrid_qsort_1_index(%c0, %35, %cast_11, %38) : (index, index, memref<?xindex>, i64) -> ()
      %39:6 = scf.for %arg26 = %c0 to %35 step %c1 iter_args(%arg27 = %arg20, %arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
        %40 = memref.load %alloc_10[%arg26] : memref<32xindex>
        %41 = memref.load %alloc_8[%40] : memref<32xf32>
        %42:6 = func.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg27, %arg28, %arg29, %arg30, %arg31, %arg32, %26, %31, %40, %41) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
        memref.store %cst, %alloc_8[%40] : memref<32xf32>
        memref.store %false, %alloc_9[%40] : memref<32xi1>
        scf.yield %42#0, %42#1, %42#2, %42#3, %42#4, %42#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
      }
      scf.yield %39#0, %39#1, %39#2, %39#3, %39#4, %39#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    } {"Emitted from" = "linalg.generic"}
    scf.yield %30#0, %30#1, %30#2, %30#3, %30#4, %30#5 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  } {"Emitted from" = "linalg.generic"}
  memref.dealloc %alloc_8 : memref<32xf32>
  memref.dealloc %alloc_9 : memref<32xi1>
  memref.dealloc %alloc_10 : memref<32xindex>
  %15 = llvm.extractvalue %14#5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %16 = arith.index_cast %15 : i64 to index
  %17 = memref.load %14#2[%c0] : memref<?xindex>
  %18 = scf.for %arg12 = %c1 to %16 step %c1 iter_args(%arg13 = %17) -> (index) {
    %26 = memref.load %14#2[%arg12] : memref<?xindex>
    %27 = arith.cmpi eq, %26, %c0 : index
    %28 = arith.select %27, %arg13, %26 : index
    scf.if %27 {
      memref.store %arg13, %14#2[%arg12] : memref<?xindex>
    }
    scf.yield %28 : index
  }
  %alloc_12 = memref.alloc() : memref<4096xf32>
  %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
  %19 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %20 = llvm.insertvalue %c0_i64, %19[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %21 = llvm.insertvalue %c128_i64, %20[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %c32_i64, %21[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  scf.for %arg12 = %c0 to %c4096 step %c1 {
    memref.store %cst, %alloc_12[%arg12] : memref<4096xf32>
  }
  %23 = llvm.insertvalue %c4096_i64, %22[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %24 = memref.load %14#0[%c0] : memref<?xindex>
  %25 = memref.load %14#0[%c1] : memref<?xindex>
  omp.parallel   {
    omp.wsloop   for  (%arg12) : index = (%24) to (%25) step (%c1) {
      %26 = memref.load %14#1[%arg12] : memref<?xindex>
      %27 = memref.load %14#2[%arg12] : memref<?xindex>
      %28 = arith.addi %arg12, %c1 : index
      %29 = memref.load %14#2[%28] : memref<?xindex>
      omp.parallel   {
        omp.wsloop   for  (%arg13) : index = (%27) to (%29) step (%c1) {
          %30 = memref.load %14#3[%arg13] : memref<?xindex>
          omp.parallel   {
            omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
              %31 = arith.muli %arg13, %c32 : index
              %32 = arith.addi %31, %arg14 : index
              %33 = arith.muli %30, %c32 : index
              %34 = arith.addi %33, %arg14 : index
              %35 = arith.muli %26, %c32 : index
              %36 = arith.addi %35, %arg14 : index
              %37 = memref.load %alloc_12[%36] : memref<4096xf32>
              %38 = memref.load %14#4[%32] : memref<?xf32>
              %39 = memref.load %arg10[%34] : memref<?xf32>
              %40 = arith.mulf %38, %39 : f32
              %41 = arith.addf %37, %40 : f32
              memref.store %41, %alloc_12[%36] : memref<4096xf32>
              omp.yield
            }
            omp.terminator
          }
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %cast_13, %23 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %0 = arith.addi %arg0, %arg1 : index
  %1 = arith.shrui %0, %c1 : index
  %2 = arith.subi %arg1, %c1 : index
  %3 = arith.subi %arg1, %arg0 : index
  %4 = arith.cmpi ult, %3, %c1000 : index
  cf.cond_br %4, ^bb1, ^bb8
^bb1:  // pred: ^bb0
  %5 = memref.load %arg2[%1] : memref<?xindex>
  %6 = memref.load %arg2[%arg0] : memref<?xindex>
  %7 = arith.cmpi ult, %5, %6 : index
  cf.cond_br %7, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %8 = memref.load %arg2[%1] : memref<?xindex>
  %9 = memref.load %arg2[%arg0] : memref<?xindex>
  memref.store %9, %arg2[%1] : memref<?xindex>
  memref.store %8, %arg2[%arg0] : memref<?xindex>
  cf.br ^bb3
^bb3:  // 2 preds: ^bb1, ^bb2
  %10 = memref.load %arg2[%2] : memref<?xindex>
  %11 = memref.load %arg2[%1] : memref<?xindex>
  %12 = arith.cmpi ult, %10, %11 : index
  cf.cond_br %12, ^bb4, ^bb7
^bb4:  // pred: ^bb3
  %13 = memref.load %arg2[%2] : memref<?xindex>
  %14 = memref.load %arg2[%1] : memref<?xindex>
  memref.store %14, %arg2[%2] : memref<?xindex>
  memref.store %13, %arg2[%1] : memref<?xindex>
  %15 = memref.load %arg2[%1] : memref<?xindex>
  %16 = memref.load %arg2[%arg0] : memref<?xindex>
  %17 = arith.cmpi ult, %15, %16 : index
  cf.cond_br %17, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %18 = memref.load %arg2[%1] : memref<?xindex>
  %19 = memref.load %arg2[%arg0] : memref<?xindex>
  memref.store %19, %arg2[%1] : memref<?xindex>
  memref.store %18, %arg2[%arg0] : memref<?xindex>
  cf.br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  cf.br ^bb7
^bb7:  // 2 preds: ^bb3, ^bb6
  cf.br ^bb29
^bb8:  // pred: ^bb0
  %20 = arith.addi %arg0, %arg1 : index
  %21 = arith.shrui %20, %c1 : index
  %22 = arith.addi %1, %arg1 : index
  %23 = arith.shrui %22, %c1 : index
  %24 = memref.load %arg2[%21] : memref<?xindex>
  %25 = memref.load %arg2[%arg0] : memref<?xindex>
  %26 = arith.cmpi ult, %24, %25 : index
  cf.cond_br %26, ^bb9, ^bb10
^bb9:  // pred: ^bb8
  %27 = memref.load %arg2[%21] : memref<?xindex>
  %28 = memref.load %arg2[%arg0] : memref<?xindex>
  memref.store %28, %arg2[%21] : memref<?xindex>
  memref.store %27, %arg2[%arg0] : memref<?xindex>
  cf.br ^bb10
^bb10:  // 2 preds: ^bb8, ^bb9
  %29 = memref.load %arg2[%1] : memref<?xindex>
  %30 = memref.load %arg2[%21] : memref<?xindex>
  %31 = arith.cmpi ult, %29, %30 : index
  cf.cond_br %31, ^bb11, ^bb14
^bb11:  // pred: ^bb10
  %32 = memref.load %arg2[%1] : memref<?xindex>
  %33 = memref.load %arg2[%21] : memref<?xindex>
  memref.store %33, %arg2[%1] : memref<?xindex>
  memref.store %32, %arg2[%21] : memref<?xindex>
  %34 = memref.load %arg2[%21] : memref<?xindex>
  %35 = memref.load %arg2[%arg0] : memref<?xindex>
  %36 = arith.cmpi ult, %34, %35 : index
  cf.cond_br %36, ^bb12, ^bb13
^bb12:  // pred: ^bb11
  %37 = memref.load %arg2[%21] : memref<?xindex>
  %38 = memref.load %arg2[%arg0] : memref<?xindex>
  memref.store %38, %arg2[%21] : memref<?xindex>
  memref.store %37, %arg2[%arg0] : memref<?xindex>
  cf.br ^bb13
^bb13:  // 2 preds: ^bb11, ^bb12
  cf.br ^bb14
^bb14:  // 2 preds: ^bb10, ^bb13
  %39 = memref.load %arg2[%23] : memref<?xindex>
  %40 = memref.load %arg2[%1] : memref<?xindex>
  %41 = arith.cmpi ult, %39, %40 : index
  cf.cond_br %41, ^bb15, ^bb20
^bb15:  // pred: ^bb14
  %42 = memref.load %arg2[%23] : memref<?xindex>
  %43 = memref.load %arg2[%1] : memref<?xindex>
  memref.store %43, %arg2[%23] : memref<?xindex>
  memref.store %42, %arg2[%1] : memref<?xindex>
  %44 = memref.load %arg2[%1] : memref<?xindex>
  %45 = memref.load %arg2[%21] : memref<?xindex>
  %46 = arith.cmpi ult, %44, %45 : index
  cf.cond_br %46, ^bb16, ^bb19
^bb16:  // pred: ^bb15
  %47 = memref.load %arg2[%1] : memref<?xindex>
  %48 = memref.load %arg2[%21] : memref<?xindex>
  memref.store %48, %arg2[%1] : memref<?xindex>
  memref.store %47, %arg2[%21] : memref<?xindex>
  %49 = memref.load %arg2[%21] : memref<?xindex>
  %50 = memref.load %arg2[%arg0] : memref<?xindex>
  %51 = arith.cmpi ult, %49, %50 : index
  cf.cond_br %51, ^bb17, ^bb18
^bb17:  // pred: ^bb16
  %52 = memref.load %arg2[%21] : memref<?xindex>
  %53 = memref.load %arg2[%arg0] : memref<?xindex>
  memref.store %53, %arg2[%21] : memref<?xindex>
  memref.store %52, %arg2[%arg0] : memref<?xindex>
  cf.br ^bb18
^bb18:  // 2 preds: ^bb16, ^bb17
  cf.br ^bb19
^bb19:  // 2 preds: ^bb15, ^bb18
  cf.br ^bb20
^bb20:  // 2 preds: ^bb14, ^bb19
  %54 = memref.load %arg2[%2] : memref<?xindex>
  %55 = memref.load %arg2[%23] : memref<?xindex>
  %56 = arith.cmpi ult, %54, %55 : index
  cf.cond_br %56, ^bb21, ^bb28
^bb21:  // pred: ^bb20
  %57 = memref.load %arg2[%2] : memref<?xindex>
  %58 = memref.load %arg2[%23] : memref<?xindex>
  memref.store %58, %arg2[%2] : memref<?xindex>
  memref.store %57, %arg2[%23] : memref<?xindex>
  %59 = memref.load %arg2[%23] : memref<?xindex>
  %60 = memref.load %arg2[%1] : memref<?xindex>
  %61 = arith.cmpi ult, %59, %60 : index
  cf.cond_br %61, ^bb22, ^bb27
^bb22:  // pred: ^bb21
  %62 = memref.load %arg2[%23] : memref<?xindex>
  %63 = memref.load %arg2[%1] : memref<?xindex>
  memref.store %63, %arg2[%23] : memref<?xindex>
  memref.store %62, %arg2[%1] : memref<?xindex>
  %64 = memref.load %arg2[%1] : memref<?xindex>
  %65 = memref.load %arg2[%21] : memref<?xindex>
  %66 = arith.cmpi ult, %64, %65 : index
  cf.cond_br %66, ^bb23, ^bb26
^bb23:  // pred: ^bb22
  %67 = memref.load %arg2[%1] : memref<?xindex>
  %68 = memref.load %arg2[%21] : memref<?xindex>
  memref.store %68, %arg2[%1] : memref<?xindex>
  memref.store %67, %arg2[%21] : memref<?xindex>
  %69 = memref.load %arg2[%21] : memref<?xindex>
  %70 = memref.load %arg2[%arg0] : memref<?xindex>
  %71 = arith.cmpi ult, %69, %70 : index
  cf.cond_br %71, ^bb24, ^bb25
^bb24:  // pred: ^bb23
  %72 = memref.load %arg2[%21] : memref<?xindex>
  %73 = memref.load %arg2[%arg0] : memref<?xindex>
  memref.store %73, %arg2[%21] : memref<?xindex>
  memref.store %72, %arg2[%arg0] : memref<?xindex>
  cf.br ^bb25
^bb25:  // 2 preds: ^bb23, ^bb24
  cf.br ^bb26
^bb26:  // 2 preds: ^bb22, ^bb25
  cf.br ^bb27
^bb27:  // 2 preds: ^bb21, ^bb26
  cf.br ^bb28
^bb28:  // 2 preds: ^bb20, ^bb27
  cf.br ^bb29
^bb29:  // 2 preds: ^bb7, ^bb28
  cf.br ^bb30(%arg0, %2, %1 : index, index, index)
^bb30(%74: index, %75: index, %76: index):  // 2 preds: ^bb29, ^bb49
  %77 = arith.cmpi ult, %74, %75 : index
  cf.cond_br %77, ^bb31(%74, %75, %76 : index, index, index), ^bb50
^bb31(%78: index, %79: index, %80: index):  // pred: ^bb30
  cf.br ^bb32(%78 : index)
^bb32(%81: index):  // 2 preds: ^bb31, ^bb33
  %82 = memref.load %arg2[%81] : memref<?xindex>
  %83 = memref.load %arg2[%80] : memref<?xindex>
  %84 = arith.cmpi ult, %82, %83 : index
  cf.cond_br %84, ^bb33(%81 : index), ^bb34
^bb33(%85: index):  // pred: ^bb32
  %86 = arith.addi %85, %c1 : index
  cf.br ^bb32(%86 : index)
^bb34:  // pred: ^bb32
  %87 = memref.load %arg2[%81] : memref<?xindex>
  %88 = memref.load %arg2[%80] : memref<?xindex>
  %89 = arith.cmpi eq, %87, %88 : index
  cf.br ^bb35(%79 : index)
^bb35(%90: index):  // 2 preds: ^bb34, ^bb36
  %91 = memref.load %arg2[%80] : memref<?xindex>
  %92 = memref.load %arg2[%90] : memref<?xindex>
  %93 = arith.cmpi ult, %91, %92 : index
  cf.cond_br %93, ^bb36(%90 : index), ^bb37
^bb36(%94: index):  // pred: ^bb35
  %95 = arith.addi %94, %c-1 : index
  cf.br ^bb35(%95 : index)
^bb37:  // pred: ^bb35
  %96 = memref.load %arg2[%90] : memref<?xindex>
  %97 = memref.load %arg2[%80] : memref<?xindex>
  %98 = arith.cmpi eq, %96, %97 : index
  %99 = arith.cmpi ult, %81, %90 : index
  cf.cond_br %99, ^bb38, ^bb47
^bb38:  // pred: ^bb37
  %100 = memref.load %arg2[%81] : memref<?xindex>
  %101 = memref.load %arg2[%90] : memref<?xindex>
  memref.store %101, %arg2[%81] : memref<?xindex>
  memref.store %100, %arg2[%90] : memref<?xindex>
  %102 = arith.cmpi eq, %81, %80 : index
  cf.cond_br %102, ^bb39, ^bb40
^bb39:  // pred: ^bb38
  cf.br ^bb41(%90 : index)
^bb40:  // pred: ^bb38
  %103 = arith.cmpi eq, %90, %80 : index
  %104 = arith.select %103, %81, %80 : index
  cf.br ^bb41(%104 : index)
^bb41(%105: index):  // 2 preds: ^bb39, ^bb40
  cf.br ^bb42
^bb42:  // pred: ^bb41
  %106 = arith.andi %89, %98 : i1
  cf.cond_br %106, ^bb43, ^bb44
^bb43:  // pred: ^bb42
  %107 = arith.addi %81, %c1 : index
  %108 = arith.subi %90, %c1 : index
  cf.br ^bb45(%107, %108 : index, index)
^bb44:  // pred: ^bb42
  cf.br ^bb45(%81, %90 : index, index)
^bb45(%109: index, %110: index):  // 2 preds: ^bb43, ^bb44
  cf.br ^bb46
^bb46:  // pred: ^bb45
  cf.br ^bb48(%109, %110, %105 : index, index, index)
^bb47:  // pred: ^bb37
  cf.br ^bb48(%81, %90, %80 : index, index, index)
^bb48(%111: index, %112: index, %113: index):  // 2 preds: ^bb46, ^bb47
  cf.br ^bb49
^bb49:  // pred: ^bb48
  cf.br ^bb30(%111, %112, %113 : index, index, index)
^bb50:  // pred: ^bb30
  return %76 : index
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %c1 = arith.constant 1 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb2
  %2 = arith.cmpi ult, %0, %1 : index
  cf.cond_br %2, ^bb2(%0, %1 : index, index), ^bb3
^bb2(%3: index, %4: index):  // pred: ^bb1
  %5 = arith.addi %3, %4 : index
  %6 = arith.shrui %5, %c1 : index
  %7 = arith.addi %6, %c1 : index
  %8 = memref.load %arg2[%arg1] : memref<?xindex>
  %9 = memref.load %arg2[%6] : memref<?xindex>
  %10 = arith.cmpi ult, %8, %9 : index
  %11 = arith.select %10, %3, %7 : index
  %12 = arith.select %10, %6, %4 : index
  cf.br ^bb1(%11, %12 : index, index)
^bb3:  // pred: ^bb1
  return %0 : index
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %0 = arith.cmpi uge, %arg3, %c2 : index
  cf.cond_br %0, ^bb1, ^bb19
^bb1:  // pred: ^bb0
  %1 = arith.subi %arg1, %arg0 : index
  %2 = arith.subi %arg3, %c2 : index
  %3 = arith.shrui %2, %c1 : index
  %4 = arith.cmpi uge, %3, %1 : index
  cf.cond_br %4, ^bb2, ^bb18
^bb2:  // pred: ^bb1
  %5 = arith.shli %1, %c1 : index
  %6 = arith.addi %5, %c1 : index
  %7 = arith.addi %6, %arg0 : index
  %8 = arith.addi %5, %c2 : index
  %9 = arith.cmpi ult, %8, %arg3 : index
  cf.cond_br %9, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  %10 = arith.addi %8, %arg0 : index
  %11 = memref.load %arg2[%7] : memref<?xindex>
  %12 = memref.load %arg2[%10] : memref<?xindex>
  %13 = arith.cmpi ult, %11, %12 : index
  %14 = arith.select %13, %8, %6 : index
  %15 = arith.select %13, %10, %7 : index
  cf.br ^bb5(%14, %15 : index, index)
^bb4:  // pred: ^bb2
  cf.br ^bb5(%6, %7 : index, index)
^bb5(%16: index, %17: index):  // 2 preds: ^bb3, ^bb4
  cf.br ^bb6
^bb6:  // pred: ^bb5
  cf.br ^bb7(%arg1, %16, %17 : index, index, index)
^bb7(%18: index, %19: index, %20: index):  // 2 preds: ^bb6, ^bb16
  %21 = memref.load %arg2[%18] : memref<?xindex>
  %22 = memref.load %arg2[%20] : memref<?xindex>
  %23 = arith.cmpi ult, %21, %22 : index
  cf.cond_br %23, ^bb8(%18, %19, %20 : index, index, index), ^bb17
^bb8(%24: index, %25: index, %26: index):  // pred: ^bb7
  %27 = memref.load %arg2[%24] : memref<?xindex>
  %28 = memref.load %arg2[%26] : memref<?xindex>
  memref.store %28, %arg2[%24] : memref<?xindex>
  memref.store %27, %arg2[%26] : memref<?xindex>
  %29 = arith.cmpi uge, %3, %25 : index
  cf.cond_br %29, ^bb9, ^bb14
^bb9:  // pred: ^bb8
  %30 = arith.shli %25, %c1 : index
  %31 = arith.addi %30, %c1 : index
  %32 = arith.addi %31, %arg0 : index
  %33 = arith.addi %30, %c2 : index
  %34 = arith.cmpi ult, %33, %arg3 : index
  cf.cond_br %34, ^bb10, ^bb11
^bb10:  // pred: ^bb9
  %35 = arith.addi %33, %arg0 : index
  %36 = memref.load %arg2[%32] : memref<?xindex>
  %37 = memref.load %arg2[%35] : memref<?xindex>
  %38 = arith.cmpi ult, %36, %37 : index
  %39 = arith.select %38, %33, %31 : index
  %40 = arith.select %38, %35, %32 : index
  cf.br ^bb12(%39, %40 : index, index)
^bb11:  // pred: ^bb9
  cf.br ^bb12(%31, %32 : index, index)
^bb12(%41: index, %42: index):  // 2 preds: ^bb10, ^bb11
  cf.br ^bb13
^bb13:  // pred: ^bb12
  cf.br ^bb15(%41, %42 : index, index)
^bb14:  // pred: ^bb8
  cf.br ^bb15(%25, %26 : index, index)
^bb15(%43: index, %44: index):  // 2 preds: ^bb13, ^bb14
  cf.br ^bb16
^bb16:  // pred: ^bb15
  cf.br ^bb7(%26, %43, %44 : index, index, index)
^bb17:  // pred: ^bb7
  cf.br ^bb18
^bb18:  // 2 preds: ^bb1, ^bb17
  cf.br ^bb19
^bb19:  // 2 preds: ^bb0, ^bb18
  return
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb17
  %2 = arith.addi %0, %c1 : index
  %3 = arith.cmpi ult, %2, %1 : index
  cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb18
^bb2(%4: index, %5: index):  // pred: ^bb1
  %6 = arith.subi %5, %4 : index
  %7 = arith.cmpi ule, %6, %c30 : index
  cf.cond_br %7, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb16(%4, %4 : index, index)
^bb4:  // pred: ^bb2
  %8 = arith.subi %arg3, %c1_i64 : i64
  %9 = arith.cmpi ule, %8, %c0_i64 : i64
  cf.cond_br %9, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb14(%4, %4 : index, index)
^bb6:  // pred: ^bb4
  %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
  %11 = arith.addi %10, %c1 : index
  %12 = arith.subi %10, %4 : index
  %13 = arith.subi %5, %10 : index
  %14 = arith.cmpi ule, %12, %13 : index
  %15 = arith.select %14, %11, %4 : index
  %16 = arith.select %14, %5, %10 : index
  cf.cond_br %14, ^bb7, ^bb10
^bb7:  // pred: ^bb6
  %17 = arith.cmpi ne, %12, %c0 : index
  cf.cond_br %17, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  call @_sparse_hybrid_qsort_1_index(%4, %10, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb9
^bb9:  // 2 preds: ^bb7, ^bb8
  cf.br ^bb13
^bb10:  // pred: ^bb6
  %18 = arith.cmpi ne, %13, %c0 : index
  cf.cond_br %18, ^bb11, ^bb12
^bb11:  // pred: ^bb10
  call @_sparse_hybrid_qsort_1_index(%11, %5, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb12
^bb12:  // 2 preds: ^bb10, ^bb11
  cf.br ^bb13
^bb13:  // 2 preds: ^bb9, ^bb12
  cf.br ^bb14(%15, %16 : index, index)
^bb14(%19: index, %20: index):  // 2 preds: ^bb5, ^bb13
  cf.br ^bb15
^bb15:  // pred: ^bb14
  cf.br ^bb16(%19, %20 : index, index)
^bb16(%21: index, %22: index):  // 2 preds: ^bb3, ^bb15
  cf.br ^bb17
^bb17:  // pred: ^bb16
  cf.br ^bb1(%21, %22 : index, index)
^bb18:  // pred: ^bb1
  return
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %0 = memref.load %arg0[%c0] : memref<?xindex>
  %1 = memref.load %arg0[%c1] : memref<?xindex>
  %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = arith.index_cast %2 : i64 to index
  %4 = arith.subi %1, %c1 : index
  %5 = arith.cmpi ult, %0, %1 : index
  cf.cond_br %5, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %6 = memref.load %arg1[%4] : memref<?xindex>
  %7 = arith.cmpi eq, %6, %arg6 : index
  cf.br ^bb3(%7 : i1)
^bb2:  // pred: ^bb0
  cf.br ^bb3(%false : i1)
^bb3(%8: i1):  // 2 preds: ^bb1, ^bb2
  cf.br ^bb4
^bb4:  // pred: ^bb3
  %9 = arith.select %8, %4, %3 : index
  cf.cond_br %8, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  cf.br ^bb15(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb6:  // pred: ^bb4
  %10 = arith.addi %3, %c1 : index
  memref.store %10, %arg0[%c1] : memref<?xindex>
  %11 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %12 = arith.index_cast %11 : i64 to index
  %dim = memref.dim %arg1, %c0 : memref<?xindex>
  %13 = arith.addi %12, %c1 : index
  %14 = arith.cmpi ugt, %13, %dim : index
  cf.cond_br %14, ^bb7, ^bb8
^bb7:  // pred: ^bb6
  %15 = arith.muli %dim, %c2 : index
  %16 = memref.realloc %arg1(%15) : memref<?xindex> to memref<?xindex>
  cf.br ^bb9(%16 : memref<?xindex>)
^bb8:  // pred: ^bb6
  cf.br ^bb9(%arg1 : memref<?xindex>)
^bb9(%17: memref<?xindex>):  // 2 preds: ^bb7, ^bb8
  cf.br ^bb10
^bb10:  // pred: ^bb9
  memref.store %arg6, %17[%12] : memref<?xindex>
  %18 = arith.index_cast %13 : index to i64
  %19 = llvm.insertvalue %18, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %20 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %21 = arith.index_cast %20 : i64 to index
  %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
  %22 = arith.addi %21, %c1 : index
  %23 = arith.cmpi ugt, %22, %dim_0 : index
  cf.cond_br %23, ^bb11, ^bb12
^bb11:  // pred: ^bb10
  %24 = arith.muli %dim_0, %c2 : index
  %25 = memref.realloc %arg2(%24) : memref<?xindex> to memref<?xindex>
  cf.br ^bb13(%25 : memref<?xindex>)
^bb12:  // pred: ^bb10
  cf.br ^bb13(%arg2 : memref<?xindex>)
^bb13(%26: memref<?xindex>):  // 2 preds: ^bb11, ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  memref.store %c0, %26[%21] : memref<?xindex>
  %27 = arith.index_cast %22 : index to i64
  %28 = llvm.insertvalue %27, %19[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb15(%17, %26, %28 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb15(%29: memref<?xindex>, %30: memref<?xindex>, %31: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb14
  cf.br ^bb16
^bb16:  // pred: ^bb15
  %32 = arith.addi %9, %c1 : index
  %33 = memref.load %30[%9] : memref<?xindex>
  %34 = memref.load %30[%32] : memref<?xindex>
  %35 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %36 = arith.index_cast %35 : i64 to index
  %37 = arith.subi %34, %c1 : index
  %38 = arith.cmpi ult, %33, %34 : index
  cf.cond_br %38, ^bb17, ^bb18
^bb17:  // pred: ^bb16
  %39 = memref.load %arg3[%37] : memref<?xindex>
  %40 = arith.cmpi eq, %39, %arg7 : index
  cf.br ^bb19(%40 : i1)
^bb18:  // pred: ^bb16
  memref.store %36, %30[%9] : memref<?xindex>
  cf.br ^bb19(%false : i1)
^bb19(%41: i1):  // 2 preds: ^bb17, ^bb18
  cf.br ^bb20
^bb20:  // pred: ^bb19
  %42 = arith.select %41, %37, %36 : index
  cf.cond_br %41, ^bb21, ^bb22
^bb21:  // pred: ^bb20
  cf.br ^bb36(%arg3, %arg4, %31 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb22:  // pred: ^bb20
  %43 = arith.addi %36, %c1 : index
  memref.store %43, %30[%32] : memref<?xindex>
  %44 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %45 = arith.index_cast %44 : i64 to index
  %dim_1 = memref.dim %arg3, %c0 : memref<?xindex>
  %46 = arith.addi %45, %c1 : index
  %47 = arith.cmpi ugt, %46, %dim_1 : index
  cf.cond_br %47, ^bb23, ^bb24
^bb23:  // pred: ^bb22
  %48 = arith.muli %dim_1, %c2 : index
  %49 = memref.realloc %arg3(%48) : memref<?xindex> to memref<?xindex>
  cf.br ^bb25(%49 : memref<?xindex>)
^bb24:  // pred: ^bb22
  cf.br ^bb25(%arg3 : memref<?xindex>)
^bb25(%50: memref<?xindex>):  // 2 preds: ^bb23, ^bb24
  cf.br ^bb26
^bb26:  // pred: ^bb25
  memref.store %arg7, %50[%45] : memref<?xindex>
  %51 = arith.index_cast %46 : index to i64
  %52 = llvm.insertvalue %51, %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %53 = llvm.extractvalue %31[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %54 = arith.index_cast %53 : i64 to index
  %dim_2 = memref.dim %arg4, %c0 : memref<?xf32>
  %55 = arith.addi %54, %c32 : index
  %56 = arith.cmpi ugt, %55, %dim_2 : index
  cf.cond_br %56, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  cf.br ^bb28(%dim_2 : index)
^bb28(%57: index):  // 2 preds: ^bb27, ^bb28
  %58 = arith.muli %57, %c2 : index
  %59 = arith.cmpi ugt, %55, %58 : index
  cf.cond_br %59, ^bb28(%58 : index), ^bb29
^bb29:  // pred: ^bb28
  %60 = memref.realloc %arg4(%58) : memref<?xf32> to memref<?xf32>
  cf.br ^bb31(%60 : memref<?xf32>)
^bb30:  // pred: ^bb26
  cf.br ^bb31(%arg4 : memref<?xf32>)
^bb31(%61: memref<?xf32>):  // 2 preds: ^bb29, ^bb30
  cf.br ^bb32
^bb32:  // pred: ^bb31
  %subview = memref.subview %61[%54] [32] [1] : memref<?xf32> to memref<32xf32, strided<[1], offset: ?>>
  cf.br ^bb33(%c0 : index)
^bb33(%62: index):  // 2 preds: ^bb32, ^bb34
  %63 = arith.cmpi slt, %62, %c32 : index
  cf.cond_br %63, ^bb34, ^bb35
^bb34:  // pred: ^bb33
  memref.store %cst, %subview[%62] : memref<32xf32, strided<[1], offset: ?>>
  %64 = arith.addi %62, %c1 : index
  cf.br ^bb33(%64 : index)
^bb35:  // pred: ^bb33
  %65 = arith.index_cast %55 : index to i64
  %66 = llvm.insertvalue %65, %52[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb36(%50, %61, %66 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb36(%67: memref<?xindex>, %68: memref<?xf32>, %69: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb21, ^bb35
  cf.br ^bb37
^bb37:  // pred: ^bb36
  %70 = arith.muli %42, %c32 : index
  %71 = arith.addi %70, %arg8 : index
  memref.store %arg9, %68[%71] : memref<?xf32>
  return %arg0, %29, %30, %67, %68, %69 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %0 = arith.subi %arg1, %arg0 : index
  %1 = arith.subi %0, %c2 : index
  %2 = arith.shrui %1, %c1 : index
  %3 = arith.addi %2, %c1 : index
  cf.br ^bb1(%c0 : index)
^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
  %5 = arith.cmpi slt, %4, %3 : index
  cf.cond_br %5, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %6 = arith.subi %2, %4 : index
  %7 = arith.addi %arg0, %6 : index
  call @_sparse_shift_down_1_index(%arg0, %7, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
  %8 = arith.addi %4, %c1 : index
  cf.br ^bb1(%8 : index)
^bb3:  // pred: ^bb1
  %9 = arith.subi %0, %c1 : index
  cf.br ^bb4(%c0 : index)
^bb4(%10: index):  // 2 preds: ^bb3, ^bb5
  %11 = arith.cmpi slt, %10, %9 : index
  cf.cond_br %11, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %12 = arith.subi %0, %10 : index
  %13 = arith.addi %arg0, %12 : index
  %14 = arith.subi %13, %c1 : index
  %15 = memref.load %arg2[%arg0] : memref<?xindex>
  %16 = memref.load %arg2[%14] : memref<?xindex>
  memref.store %16, %arg2[%arg0] : memref<?xindex>
  memref.store %15, %arg2[%14] : memref<?xindex>
  %17 = arith.subi %12, %c1 : index
  call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %17) : (index, index, memref<?xindex>, index) -> ()
  %18 = arith.addi %10, %c1 : index
  cf.br ^bb4(%18 : index)
^bb6:  // pred: ^bb4
  return
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %c0 = arith.constant 0 : index
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %alloc = memref.alloc() : memref<16xindex>
  %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
  %alloc_0 = memref.alloc() : memref<16xindex>
  %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
  %alloc_2 = memref.alloc() : memref<16xindex>
  %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
  %alloc_4 = memref.alloc() : memref<16xindex>
  %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
  %alloc_6 = memref.alloc() : memref<16xf32>
  %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
  %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c0] : memref<16xindex>
  %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc_2[%c0] : memref<16xindex>
  %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  memref.store %c0, %alloc[%c1] : memref<16xindex>
  %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %alloc_8 = memref.alloc() : memref<32xf32>
  %alloc_9 = memref.alloc() : memref<32xi1>
  %alloc_10 = memref.alloc() : memref<32xindex>
  %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
  cf.br ^bb1(%c0 : index)
^bb1(%12: index):  // 2 preds: ^bb0, ^bb2
  %13 = arith.cmpi slt, %12, %c32 : index
  cf.cond_br %13, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  memref.store %cst, %alloc_8[%12] : memref<32xf32>
  %14 = arith.addi %12, %c1 : index
  cf.br ^bb1(%14 : index)
^bb3:  // pred: ^bb1
  cf.br ^bb4(%c0 : index)
^bb4(%15: index):  // 2 preds: ^bb3, ^bb5
  %16 = arith.cmpi slt, %15, %c32 : index
  cf.cond_br %16, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  memref.store %false, %alloc_9[%15] : memref<32xi1>
  %17 = arith.addi %15, %c1 : index
  cf.br ^bb4(%17 : index)
^bb6:  // pred: ^bb4
  %18 = memref.load %arg0[%c0] : memref<?xindex>
  %19 = memref.load %arg0[%c1] : memref<?xindex>
  cf.br ^bb7(%18, %cast, %cast_1, %cast_3, %cast_5, %cast_7, %11 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb7(%20: index, %21: memref<?xindex>, %22: memref<?xindex>, %23: memref<?xindex>, %24: memref<?xindex>, %25: memref<?xf32>, %26: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
  %27 = arith.cmpi slt, %20, %19 : index
  cf.cond_br %27, ^bb8, ^bb25
^bb8:  // pred: ^bb7
  %28 = memref.load %arg1[%20] : memref<?xindex>
  %29 = memref.load %arg2[%20] : memref<?xindex>
  %30 = arith.addi %20, %c1 : index
  %31 = memref.load %arg2[%30] : memref<?xindex>
  cf.br ^bb9(%29, %21, %22, %23, %24, %25, %26 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb9(%32: index, %33: memref<?xindex>, %34: memref<?xindex>, %35: memref<?xindex>, %36: memref<?xindex>, %37: memref<?xf32>, %38: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
  %39 = arith.cmpi slt, %32, %31 : index
  cf.cond_br %39, ^bb10, ^bb24
^bb10:  // pred: ^bb9
  %40 = memref.load %arg3[%32] : memref<?xindex>
  %41 = memref.load %arg4[%32] : memref<?xindex>
  %42 = arith.addi %32, %c1 : index
  %43 = memref.load %arg4[%42] : memref<?xindex>
  cf.br ^bb11(%41, %c0 : index, index)
^bb11(%44: index, %45: index):  // 2 preds: ^bb10, ^bb19
  %46 = arith.cmpi slt, %44, %43 : index
  cf.cond_br %46, ^bb12, ^bb20
^bb12:  // pred: ^bb11
  %47 = memref.load %arg5[%44] : memref<?xindex>
  %48 = memref.load %arg6[%44] : memref<?xf32>
  cf.br ^bb13(%c0, %45 : index, index)
^bb13(%49: index, %50: index):  // 2 preds: ^bb12, ^bb18
  %51 = arith.cmpi slt, %49, %c32 : index
  cf.cond_br %51, ^bb14, ^bb19
^bb14:  // pred: ^bb13
  %52 = arith.muli %47, %c32 : index
  %53 = arith.addi %52, %49 : index
  %54 = memref.load %alloc_8[%49] : memref<32xf32>
  %55 = memref.load %arg8[%53] : memref<?xf32>
  %56 = arith.mulf %48, %55 : f32
  %57 = arith.addf %54, %56 : f32
  %58 = memref.load %alloc_9[%49] : memref<32xi1>
  %59 = arith.cmpi eq, %58, %false : i1
  cf.cond_br %59, ^bb15, ^bb16
^bb15:  // pred: ^bb14
  memref.store %true, %alloc_9[%49] : memref<32xi1>
  memref.store %49, %alloc_10[%50] : memref<32xindex>
  %60 = arith.addi %50, %c1 : index
  cf.br ^bb17(%60 : index)
^bb16:  // pred: ^bb14
  cf.br ^bb17(%50 : index)
^bb17(%61: index):  // 2 preds: ^bb15, ^bb16
  cf.br ^bb18
^bb18:  // pred: ^bb17
  memref.store %57, %alloc_8[%49] : memref<32xf32>
  %62 = arith.addi %49, %c1 : index
  cf.br ^bb13(%62, %61 : index, index)
^bb19:  // pred: ^bb13
  %63 = arith.addi %44, %c1 : index
  cf.br ^bb11(%63, %50 : index, index)
^bb20:  // pred: ^bb11
  %64 = arith.index_cast %45 : index to i64
  %65 = math.ctlz %64 : i64
  %66 = arith.subi %c64_i64, %65 : i64
  call @_sparse_hybrid_qsort_1_index(%c0, %45, %cast_11, %66) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb21(%c0, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb21(%67: index, %68: memref<?xindex>, %69: memref<?xindex>, %70: memref<?xindex>, %71: memref<?xindex>, %72: memref<?xf32>, %73: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
  %74 = arith.cmpi slt, %67, %45 : index
  cf.cond_br %74, ^bb22, ^bb23
^bb22:  // pred: ^bb21
  %75 = memref.load %alloc_10[%67] : memref<32xindex>
  %76 = memref.load %alloc_8[%75] : memref<32xf32>
  %77:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%68, %69, %70, %71, %72, %73, %28, %40, %75, %76) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  memref.store %cst, %alloc_8[%75] : memref<32xf32>
  memref.store %false, %alloc_9[%75] : memref<32xi1>
  %78 = arith.addi %67, %c1 : index
  cf.br ^bb21(%78, %77#0, %77#1, %77#2, %77#3, %77#4, %77#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb23:  // pred: ^bb21
  %79 = arith.addi %32, %c1 : index
  cf.br ^bb9(%79, %68, %69, %70, %71, %72, %73 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb24:  // pred: ^bb9
  %80 = arith.addi %20, %c1 : index
  cf.br ^bb7(%80, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb25:  // pred: ^bb7
  memref.dealloc %alloc_8 : memref<32xf32>
  memref.dealloc %alloc_9 : memref<32xi1>
  memref.dealloc %alloc_10 : memref<32xindex>
  %81 = llvm.extractvalue %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %82 = arith.index_cast %81 : i64 to index
  %83 = memref.load %23[%c0] : memref<?xindex>
  cf.br ^bb26(%c1, %83 : index, index)
^bb26(%84: index, %85: index):  // 2 preds: ^bb25, ^bb29
  %86 = arith.cmpi slt, %84, %82 : index
  cf.cond_br %86, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %87 = memref.load %23[%84] : memref<?xindex>
  %88 = arith.cmpi eq, %87, %c0 : index
  %89 = arith.select %88, %85, %87 : index
  cf.cond_br %88, ^bb28, ^bb29
^bb28:  // pred: ^bb27
  memref.store %85, %23[%84] : memref<?xindex>
  cf.br ^bb29
^bb29:  // 2 preds: ^bb27, ^bb28
  %90 = arith.addi %84, %c1 : index
  cf.br ^bb26(%90, %89 : index, index)
^bb30:  // pred: ^bb26
  %alloc_12 = memref.alloc() : memref<4096xf32>
  %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
  %91 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %92 = llvm.insertvalue %c0_i64, %91[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %93 = llvm.insertvalue %c128_i64, %92[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %94 = llvm.insertvalue %c32_i64, %93[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb31(%c0 : index)
^bb31(%95: index):  // 2 preds: ^bb30, ^bb32
  %96 = arith.cmpi slt, %95, %c4096 : index
  cf.cond_br %96, ^bb32, ^bb33
^bb32:  // pred: ^bb31
  memref.store %cst, %alloc_12[%95] : memref<4096xf32>
  %97 = arith.addi %95, %c1 : index
  cf.br ^bb31(%97 : index)
^bb33:  // pred: ^bb31
  %98 = llvm.insertvalue %c4096_i64, %94[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %99 = memref.load %21[%c0] : memref<?xindex>
  %100 = memref.load %21[%c1] : memref<?xindex>
  omp.parallel   {
    omp.wsloop   for  (%arg12) : index = (%99) to (%100) step (%c1) {
      %101 = memref.load %22[%arg12] : memref<?xindex>
      %102 = memref.load %23[%arg12] : memref<?xindex>
      %103 = arith.addi %arg12, %c1 : index
      %104 = memref.load %23[%103] : memref<?xindex>
      omp.parallel   {
        omp.wsloop   for  (%arg13) : index = (%102) to (%104) step (%c1) {
          %105 = memref.load %24[%arg13] : memref<?xindex>
          omp.parallel   {
            omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
              %106 = arith.muli %arg13, %c32 : index
              %107 = arith.addi %106, %arg14 : index
              %108 = arith.muli %105, %c32 : index
              %109 = arith.addi %108, %arg14 : index
              %110 = arith.muli %101, %c32 : index
              %111 = arith.addi %110, %arg14 : index
              %112 = memref.load %alloc_12[%111] : memref<4096xf32>
              %113 = memref.load %25[%107] : memref<?xf32>
              %114 = memref.load %arg10[%109] : memref<?xf32>
              %115 = arith.mulf %113, %114 : f32
              %116 = arith.addf %112, %115 : f32
              memref.store %116, %alloc_12[%111] : memref<4096xf32>
              omp.yield
            }
            omp.terminator
          }
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %cast_13, %98 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ExpandStridedMetadata (expand-strided-metadata) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.subi %1, %c1 : index
    %5 = arith.cmpi ult, %0, %1 : index
    cf.cond_br %5, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %6 = memref.load %arg1[%4] : memref<?xindex>
    %7 = arith.cmpi eq, %6, %arg6 : index
    cf.br ^bb3(%7 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%8: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %9 = arith.select %8, %4, %3 : index
    cf.cond_br %8, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb15(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %10 = arith.addi %3, %c1 : index
    memref.store %10, %arg0[%c1] : memref<?xindex>
    %11 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %12 = arith.index_cast %11 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %13 = arith.addi %12, %c1 : index
    %14 = arith.cmpi ugt, %13, %dim : index
    cf.cond_br %14, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %15 = arith.muli %dim, %c2 : index
    %16 = memref.realloc %arg1(%15) : memref<?xindex> to memref<?xindex>
    cf.br ^bb9(%16 : memref<?xindex>)
  ^bb8:  // pred: ^bb6
    cf.br ^bb9(%arg1 : memref<?xindex>)
  ^bb9(%17: memref<?xindex>):  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    memref.store %arg6, %17[%12] : memref<?xindex>
    %18 = arith.index_cast %13 : index to i64
    %19 = llvm.insertvalue %18, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %20 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %21 = arith.index_cast %20 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %22 = arith.addi %21, %c1 : index
    %23 = arith.cmpi ugt, %22, %dim_0 : index
    cf.cond_br %23, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %24 = arith.muli %dim_0, %c2 : index
    %25 = memref.realloc %arg2(%24) : memref<?xindex> to memref<?xindex>
    cf.br ^bb13(%25 : memref<?xindex>)
  ^bb12:  // pred: ^bb10
    cf.br ^bb13(%arg2 : memref<?xindex>)
  ^bb13(%26: memref<?xindex>):  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    memref.store %c0, %26[%21] : memref<?xindex>
    %27 = arith.index_cast %22 : index to i64
    %28 = llvm.insertvalue %27, %19[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb15(%17, %26, %28 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb15(%29: memref<?xindex>, %30: memref<?xindex>, %31: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb14
    cf.br ^bb16
  ^bb16:  // pred: ^bb15
    %32 = arith.addi %9, %c1 : index
    %33 = memref.load %30[%9] : memref<?xindex>
    %34 = memref.load %30[%32] : memref<?xindex>
    %35 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %36 = arith.index_cast %35 : i64 to index
    %37 = arith.subi %34, %c1 : index
    %38 = arith.cmpi ult, %33, %34 : index
    cf.cond_br %38, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %39 = memref.load %arg3[%37] : memref<?xindex>
    %40 = arith.cmpi eq, %39, %arg7 : index
    cf.br ^bb19(%40 : i1)
  ^bb18:  // pred: ^bb16
    memref.store %36, %30[%9] : memref<?xindex>
    cf.br ^bb19(%false : i1)
  ^bb19(%41: i1):  // 2 preds: ^bb17, ^bb18
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %42 = arith.select %41, %37, %36 : index
    cf.cond_br %41, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    cf.br ^bb36(%arg3, %arg4, %31 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb22:  // pred: ^bb20
    %43 = arith.addi %36, %c1 : index
    memref.store %43, %30[%32] : memref<?xindex>
    %44 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %45 = arith.index_cast %44 : i64 to index
    %dim_1 = memref.dim %arg3, %c0 : memref<?xindex>
    %46 = arith.addi %45, %c1 : index
    %47 = arith.cmpi ugt, %46, %dim_1 : index
    cf.cond_br %47, ^bb23, ^bb24
  ^bb23:  // pred: ^bb22
    %48 = arith.muli %dim_1, %c2 : index
    %49 = memref.realloc %arg3(%48) : memref<?xindex> to memref<?xindex>
    cf.br ^bb25(%49 : memref<?xindex>)
  ^bb24:  // pred: ^bb22
    cf.br ^bb25(%arg3 : memref<?xindex>)
  ^bb25(%50: memref<?xindex>):  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // pred: ^bb25
    memref.store %arg7, %50[%45] : memref<?xindex>
    %51 = arith.index_cast %46 : index to i64
    %52 = llvm.insertvalue %51, %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %53 = llvm.extractvalue %31[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %54 = arith.index_cast %53 : i64 to index
    %dim_2 = memref.dim %arg4, %c0 : memref<?xf32>
    %55 = arith.addi %54, %c32 : index
    %56 = arith.cmpi ugt, %55, %dim_2 : index
    cf.cond_br %56, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    cf.br ^bb28(%dim_2 : index)
  ^bb28(%57: index):  // 2 preds: ^bb27, ^bb28
    %58 = arith.muli %57, %c2 : index
    %59 = arith.cmpi ugt, %55, %58 : index
    cf.cond_br %59, ^bb28(%58 : index), ^bb29
  ^bb29:  // pred: ^bb28
    %60 = memref.realloc %arg4(%58) : memref<?xf32> to memref<?xf32>
    cf.br ^bb31(%60 : memref<?xf32>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg4 : memref<?xf32>)
  ^bb31(%61: memref<?xf32>):  // 2 preds: ^bb29, ^bb30
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %base_buffer, %offset, %sizes, %strides = memref.extract_strided_metadata %61 : memref<?xf32> -> memref<f32>, index, index, index
    %reinterpret_cast = memref.reinterpret_cast %base_buffer to offset: [%54], sizes: [32], strides: [1] : memref<f32> to memref<32xf32, strided<[1], offset: ?>>
    cf.br ^bb33(%c0 : index)
  ^bb33(%62: index):  // 2 preds: ^bb32, ^bb34
    %63 = arith.cmpi slt, %62, %c32 : index
    cf.cond_br %63, ^bb34, ^bb35
  ^bb34:  // pred: ^bb33
    memref.store %cst, %reinterpret_cast[%62] : memref<32xf32, strided<[1], offset: ?>>
    %64 = arith.addi %62, %c1 : index
    cf.br ^bb33(%64 : index)
  ^bb35:  // pred: ^bb33
    %65 = arith.index_cast %55 : index to i64
    %66 = llvm.insertvalue %65, %52[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb36(%50, %61, %66 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb36(%67: memref<?xindex>, %68: memref<?xf32>, %69: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb21, ^bb35
    cf.br ^bb37
  ^bb37:  // pred: ^bb36
    %70 = arith.muli %42, %c32 : index
    %71 = arith.addi %70, %arg8 : index
    memref.store %arg9, %68[%71] : memref<?xf32>
    return %arg0, %29, %30, %67, %68, %69 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb2
    %2 = arith.cmpi ult, %0, %1 : index
    cf.cond_br %2, ^bb2(%0, %1 : index, index), ^bb3
  ^bb2(%3: index, %4: index):  // pred: ^bb1
    %5 = arith.addi %3, %4 : index
    %6 = arith.shrui %5, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = memref.load %arg2[%arg1] : memref<?xindex>
    %9 = memref.load %arg2[%6] : memref<?xindex>
    %10 = arith.cmpi ult, %8, %9 : index
    %11 = arith.select %10, %3, %7 : index
    %12 = arith.select %10, %6, %4 : index
    cf.br ^bb1(%11, %12 : index, index)
  ^bb3:  // pred: ^bb1
    return %0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%0 : index)
  ^bb1(%1: index):  // 2 preds: ^bb0, ^bb5
    %2 = arith.cmpi slt, %1, %arg1 : index
    cf.cond_br %2, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %3 = call @_sparse_binary_search_1_index(%arg0, %1, %arg2) : (index, index, memref<?xindex>) -> index
    %4 = memref.load %arg2[%1] : memref<?xindex>
    %5 = arith.subi %1, %3 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%6: index):  // 2 preds: ^bb2, ^bb4
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %8 = arith.subi %1, %6 : index
    %9 = arith.subi %8, %c1 : index
    %10 = memref.load %arg2[%9] : memref<?xindex>
    memref.store %10, %arg2[%8] : memref<?xindex>
    %11 = arith.addi %6, %c1 : index
    cf.br ^bb3(%11 : index)
  ^bb5:  // pred: ^bb3
    memref.store %4, %arg2[%3] : memref<?xindex>
    %12 = arith.addi %1, %c1 : index
    cf.br ^bb1(%12 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %0, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    cf.cond_br %4, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %5 = arith.shli %1, %c1 : index
    %6 = arith.addi %5, %c1 : index
    %7 = arith.addi %6, %arg0 : index
    %8 = arith.addi %5, %c2 : index
    %9 = arith.cmpi ult, %8, %arg3 : index
    cf.cond_br %9, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %10 = arith.addi %8, %arg0 : index
    %11 = memref.load %arg2[%7] : memref<?xindex>
    %12 = memref.load %arg2[%10] : memref<?xindex>
    %13 = arith.cmpi ult, %11, %12 : index
    %14 = arith.select %13, %8, %6 : index
    %15 = arith.select %13, %10, %7 : index
    cf.br ^bb5(%14, %15, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%6, %7, %arg1 : index, index, index)
  ^bb5(%16: index, %17: index, %18: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%18, %16, %17 : index, index, index)
  ^bb6(%19: index, %20: index, %21: index):  // pred: ^bb5
    cf.br ^bb7(%19, %20, %21 : index, index, index)
  ^bb7(%22: index, %23: index, %24: index):  // pred: ^bb6
    %25 = memref.load %arg2[%22] : memref<?xindex>
    %26 = memref.load %arg2[%24] : memref<?xindex>
    %27 = arith.cmpi ult, %25, %26 : index
    cf.cond_br %27, ^bb8(%22, %23, %24 : index, index, index), ^bb14
  ^bb8(%28: index, %29: index, %30: index):  // pred: ^bb7
    %31 = memref.load %arg2[%28] : memref<?xindex>
    %32 = memref.load %arg2[%30] : memref<?xindex>
    memref.store %32, %arg2[%28] : memref<?xindex>
    memref.store %31, %arg2[%30] : memref<?xindex>
    %33 = arith.cmpi uge, %3, %29 : index
    cf.cond_br %33, ^bb9, ^bb13(%29, %30 : index, index)
  ^bb9:  // pred: ^bb8
    %34 = arith.shli %29, %c1 : index
    %35 = arith.addi %34, %c1 : index
    %36 = arith.addi %35, %arg0 : index
    %37 = arith.addi %34, %c2 : index
    %38 = arith.cmpi ult, %37, %arg3 : index
    cf.cond_br %38, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %39 = arith.addi %37, %arg0 : index
    %40 = memref.load %arg2[%36] : memref<?xindex>
    %41 = memref.load %arg2[%39] : memref<?xindex>
    %42 = arith.cmpi ult, %40, %41 : index
    %43 = arith.select %42, %37, %35 : index
    %44 = arith.select %42, %39, %36 : index
    cf.br ^bb12(%43, %44 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%35, %36 : index, index)
  ^bb12(%45: index, %46: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%45, %46 : index, index)
  ^bb13(%47: index, %48: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%47, %48, %30 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %3 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %6 = arith.subi %2, %4 : index
    %7 = arith.addi %arg0, %6 : index
    call @_sparse_shift_down_1_index(%arg0, %7, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    %8 = arith.addi %4, %c1 : index
    cf.br ^bb1(%8 : index)
  ^bb3:  // pred: ^bb1
    %9 = arith.subi %0, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%10: index):  // 2 preds: ^bb3, ^bb5
    %11 = arith.cmpi slt, %10, %9 : index
    cf.cond_br %11, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %12 = arith.subi %0, %10 : index
    %13 = arith.addi %arg0, %12 : index
    %14 = arith.subi %13, %c1 : index
    %15 = memref.load %arg2[%arg0] : memref<?xindex>
    %16 = memref.load %arg2[%14] : memref<?xindex>
    memref.store %16, %arg2[%arg0] : memref<?xindex>
    memref.store %15, %arg2[%14] : memref<?xindex>
    %17 = arith.subi %12, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %17) : (index, index, memref<?xindex>, index) -> ()
    %18 = arith.addi %10, %c1 : index
    cf.br ^bb4(%18 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    cf.cond_br %4, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %5 = memref.load %arg2[%1] : memref<?xindex>
    %6 = memref.load %arg2[%arg0] : memref<?xindex>
    %7 = arith.cmpi ult, %5, %6 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = memref.load %arg2[%1] : memref<?xindex>
    %9 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %9, %arg2[%1] : memref<?xindex>
    memref.store %8, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %10 = memref.load %arg2[%2] : memref<?xindex>
    %11 = memref.load %arg2[%1] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    cf.cond_br %12, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %13 = memref.load %arg2[%2] : memref<?xindex>
    %14 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %14, %arg2[%2] : memref<?xindex>
    memref.store %13, %arg2[%1] : memref<?xindex>
    %15 = memref.load %arg2[%1] : memref<?xindex>
    %16 = memref.load %arg2[%arg0] : memref<?xindex>
    %17 = arith.cmpi ult, %15, %16 : index
    cf.cond_br %17, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %18 = memref.load %arg2[%1] : memref<?xindex>
    %19 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %19, %arg2[%1] : memref<?xindex>
    memref.store %18, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %2, %1 : index, index, index)
  ^bb8:  // pred: ^bb0
    %20 = arith.addi %arg0, %arg1 : index
    %21 = arith.shrui %20, %c1 : index
    %22 = arith.addi %1, %arg1 : index
    %23 = arith.shrui %22, %c1 : index
    %24 = memref.load %arg2[%21] : memref<?xindex>
    %25 = memref.load %arg2[%arg0] : memref<?xindex>
    %26 = arith.cmpi ult, %24, %25 : index
    cf.cond_br %26, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %27 = memref.load %arg2[%21] : memref<?xindex>
    %28 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %28, %arg2[%21] : memref<?xindex>
    memref.store %27, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %29 = memref.load %arg2[%1] : memref<?xindex>
    %30 = memref.load %arg2[%21] : memref<?xindex>
    %31 = arith.cmpi ult, %29, %30 : index
    cf.cond_br %31, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %32 = memref.load %arg2[%1] : memref<?xindex>
    %33 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %33, %arg2[%1] : memref<?xindex>
    memref.store %32, %arg2[%21] : memref<?xindex>
    %34 = memref.load %arg2[%21] : memref<?xindex>
    %35 = memref.load %arg2[%arg0] : memref<?xindex>
    %36 = arith.cmpi ult, %34, %35 : index
    cf.cond_br %36, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %37 = memref.load %arg2[%21] : memref<?xindex>
    %38 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %38, %arg2[%21] : memref<?xindex>
    memref.store %37, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %39 = memref.load %arg2[%23] : memref<?xindex>
    %40 = memref.load %arg2[%1] : memref<?xindex>
    %41 = arith.cmpi ult, %39, %40 : index
    cf.cond_br %41, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %42 = memref.load %arg2[%23] : memref<?xindex>
    %43 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %43, %arg2[%23] : memref<?xindex>
    memref.store %42, %arg2[%1] : memref<?xindex>
    %44 = memref.load %arg2[%1] : memref<?xindex>
    %45 = memref.load %arg2[%21] : memref<?xindex>
    %46 = arith.cmpi ult, %44, %45 : index
    cf.cond_br %46, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %47 = memref.load %arg2[%1] : memref<?xindex>
    %48 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %48, %arg2[%1] : memref<?xindex>
    memref.store %47, %arg2[%21] : memref<?xindex>
    %49 = memref.load %arg2[%21] : memref<?xindex>
    %50 = memref.load %arg2[%arg0] : memref<?xindex>
    %51 = arith.cmpi ult, %49, %50 : index
    cf.cond_br %51, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %52 = memref.load %arg2[%21] : memref<?xindex>
    %53 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %53, %arg2[%21] : memref<?xindex>
    memref.store %52, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %54 = memref.load %arg2[%2] : memref<?xindex>
    %55 = memref.load %arg2[%23] : memref<?xindex>
    %56 = arith.cmpi ult, %54, %55 : index
    cf.cond_br %56, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %57 = memref.load %arg2[%2] : memref<?xindex>
    %58 = memref.load %arg2[%23] : memref<?xindex>
    memref.store %58, %arg2[%2] : memref<?xindex>
    memref.store %57, %arg2[%23] : memref<?xindex>
    %59 = memref.load %arg2[%23] : memref<?xindex>
    %60 = memref.load %arg2[%1] : memref<?xindex>
    %61 = arith.cmpi ult, %59, %60 : index
    cf.cond_br %61, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %62 = memref.load %arg2[%23] : memref<?xindex>
    %63 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %63, %arg2[%23] : memref<?xindex>
    memref.store %62, %arg2[%1] : memref<?xindex>
    %64 = memref.load %arg2[%1] : memref<?xindex>
    %65 = memref.load %arg2[%21] : memref<?xindex>
    %66 = arith.cmpi ult, %64, %65 : index
    cf.cond_br %66, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %67 = memref.load %arg2[%1] : memref<?xindex>
    %68 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %68, %arg2[%1] : memref<?xindex>
    memref.store %67, %arg2[%21] : memref<?xindex>
    %69 = memref.load %arg2[%21] : memref<?xindex>
    %70 = memref.load %arg2[%arg0] : memref<?xindex>
    %71 = arith.cmpi ult, %69, %70 : index
    cf.cond_br %71, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %72 = memref.load %arg2[%21] : memref<?xindex>
    %73 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %73, %arg2[%21] : memref<?xindex>
    memref.store %72, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%74: index, %75: index, %76: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%74, %75, %76 : index, index, index)
  ^bb28(%77: index, %78: index, %79: index):  // pred: ^bb27
    %80 = arith.cmpi ult, %77, %78 : index
    cf.cond_br %80, ^bb29(%77, %78, %79 : index, index, index), ^bb46
  ^bb29(%81: index, %82: index, %83: index):  // pred: ^bb28
    cf.br ^bb30(%81 : index)
  ^bb30(%84: index):  // 2 preds: ^bb29, ^bb31
    %85 = memref.load %arg2[%84] : memref<?xindex>
    %86 = memref.load %arg2[%83] : memref<?xindex>
    %87 = arith.cmpi ult, %85, %86 : index
    cf.cond_br %87, ^bb31(%84 : index), ^bb32
  ^bb31(%88: index):  // pred: ^bb30
    %89 = arith.addi %88, %c1 : index
    cf.br ^bb30(%89 : index)
  ^bb32:  // pred: ^bb30
    %90 = memref.load %arg2[%84] : memref<?xindex>
    %91 = memref.load %arg2[%83] : memref<?xindex>
    %92 = arith.cmpi eq, %90, %91 : index
    cf.br ^bb33(%82 : index)
  ^bb33(%93: index):  // 2 preds: ^bb32, ^bb34
    %94 = memref.load %arg2[%83] : memref<?xindex>
    %95 = memref.load %arg2[%93] : memref<?xindex>
    %96 = arith.cmpi ult, %94, %95 : index
    cf.cond_br %96, ^bb34(%93 : index), ^bb35
  ^bb34(%97: index):  // pred: ^bb33
    %98 = arith.addi %97, %c-1 : index
    cf.br ^bb33(%98 : index)
  ^bb35:  // pred: ^bb33
    %99 = memref.load %arg2[%93] : memref<?xindex>
    %100 = memref.load %arg2[%83] : memref<?xindex>
    %101 = arith.cmpi eq, %99, %100 : index
    %102 = arith.cmpi ult, %84, %93 : index
    cf.cond_br %102, ^bb36, ^bb44(%84, %93, %83 : index, index, index)
  ^bb36:  // pred: ^bb35
    %103 = memref.load %arg2[%84] : memref<?xindex>
    %104 = memref.load %arg2[%93] : memref<?xindex>
    memref.store %104, %arg2[%84] : memref<?xindex>
    memref.store %103, %arg2[%93] : memref<?xindex>
    %105 = arith.cmpi eq, %84, %83 : index
    cf.cond_br %105, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%93 : index)
  ^bb38:  // pred: ^bb36
    %106 = arith.cmpi eq, %93, %83 : index
    %107 = arith.select %106, %84, %83 : index
    cf.br ^bb39(%107 : index)
  ^bb39(%108: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %109 = arith.andi %92, %101 : i1
    cf.cond_br %109, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %110 = arith.addi %84, %c1 : index
    %111 = arith.subi %93, %c1 : index
    cf.br ^bb43(%110, %111 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%84, %93 : index, index)
  ^bb43(%112: index, %113: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%112, %113, %108 : index, index, index)
  ^bb44(%114: index, %115: index, %116: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%114, %115, %116 : index, index, index)
  ^bb45(%117: index, %118: index, %119: index):  // pred: ^bb44
    cf.br ^bb27(%117, %118, %119 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %79 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %alloc = memref.alloc() : memref<16xindex>
    %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
    %alloc_0 = memref.alloc() : memref<16xindex>
    %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
    %alloc_2 = memref.alloc() : memref<16xindex>
    %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
    %alloc_4 = memref.alloc() : memref<16xindex>
    %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
    %alloc_6 = memref.alloc() : memref<16xf32>
    %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c0] : memref<16xindex>
    %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc_2[%c0] : memref<16xindex>
    %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c1] : memref<16xindex>
    %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %alloc_8 = memref.alloc() : memref<32xf32>
    %alloc_9 = memref.alloc() : memref<32xi1>
    %alloc_10 = memref.alloc() : memref<32xindex>
    %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%12: index):  // 2 preds: ^bb0, ^bb2
    %13 = arith.cmpi slt, %12, %c32 : index
    cf.cond_br %13, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc_8[%12] : memref<32xf32>
    %14 = arith.addi %12, %c1 : index
    cf.br ^bb1(%14 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%15: index):  // 2 preds: ^bb3, ^bb5
    %16 = arith.cmpi slt, %15, %c32 : index
    cf.cond_br %16, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    memref.store %false, %alloc_9[%15] : memref<32xi1>
    %17 = arith.addi %15, %c1 : index
    cf.br ^bb4(%17 : index)
  ^bb6:  // pred: ^bb4
    %18 = memref.load %arg0[%c0] : memref<?xindex>
    %19 = memref.load %arg0[%c1] : memref<?xindex>
    cf.br ^bb7(%18, %cast, %cast_1, %cast_3, %cast_5, %cast_7, %11 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%20: index, %21: memref<?xindex>, %22: memref<?xindex>, %23: memref<?xindex>, %24: memref<?xindex>, %25: memref<?xf32>, %26: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %27 = arith.cmpi slt, %20, %19 : index
    cf.cond_br %27, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %28 = memref.load %arg1[%20] : memref<?xindex>
    %29 = memref.load %arg2[%20] : memref<?xindex>
    %30 = arith.addi %20, %c1 : index
    %31 = memref.load %arg2[%30] : memref<?xindex>
    cf.br ^bb9(%29, %21, %22, %23, %24, %25, %26 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%32: index, %33: memref<?xindex>, %34: memref<?xindex>, %35: memref<?xindex>, %36: memref<?xindex>, %37: memref<?xf32>, %38: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %39 = arith.cmpi slt, %32, %31 : index
    cf.cond_br %39, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %40 = memref.load %arg3[%32] : memref<?xindex>
    %41 = memref.load %arg4[%32] : memref<?xindex>
    %42 = arith.addi %32, %c1 : index
    %43 = memref.load %arg4[%42] : memref<?xindex>
    cf.br ^bb11(%41, %c0 : index, index)
  ^bb11(%44: index, %45: index):  // 2 preds: ^bb10, ^bb19
    %46 = arith.cmpi slt, %44, %43 : index
    cf.cond_br %46, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %47 = memref.load %arg5[%44] : memref<?xindex>
    %48 = memref.load %arg6[%44] : memref<?xf32>
    cf.br ^bb13(%c0, %45 : index, index)
  ^bb13(%49: index, %50: index):  // 2 preds: ^bb12, ^bb18
    %51 = arith.cmpi slt, %49, %c32 : index
    cf.cond_br %51, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %52 = arith.muli %47, %c32 : index
    %53 = arith.addi %52, %49 : index
    %54 = memref.load %alloc_8[%49] : memref<32xf32>
    %55 = memref.load %arg8[%53] : memref<?xf32>
    %56 = arith.mulf %48, %55 : f32
    %57 = arith.addf %54, %56 : f32
    %58 = memref.load %alloc_9[%49] : memref<32xi1>
    %59 = arith.cmpi eq, %58, %false : i1
    cf.cond_br %59, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    memref.store %true, %alloc_9[%49] : memref<32xi1>
    memref.store %49, %alloc_10[%50] : memref<32xindex>
    %60 = arith.addi %50, %c1 : index
    cf.br ^bb17(%60 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%50 : index)
  ^bb17(%61: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    memref.store %57, %alloc_8[%49] : memref<32xf32>
    %62 = arith.addi %49, %c1 : index
    cf.br ^bb13(%62, %61 : index, index)
  ^bb19:  // pred: ^bb13
    %63 = arith.addi %44, %c1 : index
    cf.br ^bb11(%63, %50 : index, index)
  ^bb20:  // pred: ^bb11
    %64 = arith.index_cast %45 : index to i64
    %65 = math.ctlz %64 : i64
    %66 = arith.subi %c64_i64, %65 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %45, %cast_11, %66) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%67: index, %68: memref<?xindex>, %69: memref<?xindex>, %70: memref<?xindex>, %71: memref<?xindex>, %72: memref<?xf32>, %73: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %74 = arith.cmpi slt, %67, %45 : index
    cf.cond_br %74, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %75 = memref.load %alloc_10[%67] : memref<32xindex>
    %76 = memref.load %alloc_8[%75] : memref<32xf32>
    %77:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%68, %69, %70, %71, %72, %73, %28, %40, %75, %76) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    memref.store %cst, %alloc_8[%75] : memref<32xf32>
    memref.store %false, %alloc_9[%75] : memref<32xi1>
    %78 = arith.addi %67, %c1 : index
    cf.br ^bb21(%78, %77#0, %77#1, %77#2, %77#3, %77#4, %77#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %79 = arith.addi %32, %c1 : index
    cf.br ^bb9(%79, %68, %69, %70, %71, %72, %73 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %80 = arith.addi %20, %c1 : index
    cf.br ^bb7(%80, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    memref.dealloc %alloc_8 : memref<32xf32>
    memref.dealloc %alloc_9 : memref<32xi1>
    memref.dealloc %alloc_10 : memref<32xindex>
    %81 = llvm.extractvalue %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %82 = arith.index_cast %81 : i64 to index
    %83 = memref.load %23[%c0] : memref<?xindex>
    cf.br ^bb26(%c1, %83 : index, index)
  ^bb26(%84: index, %85: index):  // 2 preds: ^bb25, ^bb29
    %86 = arith.cmpi slt, %84, %82 : index
    cf.cond_br %86, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %87 = memref.load %23[%84] : memref<?xindex>
    %88 = arith.cmpi eq, %87, %c0 : index
    %89 = arith.select %88, %85, %87 : index
    cf.cond_br %88, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    memref.store %85, %23[%84] : memref<?xindex>
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %90 = arith.addi %84, %c1 : index
    cf.br ^bb26(%90, %89 : index, index)
  ^bb30:  // pred: ^bb26
    %alloc_12 = memref.alloc() : memref<4096xf32>
    %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
    %91 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %92 = llvm.insertvalue %c0_i64, %91[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %93 = llvm.insertvalue %c128_i64, %92[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %94 = llvm.insertvalue %c32_i64, %93[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%95: index):  // 2 preds: ^bb30, ^bb32
    %96 = arith.cmpi slt, %95, %c4096 : index
    cf.cond_br %96, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    memref.store %cst, %alloc_12[%95] : memref<4096xf32>
    %97 = arith.addi %95, %c1 : index
    cf.br ^bb31(%97 : index)
  ^bb33:  // pred: ^bb31
    %98 = llvm.insertvalue %c4096_i64, %94[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %99 = memref.load %21[%c0] : memref<?xindex>
    %100 = memref.load %21[%c1] : memref<?xindex>
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%99) to (%100) step (%c1) {
        %101 = memref.load %22[%arg12] : memref<?xindex>
        %102 = memref.load %23[%arg12] : memref<?xindex>
        %103 = arith.addi %arg12, %c1 : index
        %104 = memref.load %23[%103] : memref<?xindex>
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%102) to (%104) step (%c1) {
            %105 = memref.load %24[%arg13] : memref<?xindex>
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %106 = arith.muli %arg13, %c32 : index
                %107 = arith.addi %106, %arg14 : index
                %108 = arith.muli %105, %c32 : index
                %109 = arith.addi %108, %arg14 : index
                %110 = arith.muli %101, %c32 : index
                %111 = arith.addi %110, %arg14 : index
                %112 = memref.load %alloc_12[%111] : memref<4096xf32>
                %113 = memref.load %25[%107] : memref<?xf32>
                %114 = memref.load %arg10[%109] : memref<?xf32>
                %115 = arith.mulf %113, %114 : f32
                %116 = arith.addf %112, %115 : f32
                memref.store %116, %alloc_12[%111] : memref<4096xf32>
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast_13, %98 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertAffineToStandard (lower-affine) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.subi %1, %c1 : index
    %5 = arith.cmpi ult, %0, %1 : index
    cf.cond_br %5, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %6 = memref.load %arg1[%4] : memref<?xindex>
    %7 = arith.cmpi eq, %6, %arg6 : index
    cf.br ^bb3(%7 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%8: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %9 = arith.select %8, %4, %3 : index
    cf.cond_br %8, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb15(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %10 = arith.addi %3, %c1 : index
    memref.store %10, %arg0[%c1] : memref<?xindex>
    %11 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %12 = arith.index_cast %11 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %13 = arith.addi %12, %c1 : index
    %14 = arith.cmpi ugt, %13, %dim : index
    cf.cond_br %14, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %15 = arith.muli %dim, %c2 : index
    %16 = memref.realloc %arg1(%15) : memref<?xindex> to memref<?xindex>
    cf.br ^bb9(%16 : memref<?xindex>)
  ^bb8:  // pred: ^bb6
    cf.br ^bb9(%arg1 : memref<?xindex>)
  ^bb9(%17: memref<?xindex>):  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    memref.store %arg6, %17[%12] : memref<?xindex>
    %18 = arith.index_cast %13 : index to i64
    %19 = llvm.insertvalue %18, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %20 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %21 = arith.index_cast %20 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %22 = arith.addi %21, %c1 : index
    %23 = arith.cmpi ugt, %22, %dim_0 : index
    cf.cond_br %23, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %24 = arith.muli %dim_0, %c2 : index
    %25 = memref.realloc %arg2(%24) : memref<?xindex> to memref<?xindex>
    cf.br ^bb13(%25 : memref<?xindex>)
  ^bb12:  // pred: ^bb10
    cf.br ^bb13(%arg2 : memref<?xindex>)
  ^bb13(%26: memref<?xindex>):  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    memref.store %c0, %26[%21] : memref<?xindex>
    %27 = arith.index_cast %22 : index to i64
    %28 = llvm.insertvalue %27, %19[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb15(%17, %26, %28 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb15(%29: memref<?xindex>, %30: memref<?xindex>, %31: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb14
    cf.br ^bb16
  ^bb16:  // pred: ^bb15
    %32 = arith.addi %9, %c1 : index
    %33 = memref.load %30[%9] : memref<?xindex>
    %34 = memref.load %30[%32] : memref<?xindex>
    %35 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %36 = arith.index_cast %35 : i64 to index
    %37 = arith.subi %34, %c1 : index
    %38 = arith.cmpi ult, %33, %34 : index
    cf.cond_br %38, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %39 = memref.load %arg3[%37] : memref<?xindex>
    %40 = arith.cmpi eq, %39, %arg7 : index
    cf.br ^bb19(%40 : i1)
  ^bb18:  // pred: ^bb16
    memref.store %36, %30[%9] : memref<?xindex>
    cf.br ^bb19(%false : i1)
  ^bb19(%41: i1):  // 2 preds: ^bb17, ^bb18
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %42 = arith.select %41, %37, %36 : index
    cf.cond_br %41, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    cf.br ^bb36(%arg3, %arg4, %31 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb22:  // pred: ^bb20
    %43 = arith.addi %36, %c1 : index
    memref.store %43, %30[%32] : memref<?xindex>
    %44 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %45 = arith.index_cast %44 : i64 to index
    %dim_1 = memref.dim %arg3, %c0 : memref<?xindex>
    %46 = arith.addi %45, %c1 : index
    %47 = arith.cmpi ugt, %46, %dim_1 : index
    cf.cond_br %47, ^bb23, ^bb24
  ^bb23:  // pred: ^bb22
    %48 = arith.muli %dim_1, %c2 : index
    %49 = memref.realloc %arg3(%48) : memref<?xindex> to memref<?xindex>
    cf.br ^bb25(%49 : memref<?xindex>)
  ^bb24:  // pred: ^bb22
    cf.br ^bb25(%arg3 : memref<?xindex>)
  ^bb25(%50: memref<?xindex>):  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // pred: ^bb25
    memref.store %arg7, %50[%45] : memref<?xindex>
    %51 = arith.index_cast %46 : index to i64
    %52 = llvm.insertvalue %51, %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %53 = llvm.extractvalue %31[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %54 = arith.index_cast %53 : i64 to index
    %dim_2 = memref.dim %arg4, %c0 : memref<?xf32>
    %55 = arith.addi %54, %c32 : index
    %56 = arith.cmpi ugt, %55, %dim_2 : index
    cf.cond_br %56, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    cf.br ^bb28(%dim_2 : index)
  ^bb28(%57: index):  // 2 preds: ^bb27, ^bb28
    %58 = arith.muli %57, %c2 : index
    %59 = arith.cmpi ugt, %55, %58 : index
    cf.cond_br %59, ^bb28(%58 : index), ^bb29
  ^bb29:  // pred: ^bb28
    %60 = memref.realloc %arg4(%58) : memref<?xf32> to memref<?xf32>
    cf.br ^bb31(%60 : memref<?xf32>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg4 : memref<?xf32>)
  ^bb31(%61: memref<?xf32>):  // 2 preds: ^bb29, ^bb30
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %base_buffer, %offset, %sizes, %strides = memref.extract_strided_metadata %61 : memref<?xf32> -> memref<f32>, index, index, index
    %reinterpret_cast = memref.reinterpret_cast %base_buffer to offset: [%54], sizes: [32], strides: [1] : memref<f32> to memref<32xf32, strided<[1], offset: ?>>
    cf.br ^bb33(%c0 : index)
  ^bb33(%62: index):  // 2 preds: ^bb32, ^bb34
    %63 = arith.cmpi slt, %62, %c32 : index
    cf.cond_br %63, ^bb34, ^bb35
  ^bb34:  // pred: ^bb33
    memref.store %cst, %reinterpret_cast[%62] : memref<32xf32, strided<[1], offset: ?>>
    %64 = arith.addi %62, %c1 : index
    cf.br ^bb33(%64 : index)
  ^bb35:  // pred: ^bb33
    %65 = arith.index_cast %55 : index to i64
    %66 = llvm.insertvalue %65, %52[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb36(%50, %61, %66 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb36(%67: memref<?xindex>, %68: memref<?xf32>, %69: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb21, ^bb35
    cf.br ^bb37
  ^bb37:  // pred: ^bb36
    %70 = arith.muli %42, %c32 : index
    %71 = arith.addi %70, %arg8 : index
    memref.store %arg9, %68[%71] : memref<?xf32>
    return %arg0, %29, %30, %67, %68, %69 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb2
    %2 = arith.cmpi ult, %0, %1 : index
    cf.cond_br %2, ^bb2(%0, %1 : index, index), ^bb3
  ^bb2(%3: index, %4: index):  // pred: ^bb1
    %5 = arith.addi %3, %4 : index
    %6 = arith.shrui %5, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = memref.load %arg2[%arg1] : memref<?xindex>
    %9 = memref.load %arg2[%6] : memref<?xindex>
    %10 = arith.cmpi ult, %8, %9 : index
    %11 = arith.select %10, %3, %7 : index
    %12 = arith.select %10, %6, %4 : index
    cf.br ^bb1(%11, %12 : index, index)
  ^bb3:  // pred: ^bb1
    return %0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%0 : index)
  ^bb1(%1: index):  // 2 preds: ^bb0, ^bb5
    %2 = arith.cmpi slt, %1, %arg1 : index
    cf.cond_br %2, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %3 = call @_sparse_binary_search_1_index(%arg0, %1, %arg2) : (index, index, memref<?xindex>) -> index
    %4 = memref.load %arg2[%1] : memref<?xindex>
    %5 = arith.subi %1, %3 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%6: index):  // 2 preds: ^bb2, ^bb4
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %8 = arith.subi %1, %6 : index
    %9 = arith.subi %8, %c1 : index
    %10 = memref.load %arg2[%9] : memref<?xindex>
    memref.store %10, %arg2[%8] : memref<?xindex>
    %11 = arith.addi %6, %c1 : index
    cf.br ^bb3(%11 : index)
  ^bb5:  // pred: ^bb3
    memref.store %4, %arg2[%3] : memref<?xindex>
    %12 = arith.addi %1, %c1 : index
    cf.br ^bb1(%12 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %0, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    cf.cond_br %4, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %5 = arith.shli %1, %c1 : index
    %6 = arith.addi %5, %c1 : index
    %7 = arith.addi %6, %arg0 : index
    %8 = arith.addi %5, %c2 : index
    %9 = arith.cmpi ult, %8, %arg3 : index
    cf.cond_br %9, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %10 = arith.addi %8, %arg0 : index
    %11 = memref.load %arg2[%7] : memref<?xindex>
    %12 = memref.load %arg2[%10] : memref<?xindex>
    %13 = arith.cmpi ult, %11, %12 : index
    %14 = arith.select %13, %8, %6 : index
    %15 = arith.select %13, %10, %7 : index
    cf.br ^bb5(%14, %15, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%6, %7, %arg1 : index, index, index)
  ^bb5(%16: index, %17: index, %18: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%18, %16, %17 : index, index, index)
  ^bb6(%19: index, %20: index, %21: index):  // pred: ^bb5
    cf.br ^bb7(%19, %20, %21 : index, index, index)
  ^bb7(%22: index, %23: index, %24: index):  // pred: ^bb6
    %25 = memref.load %arg2[%22] : memref<?xindex>
    %26 = memref.load %arg2[%24] : memref<?xindex>
    %27 = arith.cmpi ult, %25, %26 : index
    cf.cond_br %27, ^bb8(%22, %23, %24 : index, index, index), ^bb14
  ^bb8(%28: index, %29: index, %30: index):  // pred: ^bb7
    %31 = memref.load %arg2[%28] : memref<?xindex>
    %32 = memref.load %arg2[%30] : memref<?xindex>
    memref.store %32, %arg2[%28] : memref<?xindex>
    memref.store %31, %arg2[%30] : memref<?xindex>
    %33 = arith.cmpi uge, %3, %29 : index
    cf.cond_br %33, ^bb9, ^bb13(%29, %30 : index, index)
  ^bb9:  // pred: ^bb8
    %34 = arith.shli %29, %c1 : index
    %35 = arith.addi %34, %c1 : index
    %36 = arith.addi %35, %arg0 : index
    %37 = arith.addi %34, %c2 : index
    %38 = arith.cmpi ult, %37, %arg3 : index
    cf.cond_br %38, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %39 = arith.addi %37, %arg0 : index
    %40 = memref.load %arg2[%36] : memref<?xindex>
    %41 = memref.load %arg2[%39] : memref<?xindex>
    %42 = arith.cmpi ult, %40, %41 : index
    %43 = arith.select %42, %37, %35 : index
    %44 = arith.select %42, %39, %36 : index
    cf.br ^bb12(%43, %44 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%35, %36 : index, index)
  ^bb12(%45: index, %46: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%45, %46 : index, index)
  ^bb13(%47: index, %48: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%47, %48, %30 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %3 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %6 = arith.subi %2, %4 : index
    %7 = arith.addi %arg0, %6 : index
    call @_sparse_shift_down_1_index(%arg0, %7, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    %8 = arith.addi %4, %c1 : index
    cf.br ^bb1(%8 : index)
  ^bb3:  // pred: ^bb1
    %9 = arith.subi %0, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%10: index):  // 2 preds: ^bb3, ^bb5
    %11 = arith.cmpi slt, %10, %9 : index
    cf.cond_br %11, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %12 = arith.subi %0, %10 : index
    %13 = arith.addi %arg0, %12 : index
    %14 = arith.subi %13, %c1 : index
    %15 = memref.load %arg2[%arg0] : memref<?xindex>
    %16 = memref.load %arg2[%14] : memref<?xindex>
    memref.store %16, %arg2[%arg0] : memref<?xindex>
    memref.store %15, %arg2[%14] : memref<?xindex>
    %17 = arith.subi %12, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %17) : (index, index, memref<?xindex>, index) -> ()
    %18 = arith.addi %10, %c1 : index
    cf.br ^bb4(%18 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    cf.cond_br %4, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %5 = memref.load %arg2[%1] : memref<?xindex>
    %6 = memref.load %arg2[%arg0] : memref<?xindex>
    %7 = arith.cmpi ult, %5, %6 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = memref.load %arg2[%1] : memref<?xindex>
    %9 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %9, %arg2[%1] : memref<?xindex>
    memref.store %8, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %10 = memref.load %arg2[%2] : memref<?xindex>
    %11 = memref.load %arg2[%1] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    cf.cond_br %12, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %13 = memref.load %arg2[%2] : memref<?xindex>
    %14 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %14, %arg2[%2] : memref<?xindex>
    memref.store %13, %arg2[%1] : memref<?xindex>
    %15 = memref.load %arg2[%1] : memref<?xindex>
    %16 = memref.load %arg2[%arg0] : memref<?xindex>
    %17 = arith.cmpi ult, %15, %16 : index
    cf.cond_br %17, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %18 = memref.load %arg2[%1] : memref<?xindex>
    %19 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %19, %arg2[%1] : memref<?xindex>
    memref.store %18, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %2, %1 : index, index, index)
  ^bb8:  // pred: ^bb0
    %20 = arith.addi %arg0, %arg1 : index
    %21 = arith.shrui %20, %c1 : index
    %22 = arith.addi %1, %arg1 : index
    %23 = arith.shrui %22, %c1 : index
    %24 = memref.load %arg2[%21] : memref<?xindex>
    %25 = memref.load %arg2[%arg0] : memref<?xindex>
    %26 = arith.cmpi ult, %24, %25 : index
    cf.cond_br %26, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %27 = memref.load %arg2[%21] : memref<?xindex>
    %28 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %28, %arg2[%21] : memref<?xindex>
    memref.store %27, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %29 = memref.load %arg2[%1] : memref<?xindex>
    %30 = memref.load %arg2[%21] : memref<?xindex>
    %31 = arith.cmpi ult, %29, %30 : index
    cf.cond_br %31, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %32 = memref.load %arg2[%1] : memref<?xindex>
    %33 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %33, %arg2[%1] : memref<?xindex>
    memref.store %32, %arg2[%21] : memref<?xindex>
    %34 = memref.load %arg2[%21] : memref<?xindex>
    %35 = memref.load %arg2[%arg0] : memref<?xindex>
    %36 = arith.cmpi ult, %34, %35 : index
    cf.cond_br %36, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %37 = memref.load %arg2[%21] : memref<?xindex>
    %38 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %38, %arg2[%21] : memref<?xindex>
    memref.store %37, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %39 = memref.load %arg2[%23] : memref<?xindex>
    %40 = memref.load %arg2[%1] : memref<?xindex>
    %41 = arith.cmpi ult, %39, %40 : index
    cf.cond_br %41, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %42 = memref.load %arg2[%23] : memref<?xindex>
    %43 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %43, %arg2[%23] : memref<?xindex>
    memref.store %42, %arg2[%1] : memref<?xindex>
    %44 = memref.load %arg2[%1] : memref<?xindex>
    %45 = memref.load %arg2[%21] : memref<?xindex>
    %46 = arith.cmpi ult, %44, %45 : index
    cf.cond_br %46, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %47 = memref.load %arg2[%1] : memref<?xindex>
    %48 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %48, %arg2[%1] : memref<?xindex>
    memref.store %47, %arg2[%21] : memref<?xindex>
    %49 = memref.load %arg2[%21] : memref<?xindex>
    %50 = memref.load %arg2[%arg0] : memref<?xindex>
    %51 = arith.cmpi ult, %49, %50 : index
    cf.cond_br %51, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %52 = memref.load %arg2[%21] : memref<?xindex>
    %53 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %53, %arg2[%21] : memref<?xindex>
    memref.store %52, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %54 = memref.load %arg2[%2] : memref<?xindex>
    %55 = memref.load %arg2[%23] : memref<?xindex>
    %56 = arith.cmpi ult, %54, %55 : index
    cf.cond_br %56, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %57 = memref.load %arg2[%2] : memref<?xindex>
    %58 = memref.load %arg2[%23] : memref<?xindex>
    memref.store %58, %arg2[%2] : memref<?xindex>
    memref.store %57, %arg2[%23] : memref<?xindex>
    %59 = memref.load %arg2[%23] : memref<?xindex>
    %60 = memref.load %arg2[%1] : memref<?xindex>
    %61 = arith.cmpi ult, %59, %60 : index
    cf.cond_br %61, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %62 = memref.load %arg2[%23] : memref<?xindex>
    %63 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %63, %arg2[%23] : memref<?xindex>
    memref.store %62, %arg2[%1] : memref<?xindex>
    %64 = memref.load %arg2[%1] : memref<?xindex>
    %65 = memref.load %arg2[%21] : memref<?xindex>
    %66 = arith.cmpi ult, %64, %65 : index
    cf.cond_br %66, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %67 = memref.load %arg2[%1] : memref<?xindex>
    %68 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %68, %arg2[%1] : memref<?xindex>
    memref.store %67, %arg2[%21] : memref<?xindex>
    %69 = memref.load %arg2[%21] : memref<?xindex>
    %70 = memref.load %arg2[%arg0] : memref<?xindex>
    %71 = arith.cmpi ult, %69, %70 : index
    cf.cond_br %71, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %72 = memref.load %arg2[%21] : memref<?xindex>
    %73 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %73, %arg2[%21] : memref<?xindex>
    memref.store %72, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%74: index, %75: index, %76: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%74, %75, %76 : index, index, index)
  ^bb28(%77: index, %78: index, %79: index):  // pred: ^bb27
    %80 = arith.cmpi ult, %77, %78 : index
    cf.cond_br %80, ^bb29(%77, %78, %79 : index, index, index), ^bb46
  ^bb29(%81: index, %82: index, %83: index):  // pred: ^bb28
    cf.br ^bb30(%81 : index)
  ^bb30(%84: index):  // 2 preds: ^bb29, ^bb31
    %85 = memref.load %arg2[%84] : memref<?xindex>
    %86 = memref.load %arg2[%83] : memref<?xindex>
    %87 = arith.cmpi ult, %85, %86 : index
    cf.cond_br %87, ^bb31(%84 : index), ^bb32
  ^bb31(%88: index):  // pred: ^bb30
    %89 = arith.addi %88, %c1 : index
    cf.br ^bb30(%89 : index)
  ^bb32:  // pred: ^bb30
    %90 = memref.load %arg2[%84] : memref<?xindex>
    %91 = memref.load %arg2[%83] : memref<?xindex>
    %92 = arith.cmpi eq, %90, %91 : index
    cf.br ^bb33(%82 : index)
  ^bb33(%93: index):  // 2 preds: ^bb32, ^bb34
    %94 = memref.load %arg2[%83] : memref<?xindex>
    %95 = memref.load %arg2[%93] : memref<?xindex>
    %96 = arith.cmpi ult, %94, %95 : index
    cf.cond_br %96, ^bb34(%93 : index), ^bb35
  ^bb34(%97: index):  // pred: ^bb33
    %98 = arith.addi %97, %c-1 : index
    cf.br ^bb33(%98 : index)
  ^bb35:  // pred: ^bb33
    %99 = memref.load %arg2[%93] : memref<?xindex>
    %100 = memref.load %arg2[%83] : memref<?xindex>
    %101 = arith.cmpi eq, %99, %100 : index
    %102 = arith.cmpi ult, %84, %93 : index
    cf.cond_br %102, ^bb36, ^bb44(%84, %93, %83 : index, index, index)
  ^bb36:  // pred: ^bb35
    %103 = memref.load %arg2[%84] : memref<?xindex>
    %104 = memref.load %arg2[%93] : memref<?xindex>
    memref.store %104, %arg2[%84] : memref<?xindex>
    memref.store %103, %arg2[%93] : memref<?xindex>
    %105 = arith.cmpi eq, %84, %83 : index
    cf.cond_br %105, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%93 : index)
  ^bb38:  // pred: ^bb36
    %106 = arith.cmpi eq, %93, %83 : index
    %107 = arith.select %106, %84, %83 : index
    cf.br ^bb39(%107 : index)
  ^bb39(%108: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %109 = arith.andi %92, %101 : i1
    cf.cond_br %109, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %110 = arith.addi %84, %c1 : index
    %111 = arith.subi %93, %c1 : index
    cf.br ^bb43(%110, %111 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%84, %93 : index, index)
  ^bb43(%112: index, %113: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%112, %113, %108 : index, index, index)
  ^bb44(%114: index, %115: index, %116: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%114, %115, %116 : index, index, index)
  ^bb45(%117: index, %118: index, %119: index):  // pred: ^bb44
    cf.br ^bb27(%117, %118, %119 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %79 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %alloc = memref.alloc() : memref<16xindex>
    %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
    %alloc_0 = memref.alloc() : memref<16xindex>
    %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
    %alloc_2 = memref.alloc() : memref<16xindex>
    %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
    %alloc_4 = memref.alloc() : memref<16xindex>
    %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
    %alloc_6 = memref.alloc() : memref<16xf32>
    %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c0] : memref<16xindex>
    %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc_2[%c0] : memref<16xindex>
    %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c1] : memref<16xindex>
    %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %alloc_8 = memref.alloc() : memref<32xf32>
    %alloc_9 = memref.alloc() : memref<32xi1>
    %alloc_10 = memref.alloc() : memref<32xindex>
    %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%12: index):  // 2 preds: ^bb0, ^bb2
    %13 = arith.cmpi slt, %12, %c32 : index
    cf.cond_br %13, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc_8[%12] : memref<32xf32>
    %14 = arith.addi %12, %c1 : index
    cf.br ^bb1(%14 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%15: index):  // 2 preds: ^bb3, ^bb5
    %16 = arith.cmpi slt, %15, %c32 : index
    cf.cond_br %16, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    memref.store %false, %alloc_9[%15] : memref<32xi1>
    %17 = arith.addi %15, %c1 : index
    cf.br ^bb4(%17 : index)
  ^bb6:  // pred: ^bb4
    %18 = memref.load %arg0[%c0] : memref<?xindex>
    %19 = memref.load %arg0[%c1] : memref<?xindex>
    cf.br ^bb7(%18, %cast, %cast_1, %cast_3, %cast_5, %cast_7, %11 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%20: index, %21: memref<?xindex>, %22: memref<?xindex>, %23: memref<?xindex>, %24: memref<?xindex>, %25: memref<?xf32>, %26: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %27 = arith.cmpi slt, %20, %19 : index
    cf.cond_br %27, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %28 = memref.load %arg1[%20] : memref<?xindex>
    %29 = memref.load %arg2[%20] : memref<?xindex>
    %30 = arith.addi %20, %c1 : index
    %31 = memref.load %arg2[%30] : memref<?xindex>
    cf.br ^bb9(%29, %21, %22, %23, %24, %25, %26 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%32: index, %33: memref<?xindex>, %34: memref<?xindex>, %35: memref<?xindex>, %36: memref<?xindex>, %37: memref<?xf32>, %38: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %39 = arith.cmpi slt, %32, %31 : index
    cf.cond_br %39, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %40 = memref.load %arg3[%32] : memref<?xindex>
    %41 = memref.load %arg4[%32] : memref<?xindex>
    %42 = arith.addi %32, %c1 : index
    %43 = memref.load %arg4[%42] : memref<?xindex>
    cf.br ^bb11(%41, %c0 : index, index)
  ^bb11(%44: index, %45: index):  // 2 preds: ^bb10, ^bb19
    %46 = arith.cmpi slt, %44, %43 : index
    cf.cond_br %46, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %47 = memref.load %arg5[%44] : memref<?xindex>
    %48 = memref.load %arg6[%44] : memref<?xf32>
    cf.br ^bb13(%c0, %45 : index, index)
  ^bb13(%49: index, %50: index):  // 2 preds: ^bb12, ^bb18
    %51 = arith.cmpi slt, %49, %c32 : index
    cf.cond_br %51, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %52 = arith.muli %47, %c32 : index
    %53 = arith.addi %52, %49 : index
    %54 = memref.load %alloc_8[%49] : memref<32xf32>
    %55 = memref.load %arg8[%53] : memref<?xf32>
    %56 = arith.mulf %48, %55 : f32
    %57 = arith.addf %54, %56 : f32
    %58 = memref.load %alloc_9[%49] : memref<32xi1>
    %59 = arith.cmpi eq, %58, %false : i1
    cf.cond_br %59, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    memref.store %true, %alloc_9[%49] : memref<32xi1>
    memref.store %49, %alloc_10[%50] : memref<32xindex>
    %60 = arith.addi %50, %c1 : index
    cf.br ^bb17(%60 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%50 : index)
  ^bb17(%61: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    memref.store %57, %alloc_8[%49] : memref<32xf32>
    %62 = arith.addi %49, %c1 : index
    cf.br ^bb13(%62, %61 : index, index)
  ^bb19:  // pred: ^bb13
    %63 = arith.addi %44, %c1 : index
    cf.br ^bb11(%63, %50 : index, index)
  ^bb20:  // pred: ^bb11
    %64 = arith.index_cast %45 : index to i64
    %65 = math.ctlz %64 : i64
    %66 = arith.subi %c64_i64, %65 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %45, %cast_11, %66) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%67: index, %68: memref<?xindex>, %69: memref<?xindex>, %70: memref<?xindex>, %71: memref<?xindex>, %72: memref<?xf32>, %73: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %74 = arith.cmpi slt, %67, %45 : index
    cf.cond_br %74, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %75 = memref.load %alloc_10[%67] : memref<32xindex>
    %76 = memref.load %alloc_8[%75] : memref<32xf32>
    %77:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%68, %69, %70, %71, %72, %73, %28, %40, %75, %76) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    memref.store %cst, %alloc_8[%75] : memref<32xf32>
    memref.store %false, %alloc_9[%75] : memref<32xi1>
    %78 = arith.addi %67, %c1 : index
    cf.br ^bb21(%78, %77#0, %77#1, %77#2, %77#3, %77#4, %77#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %79 = arith.addi %32, %c1 : index
    cf.br ^bb9(%79, %68, %69, %70, %71, %72, %73 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %80 = arith.addi %20, %c1 : index
    cf.br ^bb7(%80, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    memref.dealloc %alloc_8 : memref<32xf32>
    memref.dealloc %alloc_9 : memref<32xi1>
    memref.dealloc %alloc_10 : memref<32xindex>
    %81 = llvm.extractvalue %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %82 = arith.index_cast %81 : i64 to index
    %83 = memref.load %23[%c0] : memref<?xindex>
    cf.br ^bb26(%c1, %83 : index, index)
  ^bb26(%84: index, %85: index):  // 2 preds: ^bb25, ^bb29
    %86 = arith.cmpi slt, %84, %82 : index
    cf.cond_br %86, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %87 = memref.load %23[%84] : memref<?xindex>
    %88 = arith.cmpi eq, %87, %c0 : index
    %89 = arith.select %88, %85, %87 : index
    cf.cond_br %88, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    memref.store %85, %23[%84] : memref<?xindex>
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %90 = arith.addi %84, %c1 : index
    cf.br ^bb26(%90, %89 : index, index)
  ^bb30:  // pred: ^bb26
    %alloc_12 = memref.alloc() : memref<4096xf32>
    %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
    %91 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %92 = llvm.insertvalue %c0_i64, %91[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %93 = llvm.insertvalue %c128_i64, %92[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %94 = llvm.insertvalue %c32_i64, %93[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%95: index):  // 2 preds: ^bb30, ^bb32
    %96 = arith.cmpi slt, %95, %c4096 : index
    cf.cond_br %96, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    memref.store %cst, %alloc_12[%95] : memref<4096xf32>
    %97 = arith.addi %95, %c1 : index
    cf.br ^bb31(%97 : index)
  ^bb33:  // pred: ^bb31
    %98 = llvm.insertvalue %c4096_i64, %94[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %99 = memref.load %21[%c0] : memref<?xindex>
    %100 = memref.load %21[%c1] : memref<?xindex>
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%99) to (%100) step (%c1) {
        %101 = memref.load %22[%arg12] : memref<?xindex>
        %102 = memref.load %23[%arg12] : memref<?xindex>
        %103 = arith.addi %arg12, %c1 : index
        %104 = memref.load %23[%103] : memref<?xindex>
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%102) to (%104) step (%c1) {
            %105 = memref.load %24[%arg13] : memref<?xindex>
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %106 = arith.muli %arg13, %c32 : index
                %107 = arith.addi %106, %arg14 : index
                %108 = arith.muli %105, %c32 : index
                %109 = arith.addi %108, %arg14 : index
                %110 = arith.muli %101, %c32 : index
                %111 = arith.addi %110, %arg14 : index
                %112 = memref.load %alloc_12[%111] : memref<4096xf32>
                %113 = memref.load %25[%107] : memref<?xf32>
                %114 = memref.load %arg10[%109] : memref<?xf32>
                %115 = arith.mulf %113, %114 : f32
                %116 = arith.addf %112, %115 : f32
                memref.store %116, %alloc_12[%111] : memref<4096xf32>
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast_13, %98 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %0 = memref.load %arg0[%c0] : memref<?xindex>
    %1 = memref.load %arg0[%c1] : memref<?xindex>
    %2 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = arith.index_cast %2 : i64 to index
    %4 = arith.subi %1, %c1 : index
    %5 = arith.cmpi ult, %0, %1 : index
    cf.cond_br %5, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %6 = memref.load %arg1[%4] : memref<?xindex>
    %7 = arith.cmpi eq, %6, %arg6 : index
    cf.br ^bb3(%7 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%8: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %9 = arith.select %8, %4, %3 : index
    cf.cond_br %8, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb15(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %10 = arith.addi %3, %c1 : index
    memref.store %10, %arg0[%c1] : memref<?xindex>
    %11 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %12 = arith.index_cast %11 : i64 to index
    %dim = memref.dim %arg1, %c0 : memref<?xindex>
    %13 = arith.addi %12, %c1 : index
    %14 = arith.cmpi ugt, %13, %dim : index
    cf.cond_br %14, ^bb7, ^bb8
  ^bb7:  // pred: ^bb6
    %15 = arith.muli %dim, %c2 : index
    %16 = memref.realloc %arg1(%15) : memref<?xindex> to memref<?xindex>
    cf.br ^bb9(%16 : memref<?xindex>)
  ^bb8:  // pred: ^bb6
    cf.br ^bb9(%arg1 : memref<?xindex>)
  ^bb9(%17: memref<?xindex>):  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    memref.store %arg6, %17[%12] : memref<?xindex>
    %18 = arith.index_cast %13 : index to i64
    %19 = llvm.insertvalue %18, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %20 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %21 = arith.index_cast %20 : i64 to index
    %dim_0 = memref.dim %arg2, %c0 : memref<?xindex>
    %22 = arith.addi %21, %c1 : index
    %23 = arith.cmpi ugt, %22, %dim_0 : index
    cf.cond_br %23, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %24 = arith.muli %dim_0, %c2 : index
    %25 = memref.realloc %arg2(%24) : memref<?xindex> to memref<?xindex>
    cf.br ^bb13(%25 : memref<?xindex>)
  ^bb12:  // pred: ^bb10
    cf.br ^bb13(%arg2 : memref<?xindex>)
  ^bb13(%26: memref<?xindex>):  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    memref.store %c0, %26[%21] : memref<?xindex>
    %27 = arith.index_cast %22 : index to i64
    %28 = llvm.insertvalue %27, %19[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb15(%17, %26, %28 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb15(%29: memref<?xindex>, %30: memref<?xindex>, %31: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb14
    cf.br ^bb16
  ^bb16:  // pred: ^bb15
    %32 = arith.addi %9, %c1 : index
    %33 = memref.load %30[%9] : memref<?xindex>
    %34 = memref.load %30[%32] : memref<?xindex>
    %35 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %36 = arith.index_cast %35 : i64 to index
    %37 = arith.subi %34, %c1 : index
    %38 = arith.cmpi ult, %33, %34 : index
    cf.cond_br %38, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %39 = memref.load %arg3[%37] : memref<?xindex>
    %40 = arith.cmpi eq, %39, %arg7 : index
    cf.br ^bb19(%40 : i1)
  ^bb18:  // pred: ^bb16
    memref.store %36, %30[%9] : memref<?xindex>
    cf.br ^bb19(%false : i1)
  ^bb19(%41: i1):  // 2 preds: ^bb17, ^bb18
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %42 = arith.select %41, %37, %36 : index
    cf.cond_br %41, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    cf.br ^bb36(%arg3, %arg4, %31 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb22:  // pred: ^bb20
    %43 = arith.addi %36, %c1 : index
    memref.store %43, %30[%32] : memref<?xindex>
    %44 = llvm.extractvalue %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %45 = arith.index_cast %44 : i64 to index
    %dim_1 = memref.dim %arg3, %c0 : memref<?xindex>
    %46 = arith.addi %45, %c1 : index
    %47 = arith.cmpi ugt, %46, %dim_1 : index
    cf.cond_br %47, ^bb23, ^bb24
  ^bb23:  // pred: ^bb22
    %48 = arith.muli %dim_1, %c2 : index
    %49 = memref.realloc %arg3(%48) : memref<?xindex> to memref<?xindex>
    cf.br ^bb25(%49 : memref<?xindex>)
  ^bb24:  // pred: ^bb22
    cf.br ^bb25(%arg3 : memref<?xindex>)
  ^bb25(%50: memref<?xindex>):  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // pred: ^bb25
    memref.store %arg7, %50[%45] : memref<?xindex>
    %51 = arith.index_cast %46 : index to i64
    %52 = llvm.insertvalue %51, %31[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %53 = llvm.extractvalue %31[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %54 = arith.index_cast %53 : i64 to index
    %dim_2 = memref.dim %arg4, %c0 : memref<?xf32>
    %55 = arith.addi %54, %c32 : index
    %56 = arith.cmpi ugt, %55, %dim_2 : index
    cf.cond_br %56, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    cf.br ^bb28(%dim_2 : index)
  ^bb28(%57: index):  // 2 preds: ^bb27, ^bb28
    %58 = arith.muli %57, %c2 : index
    %59 = arith.cmpi ugt, %55, %58 : index
    cf.cond_br %59, ^bb28(%58 : index), ^bb29
  ^bb29:  // pred: ^bb28
    %60 = memref.realloc %arg4(%58) : memref<?xf32> to memref<?xf32>
    cf.br ^bb31(%60 : memref<?xf32>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg4 : memref<?xf32>)
  ^bb31(%61: memref<?xf32>):  // 2 preds: ^bb29, ^bb30
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %base_buffer, %offset, %sizes, %strides = memref.extract_strided_metadata %61 : memref<?xf32> -> memref<f32>, index, index, index
    %reinterpret_cast = memref.reinterpret_cast %base_buffer to offset: [%54], sizes: [32], strides: [1] : memref<f32> to memref<32xf32, strided<[1], offset: ?>>
    cf.br ^bb33(%c0 : index)
  ^bb33(%62: index):  // 2 preds: ^bb32, ^bb34
    %63 = arith.cmpi slt, %62, %c32 : index
    cf.cond_br %63, ^bb34, ^bb35
  ^bb34:  // pred: ^bb33
    memref.store %cst, %reinterpret_cast[%62] : memref<32xf32, strided<[1], offset: ?>>
    %64 = arith.addi %62, %c1 : index
    cf.br ^bb33(%64 : index)
  ^bb35:  // pred: ^bb33
    %65 = arith.index_cast %55 : index to i64
    %66 = llvm.insertvalue %65, %52[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb36(%50, %61, %66 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb36(%67: memref<?xindex>, %68: memref<?xf32>, %69: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb21, ^bb35
    cf.br ^bb37
  ^bb37:  // pred: ^bb36
    %70 = arith.muli %42, %c32 : index
    %71 = arith.addi %70, %arg8 : index
    memref.store %arg9, %68[%71] : memref<?xf32>
    return %arg0, %29, %30, %67, %68, %69 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb2
    %2 = arith.cmpi ult, %0, %1 : index
    cf.cond_br %2, ^bb2(%0, %1 : index, index), ^bb3
  ^bb2(%3: index, %4: index):  // pred: ^bb1
    %5 = arith.addi %3, %4 : index
    %6 = arith.shrui %5, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = memref.load %arg2[%arg1] : memref<?xindex>
    %9 = memref.load %arg2[%6] : memref<?xindex>
    %10 = arith.cmpi ult, %8, %9 : index
    %11 = arith.select %10, %3, %7 : index
    %12 = arith.select %10, %6, %4 : index
    cf.br ^bb1(%11, %12 : index, index)
  ^bb3:  // pred: ^bb1
    return %0 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%0 : index)
  ^bb1(%1: index):  // 2 preds: ^bb0, ^bb5
    %2 = arith.cmpi slt, %1, %arg1 : index
    cf.cond_br %2, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %3 = call @_sparse_binary_search_1_index(%arg0, %1, %arg2) : (index, index, memref<?xindex>) -> index
    %4 = memref.load %arg2[%1] : memref<?xindex>
    %5 = arith.subi %1, %3 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%6: index):  // 2 preds: ^bb2, ^bb4
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %8 = arith.subi %1, %6 : index
    %9 = arith.subi %8, %c1 : index
    %10 = memref.load %arg2[%9] : memref<?xindex>
    memref.store %10, %arg2[%8] : memref<?xindex>
    %11 = arith.addi %6, %c1 : index
    cf.br ^bb3(%11 : index)
  ^bb5:  // pred: ^bb3
    memref.store %4, %arg2[%3] : memref<?xindex>
    %12 = arith.addi %1, %c1 : index
    cf.br ^bb1(%12 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %0, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %1 = arith.subi %arg1, %arg0 : index
    %2 = arith.subi %arg3, %c2 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = arith.cmpi uge, %3, %1 : index
    cf.cond_br %4, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %5 = arith.shli %1, %c1 : index
    %6 = arith.addi %5, %c1 : index
    %7 = arith.addi %6, %arg0 : index
    %8 = arith.addi %5, %c2 : index
    %9 = arith.cmpi ult, %8, %arg3 : index
    cf.cond_br %9, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %10 = arith.addi %8, %arg0 : index
    %11 = memref.load %arg2[%7] : memref<?xindex>
    %12 = memref.load %arg2[%10] : memref<?xindex>
    %13 = arith.cmpi ult, %11, %12 : index
    %14 = arith.select %13, %8, %6 : index
    %15 = arith.select %13, %10, %7 : index
    cf.br ^bb5(%14, %15, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%6, %7, %arg1 : index, index, index)
  ^bb5(%16: index, %17: index, %18: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%18, %16, %17 : index, index, index)
  ^bb6(%19: index, %20: index, %21: index):  // pred: ^bb5
    cf.br ^bb7(%19, %20, %21 : index, index, index)
  ^bb7(%22: index, %23: index, %24: index):  // pred: ^bb6
    %25 = memref.load %arg2[%22] : memref<?xindex>
    %26 = memref.load %arg2[%24] : memref<?xindex>
    %27 = arith.cmpi ult, %25, %26 : index
    cf.cond_br %27, ^bb8(%22, %23, %24 : index, index, index), ^bb14
  ^bb8(%28: index, %29: index, %30: index):  // pred: ^bb7
    %31 = memref.load %arg2[%28] : memref<?xindex>
    %32 = memref.load %arg2[%30] : memref<?xindex>
    memref.store %32, %arg2[%28] : memref<?xindex>
    memref.store %31, %arg2[%30] : memref<?xindex>
    %33 = arith.cmpi uge, %3, %29 : index
    cf.cond_br %33, ^bb9, ^bb13(%29, %30 : index, index)
  ^bb9:  // pred: ^bb8
    %34 = arith.shli %29, %c1 : index
    %35 = arith.addi %34, %c1 : index
    %36 = arith.addi %35, %arg0 : index
    %37 = arith.addi %34, %c2 : index
    %38 = arith.cmpi ult, %37, %arg3 : index
    cf.cond_br %38, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %39 = arith.addi %37, %arg0 : index
    %40 = memref.load %arg2[%36] : memref<?xindex>
    %41 = memref.load %arg2[%39] : memref<?xindex>
    %42 = arith.cmpi ult, %40, %41 : index
    %43 = arith.select %42, %37, %35 : index
    %44 = arith.select %42, %39, %36 : index
    cf.br ^bb12(%43, %44 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%35, %36 : index, index)
  ^bb12(%45: index, %46: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%45, %46 : index, index)
  ^bb13(%47: index, %48: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%47, %48, %30 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = arith.subi %arg1, %arg0 : index
    %1 = arith.subi %0, %c2 : index
    %2 = arith.shrui %1, %c1 : index
    %3 = arith.addi %2, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%4: index):  // 2 preds: ^bb0, ^bb2
    %5 = arith.cmpi slt, %4, %3 : index
    cf.cond_br %5, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %6 = arith.subi %2, %4 : index
    %7 = arith.addi %arg0, %6 : index
    call @_sparse_shift_down_1_index(%arg0, %7, %arg2, %0) : (index, index, memref<?xindex>, index) -> ()
    %8 = arith.addi %4, %c1 : index
    cf.br ^bb1(%8 : index)
  ^bb3:  // pred: ^bb1
    %9 = arith.subi %0, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%10: index):  // 2 preds: ^bb3, ^bb5
    %11 = arith.cmpi slt, %10, %9 : index
    cf.cond_br %11, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %12 = arith.subi %0, %10 : index
    %13 = arith.addi %arg0, %12 : index
    %14 = arith.subi %13, %c1 : index
    %15 = memref.load %arg2[%arg0] : memref<?xindex>
    %16 = memref.load %arg2[%14] : memref<?xindex>
    memref.store %16, %arg2[%arg0] : memref<?xindex>
    memref.store %15, %arg2[%14] : memref<?xindex>
    %17 = arith.subi %12, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %17) : (index, index, memref<?xindex>, index) -> ()
    %18 = arith.addi %10, %c1 : index
    cf.br ^bb4(%18 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %0 = arith.addi %arg0, %arg1 : index
    %1 = arith.shrui %0, %c1 : index
    %2 = arith.subi %arg1, %c1 : index
    %3 = arith.subi %arg1, %arg0 : index
    %4 = arith.cmpi ult, %3, %c1000 : index
    cf.cond_br %4, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %5 = memref.load %arg2[%1] : memref<?xindex>
    %6 = memref.load %arg2[%arg0] : memref<?xindex>
    %7 = arith.cmpi ult, %5, %6 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = memref.load %arg2[%1] : memref<?xindex>
    %9 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %9, %arg2[%1] : memref<?xindex>
    memref.store %8, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %10 = memref.load %arg2[%2] : memref<?xindex>
    %11 = memref.load %arg2[%1] : memref<?xindex>
    %12 = arith.cmpi ult, %10, %11 : index
    cf.cond_br %12, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %13 = memref.load %arg2[%2] : memref<?xindex>
    %14 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %14, %arg2[%2] : memref<?xindex>
    memref.store %13, %arg2[%1] : memref<?xindex>
    %15 = memref.load %arg2[%1] : memref<?xindex>
    %16 = memref.load %arg2[%arg0] : memref<?xindex>
    %17 = arith.cmpi ult, %15, %16 : index
    cf.cond_br %17, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %18 = memref.load %arg2[%1] : memref<?xindex>
    %19 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %19, %arg2[%1] : memref<?xindex>
    memref.store %18, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %2, %1 : index, index, index)
  ^bb8:  // pred: ^bb0
    %20 = arith.addi %arg0, %arg1 : index
    %21 = arith.shrui %20, %c1 : index
    %22 = arith.addi %1, %arg1 : index
    %23 = arith.shrui %22, %c1 : index
    %24 = memref.load %arg2[%21] : memref<?xindex>
    %25 = memref.load %arg2[%arg0] : memref<?xindex>
    %26 = arith.cmpi ult, %24, %25 : index
    cf.cond_br %26, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %27 = memref.load %arg2[%21] : memref<?xindex>
    %28 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %28, %arg2[%21] : memref<?xindex>
    memref.store %27, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %29 = memref.load %arg2[%1] : memref<?xindex>
    %30 = memref.load %arg2[%21] : memref<?xindex>
    %31 = arith.cmpi ult, %29, %30 : index
    cf.cond_br %31, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %32 = memref.load %arg2[%1] : memref<?xindex>
    %33 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %33, %arg2[%1] : memref<?xindex>
    memref.store %32, %arg2[%21] : memref<?xindex>
    %34 = memref.load %arg2[%21] : memref<?xindex>
    %35 = memref.load %arg2[%arg0] : memref<?xindex>
    %36 = arith.cmpi ult, %34, %35 : index
    cf.cond_br %36, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %37 = memref.load %arg2[%21] : memref<?xindex>
    %38 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %38, %arg2[%21] : memref<?xindex>
    memref.store %37, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %39 = memref.load %arg2[%23] : memref<?xindex>
    %40 = memref.load %arg2[%1] : memref<?xindex>
    %41 = arith.cmpi ult, %39, %40 : index
    cf.cond_br %41, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %42 = memref.load %arg2[%23] : memref<?xindex>
    %43 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %43, %arg2[%23] : memref<?xindex>
    memref.store %42, %arg2[%1] : memref<?xindex>
    %44 = memref.load %arg2[%1] : memref<?xindex>
    %45 = memref.load %arg2[%21] : memref<?xindex>
    %46 = arith.cmpi ult, %44, %45 : index
    cf.cond_br %46, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %47 = memref.load %arg2[%1] : memref<?xindex>
    %48 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %48, %arg2[%1] : memref<?xindex>
    memref.store %47, %arg2[%21] : memref<?xindex>
    %49 = memref.load %arg2[%21] : memref<?xindex>
    %50 = memref.load %arg2[%arg0] : memref<?xindex>
    %51 = arith.cmpi ult, %49, %50 : index
    cf.cond_br %51, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %52 = memref.load %arg2[%21] : memref<?xindex>
    %53 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %53, %arg2[%21] : memref<?xindex>
    memref.store %52, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %54 = memref.load %arg2[%2] : memref<?xindex>
    %55 = memref.load %arg2[%23] : memref<?xindex>
    %56 = arith.cmpi ult, %54, %55 : index
    cf.cond_br %56, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %57 = memref.load %arg2[%2] : memref<?xindex>
    %58 = memref.load %arg2[%23] : memref<?xindex>
    memref.store %58, %arg2[%2] : memref<?xindex>
    memref.store %57, %arg2[%23] : memref<?xindex>
    %59 = memref.load %arg2[%23] : memref<?xindex>
    %60 = memref.load %arg2[%1] : memref<?xindex>
    %61 = arith.cmpi ult, %59, %60 : index
    cf.cond_br %61, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %62 = memref.load %arg2[%23] : memref<?xindex>
    %63 = memref.load %arg2[%1] : memref<?xindex>
    memref.store %63, %arg2[%23] : memref<?xindex>
    memref.store %62, %arg2[%1] : memref<?xindex>
    %64 = memref.load %arg2[%1] : memref<?xindex>
    %65 = memref.load %arg2[%21] : memref<?xindex>
    %66 = arith.cmpi ult, %64, %65 : index
    cf.cond_br %66, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %67 = memref.load %arg2[%1] : memref<?xindex>
    %68 = memref.load %arg2[%21] : memref<?xindex>
    memref.store %68, %arg2[%1] : memref<?xindex>
    memref.store %67, %arg2[%21] : memref<?xindex>
    %69 = memref.load %arg2[%21] : memref<?xindex>
    %70 = memref.load %arg2[%arg0] : memref<?xindex>
    %71 = arith.cmpi ult, %69, %70 : index
    cf.cond_br %71, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %72 = memref.load %arg2[%21] : memref<?xindex>
    %73 = memref.load %arg2[%arg0] : memref<?xindex>
    memref.store %73, %arg2[%21] : memref<?xindex>
    memref.store %72, %arg2[%arg0] : memref<?xindex>
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%74: index, %75: index, %76: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%74, %75, %76 : index, index, index)
  ^bb28(%77: index, %78: index, %79: index):  // pred: ^bb27
    %80 = arith.cmpi ult, %77, %78 : index
    cf.cond_br %80, ^bb29(%77, %78, %79 : index, index, index), ^bb46
  ^bb29(%81: index, %82: index, %83: index):  // pred: ^bb28
    cf.br ^bb30(%81 : index)
  ^bb30(%84: index):  // 2 preds: ^bb29, ^bb31
    %85 = memref.load %arg2[%84] : memref<?xindex>
    %86 = memref.load %arg2[%83] : memref<?xindex>
    %87 = arith.cmpi ult, %85, %86 : index
    cf.cond_br %87, ^bb31(%84 : index), ^bb32
  ^bb31(%88: index):  // pred: ^bb30
    %89 = arith.addi %88, %c1 : index
    cf.br ^bb30(%89 : index)
  ^bb32:  // pred: ^bb30
    %90 = memref.load %arg2[%84] : memref<?xindex>
    %91 = memref.load %arg2[%83] : memref<?xindex>
    %92 = arith.cmpi eq, %90, %91 : index
    cf.br ^bb33(%82 : index)
  ^bb33(%93: index):  // 2 preds: ^bb32, ^bb34
    %94 = memref.load %arg2[%83] : memref<?xindex>
    %95 = memref.load %arg2[%93] : memref<?xindex>
    %96 = arith.cmpi ult, %94, %95 : index
    cf.cond_br %96, ^bb34(%93 : index), ^bb35
  ^bb34(%97: index):  // pred: ^bb33
    %98 = arith.addi %97, %c-1 : index
    cf.br ^bb33(%98 : index)
  ^bb35:  // pred: ^bb33
    %99 = memref.load %arg2[%93] : memref<?xindex>
    %100 = memref.load %arg2[%83] : memref<?xindex>
    %101 = arith.cmpi eq, %99, %100 : index
    %102 = arith.cmpi ult, %84, %93 : index
    cf.cond_br %102, ^bb36, ^bb44(%84, %93, %83 : index, index, index)
  ^bb36:  // pred: ^bb35
    %103 = memref.load %arg2[%84] : memref<?xindex>
    %104 = memref.load %arg2[%93] : memref<?xindex>
    memref.store %104, %arg2[%84] : memref<?xindex>
    memref.store %103, %arg2[%93] : memref<?xindex>
    %105 = arith.cmpi eq, %84, %83 : index
    cf.cond_br %105, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%93 : index)
  ^bb38:  // pred: ^bb36
    %106 = arith.cmpi eq, %93, %83 : index
    %107 = arith.select %106, %84, %83 : index
    cf.br ^bb39(%107 : index)
  ^bb39(%108: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %109 = arith.andi %92, %101 : i1
    cf.cond_br %109, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %110 = arith.addi %84, %c1 : index
    %111 = arith.subi %93, %c1 : index
    cf.br ^bb43(%110, %111 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%84, %93 : index, index)
  ^bb43(%112: index, %113: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%112, %113, %108 : index, index, index)
  ^bb44(%114: index, %115: index, %116: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%114, %115, %116 : index, index, index)
  ^bb45(%117: index, %118: index, %119: index):  // pred: ^bb44
    cf.br ^bb27(%117, %118, %119 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %79 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %c0 = arith.constant 0 : index
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %alloc = memref.alloc() : memref<16xindex>
    %cast = memref.cast %alloc : memref<16xindex> to memref<?xindex>
    %alloc_0 = memref.alloc() : memref<16xindex>
    %cast_1 = memref.cast %alloc_0 : memref<16xindex> to memref<?xindex>
    %alloc_2 = memref.alloc() : memref<16xindex>
    %cast_3 = memref.cast %alloc_2 : memref<16xindex> to memref<?xindex>
    %alloc_4 = memref.alloc() : memref<16xindex>
    %cast_5 = memref.cast %alloc_4 : memref<16xindex> to memref<?xindex>
    %alloc_6 = memref.alloc() : memref<16xf32>
    %cast_7 = memref.cast %alloc_6 : memref<16xf32> to memref<?xf32>
    %0 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %1 = llvm.insertvalue %c0_i64, %0[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %2 = llvm.insertvalue %c0_i64, %1[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %3 = llvm.insertvalue %c0_i64, %2[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %4 = llvm.insertvalue %c0_i64, %3[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %5 = llvm.insertvalue %c0_i64, %4[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %6 = llvm.insertvalue %c128_i64, %5[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c0] : memref<16xindex>
    %7 = llvm.insertvalue %c1_i64, %6[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %8 = llvm.insertvalue %c128_i64, %7[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc_2[%c0] : memref<16xindex>
    %9 = llvm.insertvalue %c1_i64, %8[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %10 = llvm.insertvalue %c32_i64, %9[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    memref.store %c0, %alloc[%c1] : memref<16xindex>
    %11 = llvm.insertvalue %c2_i64, %10[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %alloc_8 = memref.alloc() : memref<32xf32>
    %alloc_9 = memref.alloc() : memref<32xi1>
    %alloc_10 = memref.alloc() : memref<32xindex>
    %cast_11 = memref.cast %alloc_10 : memref<32xindex> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%12: index):  // 2 preds: ^bb0, ^bb2
    %13 = arith.cmpi slt, %12, %c32 : index
    cf.cond_br %13, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    memref.store %cst, %alloc_8[%12] : memref<32xf32>
    %14 = arith.addi %12, %c1 : index
    cf.br ^bb1(%14 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%15: index):  // 2 preds: ^bb3, ^bb5
    %16 = arith.cmpi slt, %15, %c32 : index
    cf.cond_br %16, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    memref.store %false, %alloc_9[%15] : memref<32xi1>
    %17 = arith.addi %15, %c1 : index
    cf.br ^bb4(%17 : index)
  ^bb6:  // pred: ^bb4
    %18 = memref.load %arg0[%c0] : memref<?xindex>
    %19 = memref.load %arg0[%c1] : memref<?xindex>
    cf.br ^bb7(%18, %cast, %cast_1, %cast_3, %cast_5, %cast_7, %11 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%20: index, %21: memref<?xindex>, %22: memref<?xindex>, %23: memref<?xindex>, %24: memref<?xindex>, %25: memref<?xf32>, %26: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %27 = arith.cmpi slt, %20, %19 : index
    cf.cond_br %27, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %28 = memref.load %arg1[%20] : memref<?xindex>
    %29 = memref.load %arg2[%20] : memref<?xindex>
    %30 = arith.addi %20, %c1 : index
    %31 = memref.load %arg2[%30] : memref<?xindex>
    cf.br ^bb9(%29, %21, %22, %23, %24, %25, %26 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%32: index, %33: memref<?xindex>, %34: memref<?xindex>, %35: memref<?xindex>, %36: memref<?xindex>, %37: memref<?xf32>, %38: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %39 = arith.cmpi slt, %32, %31 : index
    cf.cond_br %39, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %40 = memref.load %arg3[%32] : memref<?xindex>
    %41 = memref.load %arg4[%32] : memref<?xindex>
    %42 = arith.addi %32, %c1 : index
    %43 = memref.load %arg4[%42] : memref<?xindex>
    cf.br ^bb11(%41, %c0 : index, index)
  ^bb11(%44: index, %45: index):  // 2 preds: ^bb10, ^bb19
    %46 = arith.cmpi slt, %44, %43 : index
    cf.cond_br %46, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %47 = memref.load %arg5[%44] : memref<?xindex>
    %48 = memref.load %arg6[%44] : memref<?xf32>
    cf.br ^bb13(%c0, %45 : index, index)
  ^bb13(%49: index, %50: index):  // 2 preds: ^bb12, ^bb18
    %51 = arith.cmpi slt, %49, %c32 : index
    cf.cond_br %51, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %52 = arith.muli %47, %c32 : index
    %53 = arith.addi %52, %49 : index
    %54 = memref.load %alloc_8[%49] : memref<32xf32>
    %55 = memref.load %arg8[%53] : memref<?xf32>
    %56 = arith.mulf %48, %55 : f32
    %57 = arith.addf %54, %56 : f32
    %58 = memref.load %alloc_9[%49] : memref<32xi1>
    %59 = arith.cmpi eq, %58, %false : i1
    cf.cond_br %59, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    memref.store %true, %alloc_9[%49] : memref<32xi1>
    memref.store %49, %alloc_10[%50] : memref<32xindex>
    %60 = arith.addi %50, %c1 : index
    cf.br ^bb17(%60 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%50 : index)
  ^bb17(%61: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    memref.store %57, %alloc_8[%49] : memref<32xf32>
    %62 = arith.addi %49, %c1 : index
    cf.br ^bb13(%62, %61 : index, index)
  ^bb19:  // pred: ^bb13
    %63 = arith.addi %44, %c1 : index
    cf.br ^bb11(%63, %50 : index, index)
  ^bb20:  // pred: ^bb11
    %64 = arith.index_cast %45 : index to i64
    %65 = math.ctlz %64 : i64
    %66 = arith.subi %c64_i64, %65 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %45, %cast_11, %66) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%67: index, %68: memref<?xindex>, %69: memref<?xindex>, %70: memref<?xindex>, %71: memref<?xindex>, %72: memref<?xf32>, %73: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %74 = arith.cmpi slt, %67, %45 : index
    cf.cond_br %74, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %75 = memref.load %alloc_10[%67] : memref<32xindex>
    %76 = memref.load %alloc_8[%75] : memref<32xf32>
    %77:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%68, %69, %70, %71, %72, %73, %28, %40, %75, %76) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    memref.store %cst, %alloc_8[%75] : memref<32xf32>
    memref.store %false, %alloc_9[%75] : memref<32xi1>
    %78 = arith.addi %67, %c1 : index
    cf.br ^bb21(%78, %77#0, %77#1, %77#2, %77#3, %77#4, %77#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %79 = arith.addi %32, %c1 : index
    cf.br ^bb9(%79, %68, %69, %70, %71, %72, %73 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %80 = arith.addi %20, %c1 : index
    cf.br ^bb7(%80, %33, %34, %35, %36, %37, %38 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    memref.dealloc %alloc_8 : memref<32xf32>
    memref.dealloc %alloc_9 : memref<32xi1>
    memref.dealloc %alloc_10 : memref<32xindex>
    %81 = llvm.extractvalue %26[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %82 = arith.index_cast %81 : i64 to index
    %83 = memref.load %23[%c0] : memref<?xindex>
    cf.br ^bb26(%c1, %83 : index, index)
  ^bb26(%84: index, %85: index):  // 2 preds: ^bb25, ^bb29
    %86 = arith.cmpi slt, %84, %82 : index
    cf.cond_br %86, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %87 = memref.load %23[%84] : memref<?xindex>
    %88 = arith.cmpi eq, %87, %c0 : index
    %89 = arith.select %88, %85, %87 : index
    cf.cond_br %88, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    memref.store %85, %23[%84] : memref<?xindex>
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %90 = arith.addi %84, %c1 : index
    cf.br ^bb26(%90, %89 : index, index)
  ^bb30:  // pred: ^bb26
    %alloc_12 = memref.alloc() : memref<4096xf32>
    %cast_13 = memref.cast %alloc_12 : memref<4096xf32> to memref<?xf32>
    %91 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %92 = llvm.insertvalue %c0_i64, %91[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %93 = llvm.insertvalue %c128_i64, %92[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %94 = llvm.insertvalue %c32_i64, %93[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%95: index):  // 2 preds: ^bb30, ^bb32
    %96 = arith.cmpi slt, %95, %c4096 : index
    cf.cond_br %96, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    memref.store %cst, %alloc_12[%95] : memref<4096xf32>
    %97 = arith.addi %95, %c1 : index
    cf.br ^bb31(%97 : index)
  ^bb33:  // pred: ^bb31
    %98 = llvm.insertvalue %c4096_i64, %94[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %99 = memref.load %21[%c0] : memref<?xindex>
    %100 = memref.load %21[%c1] : memref<?xindex>
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%99) to (%100) step (%c1) {
        %101 = memref.load %22[%arg12] : memref<?xindex>
        %102 = memref.load %23[%arg12] : memref<?xindex>
        %103 = arith.addi %arg12, %c1 : index
        %104 = memref.load %23[%103] : memref<?xindex>
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%102) to (%104) step (%c1) {
            %105 = memref.load %24[%arg13] : memref<?xindex>
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %106 = arith.muli %arg13, %c32 : index
                %107 = arith.addi %106, %arg14 : index
                %108 = arith.muli %105, %c32 : index
                %109 = arith.addi %108, %arg14 : index
                %110 = arith.muli %101, %c32 : index
                %111 = arith.addi %110, %arg14 : index
                %112 = memref.load %alloc_12[%111] : memref<4096xf32>
                %113 = memref.load %25[%107] : memref<?xf32>
                %114 = memref.load %arg10[%109] : memref<?xf32>
                %115 = arith.mulf %113, %114 : f32
                %116 = arith.addf %112, %115 : f32
                memref.store %116, %alloc_12[%111] : memref<4096xf32>
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %cast_13, %98 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After FinalizeMemRefToLLVMConversionPass (finalize-memref-to-llvm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
    %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c1 = arith.constant 1 : index
    %7 = builtin.unrealized_conversion_cast %c1 : index to i64
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.subi %16, %c1 : index
    %20 = builtin.unrealized_conversion_cast %19 : index to i64
    %21 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %21, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = arith.cmpi eq, %25, %arg6 : index
    cf.br ^bb3(%26 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %28 = arith.select %27, %19, %18 : index
    %29 = builtin.unrealized_conversion_cast %28 : index to i64
    cf.cond_br %27, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %30 = arith.addi %18, %c1 : index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %31, %33 : i64, !llvm.ptr
    %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = builtin.unrealized_conversion_cast %35 : index to i64
    %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %35, %c1 : index
    %40 = arith.cmpi ugt, %39, %38 : index
    cf.cond_br %40, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %41 = arith.muli %38, %c2 : index
    %42 = builtin.unrealized_conversion_cast %41 : index to i64
    %43 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = builtin.unrealized_conversion_cast %41 : index to i64
    %45 = llvm.icmp "ugt" %44, %43 : i64
    llvm.cond_br %45, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %46 = llvm.mlir.null : !llvm.ptr
    %47 = llvm.getelementptr %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
    %49 = llvm.mul %44, %48  : i64
    %50 = llvm.mul %43, %48  : i64
    %51 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %52 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%51, %52, %50) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %53 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%53) : (!llvm.ptr) -> ()
    %54 = llvm.insertvalue %51, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %51, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%55 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%56: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %57 = llvm.insertvalue %44, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = builtin.unrealized_conversion_cast %57 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb11(%58 : memref<?xindex>)
  ^bb10:  // pred: ^bb6
    cf.br ^bb11(%arg1 : memref<?xindex>)
  ^bb11(%59: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
    %60 = builtin.unrealized_conversion_cast %59 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    %61 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.getelementptr %61[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %5, %62 : i64, !llvm.ptr
    %63 = arith.index_cast %39 : index to i64
    %64 = llvm.insertvalue %63, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %65 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %66 = arith.index_cast %65 : i64 to index
    %67 = builtin.unrealized_conversion_cast %66 : index to i64
    %68 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : i64 to index
    %70 = arith.addi %66, %c1 : index
    %71 = arith.cmpi ugt, %70, %69 : index
    cf.cond_br %71, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %72 = arith.muli %69, %c2 : index
    %73 = builtin.unrealized_conversion_cast %72 : index to i64
    %74 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = builtin.unrealized_conversion_cast %72 : index to i64
    %76 = llvm.icmp "ugt" %75, %74 : i64
    llvm.cond_br %76, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %77 = llvm.mlir.null : !llvm.ptr
    %78 = llvm.getelementptr %77[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mul %75, %79  : i64
    %81 = llvm.mul %74, %79  : i64
    %82 = llvm.call @malloc(%80) : (i64) -> !llvm.ptr
    %83 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%82, %83, %81) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %84 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%84) : (!llvm.ptr) -> ()
    %85 = llvm.insertvalue %82, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %86 = llvm.insertvalue %82, %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%87: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %88 = llvm.insertvalue %75, %87[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = builtin.unrealized_conversion_cast %88 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb17(%89 : memref<?xindex>)
  ^bb16:  // pred: ^bb12
    cf.br ^bb17(%arg2 : memref<?xindex>)
  ^bb17(%90: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
    %91 = builtin.unrealized_conversion_cast %90 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %92 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %93 = llvm.getelementptr %92[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %8, %93 : i64, !llvm.ptr
    %94 = arith.index_cast %70 : index to i64
    %95 = llvm.insertvalue %94, %64[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb19(%59, %90, %95 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%96: memref<?xindex>, %97: memref<?xindex>, %98: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %99 = builtin.unrealized_conversion_cast %97 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %100 = arith.addi %28, %c1 : index
    %101 = builtin.unrealized_conversion_cast %100 : index to i64
    %102 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.getelementptr %102[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %104 = llvm.load %103 : !llvm.ptr -> i64
    %105 = builtin.unrealized_conversion_cast %104 : i64 to index
    %106 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %108 = llvm.load %107 : !llvm.ptr -> i64
    %109 = builtin.unrealized_conversion_cast %108 : i64 to index
    %110 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %111 = arith.index_cast %110 : i64 to index
    %112 = builtin.unrealized_conversion_cast %111 : index to i64
    %113 = arith.subi %109, %c1 : index
    %114 = builtin.unrealized_conversion_cast %113 : index to i64
    %115 = arith.cmpi ult, %105, %109 : index
    cf.cond_br %115, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %116 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %118 = llvm.load %117 : !llvm.ptr -> i64
    %119 = builtin.unrealized_conversion_cast %118 : i64 to index
    %120 = arith.cmpi eq, %119, %arg7 : index
    cf.br ^bb23(%120 : i1)
  ^bb22:  // pred: ^bb20
    %121 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.getelementptr %121[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %112, %122 : i64, !llvm.ptr
    cf.br ^bb23(%false : i1)
  ^bb23(%123: i1):  // 2 preds: ^bb21, ^bb22
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    %124 = arith.select %123, %113, %111 : index
    cf.cond_br %123, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    cf.br ^bb44(%arg3, %arg4, %98 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %125 = arith.addi %111, %c1 : index
    %126 = builtin.unrealized_conversion_cast %125 : index to i64
    %127 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %126, %128 : i64, !llvm.ptr
    %129 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %130 = arith.index_cast %129 : i64 to index
    %131 = builtin.unrealized_conversion_cast %130 : index to i64
    %132 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = builtin.unrealized_conversion_cast %132 : i64 to index
    %134 = arith.addi %130, %c1 : index
    %135 = arith.cmpi ugt, %134, %133 : index
    cf.cond_br %135, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %136 = arith.muli %133, %c2 : index
    %137 = builtin.unrealized_conversion_cast %136 : index to i64
    %138 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = builtin.unrealized_conversion_cast %136 : index to i64
    %140 = llvm.icmp "ugt" %139, %138 : i64
    llvm.cond_br %140, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %141 = llvm.mlir.null : !llvm.ptr
    %142 = llvm.getelementptr %141[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %143 = llvm.ptrtoint %142 : !llvm.ptr to i64
    %144 = llvm.mul %139, %143  : i64
    %145 = llvm.mul %138, %143  : i64
    %146 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
    %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%146, %147, %145) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %148 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%148) : (!llvm.ptr) -> ()
    %149 = llvm.insertvalue %146, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %150 = llvm.insertvalue %146, %149[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%150 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%151: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %152 = llvm.insertvalue %139, %151[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = builtin.unrealized_conversion_cast %152 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb31(%153 : memref<?xindex>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg3 : memref<?xindex>)
  ^bb31(%154: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
    %155 = builtin.unrealized_conversion_cast %154 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %156 = llvm.extractvalue %155[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %157 = llvm.getelementptr %156[%131] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %3, %157 : i64, !llvm.ptr
    %158 = arith.index_cast %134 : index to i64
    %159 = llvm.insertvalue %158, %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = llvm.extractvalue %98[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %161 = arith.index_cast %160 : i64 to index
    %162 = builtin.unrealized_conversion_cast %161 : index to i64
    %163 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = builtin.unrealized_conversion_cast %163 : i64 to index
    %165 = arith.addi %161, %c32 : index
    %166 = arith.cmpi ugt, %165, %164 : index
    cf.cond_br %166, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%164 : index)
  ^bb34(%167: index):  // 2 preds: ^bb33, ^bb34
    %168 = arith.muli %167, %c2 : index
    %169 = builtin.unrealized_conversion_cast %168 : index to i64
    %170 = arith.cmpi ugt, %165, %168 : index
    cf.cond_br %170, ^bb34(%168 : index), ^bb35
  ^bb35:  // pred: ^bb34
    %171 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = builtin.unrealized_conversion_cast %168 : index to i64
    %173 = llvm.icmp "ugt" %172, %171 : i64
    llvm.cond_br %173, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %174 = llvm.mlir.null : !llvm.ptr
    %175 = llvm.getelementptr %174[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %176 = llvm.ptrtoint %175 : !llvm.ptr to i64
    %177 = llvm.mul %172, %176  : i64
    %178 = llvm.mul %171, %176  : i64
    %179 = llvm.call @malloc(%177) : (i64) -> !llvm.ptr
    %180 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%179, %180, %178) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %181 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%181) : (!llvm.ptr) -> ()
    %182 = llvm.insertvalue %179, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.insertvalue %179, %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%183 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%184: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %185 = llvm.insertvalue %172, %184[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %186 = builtin.unrealized_conversion_cast %185 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    cf.br ^bb39(%186 : memref<?xf32>)
  ^bb38:  // pred: ^bb32
    cf.br ^bb39(%arg4 : memref<?xf32>)
  ^bb39(%187: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
    %188 = builtin.unrealized_conversion_cast %187 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %189 = llvm.extractvalue %188[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %190 = llvm.extractvalue %188[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %192 = llvm.insertvalue %189, %191[0] : !llvm.struct<(ptr, ptr, i64)> 
    %193 = llvm.insertvalue %190, %192[1] : !llvm.struct<(ptr, ptr, i64)> 
    %194 = llvm.mlir.constant(0 : index) : i64
    %195 = llvm.insertvalue %194, %193[2] : !llvm.struct<(ptr, ptr, i64)> 
    %196 = llvm.extractvalue %188[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.extractvalue %188[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %198 = llvm.extractvalue %188[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %200 = llvm.extractvalue %195[0] : !llvm.struct<(ptr, ptr, i64)> 
    %201 = llvm.extractvalue %195[1] : !llvm.struct<(ptr, ptr, i64)> 
    %202 = llvm.insertvalue %200, %199[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %203 = llvm.insertvalue %201, %202[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.insertvalue %162, %203[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %205 = llvm.mlir.constant(32 : index) : i64
    %206 = llvm.insertvalue %205, %204[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %207 = llvm.mlir.constant(1 : index) : i64
    %208 = llvm.insertvalue %207, %206[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    cf.br ^bb41(%c0 : index)
  ^bb41(%209: index):  // 2 preds: ^bb40, ^bb42
    %210 = builtin.unrealized_conversion_cast %209 : index to i64
    %211 = arith.cmpi slt, %209, %c32 : index
    cf.cond_br %211, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %212 = llvm.extractvalue %208[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %213 = llvm.extractvalue %208[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %214 = llvm.getelementptr %212[%213] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %215 = llvm.getelementptr %214[%210] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %215 : f32, !llvm.ptr
    %216 = arith.addi %209, %c1 : index
    cf.br ^bb41(%216 : index)
  ^bb43:  // pred: ^bb41
    %217 = arith.index_cast %165 : index to i64
    %218 = llvm.insertvalue %217, %159[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb44(%154, %187, %218 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%219: memref<?xindex>, %220: memref<?xf32>, %221: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %222 = builtin.unrealized_conversion_cast %220 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb45
  ^bb45:  // pred: ^bb44
    %223 = arith.muli %124, %c32 : index
    %224 = arith.addi %223, %arg8 : index
    %225 = builtin.unrealized_conversion_cast %224 : index to i64
    %226 = llvm.extractvalue %222[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %227 = llvm.getelementptr %226[%225] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg9, %227 : f32, !llvm.ptr
    return %arg0, %96, %97, %219, %220, %221 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
    %c1 = arith.constant 1 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
    %4 = arith.cmpi ult, %2, %3 : index
    cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
  ^bb2(%5: index, %6: index):  // pred: ^bb1
    %7 = arith.addi %5, %6 : index
    %8 = arith.shrui %7, %c1 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %8, %c1 : index
    %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %13 = llvm.load %12 : !llvm.ptr -> i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = arith.cmpi ult, %14, %18 : index
    %20 = arith.select %19, %5, %10 : index
    %21 = arith.select %19, %8, %6 : index
    cf.br ^bb1(%20, %21 : index, index)
  ^bb3:  // pred: ^bb1
    return %2 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %1 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%1 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
    %3 = builtin.unrealized_conversion_cast %2 : index to i64
    %4 = arith.cmpi slt, %2, %arg1 : index
    cf.cond_br %4, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %9 = llvm.load %8 : !llvm.ptr -> i64
    %10 = arith.subi %2, %5 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
    %12 = arith.cmpi slt, %11, %10 : index
    cf.cond_br %12, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %13 = arith.subi %2, %11 : index
    %14 = builtin.unrealized_conversion_cast %13 : index to i64
    %15 = arith.subi %13, %c1 : index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %19, %21 : i64, !llvm.ptr
    %22 = arith.addi %11, %c1 : index
    cf.br ^bb3(%22 : index)
  ^bb5:  // pred: ^bb3
    %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %24 : i64, !llvm.ptr
    %25 = arith.addi %2, %c1 : index
    cf.br ^bb1(%25 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %1 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %1, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %arg3, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.cmpi uge, %4, %2 : index
    cf.cond_br %5, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %6 = arith.shli %2, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = arith.addi %7, %arg0 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %6, %c2 : index
    %11 = arith.cmpi ult, %10, %arg3 : index
    cf.cond_br %11, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %12 = arith.addi %10, %arg0 : index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = builtin.unrealized_conversion_cast %16 : i64 to index
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = arith.cmpi ult, %17, %21 : index
    %23 = arith.select %22, %10, %7 : index
    %24 = arith.select %22, %12, %8 : index
    cf.br ^bb5(%23, %24, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%7, %8, %arg1 : index, index, index)
  ^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%27, %25, %26 : index, index, index)
  ^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
    cf.br ^bb7(%28, %29, %30 : index, index, index)
  ^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
    %34 = builtin.unrealized_conversion_cast %31 : index to i64
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = builtin.unrealized_conversion_cast %38 : i64 to index
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = arith.cmpi ult, %39, %43 : index
    cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
  ^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = builtin.unrealized_conversion_cast %47 : index to i64
    %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = arith.cmpi uge, %4, %46 : index
    cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
  ^bb9:  // pred: ^bb8
    %61 = arith.shli %46, %c1 : index
    %62 = arith.addi %61, %c1 : index
    %63 = arith.addi %62, %arg0 : index
    %64 = builtin.unrealized_conversion_cast %63 : index to i64
    %65 = arith.addi %61, %c2 : index
    %66 = arith.cmpi ult, %65, %arg3 : index
    cf.cond_br %66, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %67 = arith.addi %65, %arg0 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %75 = llvm.load %74 : !llvm.ptr -> i64
    %76 = builtin.unrealized_conversion_cast %75 : i64 to index
    %77 = arith.cmpi ult, %72, %76 : index
    %78 = arith.select %77, %65, %62 : index
    %79 = arith.select %77, %67, %63 : index
    cf.br ^bb12(%78, %79 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%62, %63 : index, index)
  ^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%80, %81 : index, index)
  ^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%82, %83, %47 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %2, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.addi %4, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = arith.subi %4, %6 : index
    %9 = arith.addi %arg0, %8 : index
    call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
    %10 = arith.addi %6, %c1 : index
    cf.br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    %11 = arith.subi %2, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
    %13 = arith.cmpi slt, %12, %11 : index
    cf.cond_br %13, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %14 = arith.subi %2, %12 : index
    %15 = arith.addi %arg0, %14 : index
    %16 = arith.subi %15, %c1 : index
    %17 = builtin.unrealized_conversion_cast %16 : index to i64
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    %28 = arith.subi %14, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
    %29 = arith.addi %12, %c1 : index
    cf.br ^bb4(%29 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %2 = arith.addi %arg0, %arg1 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = builtin.unrealized_conversion_cast %3 : index to i64
    %5 = arith.subi %arg1, %c1 : index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = arith.subi %arg1, %arg0 : index
    %8 = arith.cmpi ult, %7, %c1000 : index
    cf.cond_br %8, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %30 = llvm.load %29 : !llvm.ptr -> i64
    %31 = builtin.unrealized_conversion_cast %30 : i64 to index
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %34 = llvm.load %33 : !llvm.ptr -> i64
    %35 = builtin.unrealized_conversion_cast %34 : i64 to index
    %36 = arith.cmpi ult, %31, %35 : index
    cf.cond_br %36, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %42, %44 : i64, !llvm.ptr
    %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %39, %46 : i64, !llvm.ptr
    %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    %55 = arith.cmpi ult, %50, %54 : index
    cf.cond_br %55, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %58 = llvm.load %57 : !llvm.ptr -> i64
    %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %61 = llvm.load %60 : !llvm.ptr -> i64
    %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %61, %63 : i64, !llvm.ptr
    %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %58, %65 : i64, !llvm.ptr
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %5, %3 : index, index, index)
  ^bb8:  // pred: ^bb0
    %66 = arith.addi %arg0, %arg1 : index
    %67 = arith.shrui %66, %c1 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = arith.addi %3, %arg1 : index
    %70 = arith.shrui %69, %c1 : index
    %71 = builtin.unrealized_conversion_cast %70 : index to i64
    %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = arith.cmpi ult, %75, %79 : index
    cf.cond_br %80, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %86, %88 : i64, !llvm.ptr
    %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %83, %90 : i64, !llvm.ptr
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    %99 = arith.cmpi ult, %94, %98 : index
    cf.cond_br %99, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %105, %107 : i64, !llvm.ptr
    %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %102, %109 : i64, !llvm.ptr
    %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %113, %117 : index
    cf.cond_br %118, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %124 = llvm.load %123 : !llvm.ptr -> i64
    %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %128 : i64, !llvm.ptr
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %135 = llvm.load %134 : !llvm.ptr -> i64
    %136 = builtin.unrealized_conversion_cast %135 : i64 to index
    %137 = arith.cmpi ult, %132, %136 : index
    cf.cond_br %137, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %140 = llvm.load %139 : !llvm.ptr -> i64
    %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %143, %145 : i64, !llvm.ptr
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %140, %147 : i64, !llvm.ptr
    %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %154 = llvm.load %153 : !llvm.ptr -> i64
    %155 = builtin.unrealized_conversion_cast %154 : i64 to index
    %156 = arith.cmpi ult, %151, %155 : index
    cf.cond_br %156, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %162, %164 : i64, !llvm.ptr
    %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %159, %166 : i64, !llvm.ptr
    %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = builtin.unrealized_conversion_cast %173 : i64 to index
    %175 = arith.cmpi ult, %170, %174 : index
    cf.cond_br %175, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %178 = llvm.load %177 : !llvm.ptr -> i64
    %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %181 = llvm.load %180 : !llvm.ptr -> i64
    %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %181, %183 : i64, !llvm.ptr
    %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %178, %185 : i64, !llvm.ptr
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %192 = llvm.load %191 : !llvm.ptr -> i64
    %193 = builtin.unrealized_conversion_cast %192 : i64 to index
    %194 = arith.cmpi ult, %189, %193 : index
    cf.cond_br %194, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = arith.cmpi ult, %208, %212 : index
    cf.cond_br %213, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %219 = llvm.load %218 : !llvm.ptr -> i64
    %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %219, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %216, %223 : i64, !llvm.ptr
    %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = arith.cmpi ult, %227, %231 : index
    cf.cond_br %232, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %235 = llvm.load %234 : !llvm.ptr -> i64
    %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %238 = llvm.load %237 : !llvm.ptr -> i64
    %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %238, %240 : i64, !llvm.ptr
    %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %235, %242 : i64, !llvm.ptr
    %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %249 = llvm.load %248 : !llvm.ptr -> i64
    %250 = builtin.unrealized_conversion_cast %249 : i64 to index
    %251 = arith.cmpi ult, %246, %250 : index
    cf.cond_br %251, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %257 = llvm.load %256 : !llvm.ptr -> i64
    %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %257, %259 : i64, !llvm.ptr
    %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %254, %261 : i64, !llvm.ptr
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%262, %263, %264 : index, index, index)
  ^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
    %268 = arith.cmpi ult, %265, %266 : index
    cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
  ^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
    %272 = builtin.unrealized_conversion_cast %271 : index to i64
    cf.br ^bb30(%269 : index)
  ^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
    %274 = builtin.unrealized_conversion_cast %273 : index to i64
    %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = builtin.unrealized_conversion_cast %281 : i64 to index
    %283 = arith.cmpi ult, %278, %282 : index
    cf.cond_br %283, ^bb31(%273 : index), ^bb32
  ^bb31(%284: index):  // pred: ^bb30
    %285 = arith.addi %284, %c1 : index
    cf.br ^bb30(%285 : index)
  ^bb32:  // pred: ^bb30
    %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %288 = llvm.load %287 : !llvm.ptr -> i64
    %289 = builtin.unrealized_conversion_cast %288 : i64 to index
    %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %292 = llvm.load %291 : !llvm.ptr -> i64
    %293 = builtin.unrealized_conversion_cast %292 : i64 to index
    %294 = arith.cmpi eq, %289, %293 : index
    cf.br ^bb33(%270 : index)
  ^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
    %296 = builtin.unrealized_conversion_cast %295 : index to i64
    %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %299 = llvm.load %298 : !llvm.ptr -> i64
    %300 = builtin.unrealized_conversion_cast %299 : i64 to index
    %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %303 = llvm.load %302 : !llvm.ptr -> i64
    %304 = builtin.unrealized_conversion_cast %303 : i64 to index
    %305 = arith.cmpi ult, %300, %304 : index
    cf.cond_br %305, ^bb34(%295 : index), ^bb35
  ^bb34(%306: index):  // pred: ^bb33
    %307 = arith.addi %306, %c-1 : index
    cf.br ^bb33(%307 : index)
  ^bb35:  // pred: ^bb33
    %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    %316 = arith.cmpi eq, %311, %315 : index
    %317 = arith.cmpi ult, %273, %295 : index
    cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
  ^bb36:  // pred: ^bb35
    %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %320 = llvm.load %319 : !llvm.ptr -> i64
    %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %323 = llvm.load %322 : !llvm.ptr -> i64
    %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %323, %325 : i64, !llvm.ptr
    %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %320, %327 : i64, !llvm.ptr
    %328 = arith.cmpi eq, %273, %271 : index
    cf.cond_br %328, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%295 : index)
  ^bb38:  // pred: ^bb36
    %329 = arith.cmpi eq, %295, %271 : index
    %330 = arith.select %329, %273, %271 : index
    cf.br ^bb39(%330 : index)
  ^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %332 = arith.andi %294, %316 : i1
    cf.cond_br %332, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %333 = arith.addi %273, %c1 : index
    %334 = arith.subi %295, %c1 : index
    cf.br ^bb43(%333, %334 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%273, %295 : index, index)
  ^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%335, %336, %331 : index, index, index)
  ^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%337, %338, %339 : index, index, index)
  ^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
    cf.br ^bb27(%340, %341, %342 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %267 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %9 = builtin.unrealized_conversion_cast %c0 : index to i64
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %10 = builtin.unrealized_conversion_cast %c1 : index to i64
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %11 = llvm.mlir.constant(16 : index) : i64
    %12 = llvm.mlir.constant(1 : index) : i64
    %13 = llvm.mlir.null : !llvm.ptr
    %14 = llvm.getelementptr %13[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
    %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
    %17 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.mlir.constant(0 : index) : i64
    %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %11, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %12, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = builtin.unrealized_conversion_cast %23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %25 = llvm.mlir.constant(16 : index) : i64
    %26 = llvm.mlir.constant(1 : index) : i64
    %27 = llvm.mlir.null : !llvm.ptr
    %28 = llvm.getelementptr %27[%25] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
    %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.mlir.constant(0 : index) : i64
    %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.insertvalue %25, %35[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %26, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %39 = llvm.mlir.constant(16 : index) : i64
    %40 = llvm.mlir.constant(1 : index) : i64
    %41 = llvm.mlir.null : !llvm.ptr
    %42 = llvm.getelementptr %41[%39] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %43 = llvm.ptrtoint %42 : !llvm.ptr to i64
    %44 = llvm.call @malloc(%43) : (i64) -> !llvm.ptr
    %45 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.mlir.constant(0 : index) : i64
    %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.insertvalue %39, %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %40, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = builtin.unrealized_conversion_cast %51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %53 = llvm.mlir.constant(16 : index) : i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.mlir.null : !llvm.ptr
    %56 = llvm.getelementptr %55[%53] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %57 = llvm.ptrtoint %56 : !llvm.ptr to i64
    %58 = llvm.call @malloc(%57) : (i64) -> !llvm.ptr
    %59 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.mlir.constant(0 : index) : i64
    %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %64 = llvm.insertvalue %53, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %54, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = builtin.unrealized_conversion_cast %65 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %67 = llvm.mlir.constant(16 : index) : i64
    %68 = llvm.mlir.constant(1 : index) : i64
    %69 = llvm.mlir.null : !llvm.ptr
    %70 = llvm.getelementptr %69[%67] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %71 = llvm.ptrtoint %70 : !llvm.ptr to i64
    %72 = llvm.call @malloc(%71) : (i64) -> !llvm.ptr
    %73 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %76 = llvm.mlir.constant(0 : index) : i64
    %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %78 = llvm.insertvalue %67, %77[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.insertvalue %68, %78[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = builtin.unrealized_conversion_cast %79 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %81 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %82 = llvm.insertvalue %c0_i64, %81[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %83 = llvm.insertvalue %c0_i64, %82[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %84 = llvm.insertvalue %c0_i64, %83[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %85 = llvm.insertvalue %c0_i64, %84[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %86 = llvm.insertvalue %c0_i64, %85[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %87 = llvm.insertvalue %c128_i64, %86[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %88 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = llvm.getelementptr %88[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %89 : i64, !llvm.ptr
    %90 = llvm.insertvalue %c1_i64, %87[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %91 = llvm.insertvalue %c128_i64, %90[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %92 = llvm.extractvalue %51[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %93 = llvm.getelementptr %92[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %93 : i64, !llvm.ptr
    %94 = llvm.insertvalue %c1_i64, %91[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %95 = llvm.insertvalue %c32_i64, %94[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %96 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %97 = llvm.getelementptr %96[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %97 : i64, !llvm.ptr
    %98 = llvm.insertvalue %c2_i64, %95[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %99 = llvm.mlir.constant(32 : index) : i64
    %100 = llvm.mlir.constant(1 : index) : i64
    %101 = llvm.mlir.null : !llvm.ptr
    %102 = llvm.getelementptr %101[%99] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %103 = llvm.ptrtoint %102 : !llvm.ptr to i64
    %104 = llvm.call @malloc(%103) : (i64) -> !llvm.ptr
    %105 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %106 = llvm.insertvalue %104, %105[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.insertvalue %104, %106[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %108 = llvm.mlir.constant(0 : index) : i64
    %109 = llvm.insertvalue %108, %107[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.insertvalue %99, %109[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.insertvalue %100, %110[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %112 = llvm.mlir.constant(32 : index) : i64
    %113 = llvm.mlir.constant(1 : index) : i64
    %114 = llvm.mlir.null : !llvm.ptr
    %115 = llvm.getelementptr %114[%112] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %116 = llvm.ptrtoint %115 : !llvm.ptr to i64
    %117 = llvm.call @malloc(%116) : (i64) -> !llvm.ptr
    %118 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %119 = llvm.insertvalue %117, %118[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.insertvalue %117, %119[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.mlir.constant(0 : index) : i64
    %122 = llvm.insertvalue %121, %120[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.insertvalue %112, %122[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.insertvalue %113, %123[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %125 = llvm.mlir.constant(32 : index) : i64
    %126 = llvm.mlir.constant(1 : index) : i64
    %127 = llvm.mlir.null : !llvm.ptr
    %128 = llvm.getelementptr %127[%125] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %129 = llvm.ptrtoint %128 : !llvm.ptr to i64
    %130 = llvm.call @malloc(%129) : (i64) -> !llvm.ptr
    %131 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %132 = llvm.insertvalue %130, %131[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = llvm.insertvalue %130, %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.mlir.constant(0 : index) : i64
    %135 = llvm.insertvalue %134, %133[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = llvm.insertvalue %125, %135[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %137 = llvm.insertvalue %126, %136[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = builtin.unrealized_conversion_cast %137 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%139: index):  // 2 preds: ^bb0, ^bb2
    %140 = builtin.unrealized_conversion_cast %139 : index to i64
    %141 = arith.cmpi slt, %139, %c32 : index
    cf.cond_br %141, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %142 = llvm.extractvalue %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %143 = llvm.getelementptr %142[%140] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %143 : f32, !llvm.ptr
    %144 = arith.addi %139, %c1 : index
    cf.br ^bb1(%144 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%145: index):  // 2 preds: ^bb3, ^bb5
    %146 = builtin.unrealized_conversion_cast %145 : index to i64
    %147 = arith.cmpi slt, %145, %c32 : index
    cf.cond_br %147, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %148 = llvm.extractvalue %124[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%146] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %149 : i1, !llvm.ptr
    %150 = arith.addi %145, %c1 : index
    cf.br ^bb4(%150 : index)
  ^bb6:  // pred: ^bb4
    %151 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %152 = llvm.getelementptr %151[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %153 = llvm.load %152 : !llvm.ptr -> i64
    %154 = builtin.unrealized_conversion_cast %153 : i64 to index
    %155 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %156 = llvm.getelementptr %155[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %157 = llvm.load %156 : !llvm.ptr -> i64
    %158 = builtin.unrealized_conversion_cast %157 : i64 to index
    cf.br ^bb7(%154, %24, %38, %52, %66, %80, %98 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%159: index, %160: memref<?xindex>, %161: memref<?xindex>, %162: memref<?xindex>, %163: memref<?xindex>, %164: memref<?xf32>, %165: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %166 = builtin.unrealized_conversion_cast %159 : index to i64
    %167 = builtin.unrealized_conversion_cast %162 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %168 = builtin.unrealized_conversion_cast %160 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %169 = builtin.unrealized_conversion_cast %161 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %170 = builtin.unrealized_conversion_cast %163 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %171 = builtin.unrealized_conversion_cast %164 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %172 = arith.cmpi slt, %159, %158 : index
    cf.cond_br %172, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %173 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %174 = llvm.getelementptr %173[%166] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %175 = llvm.load %174 : !llvm.ptr -> i64
    %176 = builtin.unrealized_conversion_cast %175 : i64 to index
    %177 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %178 = llvm.getelementptr %177[%166] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %179 = llvm.load %178 : !llvm.ptr -> i64
    %180 = builtin.unrealized_conversion_cast %179 : i64 to index
    %181 = arith.addi %159, %c1 : index
    %182 = builtin.unrealized_conversion_cast %181 : index to i64
    %183 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %184 = llvm.getelementptr %183[%182] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %185 = llvm.load %184 : !llvm.ptr -> i64
    %186 = builtin.unrealized_conversion_cast %185 : i64 to index
    cf.br ^bb9(%180, %160, %161, %162, %163, %164, %165 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%187: index, %188: memref<?xindex>, %189: memref<?xindex>, %190: memref<?xindex>, %191: memref<?xindex>, %192: memref<?xf32>, %193: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %194 = builtin.unrealized_conversion_cast %187 : index to i64
    %195 = arith.cmpi slt, %187, %186 : index
    cf.cond_br %195, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %196 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.getelementptr %196[%194] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %198 = llvm.load %197 : !llvm.ptr -> i64
    %199 = builtin.unrealized_conversion_cast %198 : i64 to index
    %200 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.getelementptr %200[%194] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %202 = llvm.load %201 : !llvm.ptr -> i64
    %203 = builtin.unrealized_conversion_cast %202 : i64 to index
    %204 = arith.addi %187, %c1 : index
    %205 = builtin.unrealized_conversion_cast %204 : index to i64
    %206 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %207 = llvm.getelementptr %206[%205] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %208 = llvm.load %207 : !llvm.ptr -> i64
    %209 = builtin.unrealized_conversion_cast %208 : i64 to index
    cf.br ^bb11(%203, %c0 : index, index)
  ^bb11(%210: index, %211: index):  // 2 preds: ^bb10, ^bb19
    %212 = builtin.unrealized_conversion_cast %210 : index to i64
    %213 = arith.cmpi slt, %210, %209 : index
    cf.cond_br %213, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %214 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%212] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = builtin.unrealized_conversion_cast %216 : i64 to index
    %218 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %219 = llvm.getelementptr %218[%212] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %220 = llvm.load %219 : !llvm.ptr -> f32
    cf.br ^bb13(%c0, %211 : index, index)
  ^bb13(%221: index, %222: index):  // 2 preds: ^bb12, ^bb18
    %223 = builtin.unrealized_conversion_cast %221 : index to i64
    %224 = builtin.unrealized_conversion_cast %222 : index to i64
    %225 = arith.cmpi slt, %221, %c32 : index
    cf.cond_br %225, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %226 = arith.muli %217, %c32 : index
    %227 = arith.addi %226, %221 : index
    %228 = builtin.unrealized_conversion_cast %227 : index to i64
    %229 = llvm.extractvalue %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %230 = llvm.getelementptr %229[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %231 = llvm.load %230 : !llvm.ptr -> f32
    %232 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %233 = llvm.getelementptr %232[%228] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %234 = llvm.load %233 : !llvm.ptr -> f32
    %235 = arith.mulf %220, %234 : f32
    %236 = arith.addf %231, %235 : f32
    %237 = llvm.extractvalue %124[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %238 = llvm.getelementptr %237[%223] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %239 = llvm.load %238 : !llvm.ptr -> i1
    %240 = arith.cmpi eq, %239, %false : i1
    cf.cond_br %240, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %241 = llvm.extractvalue %124[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%223] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %true, %242 : i1, !llvm.ptr
    %243 = llvm.extractvalue %137[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%224] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %223, %244 : i64, !llvm.ptr
    %245 = arith.addi %222, %c1 : index
    cf.br ^bb17(%245 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%222 : index)
  ^bb17(%246: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %247 = llvm.extractvalue %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %236, %248 : f32, !llvm.ptr
    %249 = arith.addi %221, %c1 : index
    cf.br ^bb13(%249, %246 : index, index)
  ^bb19:  // pred: ^bb13
    %250 = arith.addi %210, %c1 : index
    cf.br ^bb11(%250, %222 : index, index)
  ^bb20:  // pred: ^bb11
    %251 = arith.index_cast %211 : index to i64
    %252 = math.ctlz %251 : i64
    %253 = arith.subi %c64_i64, %252 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %211, %138, %253) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %188, %189, %190, %191, %192, %193 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%254: index, %255: memref<?xindex>, %256: memref<?xindex>, %257: memref<?xindex>, %258: memref<?xindex>, %259: memref<?xf32>, %260: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %261 = builtin.unrealized_conversion_cast %254 : index to i64
    %262 = arith.cmpi slt, %254, %211 : index
    cf.cond_br %262, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %263 = llvm.extractvalue %137[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %264 = llvm.getelementptr %263[%261] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %265 = llvm.load %264 : !llvm.ptr -> i64
    %266 = builtin.unrealized_conversion_cast %265 : i64 to index
    %267 = llvm.extractvalue %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %268 = llvm.getelementptr %267[%265] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %269 = llvm.load %268 : !llvm.ptr -> f32
    %270:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%255, %256, %257, %258, %259, %260, %176, %199, %266, %269) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    %271 = llvm.extractvalue %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %272 = llvm.getelementptr %271[%265] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %272 : f32, !llvm.ptr
    %273 = llvm.extractvalue %124[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %274 = llvm.getelementptr %273[%265] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %274 : i1, !llvm.ptr
    %275 = arith.addi %254, %c1 : index
    cf.br ^bb21(%275, %270#0, %270#1, %270#2, %270#3, %270#4, %270#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %276 = arith.addi %187, %c1 : index
    cf.br ^bb9(%276, %255, %256, %257, %258, %259, %260 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %277 = arith.addi %159, %c1 : index
    cf.br ^bb7(%277, %188, %189, %190, %191, %192, %193 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    %278 = llvm.extractvalue %111[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%278) : (!llvm.ptr) -> ()
    %279 = llvm.extractvalue %124[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%279) : (!llvm.ptr) -> ()
    %280 = llvm.extractvalue %137[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%280) : (!llvm.ptr) -> ()
    %281 = llvm.extractvalue %165[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %282 = arith.index_cast %281 : i64 to index
    %283 = llvm.extractvalue %167[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %284 = llvm.getelementptr %283[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %285 = llvm.load %284 : !llvm.ptr -> i64
    %286 = builtin.unrealized_conversion_cast %285 : i64 to index
    cf.br ^bb26(%c1, %286 : index, index)
  ^bb26(%287: index, %288: index):  // 2 preds: ^bb25, ^bb29
    %289 = builtin.unrealized_conversion_cast %287 : index to i64
    %290 = builtin.unrealized_conversion_cast %288 : index to i64
    %291 = arith.cmpi slt, %287, %282 : index
    cf.cond_br %291, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %292 = llvm.extractvalue %167[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %293 = llvm.getelementptr %292[%289] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %294 = llvm.load %293 : !llvm.ptr -> i64
    %295 = builtin.unrealized_conversion_cast %294 : i64 to index
    %296 = arith.cmpi eq, %295, %c0 : index
    %297 = arith.select %296, %288, %295 : index
    cf.cond_br %296, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %298 = llvm.extractvalue %167[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %299 = llvm.getelementptr %298[%289] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %290, %299 : i64, !llvm.ptr
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %300 = arith.addi %287, %c1 : index
    cf.br ^bb26(%300, %297 : index, index)
  ^bb30:  // pred: ^bb26
    %301 = llvm.mlir.constant(4096 : index) : i64
    %302 = llvm.mlir.constant(1 : index) : i64
    %303 = llvm.mlir.null : !llvm.ptr
    %304 = llvm.getelementptr %303[%301] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %305 = llvm.ptrtoint %304 : !llvm.ptr to i64
    %306 = llvm.call @malloc(%305) : (i64) -> !llvm.ptr
    %307 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %308 = llvm.insertvalue %306, %307[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.insertvalue %306, %308[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %310 = llvm.mlir.constant(0 : index) : i64
    %311 = llvm.insertvalue %310, %309[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %312 = llvm.insertvalue %301, %311[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.insertvalue %302, %312[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %314 = builtin.unrealized_conversion_cast %313 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %315 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %316 = llvm.insertvalue %c0_i64, %315[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %317 = llvm.insertvalue %c128_i64, %316[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %318 = llvm.insertvalue %c32_i64, %317[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%319: index):  // 2 preds: ^bb30, ^bb32
    %320 = builtin.unrealized_conversion_cast %319 : index to i64
    %321 = arith.cmpi slt, %319, %c4096 : index
    cf.cond_br %321, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %322 = llvm.extractvalue %313[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %323 = llvm.getelementptr %322[%320] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %323 : f32, !llvm.ptr
    %324 = arith.addi %319, %c1 : index
    cf.br ^bb31(%324 : index)
  ^bb33:  // pred: ^bb31
    %325 = llvm.insertvalue %c4096_i64, %318[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %326 = llvm.extractvalue %168[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %328 = llvm.load %327 : !llvm.ptr -> i64
    %329 = builtin.unrealized_conversion_cast %328 : i64 to index
    %330 = llvm.extractvalue %168[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %331 = llvm.getelementptr %330[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %332 = llvm.load %331 : !llvm.ptr -> i64
    %333 = builtin.unrealized_conversion_cast %332 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%329) to (%333) step (%c1) {
        %334 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %335 = llvm.extractvalue %169[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %336 = llvm.getelementptr %335[%334] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %337 = llvm.load %336 : !llvm.ptr -> i64
        %338 = builtin.unrealized_conversion_cast %337 : i64 to index
        %339 = llvm.extractvalue %167[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %340 = llvm.getelementptr %339[%334] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %341 = llvm.load %340 : !llvm.ptr -> i64
        %342 = builtin.unrealized_conversion_cast %341 : i64 to index
        %343 = arith.addi %arg12, %c1 : index
        %344 = builtin.unrealized_conversion_cast %343 : index to i64
        %345 = llvm.extractvalue %167[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %346 = llvm.getelementptr %345[%344] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %347 = llvm.load %346 : !llvm.ptr -> i64
        %348 = builtin.unrealized_conversion_cast %347 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%342) to (%348) step (%c1) {
            %349 = builtin.unrealized_conversion_cast %arg13 : index to i64
            %350 = llvm.extractvalue %170[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %351 = llvm.getelementptr %350[%349] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %352 = llvm.load %351 : !llvm.ptr -> i64
            %353 = builtin.unrealized_conversion_cast %352 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %354 = arith.muli %arg13, %c32 : index
                %355 = arith.addi %354, %arg14 : index
                %356 = builtin.unrealized_conversion_cast %355 : index to i64
                %357 = arith.muli %353, %c32 : index
                %358 = arith.addi %357, %arg14 : index
                %359 = builtin.unrealized_conversion_cast %358 : index to i64
                %360 = arith.muli %338, %c32 : index
                %361 = arith.addi %360, %arg14 : index
                %362 = builtin.unrealized_conversion_cast %361 : index to i64
                %363 = llvm.extractvalue %313[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %364 = llvm.getelementptr %363[%362] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %365 = llvm.load %364 : !llvm.ptr -> f32
                %366 = llvm.extractvalue %171[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %367 = llvm.getelementptr %366[%356] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %368 = llvm.load %367 : !llvm.ptr -> f32
                %369 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %370 = llvm.getelementptr %369[%359] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %371 = llvm.load %370 : !llvm.ptr -> f32
                %372 = arith.mulf %368, %371 : f32
                %373 = arith.addf %365, %372 : f32
                %374 = llvm.extractvalue %313[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %375 = llvm.getelementptr %374[%362] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %373, %375 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %314, %325 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
  %c1 = arith.constant 1 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
  %4 = arith.cmpi ult, %2, %3 : index
  cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
^bb2(%5: index, %6: index):  // pred: ^bb1
  %7 = arith.addi %5, %6 : index
  %8 = arith.shrui %7, %c1 : index
  %9 = builtin.unrealized_conversion_cast %8 : index to i64
  %10 = arith.addi %8, %c1 : index
  %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %13 = llvm.load %12 : !llvm.ptr -> i64
  %14 = builtin.unrealized_conversion_cast %13 : i64 to index
  %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %17 = llvm.load %16 : !llvm.ptr -> i64
  %18 = builtin.unrealized_conversion_cast %17 : i64 to index
  %19 = arith.cmpi ult, %14, %18 : index
  %20 = arith.select %19, %5, %10 : index
  %21 = arith.select %19, %8, %6 : index
  cf.br ^bb1(%20, %21 : index, index)
^bb3:  // pred: ^bb1
  return %2 : index
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %1 = arith.addi %arg0, %c1 : index
  cf.br ^bb1(%1 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
  %3 = builtin.unrealized_conversion_cast %2 : index to i64
  %4 = arith.cmpi slt, %2, %arg1 : index
  cf.cond_br %4, ^bb2, ^bb6
^bb2:  // pred: ^bb1
  %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
  %6 = builtin.unrealized_conversion_cast %5 : index to i64
  %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %9 = llvm.load %8 : !llvm.ptr -> i64
  %10 = arith.subi %2, %5 : index
  cf.br ^bb3(%c0 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
  %12 = arith.cmpi slt, %11, %10 : index
  cf.cond_br %12, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %13 = arith.subi %2, %11 : index
  %14 = builtin.unrealized_conversion_cast %13 : index to i64
  %15 = arith.subi %13, %c1 : index
  %16 = builtin.unrealized_conversion_cast %15 : index to i64
  %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %19 = llvm.load %18 : !llvm.ptr -> i64
  %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %19, %21 : i64, !llvm.ptr
  %22 = arith.addi %11, %c1 : index
  cf.br ^bb3(%22 : index)
^bb5:  // pred: ^bb3
  %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %24 : i64, !llvm.ptr
  %25 = arith.addi %2, %c1 : index
  cf.br ^bb1(%25 : index)
^bb6:  // pred: ^bb1
  return
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
  %2 = arith.addi %0, %c1 : index
  %3 = arith.cmpi ult, %2, %1 : index
  cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
^bb2(%4: index, %5: index):  // pred: ^bb1
  %6 = arith.subi %5, %4 : index
  %7 = arith.cmpi ule, %6, %c30 : index
  cf.cond_br %7, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb13(%4, %4 : index, index)
^bb4:  // pred: ^bb2
  %8 = arith.subi %arg3, %c1_i64 : i64
  %9 = arith.cmpi ule, %8, %c0_i64 : i64
  cf.cond_br %9, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb11(%4, %4 : index, index)
^bb6:  // pred: ^bb4
  %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
  %11 = arith.addi %10, %c1 : index
  %12 = arith.subi %10, %4 : index
  %13 = arith.subi %5, %10 : index
  %14 = arith.cmpi ule, %12, %13 : index
  %15 = arith.select %14, %11, %4 : index
  %16 = arith.select %14, %5, %10 : index
  cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
  %20 = arith.cmpi ne, %17, %c0 : index
  cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
^bb8(%21: index, %22: index):  // pred: ^bb7
  call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb9
^bb9:  // 2 preds: ^bb7, ^bb8
  cf.br ^bb10
^bb10:  // pred: ^bb9
  cf.br ^bb11(%15, %16 : index, index)
^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
  cf.br ^bb12
^bb12:  // pred: ^bb11
  cf.br ^bb13(%23, %24 : index, index)
^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  cf.br ^bb1(%25, %26 : index, index)
^bb15:  // pred: ^bb1
  return
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %2 = arith.subi %arg1, %arg0 : index
  %3 = arith.subi %2, %c2 : index
  %4 = arith.shrui %3, %c1 : index
  %5 = arith.addi %4, %c1 : index
  cf.br ^bb1(%c0 : index)
^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
  %7 = arith.cmpi slt, %6, %5 : index
  cf.cond_br %7, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %8 = arith.subi %4, %6 : index
  %9 = arith.addi %arg0, %8 : index
  call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
  %10 = arith.addi %6, %c1 : index
  cf.br ^bb1(%10 : index)
^bb3:  // pred: ^bb1
  %11 = arith.subi %2, %c1 : index
  cf.br ^bb4(%c0 : index)
^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
  %13 = arith.cmpi slt, %12, %11 : index
  cf.cond_br %13, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %14 = arith.subi %2, %12 : index
  %15 = arith.addi %arg0, %14 : index
  %16 = arith.subi %15, %c1 : index
  %17 = builtin.unrealized_conversion_cast %16 : index to i64
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %23 = llvm.load %22 : !llvm.ptr -> i64
  %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %23, %25 : i64, !llvm.ptr
  %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %20, %27 : i64, !llvm.ptr
  %28 = arith.subi %14, %c1 : index
  call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
  %29 = arith.addi %12, %c1 : index
  cf.br ^bb4(%29 : index)
^bb6:  // pred: ^bb4
  return
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %1 = arith.cmpi uge, %arg3, %c2 : index
  cf.cond_br %1, ^bb1, ^bb16
^bb1:  // pred: ^bb0
  %2 = arith.subi %arg1, %arg0 : index
  %3 = arith.subi %arg3, %c2 : index
  %4 = arith.shrui %3, %c1 : index
  %5 = arith.cmpi uge, %4, %2 : index
  cf.cond_br %5, ^bb2, ^bb15
^bb2:  // pred: ^bb1
  %6 = arith.shli %2, %c1 : index
  %7 = arith.addi %6, %c1 : index
  %8 = arith.addi %7, %arg0 : index
  %9 = builtin.unrealized_conversion_cast %8 : index to i64
  %10 = arith.addi %6, %c2 : index
  %11 = arith.cmpi ult, %10, %arg3 : index
  cf.cond_br %11, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  %12 = arith.addi %10, %arg0 : index
  %13 = builtin.unrealized_conversion_cast %12 : index to i64
  %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %16 = llvm.load %15 : !llvm.ptr -> i64
  %17 = builtin.unrealized_conversion_cast %16 : i64 to index
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = builtin.unrealized_conversion_cast %20 : i64 to index
  %22 = arith.cmpi ult, %17, %21 : index
  %23 = arith.select %22, %10, %7 : index
  %24 = arith.select %22, %12, %8 : index
  cf.br ^bb5(%23, %24, %arg1 : index, index, index)
^bb4:  // pred: ^bb2
  cf.br ^bb5(%7, %8, %arg1 : index, index, index)
^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
  cf.br ^bb6(%27, %25, %26 : index, index, index)
^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
  cf.br ^bb7(%28, %29, %30 : index, index, index)
^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
  %34 = builtin.unrealized_conversion_cast %31 : index to i64
  %35 = builtin.unrealized_conversion_cast %33 : index to i64
  %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %38 = llvm.load %37 : !llvm.ptr -> i64
  %39 = builtin.unrealized_conversion_cast %38 : i64 to index
  %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %42 = llvm.load %41 : !llvm.ptr -> i64
  %43 = builtin.unrealized_conversion_cast %42 : i64 to index
  %44 = arith.cmpi ult, %39, %43 : index
  cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
  %48 = builtin.unrealized_conversion_cast %45 : index to i64
  %49 = builtin.unrealized_conversion_cast %47 : index to i64
  %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %52 = llvm.load %51 : !llvm.ptr -> i64
  %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %55 = llvm.load %54 : !llvm.ptr -> i64
  %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %55, %57 : i64, !llvm.ptr
  %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %52, %59 : i64, !llvm.ptr
  %60 = arith.cmpi uge, %4, %46 : index
  cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
^bb9:  // pred: ^bb8
  %61 = arith.shli %46, %c1 : index
  %62 = arith.addi %61, %c1 : index
  %63 = arith.addi %62, %arg0 : index
  %64 = builtin.unrealized_conversion_cast %63 : index to i64
  %65 = arith.addi %61, %c2 : index
  %66 = arith.cmpi ult, %65, %arg3 : index
  cf.cond_br %66, ^bb10, ^bb11
^bb10:  // pred: ^bb9
  %67 = arith.addi %65, %arg0 : index
  %68 = builtin.unrealized_conversion_cast %67 : index to i64
  %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %71 = llvm.load %70 : !llvm.ptr -> i64
  %72 = builtin.unrealized_conversion_cast %71 : i64 to index
  %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %75 = llvm.load %74 : !llvm.ptr -> i64
  %76 = builtin.unrealized_conversion_cast %75 : i64 to index
  %77 = arith.cmpi ult, %72, %76 : index
  %78 = arith.select %77, %65, %62 : index
  %79 = arith.select %77, %67, %63 : index
  cf.br ^bb12(%78, %79 : index, index)
^bb11:  // pred: ^bb9
  cf.br ^bb12(%62, %63 : index, index)
^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
  cf.br ^bb13(%80, %81 : index, index)
^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
  cf.br ^bb5(%82, %83, %47 : index, index, index)
^bb14:  // pred: ^bb7
  cf.br ^bb15
^bb15:  // 2 preds: ^bb1, ^bb14
  cf.br ^bb16
^bb16:  // 2 preds: ^bb0, ^bb15
  return
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
  %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
  %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c1 = arith.constant 1 : index
  %7 = builtin.unrealized_conversion_cast %c1 : index to i64
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %8 = builtin.unrealized_conversion_cast %c0 : index to i64
  %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %11 = llvm.load %10 : !llvm.ptr -> i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %15 = llvm.load %14 : !llvm.ptr -> i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %18 = arith.index_cast %17 : i64 to index
  %19 = arith.subi %16, %c1 : index
  %20 = builtin.unrealized_conversion_cast %19 : index to i64
  %21 = arith.cmpi ult, %12, %16 : index
  cf.cond_br %21, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %24 = llvm.load %23 : !llvm.ptr -> i64
  %25 = builtin.unrealized_conversion_cast %24 : i64 to index
  %26 = arith.cmpi eq, %25, %arg6 : index
  cf.br ^bb3(%26 : i1)
^bb2:  // pred: ^bb0
  cf.br ^bb3(%false : i1)
^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
  cf.br ^bb4
^bb4:  // pred: ^bb3
  %28 = arith.select %27, %19, %18 : index
  %29 = builtin.unrealized_conversion_cast %28 : index to i64
  cf.cond_br %27, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb6:  // pred: ^bb4
  %30 = arith.addi %18, %c1 : index
  %31 = builtin.unrealized_conversion_cast %30 : index to i64
  %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %31, %33 : i64, !llvm.ptr
  %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %35 = arith.index_cast %34 : i64 to index
  %36 = builtin.unrealized_conversion_cast %35 : index to i64
  %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = builtin.unrealized_conversion_cast %37 : i64 to index
  %39 = arith.addi %35, %c1 : index
  %40 = arith.cmpi ugt, %39, %38 : index
  cf.cond_br %40, ^bb7, ^bb10
^bb7:  // pred: ^bb6
  %41 = arith.muli %38, %c2 : index
  %42 = builtin.unrealized_conversion_cast %41 : index to i64
  %43 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %44 = builtin.unrealized_conversion_cast %41 : index to i64
  %45 = llvm.icmp "ugt" %44, %43 : i64
  llvm.cond_br %45, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb8:  // pred: ^bb7
  %46 = llvm.mlir.null : !llvm.ptr
  %47 = llvm.getelementptr %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
  %49 = llvm.mul %44, %48  : i64
  %50 = llvm.mul %43, %48  : i64
  %51 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
  %52 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%51, %52, %50) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %53 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%53) : (!llvm.ptr) -> ()
  %54 = llvm.insertvalue %51, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %55 = llvm.insertvalue %51, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb9(%55 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb9(%56: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
  %57 = llvm.insertvalue %44, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %58 = builtin.unrealized_conversion_cast %57 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb11(%58 : memref<?xindex>)
^bb10:  // pred: ^bb6
  cf.br ^bb11(%arg1 : memref<?xindex>)
^bb11(%59: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
  %60 = builtin.unrealized_conversion_cast %59 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb12
^bb12:  // pred: ^bb11
  %61 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %62 = llvm.getelementptr %61[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %5, %62 : i64, !llvm.ptr
  %63 = arith.index_cast %39 : index to i64
  %64 = llvm.insertvalue %63, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %65 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %66 = arith.index_cast %65 : i64 to index
  %67 = builtin.unrealized_conversion_cast %66 : index to i64
  %68 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %69 = builtin.unrealized_conversion_cast %68 : i64 to index
  %70 = arith.addi %66, %c1 : index
  %71 = arith.cmpi ugt, %70, %69 : index
  cf.cond_br %71, ^bb13, ^bb16
^bb13:  // pred: ^bb12
  %72 = arith.muli %69, %c2 : index
  %73 = builtin.unrealized_conversion_cast %72 : index to i64
  %74 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %75 = builtin.unrealized_conversion_cast %72 : index to i64
  %76 = llvm.icmp "ugt" %75, %74 : i64
  llvm.cond_br %76, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb14:  // pred: ^bb13
  %77 = llvm.mlir.null : !llvm.ptr
  %78 = llvm.getelementptr %77[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
  %80 = llvm.mul %75, %79  : i64
  %81 = llvm.mul %74, %79  : i64
  %82 = llvm.call @malloc(%80) : (i64) -> !llvm.ptr
  %83 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%82, %83, %81) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %84 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%84) : (!llvm.ptr) -> ()
  %85 = llvm.insertvalue %82, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %86 = llvm.insertvalue %82, %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb15(%86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb15(%87: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
  %88 = llvm.insertvalue %75, %87[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %89 = builtin.unrealized_conversion_cast %88 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb17(%89 : memref<?xindex>)
^bb16:  // pred: ^bb12
  cf.br ^bb17(%arg2 : memref<?xindex>)
^bb17(%90: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
  %91 = builtin.unrealized_conversion_cast %90 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb18
^bb18:  // pred: ^bb17
  %92 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %93 = llvm.getelementptr %92[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %8, %93 : i64, !llvm.ptr
  %94 = arith.index_cast %70 : index to i64
  %95 = llvm.insertvalue %94, %64[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb19(%59, %90, %95 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb19(%96: memref<?xindex>, %97: memref<?xindex>, %98: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
  %99 = builtin.unrealized_conversion_cast %97 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb20
^bb20:  // pred: ^bb19
  %100 = arith.addi %28, %c1 : index
  %101 = builtin.unrealized_conversion_cast %100 : index to i64
  %102 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %103 = llvm.getelementptr %102[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %104 = llvm.load %103 : !llvm.ptr -> i64
  %105 = builtin.unrealized_conversion_cast %104 : i64 to index
  %106 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.getelementptr %106[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %108 = llvm.load %107 : !llvm.ptr -> i64
  %109 = builtin.unrealized_conversion_cast %108 : i64 to index
  %110 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %111 = arith.index_cast %110 : i64 to index
  %112 = builtin.unrealized_conversion_cast %111 : index to i64
  %113 = arith.subi %109, %c1 : index
  %114 = builtin.unrealized_conversion_cast %113 : index to i64
  %115 = arith.cmpi ult, %105, %109 : index
  cf.cond_br %115, ^bb21, ^bb22
^bb21:  // pred: ^bb20
  %116 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %117 = llvm.getelementptr %116[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %118 = llvm.load %117 : !llvm.ptr -> i64
  %119 = builtin.unrealized_conversion_cast %118 : i64 to index
  %120 = arith.cmpi eq, %119, %arg7 : index
  cf.br ^bb23(%120 : i1)
^bb22:  // pred: ^bb20
  %121 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %122 = llvm.getelementptr %121[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %112, %122 : i64, !llvm.ptr
  cf.br ^bb23(%false : i1)
^bb23(%123: i1):  // 2 preds: ^bb21, ^bb22
  cf.br ^bb24
^bb24:  // pred: ^bb23
  %124 = arith.select %123, %113, %111 : index
  cf.cond_br %123, ^bb25, ^bb26
^bb25:  // pred: ^bb24
  cf.br ^bb44(%arg3, %arg4, %98 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb26:  // pred: ^bb24
  %125 = arith.addi %111, %c1 : index
  %126 = builtin.unrealized_conversion_cast %125 : index to i64
  %127 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %128 = llvm.getelementptr %127[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %126, %128 : i64, !llvm.ptr
  %129 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %130 = arith.index_cast %129 : i64 to index
  %131 = builtin.unrealized_conversion_cast %130 : index to i64
  %132 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %133 = builtin.unrealized_conversion_cast %132 : i64 to index
  %134 = arith.addi %130, %c1 : index
  %135 = arith.cmpi ugt, %134, %133 : index
  cf.cond_br %135, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %136 = arith.muli %133, %c2 : index
  %137 = builtin.unrealized_conversion_cast %136 : index to i64
  %138 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %139 = builtin.unrealized_conversion_cast %136 : index to i64
  %140 = llvm.icmp "ugt" %139, %138 : i64
  llvm.cond_br %140, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb28:  // pred: ^bb27
  %141 = llvm.mlir.null : !llvm.ptr
  %142 = llvm.getelementptr %141[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %143 = llvm.ptrtoint %142 : !llvm.ptr to i64
  %144 = llvm.mul %139, %143  : i64
  %145 = llvm.mul %138, %143  : i64
  %146 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
  %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%146, %147, %145) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %148 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%148) : (!llvm.ptr) -> ()
  %149 = llvm.insertvalue %146, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %150 = llvm.insertvalue %146, %149[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb29(%150 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb29(%151: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
  %152 = llvm.insertvalue %139, %151[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %153 = builtin.unrealized_conversion_cast %152 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb31(%153 : memref<?xindex>)
^bb30:  // pred: ^bb26
  cf.br ^bb31(%arg3 : memref<?xindex>)
^bb31(%154: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
  %155 = builtin.unrealized_conversion_cast %154 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb32
^bb32:  // pred: ^bb31
  %156 = llvm.extractvalue %155[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %157 = llvm.getelementptr %156[%131] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %3, %157 : i64, !llvm.ptr
  %158 = arith.index_cast %134 : index to i64
  %159 = llvm.insertvalue %158, %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %160 = llvm.extractvalue %98[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %161 = arith.index_cast %160 : i64 to index
  %162 = builtin.unrealized_conversion_cast %161 : index to i64
  %163 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %164 = builtin.unrealized_conversion_cast %163 : i64 to index
  %165 = arith.addi %161, %c32 : index
  %166 = arith.cmpi ugt, %165, %164 : index
  cf.cond_br %166, ^bb33, ^bb38
^bb33:  // pred: ^bb32
  cf.br ^bb34(%164 : index)
^bb34(%167: index):  // 2 preds: ^bb33, ^bb34
  %168 = arith.muli %167, %c2 : index
  %169 = builtin.unrealized_conversion_cast %168 : index to i64
  %170 = arith.cmpi ugt, %165, %168 : index
  cf.cond_br %170, ^bb34(%168 : index), ^bb35
^bb35:  // pred: ^bb34
  %171 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %172 = builtin.unrealized_conversion_cast %168 : index to i64
  %173 = llvm.icmp "ugt" %172, %171 : i64
  llvm.cond_br %173, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb36:  // pred: ^bb35
  %174 = llvm.mlir.null : !llvm.ptr
  %175 = llvm.getelementptr %174[1] : (!llvm.ptr) -> !llvm.ptr, f32
  %176 = llvm.ptrtoint %175 : !llvm.ptr to i64
  %177 = llvm.mul %172, %176  : i64
  %178 = llvm.mul %171, %176  : i64
  %179 = llvm.call @malloc(%177) : (i64) -> !llvm.ptr
  %180 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%179, %180, %178) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %181 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%181) : (!llvm.ptr) -> ()
  %182 = llvm.insertvalue %179, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %183 = llvm.insertvalue %179, %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb37(%183 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb37(%184: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
  %185 = llvm.insertvalue %172, %184[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %186 = builtin.unrealized_conversion_cast %185 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  cf.br ^bb39(%186 : memref<?xf32>)
^bb38:  // pred: ^bb32
  cf.br ^bb39(%arg4 : memref<?xf32>)
^bb39(%187: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
  %188 = builtin.unrealized_conversion_cast %187 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb40
^bb40:  // pred: ^bb39
  %189 = llvm.extractvalue %188[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %190 = llvm.extractvalue %188[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %191 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
  %192 = llvm.insertvalue %189, %191[0] : !llvm.struct<(ptr, ptr, i64)> 
  %193 = llvm.insertvalue %190, %192[1] : !llvm.struct<(ptr, ptr, i64)> 
  %194 = llvm.mlir.constant(0 : index) : i64
  %195 = llvm.insertvalue %194, %193[2] : !llvm.struct<(ptr, ptr, i64)> 
  %196 = llvm.extractvalue %188[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %197 = llvm.extractvalue %188[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %198 = llvm.extractvalue %188[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %199 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %200 = llvm.insertvalue %189, %199[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %201 = llvm.insertvalue %190, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.insertvalue %162, %201[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %203 = llvm.mlir.constant(32 : index) : i64
  %204 = llvm.insertvalue %203, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %205 = llvm.mlir.constant(1 : index) : i64
  %206 = llvm.insertvalue %205, %204[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  cf.br ^bb41(%c0 : index)
^bb41(%207: index):  // 2 preds: ^bb40, ^bb42
  %208 = builtin.unrealized_conversion_cast %207 : index to i64
  %209 = arith.cmpi slt, %207, %c32 : index
  cf.cond_br %209, ^bb42, ^bb43
^bb42:  // pred: ^bb41
  %210 = llvm.getelementptr %190[%162] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %211 = llvm.getelementptr %210[%208] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %211 : f32, !llvm.ptr
  %212 = arith.addi %207, %c1 : index
  cf.br ^bb41(%212 : index)
^bb43:  // pred: ^bb41
  %213 = arith.index_cast %165 : index to i64
  %214 = llvm.insertvalue %213, %159[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb44(%154, %187, %214 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb44(%215: memref<?xindex>, %216: memref<?xf32>, %217: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
  %218 = builtin.unrealized_conversion_cast %216 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb45
^bb45:  // pred: ^bb44
  %219 = arith.muli %124, %c32 : index
  %220 = arith.addi %219, %arg8 : index
  %221 = builtin.unrealized_conversion_cast %220 : index to i64
  %222 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %223 = llvm.getelementptr %222[%221] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %arg9, %223 : f32, !llvm.ptr
  return %arg0, %96, %97, %215, %216, %217 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %2 = arith.addi %arg0, %arg1 : index
  %3 = arith.shrui %2, %c1 : index
  %4 = builtin.unrealized_conversion_cast %3 : index to i64
  %5 = arith.subi %arg1, %c1 : index
  %6 = builtin.unrealized_conversion_cast %5 : index to i64
  %7 = arith.subi %arg1, %arg0 : index
  %8 = arith.cmpi ult, %7, %c1000 : index
  cf.cond_br %8, ^bb1, ^bb8
^bb1:  // pred: ^bb0
  %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %11 = llvm.load %10 : !llvm.ptr -> i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %15 = llvm.load %14 : !llvm.ptr -> i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = arith.cmpi ult, %12, %16 : index
  cf.cond_br %17, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %23 = llvm.load %22 : !llvm.ptr -> i64
  %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %23, %25 : i64, !llvm.ptr
  %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %20, %27 : i64, !llvm.ptr
  cf.br ^bb3
^bb3:  // 2 preds: ^bb1, ^bb2
  %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %30 = llvm.load %29 : !llvm.ptr -> i64
  %31 = builtin.unrealized_conversion_cast %30 : i64 to index
  %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %34 = llvm.load %33 : !llvm.ptr -> i64
  %35 = builtin.unrealized_conversion_cast %34 : i64 to index
  %36 = arith.cmpi ult, %31, %35 : index
  cf.cond_br %36, ^bb4, ^bb7
^bb4:  // pred: ^bb3
  %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %39 = llvm.load %38 : !llvm.ptr -> i64
  %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %42 = llvm.load %41 : !llvm.ptr -> i64
  %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %42, %44 : i64, !llvm.ptr
  %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %39, %46 : i64, !llvm.ptr
  %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %49 = llvm.load %48 : !llvm.ptr -> i64
  %50 = builtin.unrealized_conversion_cast %49 : i64 to index
  %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %53 = llvm.load %52 : !llvm.ptr -> i64
  %54 = builtin.unrealized_conversion_cast %53 : i64 to index
  %55 = arith.cmpi ult, %50, %54 : index
  cf.cond_br %55, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %58 = llvm.load %57 : !llvm.ptr -> i64
  %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %61 = llvm.load %60 : !llvm.ptr -> i64
  %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %61, %63 : i64, !llvm.ptr
  %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %58, %65 : i64, !llvm.ptr
  cf.br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
  cf.br ^bb7
^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
  cf.br ^bb27(%arg0, %5, %3 : index, index, index)
^bb8:  // pred: ^bb0
  %66 = arith.addi %arg0, %arg1 : index
  %67 = arith.shrui %66, %c1 : index
  %68 = builtin.unrealized_conversion_cast %67 : index to i64
  %69 = arith.addi %3, %arg1 : index
  %70 = arith.shrui %69, %c1 : index
  %71 = builtin.unrealized_conversion_cast %70 : index to i64
  %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %74 = llvm.load %73 : !llvm.ptr -> i64
  %75 = builtin.unrealized_conversion_cast %74 : i64 to index
  %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %78 = llvm.load %77 : !llvm.ptr -> i64
  %79 = builtin.unrealized_conversion_cast %78 : i64 to index
  %80 = arith.cmpi ult, %75, %79 : index
  cf.cond_br %80, ^bb9, ^bb10
^bb9:  // pred: ^bb8
  %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %83 = llvm.load %82 : !llvm.ptr -> i64
  %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %86 = llvm.load %85 : !llvm.ptr -> i64
  %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %86, %88 : i64, !llvm.ptr
  %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %83, %90 : i64, !llvm.ptr
  cf.br ^bb10
^bb10:  // 2 preds: ^bb8, ^bb9
  %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %93 = llvm.load %92 : !llvm.ptr -> i64
  %94 = builtin.unrealized_conversion_cast %93 : i64 to index
  %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %97 = llvm.load %96 : !llvm.ptr -> i64
  %98 = builtin.unrealized_conversion_cast %97 : i64 to index
  %99 = arith.cmpi ult, %94, %98 : index
  cf.cond_br %99, ^bb11, ^bb14
^bb11:  // pred: ^bb10
  %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %102 = llvm.load %101 : !llvm.ptr -> i64
  %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %105 = llvm.load %104 : !llvm.ptr -> i64
  %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %105, %107 : i64, !llvm.ptr
  %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %102, %109 : i64, !llvm.ptr
  %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %112 = llvm.load %111 : !llvm.ptr -> i64
  %113 = builtin.unrealized_conversion_cast %112 : i64 to index
  %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %116 = llvm.load %115 : !llvm.ptr -> i64
  %117 = builtin.unrealized_conversion_cast %116 : i64 to index
  %118 = arith.cmpi ult, %113, %117 : index
  cf.cond_br %118, ^bb12, ^bb13
^bb12:  // pred: ^bb11
  %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %121 = llvm.load %120 : !llvm.ptr -> i64
  %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %124 = llvm.load %123 : !llvm.ptr -> i64
  %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %124, %126 : i64, !llvm.ptr
  %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %121, %128 : i64, !llvm.ptr
  cf.br ^bb13
^bb13:  // 2 preds: ^bb11, ^bb12
  cf.br ^bb14
^bb14:  // 2 preds: ^bb10, ^bb13
  %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %131 = llvm.load %130 : !llvm.ptr -> i64
  %132 = builtin.unrealized_conversion_cast %131 : i64 to index
  %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %135 = llvm.load %134 : !llvm.ptr -> i64
  %136 = builtin.unrealized_conversion_cast %135 : i64 to index
  %137 = arith.cmpi ult, %132, %136 : index
  cf.cond_br %137, ^bb15, ^bb20
^bb15:  // pred: ^bb14
  %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %140 = llvm.load %139 : !llvm.ptr -> i64
  %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %143 = llvm.load %142 : !llvm.ptr -> i64
  %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %143, %145 : i64, !llvm.ptr
  %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %140, %147 : i64, !llvm.ptr
  %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %150 = llvm.load %149 : !llvm.ptr -> i64
  %151 = builtin.unrealized_conversion_cast %150 : i64 to index
  %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %154 = llvm.load %153 : !llvm.ptr -> i64
  %155 = builtin.unrealized_conversion_cast %154 : i64 to index
  %156 = arith.cmpi ult, %151, %155 : index
  cf.cond_br %156, ^bb16, ^bb19
^bb16:  // pred: ^bb15
  %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %159 = llvm.load %158 : !llvm.ptr -> i64
  %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %162 = llvm.load %161 : !llvm.ptr -> i64
  %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %162, %164 : i64, !llvm.ptr
  %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %159, %166 : i64, !llvm.ptr
  %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %169 = llvm.load %168 : !llvm.ptr -> i64
  %170 = builtin.unrealized_conversion_cast %169 : i64 to index
  %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %173 = llvm.load %172 : !llvm.ptr -> i64
  %174 = builtin.unrealized_conversion_cast %173 : i64 to index
  %175 = arith.cmpi ult, %170, %174 : index
  cf.cond_br %175, ^bb17, ^bb18
^bb17:  // pred: ^bb16
  %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %178 = llvm.load %177 : !llvm.ptr -> i64
  %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %181 = llvm.load %180 : !llvm.ptr -> i64
  %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %181, %183 : i64, !llvm.ptr
  %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %178, %185 : i64, !llvm.ptr
  cf.br ^bb18
^bb18:  // 2 preds: ^bb16, ^bb17
  cf.br ^bb19
^bb19:  // 2 preds: ^bb15, ^bb18
  cf.br ^bb20
^bb20:  // 2 preds: ^bb14, ^bb19
  %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %188 = llvm.load %187 : !llvm.ptr -> i64
  %189 = builtin.unrealized_conversion_cast %188 : i64 to index
  %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %192 = llvm.load %191 : !llvm.ptr -> i64
  %193 = builtin.unrealized_conversion_cast %192 : i64 to index
  %194 = arith.cmpi ult, %189, %193 : index
  cf.cond_br %194, ^bb21, ^bb7
^bb21:  // pred: ^bb20
  %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %197 = llvm.load %196 : !llvm.ptr -> i64
  %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %200 = llvm.load %199 : !llvm.ptr -> i64
  %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %200, %202 : i64, !llvm.ptr
  %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %197, %204 : i64, !llvm.ptr
  %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %207 = llvm.load %206 : !llvm.ptr -> i64
  %208 = builtin.unrealized_conversion_cast %207 : i64 to index
  %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %211 = llvm.load %210 : !llvm.ptr -> i64
  %212 = builtin.unrealized_conversion_cast %211 : i64 to index
  %213 = arith.cmpi ult, %208, %212 : index
  cf.cond_br %213, ^bb22, ^bb6
^bb22:  // pred: ^bb21
  %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %216 = llvm.load %215 : !llvm.ptr -> i64
  %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %219 = llvm.load %218 : !llvm.ptr -> i64
  %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %219, %221 : i64, !llvm.ptr
  %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %216, %223 : i64, !llvm.ptr
  %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %226 = llvm.load %225 : !llvm.ptr -> i64
  %227 = builtin.unrealized_conversion_cast %226 : i64 to index
  %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %230 = llvm.load %229 : !llvm.ptr -> i64
  %231 = builtin.unrealized_conversion_cast %230 : i64 to index
  %232 = arith.cmpi ult, %227, %231 : index
  cf.cond_br %232, ^bb23, ^bb26
^bb23:  // pred: ^bb22
  %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %235 = llvm.load %234 : !llvm.ptr -> i64
  %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %238 = llvm.load %237 : !llvm.ptr -> i64
  %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %238, %240 : i64, !llvm.ptr
  %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %235, %242 : i64, !llvm.ptr
  %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %245 = llvm.load %244 : !llvm.ptr -> i64
  %246 = builtin.unrealized_conversion_cast %245 : i64 to index
  %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %249 = llvm.load %248 : !llvm.ptr -> i64
  %250 = builtin.unrealized_conversion_cast %249 : i64 to index
  %251 = arith.cmpi ult, %246, %250 : index
  cf.cond_br %251, ^bb24, ^bb25
^bb24:  // pred: ^bb23
  %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %254 = llvm.load %253 : !llvm.ptr -> i64
  %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %257 = llvm.load %256 : !llvm.ptr -> i64
  %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %257, %259 : i64, !llvm.ptr
  %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %254, %261 : i64, !llvm.ptr
  cf.br ^bb25
^bb25:  // 2 preds: ^bb23, ^bb24
  cf.br ^bb26
^bb26:  // 2 preds: ^bb22, ^bb25
  cf.br ^bb6
^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
  cf.br ^bb28(%262, %263, %264 : index, index, index)
^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
  %268 = arith.cmpi ult, %265, %266 : index
  cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
  %272 = builtin.unrealized_conversion_cast %271 : index to i64
  cf.br ^bb30(%269 : index)
^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
  %274 = builtin.unrealized_conversion_cast %273 : index to i64
  %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %277 = llvm.load %276 : !llvm.ptr -> i64
  %278 = builtin.unrealized_conversion_cast %277 : i64 to index
  %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %281 = llvm.load %280 : !llvm.ptr -> i64
  %282 = builtin.unrealized_conversion_cast %281 : i64 to index
  %283 = arith.cmpi ult, %278, %282 : index
  cf.cond_br %283, ^bb31(%273 : index), ^bb32
^bb31(%284: index):  // pred: ^bb30
  %285 = arith.addi %284, %c1 : index
  cf.br ^bb30(%285 : index)
^bb32:  // pred: ^bb30
  %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %288 = llvm.load %287 : !llvm.ptr -> i64
  %289 = builtin.unrealized_conversion_cast %288 : i64 to index
  %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %292 = llvm.load %291 : !llvm.ptr -> i64
  %293 = builtin.unrealized_conversion_cast %292 : i64 to index
  %294 = arith.cmpi eq, %289, %293 : index
  cf.br ^bb33(%270 : index)
^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
  %296 = builtin.unrealized_conversion_cast %295 : index to i64
  %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %299 = llvm.load %298 : !llvm.ptr -> i64
  %300 = builtin.unrealized_conversion_cast %299 : i64 to index
  %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %303 = llvm.load %302 : !llvm.ptr -> i64
  %304 = builtin.unrealized_conversion_cast %303 : i64 to index
  %305 = arith.cmpi ult, %300, %304 : index
  cf.cond_br %305, ^bb34(%295 : index), ^bb35
^bb34(%306: index):  // pred: ^bb33
  %307 = arith.addi %306, %c-1 : index
  cf.br ^bb33(%307 : index)
^bb35:  // pred: ^bb33
  %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %310 = llvm.load %309 : !llvm.ptr -> i64
  %311 = builtin.unrealized_conversion_cast %310 : i64 to index
  %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %314 = llvm.load %313 : !llvm.ptr -> i64
  %315 = builtin.unrealized_conversion_cast %314 : i64 to index
  %316 = arith.cmpi eq, %311, %315 : index
  %317 = arith.cmpi ult, %273, %295 : index
  cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
^bb36:  // pred: ^bb35
  %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %320 = llvm.load %319 : !llvm.ptr -> i64
  %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %323 = llvm.load %322 : !llvm.ptr -> i64
  %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %323, %325 : i64, !llvm.ptr
  %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %320, %327 : i64, !llvm.ptr
  %328 = arith.cmpi eq, %273, %271 : index
  cf.cond_br %328, ^bb37, ^bb38
^bb37:  // pred: ^bb36
  cf.br ^bb39(%295 : index)
^bb38:  // pred: ^bb36
  %329 = arith.cmpi eq, %295, %271 : index
  %330 = arith.select %329, %273, %271 : index
  cf.br ^bb39(%330 : index)
^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
  cf.br ^bb40
^bb40:  // pred: ^bb39
  %332 = arith.andi %294, %316 : i1
  cf.cond_br %332, ^bb41, ^bb42
^bb41:  // pred: ^bb40
  %333 = arith.addi %273, %c1 : index
  %334 = arith.subi %295, %c1 : index
  cf.br ^bb43(%333, %334 : index, index)
^bb42:  // pred: ^bb40
  cf.br ^bb43(%273, %295 : index, index)
^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
  cf.br ^bb44(%335, %336, %331 : index, index, index)
^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
  cf.br ^bb45(%337, %338, %339 : index, index, index)
^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
  cf.br ^bb27(%340, %341, %342 : index, index, index)
^bb46:  // pred: ^bb28
  return %267 : index
}

// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %6 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %7 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %8 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %9 = builtin.unrealized_conversion_cast %c0 : index to i64
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %10 = builtin.unrealized_conversion_cast %c1 : index to i64
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %11 = llvm.mlir.constant(16 : index) : i64
  %12 = llvm.mlir.constant(1 : index) : i64
  %13 = llvm.mlir.null : !llvm.ptr
  %14 = llvm.getelementptr %13[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
  %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
  %17 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %20 = llvm.mlir.constant(0 : index) : i64
  %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %11, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %12, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %24 = builtin.unrealized_conversion_cast %23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %25 = llvm.mlir.constant(16 : index) : i64
  %26 = llvm.mlir.constant(1 : index) : i64
  %27 = llvm.mlir.null : !llvm.ptr
  %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
  %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
  %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %34 = llvm.mlir.constant(0 : index) : i64
  %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %36 = llvm.insertvalue %25, %35[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %37 = llvm.insertvalue %26, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = builtin.unrealized_conversion_cast %37 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %39 = llvm.mlir.constant(16 : index) : i64
  %40 = llvm.mlir.constant(1 : index) : i64
  %41 = llvm.mlir.null : !llvm.ptr
  %42 = llvm.getelementptr %41[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %43 = llvm.ptrtoint %42 : !llvm.ptr to i64
  %44 = llvm.call @malloc(%43) : (i64) -> !llvm.ptr
  %45 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %48 = llvm.mlir.constant(0 : index) : i64
  %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %50 = llvm.insertvalue %39, %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %51 = llvm.insertvalue %40, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = builtin.unrealized_conversion_cast %51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %53 = llvm.mlir.constant(16 : index) : i64
  %54 = llvm.mlir.constant(1 : index) : i64
  %55 = llvm.mlir.null : !llvm.ptr
  %56 = llvm.getelementptr %55[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %57 = llvm.ptrtoint %56 : !llvm.ptr to i64
  %58 = llvm.call @malloc(%57) : (i64) -> !llvm.ptr
  %59 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %62 = llvm.mlir.constant(0 : index) : i64
  %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %64 = llvm.insertvalue %53, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %65 = llvm.insertvalue %54, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %66 = builtin.unrealized_conversion_cast %65 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %67 = llvm.mlir.constant(16 : index) : i64
  %68 = llvm.mlir.constant(1 : index) : i64
  %69 = llvm.mlir.null : !llvm.ptr
  %70 = llvm.getelementptr %69[16] : (!llvm.ptr) -> !llvm.ptr, f32
  %71 = llvm.ptrtoint %70 : !llvm.ptr to i64
  %72 = llvm.call @malloc(%71) : (i64) -> !llvm.ptr
  %73 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %76 = llvm.mlir.constant(0 : index) : i64
  %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %78 = llvm.insertvalue %67, %77[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %79 = llvm.insertvalue %68, %78[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %80 = builtin.unrealized_conversion_cast %79 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %81 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %82 = llvm.insertvalue %c0_i64, %81[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %83 = llvm.insertvalue %c0_i64, %82[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %84 = llvm.insertvalue %c0_i64, %83[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %85 = llvm.insertvalue %c0_i64, %84[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %86 = llvm.insertvalue %c0_i64, %85[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %87 = llvm.insertvalue %c128_i64, %86[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %88 = llvm.getelementptr %16[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %88 : i64, !llvm.ptr
  %89 = llvm.insertvalue %c1_i64, %87[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %90 = llvm.insertvalue %c128_i64, %89[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %91 = llvm.getelementptr %44[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %91 : i64, !llvm.ptr
  %92 = llvm.insertvalue %c1_i64, %90[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %93 = llvm.insertvalue %c32_i64, %92[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %94 = llvm.getelementptr %16[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %94 : i64, !llvm.ptr
  %95 = llvm.insertvalue %c2_i64, %93[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %96 = llvm.mlir.constant(32 : index) : i64
  %97 = llvm.mlir.constant(1 : index) : i64
  %98 = llvm.mlir.null : !llvm.ptr
  %99 = llvm.getelementptr %98[32] : (!llvm.ptr) -> !llvm.ptr, f32
  %100 = llvm.ptrtoint %99 : !llvm.ptr to i64
  %101 = llvm.call @malloc(%100) : (i64) -> !llvm.ptr
  %102 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %103 = llvm.insertvalue %101, %102[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %104 = llvm.insertvalue %101, %103[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %105 = llvm.mlir.constant(0 : index) : i64
  %106 = llvm.insertvalue %105, %104[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.insertvalue %96, %106[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %108 = llvm.insertvalue %97, %107[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %109 = llvm.mlir.constant(32 : index) : i64
  %110 = llvm.mlir.constant(1 : index) : i64
  %111 = llvm.mlir.null : !llvm.ptr
  %112 = llvm.getelementptr %111[32] : (!llvm.ptr) -> !llvm.ptr, i1
  %113 = llvm.ptrtoint %112 : !llvm.ptr to i64
  %114 = llvm.call @malloc(%113) : (i64) -> !llvm.ptr
  %115 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %116 = llvm.insertvalue %114, %115[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %117 = llvm.insertvalue %114, %116[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %118 = llvm.mlir.constant(0 : index) : i64
  %119 = llvm.insertvalue %118, %117[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %120 = llvm.insertvalue %109, %119[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %121 = llvm.insertvalue %110, %120[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %122 = llvm.mlir.constant(32 : index) : i64
  %123 = llvm.mlir.constant(1 : index) : i64
  %124 = llvm.mlir.null : !llvm.ptr
  %125 = llvm.getelementptr %124[32] : (!llvm.ptr) -> !llvm.ptr, i64
  %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
  %127 = llvm.call @malloc(%126) : (i64) -> !llvm.ptr
  %128 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %129 = llvm.insertvalue %127, %128[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %130 = llvm.insertvalue %127, %129[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %131 = llvm.mlir.constant(0 : index) : i64
  %132 = llvm.insertvalue %131, %130[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %133 = llvm.insertvalue %122, %132[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %134 = llvm.insertvalue %123, %133[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %135 = builtin.unrealized_conversion_cast %134 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb1(%c0 : index)
^bb1(%136: index):  // 2 preds: ^bb0, ^bb2
  %137 = builtin.unrealized_conversion_cast %136 : index to i64
  %138 = arith.cmpi slt, %136, %c32 : index
  cf.cond_br %138, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %139 = llvm.getelementptr %101[%137] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %139 : f32, !llvm.ptr
  %140 = arith.addi %136, %c1 : index
  cf.br ^bb1(%140 : index)
^bb3:  // pred: ^bb1
  cf.br ^bb4(%c0 : index)
^bb4(%141: index):  // 2 preds: ^bb3, ^bb5
  %142 = builtin.unrealized_conversion_cast %141 : index to i64
  %143 = arith.cmpi slt, %141, %c32 : index
  cf.cond_br %143, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %144 = llvm.getelementptr %114[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %false, %144 : i1, !llvm.ptr
  %145 = arith.addi %141, %c1 : index
  cf.br ^bb4(%145 : index)
^bb6:  // pred: ^bb4
  %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %147 = llvm.getelementptr %146[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %148 = llvm.load %147 : !llvm.ptr -> i64
  %149 = builtin.unrealized_conversion_cast %148 : i64 to index
  %150 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %151 = llvm.getelementptr %150[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %152 = llvm.load %151 : !llvm.ptr -> i64
  %153 = builtin.unrealized_conversion_cast %152 : i64 to index
  cf.br ^bb7(%149, %24, %38, %52, %66, %80, %95 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb7(%154: index, %155: memref<?xindex>, %156: memref<?xindex>, %157: memref<?xindex>, %158: memref<?xindex>, %159: memref<?xf32>, %160: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
  %161 = builtin.unrealized_conversion_cast %154 : index to i64
  %162 = builtin.unrealized_conversion_cast %157 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %163 = builtin.unrealized_conversion_cast %155 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %164 = builtin.unrealized_conversion_cast %156 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %165 = builtin.unrealized_conversion_cast %158 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %166 = builtin.unrealized_conversion_cast %159 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %167 = arith.cmpi slt, %154, %153 : index
  cf.cond_br %167, ^bb8, ^bb25
^bb8:  // pred: ^bb7
  %168 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %169 = llvm.getelementptr %168[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %170 = llvm.load %169 : !llvm.ptr -> i64
  %171 = builtin.unrealized_conversion_cast %170 : i64 to index
  %172 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %173 = llvm.getelementptr %172[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %174 = llvm.load %173 : !llvm.ptr -> i64
  %175 = builtin.unrealized_conversion_cast %174 : i64 to index
  %176 = arith.addi %154, %c1 : index
  %177 = builtin.unrealized_conversion_cast %176 : index to i64
  %178 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %179 = llvm.getelementptr %178[%177] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %180 = llvm.load %179 : !llvm.ptr -> i64
  %181 = builtin.unrealized_conversion_cast %180 : i64 to index
  cf.br ^bb9(%175, %155, %156, %157, %158, %159, %160 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb9(%182: index, %183: memref<?xindex>, %184: memref<?xindex>, %185: memref<?xindex>, %186: memref<?xindex>, %187: memref<?xf32>, %188: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
  %189 = builtin.unrealized_conversion_cast %182 : index to i64
  %190 = arith.cmpi slt, %182, %181 : index
  cf.cond_br %190, ^bb10, ^bb24
^bb10:  // pred: ^bb9
  %191 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %192 = llvm.getelementptr %191[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %193 = llvm.load %192 : !llvm.ptr -> i64
  %194 = builtin.unrealized_conversion_cast %193 : i64 to index
  %195 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %196 = llvm.getelementptr %195[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %197 = llvm.load %196 : !llvm.ptr -> i64
  %198 = builtin.unrealized_conversion_cast %197 : i64 to index
  %199 = arith.addi %182, %c1 : index
  %200 = builtin.unrealized_conversion_cast %199 : index to i64
  %201 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %203 = llvm.load %202 : !llvm.ptr -> i64
  %204 = builtin.unrealized_conversion_cast %203 : i64 to index
  cf.br ^bb11(%198, %c0 : index, index)
^bb11(%205: index, %206: index):  // 2 preds: ^bb10, ^bb19
  %207 = builtin.unrealized_conversion_cast %205 : index to i64
  %208 = arith.cmpi slt, %205, %204 : index
  cf.cond_br %208, ^bb12, ^bb20
^bb12:  // pred: ^bb11
  %209 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %210 = llvm.getelementptr %209[%207] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %211 = llvm.load %210 : !llvm.ptr -> i64
  %212 = builtin.unrealized_conversion_cast %211 : i64 to index
  %213 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %214 = llvm.getelementptr %213[%207] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %215 = llvm.load %214 : !llvm.ptr -> f32
  cf.br ^bb13(%c0, %206 : index, index)
^bb13(%216: index, %217: index):  // 2 preds: ^bb12, ^bb18
  %218 = builtin.unrealized_conversion_cast %216 : index to i64
  %219 = builtin.unrealized_conversion_cast %217 : index to i64
  %220 = arith.cmpi slt, %216, %c32 : index
  cf.cond_br %220, ^bb14, ^bb19
^bb14:  // pred: ^bb13
  %221 = arith.muli %212, %c32 : index
  %222 = arith.addi %221, %216 : index
  %223 = builtin.unrealized_conversion_cast %222 : index to i64
  %224 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %225 = llvm.load %224 : !llvm.ptr -> f32
  %226 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %227 = llvm.getelementptr %226[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %228 = llvm.load %227 : !llvm.ptr -> f32
  %229 = arith.mulf %215, %228 : f32
  %230 = arith.addf %225, %229 : f32
  %231 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  %232 = llvm.load %231 : !llvm.ptr -> i1
  %233 = arith.cmpi eq, %232, %false : i1
  cf.cond_br %233, ^bb15, ^bb16
^bb15:  // pred: ^bb14
  %234 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %true, %234 : i1, !llvm.ptr
  %235 = llvm.getelementptr %127[%219] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %218, %235 : i64, !llvm.ptr
  %236 = arith.addi %217, %c1 : index
  cf.br ^bb17(%236 : index)
^bb16:  // pred: ^bb14
  cf.br ^bb17(%217 : index)
^bb17(%237: index):  // 2 preds: ^bb15, ^bb16
  cf.br ^bb18
^bb18:  // pred: ^bb17
  %238 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %230, %238 : f32, !llvm.ptr
  %239 = arith.addi %216, %c1 : index
  cf.br ^bb13(%239, %237 : index, index)
^bb19:  // pred: ^bb13
  %240 = arith.addi %205, %c1 : index
  cf.br ^bb11(%240, %217 : index, index)
^bb20:  // pred: ^bb11
  %241 = arith.index_cast %206 : index to i64
  %242 = math.ctlz %241 : i64
  %243 = arith.subi %c64_i64, %242 : i64
  call @_sparse_hybrid_qsort_1_index(%c0, %206, %135, %243) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb21(%c0, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb21(%244: index, %245: memref<?xindex>, %246: memref<?xindex>, %247: memref<?xindex>, %248: memref<?xindex>, %249: memref<?xf32>, %250: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
  %251 = builtin.unrealized_conversion_cast %244 : index to i64
  %252 = arith.cmpi slt, %244, %206 : index
  cf.cond_br %252, ^bb22, ^bb23
^bb22:  // pred: ^bb21
  %253 = llvm.getelementptr %127[%251] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %254 = llvm.load %253 : !llvm.ptr -> i64
  %255 = builtin.unrealized_conversion_cast %254 : i64 to index
  %256 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %257 = llvm.load %256 : !llvm.ptr -> f32
  %258:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%245, %246, %247, %248, %249, %250, %171, %194, %255, %257) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  %259 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %259 : f32, !llvm.ptr
  %260 = llvm.getelementptr %114[%254] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %false, %260 : i1, !llvm.ptr
  %261 = arith.addi %244, %c1 : index
  cf.br ^bb21(%261, %258#0, %258#1, %258#2, %258#3, %258#4, %258#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb23:  // pred: ^bb21
  %262 = arith.addi %182, %c1 : index
  cf.br ^bb9(%262, %245, %246, %247, %248, %249, %250 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb24:  // pred: ^bb9
  %263 = arith.addi %154, %c1 : index
  cf.br ^bb7(%263, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb25:  // pred: ^bb7
  llvm.call @free(%101) : (!llvm.ptr) -> ()
  llvm.call @free(%114) : (!llvm.ptr) -> ()
  llvm.call @free(%127) : (!llvm.ptr) -> ()
  %264 = llvm.extractvalue %160[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %265 = arith.index_cast %264 : i64 to index
  %266 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %267 = llvm.getelementptr %266[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %268 = llvm.load %267 : !llvm.ptr -> i64
  %269 = builtin.unrealized_conversion_cast %268 : i64 to index
  cf.br ^bb26(%c1, %269 : index, index)
^bb26(%270: index, %271: index):  // 2 preds: ^bb25, ^bb29
  %272 = builtin.unrealized_conversion_cast %270 : index to i64
  %273 = builtin.unrealized_conversion_cast %271 : index to i64
  %274 = arith.cmpi slt, %270, %265 : index
  cf.cond_br %274, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %275 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %276 = llvm.getelementptr %275[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %277 = llvm.load %276 : !llvm.ptr -> i64
  %278 = builtin.unrealized_conversion_cast %277 : i64 to index
  %279 = arith.cmpi eq, %278, %c0 : index
  %280 = arith.select %279, %271, %278 : index
  cf.cond_br %279, ^bb28, ^bb29
^bb28:  // pred: ^bb27
  %281 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %282 = llvm.getelementptr %281[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %273, %282 : i64, !llvm.ptr
  cf.br ^bb29
^bb29:  // 2 preds: ^bb27, ^bb28
  %283 = arith.addi %270, %c1 : index
  cf.br ^bb26(%283, %280 : index, index)
^bb30:  // pred: ^bb26
  %284 = llvm.mlir.constant(4096 : index) : i64
  %285 = llvm.mlir.constant(1 : index) : i64
  %286 = llvm.mlir.null : !llvm.ptr
  %287 = llvm.getelementptr %286[4096] : (!llvm.ptr) -> !llvm.ptr, f32
  %288 = llvm.ptrtoint %287 : !llvm.ptr to i64
  %289 = llvm.call @malloc(%288) : (i64) -> !llvm.ptr
  %290 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %291 = llvm.insertvalue %289, %290[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %292 = llvm.insertvalue %289, %291[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %293 = llvm.mlir.constant(0 : index) : i64
  %294 = llvm.insertvalue %293, %292[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %295 = llvm.insertvalue %284, %294[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %296 = llvm.insertvalue %285, %295[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %297 = builtin.unrealized_conversion_cast %296 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %298 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %299 = llvm.insertvalue %c0_i64, %298[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %300 = llvm.insertvalue %c128_i64, %299[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %301 = llvm.insertvalue %c32_i64, %300[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb31(%c0 : index)
^bb31(%302: index):  // 2 preds: ^bb30, ^bb32
  %303 = builtin.unrealized_conversion_cast %302 : index to i64
  %304 = arith.cmpi slt, %302, %c4096 : index
  cf.cond_br %304, ^bb32, ^bb33
^bb32:  // pred: ^bb31
  %305 = llvm.getelementptr %289[%303] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %305 : f32, !llvm.ptr
  %306 = arith.addi %302, %c1 : index
  cf.br ^bb31(%306 : index)
^bb33:  // pred: ^bb31
  %307 = llvm.insertvalue %c4096_i64, %301[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %308 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %309 = llvm.getelementptr %308[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %310 = llvm.load %309 : !llvm.ptr -> i64
  %311 = builtin.unrealized_conversion_cast %310 : i64 to index
  %312 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %313 = llvm.getelementptr %312[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %314 = llvm.load %313 : !llvm.ptr -> i64
  %315 = builtin.unrealized_conversion_cast %314 : i64 to index
  omp.parallel   {
    omp.wsloop   for  (%arg12) : index = (%311) to (%315) step (%c1) {
      %316 = builtin.unrealized_conversion_cast %arg12 : index to i64
      %317 = llvm.extractvalue %164[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %318 = llvm.getelementptr %317[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %319 = llvm.load %318 : !llvm.ptr -> i64
      %320 = builtin.unrealized_conversion_cast %319 : i64 to index
      %321 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %322 = llvm.getelementptr %321[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %323 = llvm.load %322 : !llvm.ptr -> i64
      %324 = builtin.unrealized_conversion_cast %323 : i64 to index
      %325 = arith.addi %arg12, %c1 : index
      %326 = builtin.unrealized_conversion_cast %325 : index to i64
      %327 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %328 = llvm.getelementptr %327[%326] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %329 = llvm.load %328 : !llvm.ptr -> i64
      %330 = builtin.unrealized_conversion_cast %329 : i64 to index
      omp.parallel   {
        omp.wsloop   for  (%arg13) : index = (%324) to (%330) step (%c1) {
          %331 = builtin.unrealized_conversion_cast %arg13 : index to i64
          %332 = llvm.extractvalue %165[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %333 = llvm.getelementptr %332[%331] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %334 = llvm.load %333 : !llvm.ptr -> i64
          %335 = builtin.unrealized_conversion_cast %334 : i64 to index
          omp.parallel   {
            omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
              %336 = arith.muli %arg13, %c32 : index
              %337 = arith.addi %336, %arg14 : index
              %338 = builtin.unrealized_conversion_cast %337 : index to i64
              %339 = arith.muli %335, %c32 : index
              %340 = arith.addi %339, %arg14 : index
              %341 = builtin.unrealized_conversion_cast %340 : index to i64
              %342 = arith.muli %320, %c32 : index
              %343 = arith.addi %342, %arg14 : index
              %344 = builtin.unrealized_conversion_cast %343 : index to i64
              %345 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %346 = llvm.load %345 : !llvm.ptr -> f32
              %347 = llvm.extractvalue %166[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
              %348 = llvm.getelementptr %347[%338] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %349 = llvm.load %348 : !llvm.ptr -> f32
              %350 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
              %351 = llvm.getelementptr %350[%341] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %352 = llvm.load %351 : !llvm.ptr -> f32
              %353 = arith.mulf %349, %352 : f32
              %354 = arith.addf %346, %353 : f32
              %355 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              llvm.store %354, %355 : f32, !llvm.ptr
              omp.yield
            }
            omp.terminator
          }
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %297, %307 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
  %c1 = arith.constant 1 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
  %4 = arith.cmpi ult, %2, %3 : index
  cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
^bb2(%5: index, %6: index):  // pred: ^bb1
  %7 = arith.addi %5, %6 : index
  %8 = arith.shrui %7, %c1 : index
  %9 = builtin.unrealized_conversion_cast %8 : index to i64
  %10 = arith.addi %8, %c1 : index
  %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %13 = llvm.load %12 : !llvm.ptr -> i64
  %14 = builtin.unrealized_conversion_cast %13 : i64 to index
  %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %17 = llvm.load %16 : !llvm.ptr -> i64
  %18 = builtin.unrealized_conversion_cast %17 : i64 to index
  %19 = arith.cmpi ult, %14, %18 : index
  %20 = arith.select %19, %5, %10 : index
  %21 = arith.select %19, %8, %6 : index
  cf.br ^bb1(%20, %21 : index, index)
^bb3:  // pred: ^bb1
  return %2 : index
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %1 = arith.addi %arg0, %c1 : index
  cf.br ^bb1(%1 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
  %3 = builtin.unrealized_conversion_cast %2 : index to i64
  %4 = arith.cmpi slt, %2, %arg1 : index
  cf.cond_br %4, ^bb2, ^bb6
^bb2:  // pred: ^bb1
  %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
  %6 = builtin.unrealized_conversion_cast %5 : index to i64
  %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %9 = llvm.load %8 : !llvm.ptr -> i64
  %10 = arith.subi %2, %5 : index
  cf.br ^bb3(%c0 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
  %12 = arith.cmpi slt, %11, %10 : index
  cf.cond_br %12, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %13 = arith.subi %2, %11 : index
  %14 = builtin.unrealized_conversion_cast %13 : index to i64
  %15 = arith.subi %13, %c1 : index
  %16 = builtin.unrealized_conversion_cast %15 : index to i64
  %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %19 = llvm.load %18 : !llvm.ptr -> i64
  %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %19, %21 : i64, !llvm.ptr
  %22 = arith.addi %11, %c1 : index
  cf.br ^bb3(%22 : index)
^bb5:  // pred: ^bb3
  %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %24 : i64, !llvm.ptr
  %25 = arith.addi %2, %c1 : index
  cf.br ^bb1(%25 : index)
^bb6:  // pred: ^bb1
  return
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
  %2 = arith.addi %0, %c1 : index
  %3 = arith.cmpi ult, %2, %1 : index
  cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
^bb2(%4: index, %5: index):  // pred: ^bb1
  %6 = arith.subi %5, %4 : index
  %7 = arith.cmpi ule, %6, %c30 : index
  cf.cond_br %7, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb13(%4, %4 : index, index)
^bb4:  // pred: ^bb2
  %8 = arith.subi %arg3, %c1_i64 : i64
  %9 = arith.cmpi ule, %8, %c0_i64 : i64
  cf.cond_br %9, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb11(%4, %4 : index, index)
^bb6:  // pred: ^bb4
  %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
  %11 = arith.addi %10, %c1 : index
  %12 = arith.subi %10, %4 : index
  %13 = arith.subi %5, %10 : index
  %14 = arith.cmpi ule, %12, %13 : index
  %15 = arith.select %14, %11, %4 : index
  %16 = arith.select %14, %5, %10 : index
  cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
  %20 = arith.cmpi ne, %17, %c0 : index
  cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
^bb8(%21: index, %22: index):  // pred: ^bb7
  call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb9
^bb9:  // 2 preds: ^bb7, ^bb8
  cf.br ^bb10
^bb10:  // pred: ^bb9
  cf.br ^bb11(%15, %16 : index, index)
^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
  cf.br ^bb12
^bb12:  // pred: ^bb11
  cf.br ^bb13(%23, %24 : index, index)
^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  cf.br ^bb1(%25, %26 : index, index)
^bb15:  // pred: ^bb1
  return
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %2 = arith.subi %arg1, %arg0 : index
  %3 = arith.subi %2, %c2 : index
  %4 = arith.shrui %3, %c1 : index
  %5 = arith.addi %4, %c1 : index
  cf.br ^bb1(%c0 : index)
^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
  %7 = arith.cmpi slt, %6, %5 : index
  cf.cond_br %7, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %8 = arith.subi %4, %6 : index
  %9 = arith.addi %arg0, %8 : index
  call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
  %10 = arith.addi %6, %c1 : index
  cf.br ^bb1(%10 : index)
^bb3:  // pred: ^bb1
  %11 = arith.subi %2, %c1 : index
  cf.br ^bb4(%c0 : index)
^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
  %13 = arith.cmpi slt, %12, %11 : index
  cf.cond_br %13, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %14 = arith.subi %2, %12 : index
  %15 = arith.addi %arg0, %14 : index
  %16 = arith.subi %15, %c1 : index
  %17 = builtin.unrealized_conversion_cast %16 : index to i64
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %23 = llvm.load %22 : !llvm.ptr -> i64
  %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %23, %25 : i64, !llvm.ptr
  %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %20, %27 : i64, !llvm.ptr
  %28 = arith.subi %14, %c1 : index
  call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
  %29 = arith.addi %12, %c1 : index
  cf.br ^bb4(%29 : index)
^bb6:  // pred: ^bb4
  return
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %1 = arith.cmpi uge, %arg3, %c2 : index
  cf.cond_br %1, ^bb1, ^bb16
^bb1:  // pred: ^bb0
  %2 = arith.subi %arg1, %arg0 : index
  %3 = arith.subi %arg3, %c2 : index
  %4 = arith.shrui %3, %c1 : index
  %5 = arith.cmpi uge, %4, %2 : index
  cf.cond_br %5, ^bb2, ^bb15
^bb2:  // pred: ^bb1
  %6 = arith.shli %2, %c1 : index
  %7 = arith.addi %6, %c1 : index
  %8 = arith.addi %7, %arg0 : index
  %9 = builtin.unrealized_conversion_cast %8 : index to i64
  %10 = arith.addi %6, %c2 : index
  %11 = arith.cmpi ult, %10, %arg3 : index
  cf.cond_br %11, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  %12 = arith.addi %10, %arg0 : index
  %13 = builtin.unrealized_conversion_cast %12 : index to i64
  %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %16 = llvm.load %15 : !llvm.ptr -> i64
  %17 = builtin.unrealized_conversion_cast %16 : i64 to index
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = builtin.unrealized_conversion_cast %20 : i64 to index
  %22 = arith.cmpi ult, %17, %21 : index
  %23 = arith.select %22, %10, %7 : index
  %24 = arith.select %22, %12, %8 : index
  cf.br ^bb5(%23, %24, %arg1 : index, index, index)
^bb4:  // pred: ^bb2
  cf.br ^bb5(%7, %8, %arg1 : index, index, index)
^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
  cf.br ^bb6(%27, %25, %26 : index, index, index)
^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
  cf.br ^bb7(%28, %29, %30 : index, index, index)
^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
  %34 = builtin.unrealized_conversion_cast %31 : index to i64
  %35 = builtin.unrealized_conversion_cast %33 : index to i64
  %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %38 = llvm.load %37 : !llvm.ptr -> i64
  %39 = builtin.unrealized_conversion_cast %38 : i64 to index
  %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %42 = llvm.load %41 : !llvm.ptr -> i64
  %43 = builtin.unrealized_conversion_cast %42 : i64 to index
  %44 = arith.cmpi ult, %39, %43 : index
  cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
  %48 = builtin.unrealized_conversion_cast %45 : index to i64
  %49 = builtin.unrealized_conversion_cast %47 : index to i64
  %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %52 = llvm.load %51 : !llvm.ptr -> i64
  %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %55 = llvm.load %54 : !llvm.ptr -> i64
  %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %55, %57 : i64, !llvm.ptr
  %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %52, %59 : i64, !llvm.ptr
  %60 = arith.cmpi uge, %4, %46 : index
  cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
^bb9:  // pred: ^bb8
  %61 = arith.shli %46, %c1 : index
  %62 = arith.addi %61, %c1 : index
  %63 = arith.addi %62, %arg0 : index
  %64 = builtin.unrealized_conversion_cast %63 : index to i64
  %65 = arith.addi %61, %c2 : index
  %66 = arith.cmpi ult, %65, %arg3 : index
  cf.cond_br %66, ^bb10, ^bb11
^bb10:  // pred: ^bb9
  %67 = arith.addi %65, %arg0 : index
  %68 = builtin.unrealized_conversion_cast %67 : index to i64
  %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %71 = llvm.load %70 : !llvm.ptr -> i64
  %72 = builtin.unrealized_conversion_cast %71 : i64 to index
  %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %75 = llvm.load %74 : !llvm.ptr -> i64
  %76 = builtin.unrealized_conversion_cast %75 : i64 to index
  %77 = arith.cmpi ult, %72, %76 : index
  %78 = arith.select %77, %65, %62 : index
  %79 = arith.select %77, %67, %63 : index
  cf.br ^bb12(%78, %79 : index, index)
^bb11:  // pred: ^bb9
  cf.br ^bb12(%62, %63 : index, index)
^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
  cf.br ^bb13(%80, %81 : index, index)
^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
  cf.br ^bb5(%82, %83, %47 : index, index, index)
^bb14:  // pred: ^bb7
  cf.br ^bb15
^bb15:  // 2 preds: ^bb1, ^bb14
  cf.br ^bb16
^bb16:  // 2 preds: ^bb0, ^bb15
  return
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
  %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
  %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c1 = arith.constant 1 : index
  %7 = builtin.unrealized_conversion_cast %c1 : index to i64
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %8 = builtin.unrealized_conversion_cast %c0 : index to i64
  %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %11 = llvm.load %10 : !llvm.ptr -> i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %15 = llvm.load %14 : !llvm.ptr -> i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %18 = arith.index_cast %17 : i64 to index
  %19 = arith.subi %16, %c1 : index
  %20 = builtin.unrealized_conversion_cast %19 : index to i64
  %21 = arith.cmpi ult, %12, %16 : index
  cf.cond_br %21, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %24 = llvm.load %23 : !llvm.ptr -> i64
  %25 = builtin.unrealized_conversion_cast %24 : i64 to index
  %26 = arith.cmpi eq, %25, %arg6 : index
  cf.br ^bb3(%26 : i1)
^bb2:  // pred: ^bb0
  cf.br ^bb3(%false : i1)
^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
  cf.br ^bb4
^bb4:  // pred: ^bb3
  %28 = arith.select %27, %19, %18 : index
  %29 = builtin.unrealized_conversion_cast %28 : index to i64
  cf.cond_br %27, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb6:  // pred: ^bb4
  %30 = arith.addi %18, %c1 : index
  %31 = builtin.unrealized_conversion_cast %30 : index to i64
  %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %31, %33 : i64, !llvm.ptr
  %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %35 = arith.index_cast %34 : i64 to index
  %36 = builtin.unrealized_conversion_cast %35 : index to i64
  %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = builtin.unrealized_conversion_cast %37 : i64 to index
  %39 = arith.addi %35, %c1 : index
  %40 = arith.cmpi ugt, %39, %38 : index
  cf.cond_br %40, ^bb7, ^bb10
^bb7:  // pred: ^bb6
  %41 = arith.muli %38, %c2 : index
  %42 = builtin.unrealized_conversion_cast %41 : index to i64
  %43 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %44 = builtin.unrealized_conversion_cast %41 : index to i64
  %45 = llvm.icmp "ugt" %44, %43 : i64
  llvm.cond_br %45, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb8:  // pred: ^bb7
  %46 = llvm.mlir.null : !llvm.ptr
  %47 = llvm.getelementptr %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
  %49 = llvm.mul %44, %48  : i64
  %50 = llvm.mul %43, %48  : i64
  %51 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
  %52 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%51, %52, %50) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %53 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%53) : (!llvm.ptr) -> ()
  %54 = llvm.insertvalue %51, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %55 = llvm.insertvalue %51, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb9(%55 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb9(%56: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
  %57 = llvm.insertvalue %44, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %58 = builtin.unrealized_conversion_cast %57 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb11(%58 : memref<?xindex>)
^bb10:  // pred: ^bb6
  cf.br ^bb11(%arg1 : memref<?xindex>)
^bb11(%59: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
  %60 = builtin.unrealized_conversion_cast %59 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb12
^bb12:  // pred: ^bb11
  %61 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %62 = llvm.getelementptr %61[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %5, %62 : i64, !llvm.ptr
  %63 = arith.index_cast %39 : index to i64
  %64 = llvm.insertvalue %63, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %65 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %66 = arith.index_cast %65 : i64 to index
  %67 = builtin.unrealized_conversion_cast %66 : index to i64
  %68 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %69 = builtin.unrealized_conversion_cast %68 : i64 to index
  %70 = arith.addi %66, %c1 : index
  %71 = arith.cmpi ugt, %70, %69 : index
  cf.cond_br %71, ^bb13, ^bb16
^bb13:  // pred: ^bb12
  %72 = arith.muli %69, %c2 : index
  %73 = builtin.unrealized_conversion_cast %72 : index to i64
  %74 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %75 = builtin.unrealized_conversion_cast %72 : index to i64
  %76 = llvm.icmp "ugt" %75, %74 : i64
  llvm.cond_br %76, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb14:  // pred: ^bb13
  %77 = llvm.mlir.null : !llvm.ptr
  %78 = llvm.getelementptr %77[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
  %80 = llvm.mul %75, %79  : i64
  %81 = llvm.mul %74, %79  : i64
  %82 = llvm.call @malloc(%80) : (i64) -> !llvm.ptr
  %83 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%82, %83, %81) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %84 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%84) : (!llvm.ptr) -> ()
  %85 = llvm.insertvalue %82, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %86 = llvm.insertvalue %82, %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb15(%86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb15(%87: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
  %88 = llvm.insertvalue %75, %87[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %89 = builtin.unrealized_conversion_cast %88 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb17(%89 : memref<?xindex>)
^bb16:  // pred: ^bb12
  cf.br ^bb17(%arg2 : memref<?xindex>)
^bb17(%90: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
  %91 = builtin.unrealized_conversion_cast %90 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb18
^bb18:  // pred: ^bb17
  %92 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %93 = llvm.getelementptr %92[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %8, %93 : i64, !llvm.ptr
  %94 = arith.index_cast %70 : index to i64
  %95 = llvm.insertvalue %94, %64[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb19(%59, %90, %95 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb19(%96: memref<?xindex>, %97: memref<?xindex>, %98: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
  %99 = builtin.unrealized_conversion_cast %97 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb20
^bb20:  // pred: ^bb19
  %100 = arith.addi %28, %c1 : index
  %101 = builtin.unrealized_conversion_cast %100 : index to i64
  %102 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %103 = llvm.getelementptr %102[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %104 = llvm.load %103 : !llvm.ptr -> i64
  %105 = builtin.unrealized_conversion_cast %104 : i64 to index
  %106 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.getelementptr %106[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %108 = llvm.load %107 : !llvm.ptr -> i64
  %109 = builtin.unrealized_conversion_cast %108 : i64 to index
  %110 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %111 = arith.index_cast %110 : i64 to index
  %112 = builtin.unrealized_conversion_cast %111 : index to i64
  %113 = arith.subi %109, %c1 : index
  %114 = builtin.unrealized_conversion_cast %113 : index to i64
  %115 = arith.cmpi ult, %105, %109 : index
  cf.cond_br %115, ^bb21, ^bb22
^bb21:  // pred: ^bb20
  %116 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %117 = llvm.getelementptr %116[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %118 = llvm.load %117 : !llvm.ptr -> i64
  %119 = builtin.unrealized_conversion_cast %118 : i64 to index
  %120 = arith.cmpi eq, %119, %arg7 : index
  cf.br ^bb23(%120 : i1)
^bb22:  // pred: ^bb20
  %121 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %122 = llvm.getelementptr %121[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %112, %122 : i64, !llvm.ptr
  cf.br ^bb23(%false : i1)
^bb23(%123: i1):  // 2 preds: ^bb21, ^bb22
  cf.br ^bb24
^bb24:  // pred: ^bb23
  %124 = arith.select %123, %113, %111 : index
  cf.cond_br %123, ^bb25, ^bb26
^bb25:  // pred: ^bb24
  cf.br ^bb44(%arg3, %arg4, %98 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb26:  // pred: ^bb24
  %125 = arith.addi %111, %c1 : index
  %126 = builtin.unrealized_conversion_cast %125 : index to i64
  %127 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %128 = llvm.getelementptr %127[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %126, %128 : i64, !llvm.ptr
  %129 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %130 = arith.index_cast %129 : i64 to index
  %131 = builtin.unrealized_conversion_cast %130 : index to i64
  %132 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %133 = builtin.unrealized_conversion_cast %132 : i64 to index
  %134 = arith.addi %130, %c1 : index
  %135 = arith.cmpi ugt, %134, %133 : index
  cf.cond_br %135, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %136 = arith.muli %133, %c2 : index
  %137 = builtin.unrealized_conversion_cast %136 : index to i64
  %138 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %139 = builtin.unrealized_conversion_cast %136 : index to i64
  %140 = llvm.icmp "ugt" %139, %138 : i64
  llvm.cond_br %140, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb28:  // pred: ^bb27
  %141 = llvm.mlir.null : !llvm.ptr
  %142 = llvm.getelementptr %141[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %143 = llvm.ptrtoint %142 : !llvm.ptr to i64
  %144 = llvm.mul %139, %143  : i64
  %145 = llvm.mul %138, %143  : i64
  %146 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
  %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%146, %147, %145) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %148 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%148) : (!llvm.ptr) -> ()
  %149 = llvm.insertvalue %146, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %150 = llvm.insertvalue %146, %149[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb29(%150 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb29(%151: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
  %152 = llvm.insertvalue %139, %151[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %153 = builtin.unrealized_conversion_cast %152 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb31(%153 : memref<?xindex>)
^bb30:  // pred: ^bb26
  cf.br ^bb31(%arg3 : memref<?xindex>)
^bb31(%154: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
  %155 = builtin.unrealized_conversion_cast %154 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb32
^bb32:  // pred: ^bb31
  %156 = llvm.extractvalue %155[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %157 = llvm.getelementptr %156[%131] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %3, %157 : i64, !llvm.ptr
  %158 = arith.index_cast %134 : index to i64
  %159 = llvm.insertvalue %158, %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %160 = llvm.extractvalue %98[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %161 = arith.index_cast %160 : i64 to index
  %162 = builtin.unrealized_conversion_cast %161 : index to i64
  %163 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %164 = builtin.unrealized_conversion_cast %163 : i64 to index
  %165 = arith.addi %161, %c32 : index
  %166 = arith.cmpi ugt, %165, %164 : index
  cf.cond_br %166, ^bb33, ^bb38
^bb33:  // pred: ^bb32
  cf.br ^bb34(%164 : index)
^bb34(%167: index):  // 2 preds: ^bb33, ^bb34
  %168 = arith.muli %167, %c2 : index
  %169 = builtin.unrealized_conversion_cast %168 : index to i64
  %170 = arith.cmpi ugt, %165, %168 : index
  cf.cond_br %170, ^bb34(%168 : index), ^bb35
^bb35:  // pred: ^bb34
  %171 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %172 = builtin.unrealized_conversion_cast %168 : index to i64
  %173 = llvm.icmp "ugt" %172, %171 : i64
  llvm.cond_br %173, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb36:  // pred: ^bb35
  %174 = llvm.mlir.null : !llvm.ptr
  %175 = llvm.getelementptr %174[1] : (!llvm.ptr) -> !llvm.ptr, f32
  %176 = llvm.ptrtoint %175 : !llvm.ptr to i64
  %177 = llvm.mul %172, %176  : i64
  %178 = llvm.mul %171, %176  : i64
  %179 = llvm.call @malloc(%177) : (i64) -> !llvm.ptr
  %180 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%179, %180, %178) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %181 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%181) : (!llvm.ptr) -> ()
  %182 = llvm.insertvalue %179, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %183 = llvm.insertvalue %179, %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb37(%183 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb37(%184: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
  %185 = llvm.insertvalue %172, %184[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %186 = builtin.unrealized_conversion_cast %185 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  cf.br ^bb39(%186 : memref<?xf32>)
^bb38:  // pred: ^bb32
  cf.br ^bb39(%arg4 : memref<?xf32>)
^bb39(%187: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
  %188 = builtin.unrealized_conversion_cast %187 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb40
^bb40:  // pred: ^bb39
  %189 = llvm.extractvalue %188[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %190 = llvm.extractvalue %188[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %191 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
  %192 = llvm.insertvalue %189, %191[0] : !llvm.struct<(ptr, ptr, i64)> 
  %193 = llvm.insertvalue %190, %192[1] : !llvm.struct<(ptr, ptr, i64)> 
  %194 = llvm.mlir.constant(0 : index) : i64
  %195 = llvm.insertvalue %194, %193[2] : !llvm.struct<(ptr, ptr, i64)> 
  %196 = llvm.extractvalue %188[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %197 = llvm.extractvalue %188[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %198 = llvm.extractvalue %188[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %199 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %200 = llvm.insertvalue %189, %199[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %201 = llvm.insertvalue %190, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.insertvalue %162, %201[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %203 = llvm.mlir.constant(32 : index) : i64
  %204 = llvm.insertvalue %203, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %205 = llvm.mlir.constant(1 : index) : i64
  %206 = llvm.insertvalue %205, %204[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  cf.br ^bb41(%c0 : index)
^bb41(%207: index):  // 2 preds: ^bb40, ^bb42
  %208 = builtin.unrealized_conversion_cast %207 : index to i64
  %209 = arith.cmpi slt, %207, %c32 : index
  cf.cond_br %209, ^bb42, ^bb43
^bb42:  // pred: ^bb41
  %210 = llvm.getelementptr %190[%162] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %211 = llvm.getelementptr %210[%208] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %211 : f32, !llvm.ptr
  %212 = arith.addi %207, %c1 : index
  cf.br ^bb41(%212 : index)
^bb43:  // pred: ^bb41
  %213 = arith.index_cast %165 : index to i64
  %214 = llvm.insertvalue %213, %159[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb44(%154, %187, %214 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb44(%215: memref<?xindex>, %216: memref<?xf32>, %217: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
  %218 = builtin.unrealized_conversion_cast %216 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb45
^bb45:  // pred: ^bb44
  %219 = arith.muli %124, %c32 : index
  %220 = arith.addi %219, %arg8 : index
  %221 = builtin.unrealized_conversion_cast %220 : index to i64
  %222 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %223 = llvm.getelementptr %222[%221] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %arg9, %223 : f32, !llvm.ptr
  return %arg0, %96, %97, %215, %216, %217 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %2 = arith.addi %arg0, %arg1 : index
  %3 = arith.shrui %2, %c1 : index
  %4 = builtin.unrealized_conversion_cast %3 : index to i64
  %5 = arith.subi %arg1, %c1 : index
  %6 = builtin.unrealized_conversion_cast %5 : index to i64
  %7 = arith.subi %arg1, %arg0 : index
  %8 = arith.cmpi ult, %7, %c1000 : index
  cf.cond_br %8, ^bb1, ^bb8
^bb1:  // pred: ^bb0
  %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %11 = llvm.load %10 : !llvm.ptr -> i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %15 = llvm.load %14 : !llvm.ptr -> i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = arith.cmpi ult, %12, %16 : index
  cf.cond_br %17, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %23 = llvm.load %22 : !llvm.ptr -> i64
  %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %23, %25 : i64, !llvm.ptr
  %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %20, %27 : i64, !llvm.ptr
  cf.br ^bb3
^bb3:  // 2 preds: ^bb1, ^bb2
  %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %30 = llvm.load %29 : !llvm.ptr -> i64
  %31 = builtin.unrealized_conversion_cast %30 : i64 to index
  %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %34 = llvm.load %33 : !llvm.ptr -> i64
  %35 = builtin.unrealized_conversion_cast %34 : i64 to index
  %36 = arith.cmpi ult, %31, %35 : index
  cf.cond_br %36, ^bb4, ^bb7
^bb4:  // pred: ^bb3
  %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %39 = llvm.load %38 : !llvm.ptr -> i64
  %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %42 = llvm.load %41 : !llvm.ptr -> i64
  %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %42, %44 : i64, !llvm.ptr
  %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %39, %46 : i64, !llvm.ptr
  %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %49 = llvm.load %48 : !llvm.ptr -> i64
  %50 = builtin.unrealized_conversion_cast %49 : i64 to index
  %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %53 = llvm.load %52 : !llvm.ptr -> i64
  %54 = builtin.unrealized_conversion_cast %53 : i64 to index
  %55 = arith.cmpi ult, %50, %54 : index
  cf.cond_br %55, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %58 = llvm.load %57 : !llvm.ptr -> i64
  %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %61 = llvm.load %60 : !llvm.ptr -> i64
  %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %61, %63 : i64, !llvm.ptr
  %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %58, %65 : i64, !llvm.ptr
  cf.br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
  cf.br ^bb7
^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
  cf.br ^bb27(%arg0, %5, %3 : index, index, index)
^bb8:  // pred: ^bb0
  %66 = arith.addi %arg0, %arg1 : index
  %67 = arith.shrui %66, %c1 : index
  %68 = builtin.unrealized_conversion_cast %67 : index to i64
  %69 = arith.addi %3, %arg1 : index
  %70 = arith.shrui %69, %c1 : index
  %71 = builtin.unrealized_conversion_cast %70 : index to i64
  %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %74 = llvm.load %73 : !llvm.ptr -> i64
  %75 = builtin.unrealized_conversion_cast %74 : i64 to index
  %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %78 = llvm.load %77 : !llvm.ptr -> i64
  %79 = builtin.unrealized_conversion_cast %78 : i64 to index
  %80 = arith.cmpi ult, %75, %79 : index
  cf.cond_br %80, ^bb9, ^bb10
^bb9:  // pred: ^bb8
  %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %83 = llvm.load %82 : !llvm.ptr -> i64
  %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %86 = llvm.load %85 : !llvm.ptr -> i64
  %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %86, %88 : i64, !llvm.ptr
  %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %83, %90 : i64, !llvm.ptr
  cf.br ^bb10
^bb10:  // 2 preds: ^bb8, ^bb9
  %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %93 = llvm.load %92 : !llvm.ptr -> i64
  %94 = builtin.unrealized_conversion_cast %93 : i64 to index
  %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %97 = llvm.load %96 : !llvm.ptr -> i64
  %98 = builtin.unrealized_conversion_cast %97 : i64 to index
  %99 = arith.cmpi ult, %94, %98 : index
  cf.cond_br %99, ^bb11, ^bb14
^bb11:  // pred: ^bb10
  %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %102 = llvm.load %101 : !llvm.ptr -> i64
  %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %105 = llvm.load %104 : !llvm.ptr -> i64
  %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %105, %107 : i64, !llvm.ptr
  %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %102, %109 : i64, !llvm.ptr
  %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %112 = llvm.load %111 : !llvm.ptr -> i64
  %113 = builtin.unrealized_conversion_cast %112 : i64 to index
  %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %116 = llvm.load %115 : !llvm.ptr -> i64
  %117 = builtin.unrealized_conversion_cast %116 : i64 to index
  %118 = arith.cmpi ult, %113, %117 : index
  cf.cond_br %118, ^bb12, ^bb13
^bb12:  // pred: ^bb11
  %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %121 = llvm.load %120 : !llvm.ptr -> i64
  %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %124 = llvm.load %123 : !llvm.ptr -> i64
  %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %124, %126 : i64, !llvm.ptr
  %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %121, %128 : i64, !llvm.ptr
  cf.br ^bb13
^bb13:  // 2 preds: ^bb11, ^bb12
  cf.br ^bb14
^bb14:  // 2 preds: ^bb10, ^bb13
  %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %131 = llvm.load %130 : !llvm.ptr -> i64
  %132 = builtin.unrealized_conversion_cast %131 : i64 to index
  %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %135 = llvm.load %134 : !llvm.ptr -> i64
  %136 = builtin.unrealized_conversion_cast %135 : i64 to index
  %137 = arith.cmpi ult, %132, %136 : index
  cf.cond_br %137, ^bb15, ^bb20
^bb15:  // pred: ^bb14
  %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %140 = llvm.load %139 : !llvm.ptr -> i64
  %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %143 = llvm.load %142 : !llvm.ptr -> i64
  %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %143, %145 : i64, !llvm.ptr
  %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %140, %147 : i64, !llvm.ptr
  %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %150 = llvm.load %149 : !llvm.ptr -> i64
  %151 = builtin.unrealized_conversion_cast %150 : i64 to index
  %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %154 = llvm.load %153 : !llvm.ptr -> i64
  %155 = builtin.unrealized_conversion_cast %154 : i64 to index
  %156 = arith.cmpi ult, %151, %155 : index
  cf.cond_br %156, ^bb16, ^bb19
^bb16:  // pred: ^bb15
  %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %159 = llvm.load %158 : !llvm.ptr -> i64
  %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %162 = llvm.load %161 : !llvm.ptr -> i64
  %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %162, %164 : i64, !llvm.ptr
  %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %159, %166 : i64, !llvm.ptr
  %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %169 = llvm.load %168 : !llvm.ptr -> i64
  %170 = builtin.unrealized_conversion_cast %169 : i64 to index
  %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %173 = llvm.load %172 : !llvm.ptr -> i64
  %174 = builtin.unrealized_conversion_cast %173 : i64 to index
  %175 = arith.cmpi ult, %170, %174 : index
  cf.cond_br %175, ^bb17, ^bb18
^bb17:  // pred: ^bb16
  %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %178 = llvm.load %177 : !llvm.ptr -> i64
  %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %181 = llvm.load %180 : !llvm.ptr -> i64
  %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %181, %183 : i64, !llvm.ptr
  %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %178, %185 : i64, !llvm.ptr
  cf.br ^bb18
^bb18:  // 2 preds: ^bb16, ^bb17
  cf.br ^bb19
^bb19:  // 2 preds: ^bb15, ^bb18
  cf.br ^bb20
^bb20:  // 2 preds: ^bb14, ^bb19
  %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %188 = llvm.load %187 : !llvm.ptr -> i64
  %189 = builtin.unrealized_conversion_cast %188 : i64 to index
  %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %192 = llvm.load %191 : !llvm.ptr -> i64
  %193 = builtin.unrealized_conversion_cast %192 : i64 to index
  %194 = arith.cmpi ult, %189, %193 : index
  cf.cond_br %194, ^bb21, ^bb7
^bb21:  // pred: ^bb20
  %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %197 = llvm.load %196 : !llvm.ptr -> i64
  %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %200 = llvm.load %199 : !llvm.ptr -> i64
  %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %200, %202 : i64, !llvm.ptr
  %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %197, %204 : i64, !llvm.ptr
  %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %207 = llvm.load %206 : !llvm.ptr -> i64
  %208 = builtin.unrealized_conversion_cast %207 : i64 to index
  %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %211 = llvm.load %210 : !llvm.ptr -> i64
  %212 = builtin.unrealized_conversion_cast %211 : i64 to index
  %213 = arith.cmpi ult, %208, %212 : index
  cf.cond_br %213, ^bb22, ^bb6
^bb22:  // pred: ^bb21
  %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %216 = llvm.load %215 : !llvm.ptr -> i64
  %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %219 = llvm.load %218 : !llvm.ptr -> i64
  %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %219, %221 : i64, !llvm.ptr
  %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %216, %223 : i64, !llvm.ptr
  %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %226 = llvm.load %225 : !llvm.ptr -> i64
  %227 = builtin.unrealized_conversion_cast %226 : i64 to index
  %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %230 = llvm.load %229 : !llvm.ptr -> i64
  %231 = builtin.unrealized_conversion_cast %230 : i64 to index
  %232 = arith.cmpi ult, %227, %231 : index
  cf.cond_br %232, ^bb23, ^bb26
^bb23:  // pred: ^bb22
  %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %235 = llvm.load %234 : !llvm.ptr -> i64
  %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %238 = llvm.load %237 : !llvm.ptr -> i64
  %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %238, %240 : i64, !llvm.ptr
  %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %235, %242 : i64, !llvm.ptr
  %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %245 = llvm.load %244 : !llvm.ptr -> i64
  %246 = builtin.unrealized_conversion_cast %245 : i64 to index
  %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %249 = llvm.load %248 : !llvm.ptr -> i64
  %250 = builtin.unrealized_conversion_cast %249 : i64 to index
  %251 = arith.cmpi ult, %246, %250 : index
  cf.cond_br %251, ^bb24, ^bb25
^bb24:  // pred: ^bb23
  %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %254 = llvm.load %253 : !llvm.ptr -> i64
  %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %257 = llvm.load %256 : !llvm.ptr -> i64
  %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %257, %259 : i64, !llvm.ptr
  %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %254, %261 : i64, !llvm.ptr
  cf.br ^bb25
^bb25:  // 2 preds: ^bb23, ^bb24
  cf.br ^bb26
^bb26:  // 2 preds: ^bb22, ^bb25
  cf.br ^bb6
^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
  cf.br ^bb28(%262, %263, %264 : index, index, index)
^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
  %268 = arith.cmpi ult, %265, %266 : index
  cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
  %272 = builtin.unrealized_conversion_cast %271 : index to i64
  cf.br ^bb30(%269 : index)
^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
  %274 = builtin.unrealized_conversion_cast %273 : index to i64
  %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %277 = llvm.load %276 : !llvm.ptr -> i64
  %278 = builtin.unrealized_conversion_cast %277 : i64 to index
  %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %281 = llvm.load %280 : !llvm.ptr -> i64
  %282 = builtin.unrealized_conversion_cast %281 : i64 to index
  %283 = arith.cmpi ult, %278, %282 : index
  cf.cond_br %283, ^bb31(%273 : index), ^bb32
^bb31(%284: index):  // pred: ^bb30
  %285 = arith.addi %284, %c1 : index
  cf.br ^bb30(%285 : index)
^bb32:  // pred: ^bb30
  %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %288 = llvm.load %287 : !llvm.ptr -> i64
  %289 = builtin.unrealized_conversion_cast %288 : i64 to index
  %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %292 = llvm.load %291 : !llvm.ptr -> i64
  %293 = builtin.unrealized_conversion_cast %292 : i64 to index
  %294 = arith.cmpi eq, %289, %293 : index
  cf.br ^bb33(%270 : index)
^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
  %296 = builtin.unrealized_conversion_cast %295 : index to i64
  %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %299 = llvm.load %298 : !llvm.ptr -> i64
  %300 = builtin.unrealized_conversion_cast %299 : i64 to index
  %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %303 = llvm.load %302 : !llvm.ptr -> i64
  %304 = builtin.unrealized_conversion_cast %303 : i64 to index
  %305 = arith.cmpi ult, %300, %304 : index
  cf.cond_br %305, ^bb34(%295 : index), ^bb35
^bb34(%306: index):  // pred: ^bb33
  %307 = arith.addi %306, %c-1 : index
  cf.br ^bb33(%307 : index)
^bb35:  // pred: ^bb33
  %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %310 = llvm.load %309 : !llvm.ptr -> i64
  %311 = builtin.unrealized_conversion_cast %310 : i64 to index
  %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %314 = llvm.load %313 : !llvm.ptr -> i64
  %315 = builtin.unrealized_conversion_cast %314 : i64 to index
  %316 = arith.cmpi eq, %311, %315 : index
  %317 = arith.cmpi ult, %273, %295 : index
  cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
^bb36:  // pred: ^bb35
  %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %320 = llvm.load %319 : !llvm.ptr -> i64
  %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %323 = llvm.load %322 : !llvm.ptr -> i64
  %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %323, %325 : i64, !llvm.ptr
  %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %320, %327 : i64, !llvm.ptr
  %328 = arith.cmpi eq, %273, %271 : index
  cf.cond_br %328, ^bb37, ^bb38
^bb37:  // pred: ^bb36
  cf.br ^bb39(%295 : index)
^bb38:  // pred: ^bb36
  %329 = arith.cmpi eq, %295, %271 : index
  %330 = arith.select %329, %273, %271 : index
  cf.br ^bb39(%330 : index)
^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
  cf.br ^bb40
^bb40:  // pred: ^bb39
  %332 = arith.andi %294, %316 : i1
  cf.cond_br %332, ^bb41, ^bb42
^bb41:  // pred: ^bb40
  %333 = arith.addi %273, %c1 : index
  %334 = arith.subi %295, %c1 : index
  cf.br ^bb43(%333, %334 : index, index)
^bb42:  // pred: ^bb40
  cf.br ^bb43(%273, %295 : index, index)
^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
  cf.br ^bb44(%335, %336, %331 : index, index, index)
^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
  cf.br ^bb45(%337, %338, %339 : index, index, index)
^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
  cf.br ^bb27(%340, %341, %342 : index, index, index)
^bb46:  // pred: ^bb28
  return %267 : index
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %6 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %7 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %8 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %9 = builtin.unrealized_conversion_cast %c0 : index to i64
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %10 = builtin.unrealized_conversion_cast %c1 : index to i64
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %11 = llvm.mlir.constant(16 : index) : i64
  %12 = llvm.mlir.constant(1 : index) : i64
  %13 = llvm.mlir.null : !llvm.ptr
  %14 = llvm.getelementptr %13[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
  %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
  %17 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %20 = llvm.mlir.constant(0 : index) : i64
  %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %11, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %12, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %24 = builtin.unrealized_conversion_cast %23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %25 = llvm.mlir.constant(16 : index) : i64
  %26 = llvm.mlir.constant(1 : index) : i64
  %27 = llvm.mlir.null : !llvm.ptr
  %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
  %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
  %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %34 = llvm.mlir.constant(0 : index) : i64
  %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %36 = llvm.insertvalue %25, %35[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %37 = llvm.insertvalue %26, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = builtin.unrealized_conversion_cast %37 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %39 = llvm.mlir.constant(16 : index) : i64
  %40 = llvm.mlir.constant(1 : index) : i64
  %41 = llvm.mlir.null : !llvm.ptr
  %42 = llvm.getelementptr %41[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %43 = llvm.ptrtoint %42 : !llvm.ptr to i64
  %44 = llvm.call @malloc(%43) : (i64) -> !llvm.ptr
  %45 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %48 = llvm.mlir.constant(0 : index) : i64
  %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %50 = llvm.insertvalue %39, %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %51 = llvm.insertvalue %40, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = builtin.unrealized_conversion_cast %51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %53 = llvm.mlir.constant(16 : index) : i64
  %54 = llvm.mlir.constant(1 : index) : i64
  %55 = llvm.mlir.null : !llvm.ptr
  %56 = llvm.getelementptr %55[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %57 = llvm.ptrtoint %56 : !llvm.ptr to i64
  %58 = llvm.call @malloc(%57) : (i64) -> !llvm.ptr
  %59 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %62 = llvm.mlir.constant(0 : index) : i64
  %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %64 = llvm.insertvalue %53, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %65 = llvm.insertvalue %54, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %66 = builtin.unrealized_conversion_cast %65 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %67 = llvm.mlir.constant(16 : index) : i64
  %68 = llvm.mlir.constant(1 : index) : i64
  %69 = llvm.mlir.null : !llvm.ptr
  %70 = llvm.getelementptr %69[16] : (!llvm.ptr) -> !llvm.ptr, f32
  %71 = llvm.ptrtoint %70 : !llvm.ptr to i64
  %72 = llvm.call @malloc(%71) : (i64) -> !llvm.ptr
  %73 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %76 = llvm.mlir.constant(0 : index) : i64
  %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %78 = llvm.insertvalue %67, %77[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %79 = llvm.insertvalue %68, %78[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %80 = builtin.unrealized_conversion_cast %79 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %81 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %82 = llvm.insertvalue %c0_i64, %81[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %83 = llvm.insertvalue %c0_i64, %82[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %84 = llvm.insertvalue %c0_i64, %83[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %85 = llvm.insertvalue %c0_i64, %84[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %86 = llvm.insertvalue %c0_i64, %85[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %87 = llvm.insertvalue %c128_i64, %86[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %88 = llvm.getelementptr %16[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %88 : i64, !llvm.ptr
  %89 = llvm.insertvalue %c1_i64, %87[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %90 = llvm.insertvalue %c128_i64, %89[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %91 = llvm.getelementptr %44[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %91 : i64, !llvm.ptr
  %92 = llvm.insertvalue %c1_i64, %90[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %93 = llvm.insertvalue %c32_i64, %92[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %94 = llvm.getelementptr %16[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %94 : i64, !llvm.ptr
  %95 = llvm.insertvalue %c2_i64, %93[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %96 = llvm.mlir.constant(32 : index) : i64
  %97 = llvm.mlir.constant(1 : index) : i64
  %98 = llvm.mlir.null : !llvm.ptr
  %99 = llvm.getelementptr %98[32] : (!llvm.ptr) -> !llvm.ptr, f32
  %100 = llvm.ptrtoint %99 : !llvm.ptr to i64
  %101 = llvm.call @malloc(%100) : (i64) -> !llvm.ptr
  %102 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %103 = llvm.insertvalue %101, %102[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %104 = llvm.insertvalue %101, %103[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %105 = llvm.mlir.constant(0 : index) : i64
  %106 = llvm.insertvalue %105, %104[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.insertvalue %96, %106[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %108 = llvm.insertvalue %97, %107[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %109 = llvm.mlir.constant(32 : index) : i64
  %110 = llvm.mlir.constant(1 : index) : i64
  %111 = llvm.mlir.null : !llvm.ptr
  %112 = llvm.getelementptr %111[32] : (!llvm.ptr) -> !llvm.ptr, i1
  %113 = llvm.ptrtoint %112 : !llvm.ptr to i64
  %114 = llvm.call @malloc(%113) : (i64) -> !llvm.ptr
  %115 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %116 = llvm.insertvalue %114, %115[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %117 = llvm.insertvalue %114, %116[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %118 = llvm.mlir.constant(0 : index) : i64
  %119 = llvm.insertvalue %118, %117[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %120 = llvm.insertvalue %109, %119[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %121 = llvm.insertvalue %110, %120[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %122 = llvm.mlir.constant(32 : index) : i64
  %123 = llvm.mlir.constant(1 : index) : i64
  %124 = llvm.mlir.null : !llvm.ptr
  %125 = llvm.getelementptr %124[32] : (!llvm.ptr) -> !llvm.ptr, i64
  %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
  %127 = llvm.call @malloc(%126) : (i64) -> !llvm.ptr
  %128 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %129 = llvm.insertvalue %127, %128[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %130 = llvm.insertvalue %127, %129[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %131 = llvm.mlir.constant(0 : index) : i64
  %132 = llvm.insertvalue %131, %130[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %133 = llvm.insertvalue %122, %132[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %134 = llvm.insertvalue %123, %133[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %135 = builtin.unrealized_conversion_cast %134 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb1(%c0 : index)
^bb1(%136: index):  // 2 preds: ^bb0, ^bb2
  %137 = builtin.unrealized_conversion_cast %136 : index to i64
  %138 = arith.cmpi slt, %136, %c32 : index
  cf.cond_br %138, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %139 = llvm.getelementptr %101[%137] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %139 : f32, !llvm.ptr
  %140 = arith.addi %136, %c1 : index
  cf.br ^bb1(%140 : index)
^bb3:  // pred: ^bb1
  cf.br ^bb4(%c0 : index)
^bb4(%141: index):  // 2 preds: ^bb3, ^bb5
  %142 = builtin.unrealized_conversion_cast %141 : index to i64
  %143 = arith.cmpi slt, %141, %c32 : index
  cf.cond_br %143, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %144 = llvm.getelementptr %114[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %false, %144 : i1, !llvm.ptr
  %145 = arith.addi %141, %c1 : index
  cf.br ^bb4(%145 : index)
^bb6:  // pred: ^bb4
  %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %147 = llvm.getelementptr %146[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %148 = llvm.load %147 : !llvm.ptr -> i64
  %149 = builtin.unrealized_conversion_cast %148 : i64 to index
  %150 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %151 = llvm.getelementptr %150[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %152 = llvm.load %151 : !llvm.ptr -> i64
  %153 = builtin.unrealized_conversion_cast %152 : i64 to index
  cf.br ^bb7(%149, %24, %38, %52, %66, %80, %95 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb7(%154: index, %155: memref<?xindex>, %156: memref<?xindex>, %157: memref<?xindex>, %158: memref<?xindex>, %159: memref<?xf32>, %160: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
  %161 = builtin.unrealized_conversion_cast %154 : index to i64
  %162 = builtin.unrealized_conversion_cast %157 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %163 = builtin.unrealized_conversion_cast %155 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %164 = builtin.unrealized_conversion_cast %156 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %165 = builtin.unrealized_conversion_cast %158 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %166 = builtin.unrealized_conversion_cast %159 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %167 = arith.cmpi slt, %154, %153 : index
  cf.cond_br %167, ^bb8, ^bb25
^bb8:  // pred: ^bb7
  %168 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %169 = llvm.getelementptr %168[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %170 = llvm.load %169 : !llvm.ptr -> i64
  %171 = builtin.unrealized_conversion_cast %170 : i64 to index
  %172 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %173 = llvm.getelementptr %172[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %174 = llvm.load %173 : !llvm.ptr -> i64
  %175 = builtin.unrealized_conversion_cast %174 : i64 to index
  %176 = arith.addi %154, %c1 : index
  %177 = builtin.unrealized_conversion_cast %176 : index to i64
  %178 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %179 = llvm.getelementptr %178[%177] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %180 = llvm.load %179 : !llvm.ptr -> i64
  %181 = builtin.unrealized_conversion_cast %180 : i64 to index
  cf.br ^bb9(%175, %155, %156, %157, %158, %159, %160 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb9(%182: index, %183: memref<?xindex>, %184: memref<?xindex>, %185: memref<?xindex>, %186: memref<?xindex>, %187: memref<?xf32>, %188: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
  %189 = builtin.unrealized_conversion_cast %182 : index to i64
  %190 = arith.cmpi slt, %182, %181 : index
  cf.cond_br %190, ^bb10, ^bb24
^bb10:  // pred: ^bb9
  %191 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %192 = llvm.getelementptr %191[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %193 = llvm.load %192 : !llvm.ptr -> i64
  %194 = builtin.unrealized_conversion_cast %193 : i64 to index
  %195 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %196 = llvm.getelementptr %195[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %197 = llvm.load %196 : !llvm.ptr -> i64
  %198 = builtin.unrealized_conversion_cast %197 : i64 to index
  %199 = arith.addi %182, %c1 : index
  %200 = builtin.unrealized_conversion_cast %199 : index to i64
  %201 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %203 = llvm.load %202 : !llvm.ptr -> i64
  %204 = builtin.unrealized_conversion_cast %203 : i64 to index
  cf.br ^bb11(%198, %c0 : index, index)
^bb11(%205: index, %206: index):  // 2 preds: ^bb10, ^bb19
  %207 = builtin.unrealized_conversion_cast %205 : index to i64
  %208 = arith.cmpi slt, %205, %204 : index
  cf.cond_br %208, ^bb12, ^bb20
^bb12:  // pred: ^bb11
  %209 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %210 = llvm.getelementptr %209[%207] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %211 = llvm.load %210 : !llvm.ptr -> i64
  %212 = builtin.unrealized_conversion_cast %211 : i64 to index
  %213 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %214 = llvm.getelementptr %213[%207] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %215 = llvm.load %214 : !llvm.ptr -> f32
  cf.br ^bb13(%c0, %206 : index, index)
^bb13(%216: index, %217: index):  // 2 preds: ^bb12, ^bb18
  %218 = builtin.unrealized_conversion_cast %216 : index to i64
  %219 = builtin.unrealized_conversion_cast %217 : index to i64
  %220 = arith.cmpi slt, %216, %c32 : index
  cf.cond_br %220, ^bb14, ^bb19
^bb14:  // pred: ^bb13
  %221 = arith.muli %212, %c32 : index
  %222 = arith.addi %221, %216 : index
  %223 = builtin.unrealized_conversion_cast %222 : index to i64
  %224 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %225 = llvm.load %224 : !llvm.ptr -> f32
  %226 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %227 = llvm.getelementptr %226[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %228 = llvm.load %227 : !llvm.ptr -> f32
  %229 = arith.mulf %215, %228 : f32
  %230 = arith.addf %225, %229 : f32
  %231 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  %232 = llvm.load %231 : !llvm.ptr -> i1
  %233 = arith.cmpi eq, %232, %false : i1
  cf.cond_br %233, ^bb15, ^bb16
^bb15:  // pred: ^bb14
  %234 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %true, %234 : i1, !llvm.ptr
  %235 = llvm.getelementptr %127[%219] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %218, %235 : i64, !llvm.ptr
  %236 = arith.addi %217, %c1 : index
  cf.br ^bb17(%236 : index)
^bb16:  // pred: ^bb14
  cf.br ^bb17(%217 : index)
^bb17(%237: index):  // 2 preds: ^bb15, ^bb16
  cf.br ^bb18
^bb18:  // pred: ^bb17
  %238 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %230, %238 : f32, !llvm.ptr
  %239 = arith.addi %216, %c1 : index
  cf.br ^bb13(%239, %237 : index, index)
^bb19:  // pred: ^bb13
  %240 = arith.addi %205, %c1 : index
  cf.br ^bb11(%240, %217 : index, index)
^bb20:  // pred: ^bb11
  %241 = arith.index_cast %206 : index to i64
  %242 = math.ctlz %241 : i64
  %243 = arith.subi %c64_i64, %242 : i64
  call @_sparse_hybrid_qsort_1_index(%c0, %206, %135, %243) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb21(%c0, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb21(%244: index, %245: memref<?xindex>, %246: memref<?xindex>, %247: memref<?xindex>, %248: memref<?xindex>, %249: memref<?xf32>, %250: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
  %251 = builtin.unrealized_conversion_cast %244 : index to i64
  %252 = arith.cmpi slt, %244, %206 : index
  cf.cond_br %252, ^bb22, ^bb23
^bb22:  // pred: ^bb21
  %253 = llvm.getelementptr %127[%251] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %254 = llvm.load %253 : !llvm.ptr -> i64
  %255 = builtin.unrealized_conversion_cast %254 : i64 to index
  %256 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %257 = llvm.load %256 : !llvm.ptr -> f32
  %258:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%245, %246, %247, %248, %249, %250, %171, %194, %255, %257) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  %259 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %259 : f32, !llvm.ptr
  %260 = llvm.getelementptr %114[%254] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %false, %260 : i1, !llvm.ptr
  %261 = arith.addi %244, %c1 : index
  cf.br ^bb21(%261, %258#0, %258#1, %258#2, %258#3, %258#4, %258#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb23:  // pred: ^bb21
  %262 = arith.addi %182, %c1 : index
  cf.br ^bb9(%262, %245, %246, %247, %248, %249, %250 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb24:  // pred: ^bb9
  %263 = arith.addi %154, %c1 : index
  cf.br ^bb7(%263, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb25:  // pred: ^bb7
  llvm.call @free(%101) : (!llvm.ptr) -> ()
  llvm.call @free(%114) : (!llvm.ptr) -> ()
  llvm.call @free(%127) : (!llvm.ptr) -> ()
  %264 = llvm.extractvalue %160[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %265 = arith.index_cast %264 : i64 to index
  %266 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %267 = llvm.getelementptr %266[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %268 = llvm.load %267 : !llvm.ptr -> i64
  %269 = builtin.unrealized_conversion_cast %268 : i64 to index
  cf.br ^bb26(%c1, %269 : index, index)
^bb26(%270: index, %271: index):  // 2 preds: ^bb25, ^bb29
  %272 = builtin.unrealized_conversion_cast %270 : index to i64
  %273 = builtin.unrealized_conversion_cast %271 : index to i64
  %274 = arith.cmpi slt, %270, %265 : index
  cf.cond_br %274, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %275 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %276 = llvm.getelementptr %275[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %277 = llvm.load %276 : !llvm.ptr -> i64
  %278 = builtin.unrealized_conversion_cast %277 : i64 to index
  %279 = arith.cmpi eq, %278, %c0 : index
  %280 = arith.select %279, %271, %278 : index
  cf.cond_br %279, ^bb28, ^bb29
^bb28:  // pred: ^bb27
  %281 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %282 = llvm.getelementptr %281[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %273, %282 : i64, !llvm.ptr
  cf.br ^bb29
^bb29:  // 2 preds: ^bb27, ^bb28
  %283 = arith.addi %270, %c1 : index
  cf.br ^bb26(%283, %280 : index, index)
^bb30:  // pred: ^bb26
  %284 = llvm.mlir.constant(4096 : index) : i64
  %285 = llvm.mlir.constant(1 : index) : i64
  %286 = llvm.mlir.null : !llvm.ptr
  %287 = llvm.getelementptr %286[4096] : (!llvm.ptr) -> !llvm.ptr, f32
  %288 = llvm.ptrtoint %287 : !llvm.ptr to i64
  %289 = llvm.call @malloc(%288) : (i64) -> !llvm.ptr
  %290 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %291 = llvm.insertvalue %289, %290[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %292 = llvm.insertvalue %289, %291[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %293 = llvm.mlir.constant(0 : index) : i64
  %294 = llvm.insertvalue %293, %292[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %295 = llvm.insertvalue %284, %294[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %296 = llvm.insertvalue %285, %295[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %297 = builtin.unrealized_conversion_cast %296 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %298 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %299 = llvm.insertvalue %c0_i64, %298[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %300 = llvm.insertvalue %c128_i64, %299[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %301 = llvm.insertvalue %c32_i64, %300[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb31(%c0 : index)
^bb31(%302: index):  // 2 preds: ^bb30, ^bb32
  %303 = builtin.unrealized_conversion_cast %302 : index to i64
  %304 = arith.cmpi slt, %302, %c4096 : index
  cf.cond_br %304, ^bb32, ^bb33
^bb32:  // pred: ^bb31
  %305 = llvm.getelementptr %289[%303] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %305 : f32, !llvm.ptr
  %306 = arith.addi %302, %c1 : index
  cf.br ^bb31(%306 : index)
^bb33:  // pred: ^bb31
  %307 = llvm.insertvalue %c4096_i64, %301[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %308 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %309 = llvm.getelementptr %308[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %310 = llvm.load %309 : !llvm.ptr -> i64
  %311 = builtin.unrealized_conversion_cast %310 : i64 to index
  %312 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %313 = llvm.getelementptr %312[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %314 = llvm.load %313 : !llvm.ptr -> i64
  %315 = builtin.unrealized_conversion_cast %314 : i64 to index
  omp.parallel   {
    omp.wsloop   for  (%arg12) : index = (%311) to (%315) step (%c1) {
      %316 = builtin.unrealized_conversion_cast %arg12 : index to i64
      %317 = llvm.extractvalue %164[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %318 = llvm.getelementptr %317[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %319 = llvm.load %318 : !llvm.ptr -> i64
      %320 = builtin.unrealized_conversion_cast %319 : i64 to index
      %321 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %322 = llvm.getelementptr %321[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %323 = llvm.load %322 : !llvm.ptr -> i64
      %324 = builtin.unrealized_conversion_cast %323 : i64 to index
      %325 = arith.addi %arg12, %c1 : index
      %326 = builtin.unrealized_conversion_cast %325 : index to i64
      %327 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %328 = llvm.getelementptr %327[%326] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %329 = llvm.load %328 : !llvm.ptr -> i64
      %330 = builtin.unrealized_conversion_cast %329 : i64 to index
      omp.parallel   {
        omp.wsloop   for  (%arg13) : index = (%324) to (%330) step (%c1) {
          %331 = builtin.unrealized_conversion_cast %arg13 : index to i64
          %332 = llvm.extractvalue %165[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %333 = llvm.getelementptr %332[%331] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %334 = llvm.load %333 : !llvm.ptr -> i64
          %335 = builtin.unrealized_conversion_cast %334 : i64 to index
          omp.parallel   {
            omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
              %336 = arith.muli %arg13, %c32 : index
              %337 = arith.addi %336, %arg14 : index
              %338 = builtin.unrealized_conversion_cast %337 : index to i64
              %339 = arith.muli %335, %c32 : index
              %340 = arith.addi %339, %arg14 : index
              %341 = builtin.unrealized_conversion_cast %340 : index to i64
              %342 = arith.muli %320, %c32 : index
              %343 = arith.addi %342, %arg14 : index
              %344 = builtin.unrealized_conversion_cast %343 : index to i64
              %345 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %346 = llvm.load %345 : !llvm.ptr -> f32
              %347 = llvm.extractvalue %166[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
              %348 = llvm.getelementptr %347[%338] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %349 = llvm.load %348 : !llvm.ptr -> f32
              %350 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
              %351 = llvm.getelementptr %350[%341] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %352 = llvm.load %351 : !llvm.ptr -> f32
              %353 = arith.mulf %349, %352 : f32
              %354 = arith.addf %346, %353 : f32
              %355 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              llvm.store %354, %355 : f32, !llvm.ptr
              omp.yield
            }
            omp.terminator
          }
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %297, %307 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
  %c1 = arith.constant 1 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
  %4 = arith.cmpi ult, %2, %3 : index
  cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
^bb2(%5: index, %6: index):  // pred: ^bb1
  %7 = arith.addi %5, %6 : index
  %8 = arith.shrui %7, %c1 : index
  %9 = builtin.unrealized_conversion_cast %8 : index to i64
  %10 = arith.addi %8, %c1 : index
  %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %13 = llvm.load %12 : !llvm.ptr -> i64
  %14 = builtin.unrealized_conversion_cast %13 : i64 to index
  %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %17 = llvm.load %16 : !llvm.ptr -> i64
  %18 = builtin.unrealized_conversion_cast %17 : i64 to index
  %19 = arith.cmpi ult, %14, %18 : index
  %20 = arith.select %19, %5, %10 : index
  %21 = arith.select %19, %8, %6 : index
  cf.br ^bb1(%20, %21 : index, index)
^bb3:  // pred: ^bb1
  return %2 : index
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %1 = arith.addi %arg0, %c1 : index
  cf.br ^bb1(%1 : index)
^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
  %3 = builtin.unrealized_conversion_cast %2 : index to i64
  %4 = arith.cmpi slt, %2, %arg1 : index
  cf.cond_br %4, ^bb2, ^bb6
^bb2:  // pred: ^bb1
  %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
  %6 = builtin.unrealized_conversion_cast %5 : index to i64
  %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %9 = llvm.load %8 : !llvm.ptr -> i64
  %10 = arith.subi %2, %5 : index
  cf.br ^bb3(%c0 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
  %12 = arith.cmpi slt, %11, %10 : index
  cf.cond_br %12, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  %13 = arith.subi %2, %11 : index
  %14 = builtin.unrealized_conversion_cast %13 : index to i64
  %15 = arith.subi %13, %c1 : index
  %16 = builtin.unrealized_conversion_cast %15 : index to i64
  %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %19 = llvm.load %18 : !llvm.ptr -> i64
  %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %19, %21 : i64, !llvm.ptr
  %22 = arith.addi %11, %c1 : index
  cf.br ^bb3(%22 : index)
^bb5:  // pred: ^bb3
  %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %24 : i64, !llvm.ptr
  %25 = arith.addi %2, %c1 : index
  cf.br ^bb1(%25 : index)
^bb6:  // pred: ^bb1
  return
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
  %c30 = arith.constant 30 : index
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  cf.br ^bb1(%arg0, %arg1 : index, index)
^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
  %2 = arith.addi %0, %c1 : index
  %3 = arith.cmpi ult, %2, %1 : index
  cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
^bb2(%4: index, %5: index):  // pred: ^bb1
  %6 = arith.subi %5, %4 : index
  %7 = arith.cmpi ule, %6, %c30 : index
  cf.cond_br %7, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb13(%4, %4 : index, index)
^bb4:  // pred: ^bb2
  %8 = arith.subi %arg3, %c1_i64 : i64
  %9 = arith.cmpi ule, %8, %c0_i64 : i64
  cf.cond_br %9, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
  cf.br ^bb11(%4, %4 : index, index)
^bb6:  // pred: ^bb4
  %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
  %11 = arith.addi %10, %c1 : index
  %12 = arith.subi %10, %4 : index
  %13 = arith.subi %5, %10 : index
  %14 = arith.cmpi ule, %12, %13 : index
  %15 = arith.select %14, %11, %4 : index
  %16 = arith.select %14, %5, %10 : index
  cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
  %20 = arith.cmpi ne, %17, %c0 : index
  cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
^bb8(%21: index, %22: index):  // pred: ^bb7
  call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb9
^bb9:  // 2 preds: ^bb7, ^bb8
  cf.br ^bb10
^bb10:  // pred: ^bb9
  cf.br ^bb11(%15, %16 : index, index)
^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
  cf.br ^bb12
^bb12:  // pred: ^bb11
  cf.br ^bb13(%23, %24 : index, index)
^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  cf.br ^bb1(%25, %26 : index, index)
^bb15:  // pred: ^bb1
  return
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %2 = arith.subi %arg1, %arg0 : index
  %3 = arith.subi %2, %c2 : index
  %4 = arith.shrui %3, %c1 : index
  %5 = arith.addi %4, %c1 : index
  cf.br ^bb1(%c0 : index)
^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
  %7 = arith.cmpi slt, %6, %5 : index
  cf.cond_br %7, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %8 = arith.subi %4, %6 : index
  %9 = arith.addi %arg0, %8 : index
  call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
  %10 = arith.addi %6, %c1 : index
  cf.br ^bb1(%10 : index)
^bb3:  // pred: ^bb1
  %11 = arith.subi %2, %c1 : index
  cf.br ^bb4(%c0 : index)
^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
  %13 = arith.cmpi slt, %12, %11 : index
  cf.cond_br %13, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %14 = arith.subi %2, %12 : index
  %15 = arith.addi %arg0, %14 : index
  %16 = arith.subi %15, %c1 : index
  %17 = builtin.unrealized_conversion_cast %16 : index to i64
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %23 = llvm.load %22 : !llvm.ptr -> i64
  %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %23, %25 : i64, !llvm.ptr
  %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %20, %27 : i64, !llvm.ptr
  %28 = arith.subi %14, %c1 : index
  call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
  %29 = arith.addi %12, %c1 : index
  cf.br ^bb4(%29 : index)
^bb6:  // pred: ^bb4
  return
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %1 = arith.cmpi uge, %arg3, %c2 : index
  cf.cond_br %1, ^bb1, ^bb16
^bb1:  // pred: ^bb0
  %2 = arith.subi %arg1, %arg0 : index
  %3 = arith.subi %arg3, %c2 : index
  %4 = arith.shrui %3, %c1 : index
  %5 = arith.cmpi uge, %4, %2 : index
  cf.cond_br %5, ^bb2, ^bb15
^bb2:  // pred: ^bb1
  %6 = arith.shli %2, %c1 : index
  %7 = arith.addi %6, %c1 : index
  %8 = arith.addi %7, %arg0 : index
  %9 = builtin.unrealized_conversion_cast %8 : index to i64
  %10 = arith.addi %6, %c2 : index
  %11 = arith.cmpi ult, %10, %arg3 : index
  cf.cond_br %11, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  %12 = arith.addi %10, %arg0 : index
  %13 = builtin.unrealized_conversion_cast %12 : index to i64
  %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %16 = llvm.load %15 : !llvm.ptr -> i64
  %17 = builtin.unrealized_conversion_cast %16 : i64 to index
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = builtin.unrealized_conversion_cast %20 : i64 to index
  %22 = arith.cmpi ult, %17, %21 : index
  %23 = arith.select %22, %10, %7 : index
  %24 = arith.select %22, %12, %8 : index
  cf.br ^bb5(%23, %24, %arg1 : index, index, index)
^bb4:  // pred: ^bb2
  cf.br ^bb5(%7, %8, %arg1 : index, index, index)
^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
  cf.br ^bb6(%27, %25, %26 : index, index, index)
^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
  cf.br ^bb7(%28, %29, %30 : index, index, index)
^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
  %34 = builtin.unrealized_conversion_cast %31 : index to i64
  %35 = builtin.unrealized_conversion_cast %33 : index to i64
  %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %38 = llvm.load %37 : !llvm.ptr -> i64
  %39 = builtin.unrealized_conversion_cast %38 : i64 to index
  %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %42 = llvm.load %41 : !llvm.ptr -> i64
  %43 = builtin.unrealized_conversion_cast %42 : i64 to index
  %44 = arith.cmpi ult, %39, %43 : index
  cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
  %48 = builtin.unrealized_conversion_cast %45 : index to i64
  %49 = builtin.unrealized_conversion_cast %47 : index to i64
  %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %52 = llvm.load %51 : !llvm.ptr -> i64
  %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %55 = llvm.load %54 : !llvm.ptr -> i64
  %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %55, %57 : i64, !llvm.ptr
  %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %52, %59 : i64, !llvm.ptr
  %60 = arith.cmpi uge, %4, %46 : index
  cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
^bb9:  // pred: ^bb8
  %61 = arith.shli %46, %c1 : index
  %62 = arith.addi %61, %c1 : index
  %63 = arith.addi %62, %arg0 : index
  %64 = builtin.unrealized_conversion_cast %63 : index to i64
  %65 = arith.addi %61, %c2 : index
  %66 = arith.cmpi ult, %65, %arg3 : index
  cf.cond_br %66, ^bb10, ^bb11
^bb10:  // pred: ^bb9
  %67 = arith.addi %65, %arg0 : index
  %68 = builtin.unrealized_conversion_cast %67 : index to i64
  %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %71 = llvm.load %70 : !llvm.ptr -> i64
  %72 = builtin.unrealized_conversion_cast %71 : i64 to index
  %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %75 = llvm.load %74 : !llvm.ptr -> i64
  %76 = builtin.unrealized_conversion_cast %75 : i64 to index
  %77 = arith.cmpi ult, %72, %76 : index
  %78 = arith.select %77, %65, %62 : index
  %79 = arith.select %77, %67, %63 : index
  cf.br ^bb12(%78, %79 : index, index)
^bb11:  // pred: ^bb9
  cf.br ^bb12(%62, %63 : index, index)
^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
  cf.br ^bb13(%80, %81 : index, index)
^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
  cf.br ^bb5(%82, %83, %47 : index, index, index)
^bb14:  // pred: ^bb7
  cf.br ^bb15
^bb15:  // 2 preds: ^bb1, ^bb14
  cf.br ^bb16
^bb16:  // 2 preds: ^bb0, ^bb15
  return
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
  %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
  %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c1 = arith.constant 1 : index
  %7 = builtin.unrealized_conversion_cast %c1 : index to i64
  %c2 = arith.constant 2 : index
  %cst = arith.constant 0.000000e+00 : f32
  %c32 = arith.constant 32 : index
  %false = arith.constant false
  %c0 = arith.constant 0 : index
  %8 = builtin.unrealized_conversion_cast %c0 : index to i64
  %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %11 = llvm.load %10 : !llvm.ptr -> i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %15 = llvm.load %14 : !llvm.ptr -> i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %18 = arith.index_cast %17 : i64 to index
  %19 = arith.subi %16, %c1 : index
  %20 = builtin.unrealized_conversion_cast %19 : index to i64
  %21 = arith.cmpi ult, %12, %16 : index
  cf.cond_br %21, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %24 = llvm.load %23 : !llvm.ptr -> i64
  %25 = builtin.unrealized_conversion_cast %24 : i64 to index
  %26 = arith.cmpi eq, %25, %arg6 : index
  cf.br ^bb3(%26 : i1)
^bb2:  // pred: ^bb0
  cf.br ^bb3(%false : i1)
^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
  cf.br ^bb4
^bb4:  // pred: ^bb3
  %28 = arith.select %27, %19, %18 : index
  %29 = builtin.unrealized_conversion_cast %28 : index to i64
  cf.cond_br %27, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb6:  // pred: ^bb4
  %30 = arith.addi %18, %c1 : index
  %31 = builtin.unrealized_conversion_cast %30 : index to i64
  %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %31, %33 : i64, !llvm.ptr
  %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %35 = arith.index_cast %34 : i64 to index
  %36 = builtin.unrealized_conversion_cast %35 : index to i64
  %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = builtin.unrealized_conversion_cast %37 : i64 to index
  %39 = arith.addi %35, %c1 : index
  %40 = arith.cmpi ugt, %39, %38 : index
  cf.cond_br %40, ^bb7, ^bb10
^bb7:  // pred: ^bb6
  %41 = arith.muli %38, %c2 : index
  %42 = builtin.unrealized_conversion_cast %41 : index to i64
  %43 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %44 = builtin.unrealized_conversion_cast %41 : index to i64
  %45 = llvm.icmp "ugt" %44, %43 : i64
  llvm.cond_br %45, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb8:  // pred: ^bb7
  %46 = llvm.mlir.null : !llvm.ptr
  %47 = llvm.getelementptr %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
  %49 = llvm.mul %44, %48  : i64
  %50 = llvm.mul %43, %48  : i64
  %51 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
  %52 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%51, %52, %50) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %53 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%53) : (!llvm.ptr) -> ()
  %54 = llvm.insertvalue %51, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %55 = llvm.insertvalue %51, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb9(%55 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb9(%56: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
  %57 = llvm.insertvalue %44, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %58 = builtin.unrealized_conversion_cast %57 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb11(%58 : memref<?xindex>)
^bb10:  // pred: ^bb6
  cf.br ^bb11(%arg1 : memref<?xindex>)
^bb11(%59: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
  %60 = builtin.unrealized_conversion_cast %59 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb12
^bb12:  // pred: ^bb11
  %61 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %62 = llvm.getelementptr %61[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %5, %62 : i64, !llvm.ptr
  %63 = arith.index_cast %39 : index to i64
  %64 = llvm.insertvalue %63, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %65 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %66 = arith.index_cast %65 : i64 to index
  %67 = builtin.unrealized_conversion_cast %66 : index to i64
  %68 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %69 = builtin.unrealized_conversion_cast %68 : i64 to index
  %70 = arith.addi %66, %c1 : index
  %71 = arith.cmpi ugt, %70, %69 : index
  cf.cond_br %71, ^bb13, ^bb16
^bb13:  // pred: ^bb12
  %72 = arith.muli %69, %c2 : index
  %73 = builtin.unrealized_conversion_cast %72 : index to i64
  %74 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %75 = builtin.unrealized_conversion_cast %72 : index to i64
  %76 = llvm.icmp "ugt" %75, %74 : i64
  llvm.cond_br %76, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb14:  // pred: ^bb13
  %77 = llvm.mlir.null : !llvm.ptr
  %78 = llvm.getelementptr %77[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
  %80 = llvm.mul %75, %79  : i64
  %81 = llvm.mul %74, %79  : i64
  %82 = llvm.call @malloc(%80) : (i64) -> !llvm.ptr
  %83 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%82, %83, %81) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %84 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%84) : (!llvm.ptr) -> ()
  %85 = llvm.insertvalue %82, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %86 = llvm.insertvalue %82, %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb15(%86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb15(%87: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
  %88 = llvm.insertvalue %75, %87[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %89 = builtin.unrealized_conversion_cast %88 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb17(%89 : memref<?xindex>)
^bb16:  // pred: ^bb12
  cf.br ^bb17(%arg2 : memref<?xindex>)
^bb17(%90: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
  %91 = builtin.unrealized_conversion_cast %90 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb18
^bb18:  // pred: ^bb17
  %92 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %93 = llvm.getelementptr %92[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %8, %93 : i64, !llvm.ptr
  %94 = arith.index_cast %70 : index to i64
  %95 = llvm.insertvalue %94, %64[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb19(%59, %90, %95 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb19(%96: memref<?xindex>, %97: memref<?xindex>, %98: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
  %99 = builtin.unrealized_conversion_cast %97 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb20
^bb20:  // pred: ^bb19
  %100 = arith.addi %28, %c1 : index
  %101 = builtin.unrealized_conversion_cast %100 : index to i64
  %102 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %103 = llvm.getelementptr %102[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %104 = llvm.load %103 : !llvm.ptr -> i64
  %105 = builtin.unrealized_conversion_cast %104 : i64 to index
  %106 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.getelementptr %106[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %108 = llvm.load %107 : !llvm.ptr -> i64
  %109 = builtin.unrealized_conversion_cast %108 : i64 to index
  %110 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %111 = arith.index_cast %110 : i64 to index
  %112 = builtin.unrealized_conversion_cast %111 : index to i64
  %113 = arith.subi %109, %c1 : index
  %114 = builtin.unrealized_conversion_cast %113 : index to i64
  %115 = arith.cmpi ult, %105, %109 : index
  cf.cond_br %115, ^bb21, ^bb22
^bb21:  // pred: ^bb20
  %116 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %117 = llvm.getelementptr %116[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %118 = llvm.load %117 : !llvm.ptr -> i64
  %119 = builtin.unrealized_conversion_cast %118 : i64 to index
  %120 = arith.cmpi eq, %119, %arg7 : index
  cf.br ^bb23(%120 : i1)
^bb22:  // pred: ^bb20
  %121 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %122 = llvm.getelementptr %121[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %112, %122 : i64, !llvm.ptr
  cf.br ^bb23(%false : i1)
^bb23(%123: i1):  // 2 preds: ^bb21, ^bb22
  cf.br ^bb24
^bb24:  // pred: ^bb23
  %124 = arith.select %123, %113, %111 : index
  cf.cond_br %123, ^bb25, ^bb26
^bb25:  // pred: ^bb24
  cf.br ^bb44(%arg3, %arg4, %98 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb26:  // pred: ^bb24
  %125 = arith.addi %111, %c1 : index
  %126 = builtin.unrealized_conversion_cast %125 : index to i64
  %127 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %128 = llvm.getelementptr %127[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %126, %128 : i64, !llvm.ptr
  %129 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %130 = arith.index_cast %129 : i64 to index
  %131 = builtin.unrealized_conversion_cast %130 : index to i64
  %132 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %133 = builtin.unrealized_conversion_cast %132 : i64 to index
  %134 = arith.addi %130, %c1 : index
  %135 = arith.cmpi ugt, %134, %133 : index
  cf.cond_br %135, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %136 = arith.muli %133, %c2 : index
  %137 = builtin.unrealized_conversion_cast %136 : index to i64
  %138 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %139 = builtin.unrealized_conversion_cast %136 : index to i64
  %140 = llvm.icmp "ugt" %139, %138 : i64
  llvm.cond_br %140, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb28:  // pred: ^bb27
  %141 = llvm.mlir.null : !llvm.ptr
  %142 = llvm.getelementptr %141[1] : (!llvm.ptr) -> !llvm.ptr, i64
  %143 = llvm.ptrtoint %142 : !llvm.ptr to i64
  %144 = llvm.mul %139, %143  : i64
  %145 = llvm.mul %138, %143  : i64
  %146 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
  %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%146, %147, %145) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %148 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%148) : (!llvm.ptr) -> ()
  %149 = llvm.insertvalue %146, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %150 = llvm.insertvalue %146, %149[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb29(%150 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb29(%151: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
  %152 = llvm.insertvalue %139, %151[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %153 = builtin.unrealized_conversion_cast %152 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb31(%153 : memref<?xindex>)
^bb30:  // pred: ^bb26
  cf.br ^bb31(%arg3 : memref<?xindex>)
^bb31(%154: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
  %155 = builtin.unrealized_conversion_cast %154 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb32
^bb32:  // pred: ^bb31
  %156 = llvm.extractvalue %155[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %157 = llvm.getelementptr %156[%131] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %3, %157 : i64, !llvm.ptr
  %158 = arith.index_cast %134 : index to i64
  %159 = llvm.insertvalue %158, %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %160 = llvm.extractvalue %98[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %161 = arith.index_cast %160 : i64 to index
  %162 = builtin.unrealized_conversion_cast %161 : index to i64
  %163 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %164 = builtin.unrealized_conversion_cast %163 : i64 to index
  %165 = arith.addi %161, %c32 : index
  %166 = arith.cmpi ugt, %165, %164 : index
  cf.cond_br %166, ^bb33, ^bb38
^bb33:  // pred: ^bb32
  cf.br ^bb34(%164 : index)
^bb34(%167: index):  // 2 preds: ^bb33, ^bb34
  %168 = arith.muli %167, %c2 : index
  %169 = builtin.unrealized_conversion_cast %168 : index to i64
  %170 = arith.cmpi ugt, %165, %168 : index
  cf.cond_br %170, ^bb34(%168 : index), ^bb35
^bb35:  // pred: ^bb34
  %171 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %172 = builtin.unrealized_conversion_cast %168 : index to i64
  %173 = llvm.icmp "ugt" %172, %171 : i64
  llvm.cond_br %173, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb36:  // pred: ^bb35
  %174 = llvm.mlir.null : !llvm.ptr
  %175 = llvm.getelementptr %174[1] : (!llvm.ptr) -> !llvm.ptr, f32
  %176 = llvm.ptrtoint %175 : !llvm.ptr to i64
  %177 = llvm.mul %172, %176  : i64
  %178 = llvm.mul %171, %176  : i64
  %179 = llvm.call @malloc(%177) : (i64) -> !llvm.ptr
  %180 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  "llvm.intr.memcpy"(%179, %180, %178) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
  %181 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.call @free(%181) : (!llvm.ptr) -> ()
  %182 = llvm.insertvalue %179, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %183 = llvm.insertvalue %179, %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  llvm.br ^bb37(%183 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
^bb37(%184: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
  %185 = llvm.insertvalue %172, %184[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %186 = builtin.unrealized_conversion_cast %185 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  cf.br ^bb39(%186 : memref<?xf32>)
^bb38:  // pred: ^bb32
  cf.br ^bb39(%arg4 : memref<?xf32>)
^bb39(%187: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
  %188 = builtin.unrealized_conversion_cast %187 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb40
^bb40:  // pred: ^bb39
  %189 = llvm.extractvalue %188[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %190 = llvm.extractvalue %188[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %191 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
  %192 = llvm.insertvalue %189, %191[0] : !llvm.struct<(ptr, ptr, i64)> 
  %193 = llvm.insertvalue %190, %192[1] : !llvm.struct<(ptr, ptr, i64)> 
  %194 = llvm.mlir.constant(0 : index) : i64
  %195 = llvm.insertvalue %194, %193[2] : !llvm.struct<(ptr, ptr, i64)> 
  %196 = llvm.extractvalue %188[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %197 = llvm.extractvalue %188[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %198 = llvm.extractvalue %188[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %199 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %200 = llvm.insertvalue %189, %199[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %201 = llvm.insertvalue %190, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.insertvalue %162, %201[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %203 = llvm.mlir.constant(32 : index) : i64
  %204 = llvm.insertvalue %203, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %205 = llvm.mlir.constant(1 : index) : i64
  %206 = llvm.insertvalue %205, %204[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  cf.br ^bb41(%c0 : index)
^bb41(%207: index):  // 2 preds: ^bb40, ^bb42
  %208 = builtin.unrealized_conversion_cast %207 : index to i64
  %209 = arith.cmpi slt, %207, %c32 : index
  cf.cond_br %209, ^bb42, ^bb43
^bb42:  // pred: ^bb41
  %210 = llvm.getelementptr %190[%162] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %211 = llvm.getelementptr %210[%208] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %211 : f32, !llvm.ptr
  %212 = arith.addi %207, %c1 : index
  cf.br ^bb41(%212 : index)
^bb43:  // pred: ^bb41
  %213 = arith.index_cast %165 : index to i64
  %214 = llvm.insertvalue %213, %159[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  cf.br ^bb44(%154, %187, %214 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb44(%215: memref<?xindex>, %216: memref<?xf32>, %217: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
  %218 = builtin.unrealized_conversion_cast %216 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  cf.br ^bb45
^bb45:  // pred: ^bb44
  %219 = arith.muli %124, %c32 : index
  %220 = arith.addi %219, %arg8 : index
  %221 = builtin.unrealized_conversion_cast %220 : index to i64
  %222 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %223 = llvm.getelementptr %222[%221] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %arg9, %223 : f32, !llvm.ptr
  return %arg0, %96, %97, %215, %216, %217 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
  %c1 = arith.constant 1 : index
  %c1000 = arith.constant 1000 : index
  %c-1 = arith.constant -1 : index
  %2 = arith.addi %arg0, %arg1 : index
  %3 = arith.shrui %2, %c1 : index
  %4 = builtin.unrealized_conversion_cast %3 : index to i64
  %5 = arith.subi %arg1, %c1 : index
  %6 = builtin.unrealized_conversion_cast %5 : index to i64
  %7 = arith.subi %arg1, %arg0 : index
  %8 = arith.cmpi ult, %7, %c1000 : index
  cf.cond_br %8, ^bb1, ^bb8
^bb1:  // pred: ^bb0
  %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %11 = llvm.load %10 : !llvm.ptr -> i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %15 = llvm.load %14 : !llvm.ptr -> i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = arith.cmpi ult, %12, %16 : index
  cf.cond_br %17, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %20 = llvm.load %19 : !llvm.ptr -> i64
  %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %23 = llvm.load %22 : !llvm.ptr -> i64
  %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %23, %25 : i64, !llvm.ptr
  %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %20, %27 : i64, !llvm.ptr
  cf.br ^bb3
^bb3:  // 2 preds: ^bb1, ^bb2
  %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %30 = llvm.load %29 : !llvm.ptr -> i64
  %31 = builtin.unrealized_conversion_cast %30 : i64 to index
  %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %34 = llvm.load %33 : !llvm.ptr -> i64
  %35 = builtin.unrealized_conversion_cast %34 : i64 to index
  %36 = arith.cmpi ult, %31, %35 : index
  cf.cond_br %36, ^bb4, ^bb7
^bb4:  // pred: ^bb3
  %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %39 = llvm.load %38 : !llvm.ptr -> i64
  %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %42 = llvm.load %41 : !llvm.ptr -> i64
  %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %42, %44 : i64, !llvm.ptr
  %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %39, %46 : i64, !llvm.ptr
  %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %49 = llvm.load %48 : !llvm.ptr -> i64
  %50 = builtin.unrealized_conversion_cast %49 : i64 to index
  %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %53 = llvm.load %52 : !llvm.ptr -> i64
  %54 = builtin.unrealized_conversion_cast %53 : i64 to index
  %55 = arith.cmpi ult, %50, %54 : index
  cf.cond_br %55, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %58 = llvm.load %57 : !llvm.ptr -> i64
  %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %61 = llvm.load %60 : !llvm.ptr -> i64
  %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %61, %63 : i64, !llvm.ptr
  %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %58, %65 : i64, !llvm.ptr
  cf.br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
  cf.br ^bb7
^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
  cf.br ^bb27(%arg0, %5, %3 : index, index, index)
^bb8:  // pred: ^bb0
  %66 = arith.addi %arg0, %arg1 : index
  %67 = arith.shrui %66, %c1 : index
  %68 = builtin.unrealized_conversion_cast %67 : index to i64
  %69 = arith.addi %3, %arg1 : index
  %70 = arith.shrui %69, %c1 : index
  %71 = builtin.unrealized_conversion_cast %70 : index to i64
  %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %74 = llvm.load %73 : !llvm.ptr -> i64
  %75 = builtin.unrealized_conversion_cast %74 : i64 to index
  %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %78 = llvm.load %77 : !llvm.ptr -> i64
  %79 = builtin.unrealized_conversion_cast %78 : i64 to index
  %80 = arith.cmpi ult, %75, %79 : index
  cf.cond_br %80, ^bb9, ^bb10
^bb9:  // pred: ^bb8
  %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %83 = llvm.load %82 : !llvm.ptr -> i64
  %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %86 = llvm.load %85 : !llvm.ptr -> i64
  %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %86, %88 : i64, !llvm.ptr
  %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %83, %90 : i64, !llvm.ptr
  cf.br ^bb10
^bb10:  // 2 preds: ^bb8, ^bb9
  %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %93 = llvm.load %92 : !llvm.ptr -> i64
  %94 = builtin.unrealized_conversion_cast %93 : i64 to index
  %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %97 = llvm.load %96 : !llvm.ptr -> i64
  %98 = builtin.unrealized_conversion_cast %97 : i64 to index
  %99 = arith.cmpi ult, %94, %98 : index
  cf.cond_br %99, ^bb11, ^bb14
^bb11:  // pred: ^bb10
  %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %102 = llvm.load %101 : !llvm.ptr -> i64
  %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %105 = llvm.load %104 : !llvm.ptr -> i64
  %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %105, %107 : i64, !llvm.ptr
  %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %102, %109 : i64, !llvm.ptr
  %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %112 = llvm.load %111 : !llvm.ptr -> i64
  %113 = builtin.unrealized_conversion_cast %112 : i64 to index
  %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %116 = llvm.load %115 : !llvm.ptr -> i64
  %117 = builtin.unrealized_conversion_cast %116 : i64 to index
  %118 = arith.cmpi ult, %113, %117 : index
  cf.cond_br %118, ^bb12, ^bb13
^bb12:  // pred: ^bb11
  %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %121 = llvm.load %120 : !llvm.ptr -> i64
  %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %124 = llvm.load %123 : !llvm.ptr -> i64
  %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %124, %126 : i64, !llvm.ptr
  %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %121, %128 : i64, !llvm.ptr
  cf.br ^bb13
^bb13:  // 2 preds: ^bb11, ^bb12
  cf.br ^bb14
^bb14:  // 2 preds: ^bb10, ^bb13
  %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %131 = llvm.load %130 : !llvm.ptr -> i64
  %132 = builtin.unrealized_conversion_cast %131 : i64 to index
  %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %135 = llvm.load %134 : !llvm.ptr -> i64
  %136 = builtin.unrealized_conversion_cast %135 : i64 to index
  %137 = arith.cmpi ult, %132, %136 : index
  cf.cond_br %137, ^bb15, ^bb20
^bb15:  // pred: ^bb14
  %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %140 = llvm.load %139 : !llvm.ptr -> i64
  %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %143 = llvm.load %142 : !llvm.ptr -> i64
  %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %143, %145 : i64, !llvm.ptr
  %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %140, %147 : i64, !llvm.ptr
  %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %150 = llvm.load %149 : !llvm.ptr -> i64
  %151 = builtin.unrealized_conversion_cast %150 : i64 to index
  %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %154 = llvm.load %153 : !llvm.ptr -> i64
  %155 = builtin.unrealized_conversion_cast %154 : i64 to index
  %156 = arith.cmpi ult, %151, %155 : index
  cf.cond_br %156, ^bb16, ^bb19
^bb16:  // pred: ^bb15
  %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %159 = llvm.load %158 : !llvm.ptr -> i64
  %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %162 = llvm.load %161 : !llvm.ptr -> i64
  %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %162, %164 : i64, !llvm.ptr
  %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %159, %166 : i64, !llvm.ptr
  %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %169 = llvm.load %168 : !llvm.ptr -> i64
  %170 = builtin.unrealized_conversion_cast %169 : i64 to index
  %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %173 = llvm.load %172 : !llvm.ptr -> i64
  %174 = builtin.unrealized_conversion_cast %173 : i64 to index
  %175 = arith.cmpi ult, %170, %174 : index
  cf.cond_br %175, ^bb17, ^bb18
^bb17:  // pred: ^bb16
  %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %178 = llvm.load %177 : !llvm.ptr -> i64
  %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %181 = llvm.load %180 : !llvm.ptr -> i64
  %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %181, %183 : i64, !llvm.ptr
  %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %178, %185 : i64, !llvm.ptr
  cf.br ^bb18
^bb18:  // 2 preds: ^bb16, ^bb17
  cf.br ^bb19
^bb19:  // 2 preds: ^bb15, ^bb18
  cf.br ^bb20
^bb20:  // 2 preds: ^bb14, ^bb19
  %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %188 = llvm.load %187 : !llvm.ptr -> i64
  %189 = builtin.unrealized_conversion_cast %188 : i64 to index
  %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %192 = llvm.load %191 : !llvm.ptr -> i64
  %193 = builtin.unrealized_conversion_cast %192 : i64 to index
  %194 = arith.cmpi ult, %189, %193 : index
  cf.cond_br %194, ^bb21, ^bb7
^bb21:  // pred: ^bb20
  %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %197 = llvm.load %196 : !llvm.ptr -> i64
  %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %200 = llvm.load %199 : !llvm.ptr -> i64
  %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %200, %202 : i64, !llvm.ptr
  %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %197, %204 : i64, !llvm.ptr
  %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %207 = llvm.load %206 : !llvm.ptr -> i64
  %208 = builtin.unrealized_conversion_cast %207 : i64 to index
  %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %211 = llvm.load %210 : !llvm.ptr -> i64
  %212 = builtin.unrealized_conversion_cast %211 : i64 to index
  %213 = arith.cmpi ult, %208, %212 : index
  cf.cond_br %213, ^bb22, ^bb6
^bb22:  // pred: ^bb21
  %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %216 = llvm.load %215 : !llvm.ptr -> i64
  %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %219 = llvm.load %218 : !llvm.ptr -> i64
  %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %219, %221 : i64, !llvm.ptr
  %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %216, %223 : i64, !llvm.ptr
  %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %226 = llvm.load %225 : !llvm.ptr -> i64
  %227 = builtin.unrealized_conversion_cast %226 : i64 to index
  %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %230 = llvm.load %229 : !llvm.ptr -> i64
  %231 = builtin.unrealized_conversion_cast %230 : i64 to index
  %232 = arith.cmpi ult, %227, %231 : index
  cf.cond_br %232, ^bb23, ^bb26
^bb23:  // pred: ^bb22
  %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %235 = llvm.load %234 : !llvm.ptr -> i64
  %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %238 = llvm.load %237 : !llvm.ptr -> i64
  %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %238, %240 : i64, !llvm.ptr
  %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %235, %242 : i64, !llvm.ptr
  %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %245 = llvm.load %244 : !llvm.ptr -> i64
  %246 = builtin.unrealized_conversion_cast %245 : i64 to index
  %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %249 = llvm.load %248 : !llvm.ptr -> i64
  %250 = builtin.unrealized_conversion_cast %249 : i64 to index
  %251 = arith.cmpi ult, %246, %250 : index
  cf.cond_br %251, ^bb24, ^bb25
^bb24:  // pred: ^bb23
  %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %254 = llvm.load %253 : !llvm.ptr -> i64
  %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %257 = llvm.load %256 : !llvm.ptr -> i64
  %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %257, %259 : i64, !llvm.ptr
  %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %254, %261 : i64, !llvm.ptr
  cf.br ^bb25
^bb25:  // 2 preds: ^bb23, ^bb24
  cf.br ^bb26
^bb26:  // 2 preds: ^bb22, ^bb25
  cf.br ^bb6
^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
  cf.br ^bb28(%262, %263, %264 : index, index, index)
^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
  %268 = arith.cmpi ult, %265, %266 : index
  cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
  %272 = builtin.unrealized_conversion_cast %271 : index to i64
  cf.br ^bb30(%269 : index)
^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
  %274 = builtin.unrealized_conversion_cast %273 : index to i64
  %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %277 = llvm.load %276 : !llvm.ptr -> i64
  %278 = builtin.unrealized_conversion_cast %277 : i64 to index
  %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %281 = llvm.load %280 : !llvm.ptr -> i64
  %282 = builtin.unrealized_conversion_cast %281 : i64 to index
  %283 = arith.cmpi ult, %278, %282 : index
  cf.cond_br %283, ^bb31(%273 : index), ^bb32
^bb31(%284: index):  // pred: ^bb30
  %285 = arith.addi %284, %c1 : index
  cf.br ^bb30(%285 : index)
^bb32:  // pred: ^bb30
  %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %288 = llvm.load %287 : !llvm.ptr -> i64
  %289 = builtin.unrealized_conversion_cast %288 : i64 to index
  %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %292 = llvm.load %291 : !llvm.ptr -> i64
  %293 = builtin.unrealized_conversion_cast %292 : i64 to index
  %294 = arith.cmpi eq, %289, %293 : index
  cf.br ^bb33(%270 : index)
^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
  %296 = builtin.unrealized_conversion_cast %295 : index to i64
  %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %299 = llvm.load %298 : !llvm.ptr -> i64
  %300 = builtin.unrealized_conversion_cast %299 : i64 to index
  %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %303 = llvm.load %302 : !llvm.ptr -> i64
  %304 = builtin.unrealized_conversion_cast %303 : i64 to index
  %305 = arith.cmpi ult, %300, %304 : index
  cf.cond_br %305, ^bb34(%295 : index), ^bb35
^bb34(%306: index):  // pred: ^bb33
  %307 = arith.addi %306, %c-1 : index
  cf.br ^bb33(%307 : index)
^bb35:  // pred: ^bb33
  %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %310 = llvm.load %309 : !llvm.ptr -> i64
  %311 = builtin.unrealized_conversion_cast %310 : i64 to index
  %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %314 = llvm.load %313 : !llvm.ptr -> i64
  %315 = builtin.unrealized_conversion_cast %314 : i64 to index
  %316 = arith.cmpi eq, %311, %315 : index
  %317 = arith.cmpi ult, %273, %295 : index
  cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
^bb36:  // pred: ^bb35
  %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %320 = llvm.load %319 : !llvm.ptr -> i64
  %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %323 = llvm.load %322 : !llvm.ptr -> i64
  %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %323, %325 : i64, !llvm.ptr
  %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %320, %327 : i64, !llvm.ptr
  %328 = arith.cmpi eq, %273, %271 : index
  cf.cond_br %328, ^bb37, ^bb38
^bb37:  // pred: ^bb36
  cf.br ^bb39(%295 : index)
^bb38:  // pred: ^bb36
  %329 = arith.cmpi eq, %295, %271 : index
  %330 = arith.select %329, %273, %271 : index
  cf.br ^bb39(%330 : index)
^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
  cf.br ^bb40
^bb40:  // pred: ^bb39
  %332 = arith.andi %294, %316 : i1
  cf.cond_br %332, ^bb41, ^bb42
^bb41:  // pred: ^bb40
  %333 = arith.addi %273, %c1 : index
  %334 = arith.subi %295, %c1 : index
  cf.br ^bb43(%333, %334 : index, index)
^bb42:  // pred: ^bb40
  cf.br ^bb43(%273, %295 : index, index)
^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
  cf.br ^bb44(%335, %336, %331 : index, index, index)
^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
  cf.br ^bb45(%337, %338, %339 : index, index, index)
^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
  cf.br ^bb27(%340, %341, %342 : index, index, index)
^bb46:  // pred: ^bb28
  return %267 : index
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %6 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %7 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %8 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c0 = arith.constant 0 : index
  %9 = builtin.unrealized_conversion_cast %c0 : index to i64
  %c32 = arith.constant 32 : index
  %c1 = arith.constant 1 : index
  %10 = builtin.unrealized_conversion_cast %c1 : index to i64
  %c4096 = arith.constant 4096 : index
  %c4096_i64 = arith.constant 4096 : i64
  %false = arith.constant false
  %c32_i64 = arith.constant 32 : i64
  %c128_i64 = arith.constant 128 : i64
  %c2_i64 = arith.constant 2 : i64
  %c1_i64 = arith.constant 1 : i64
  %c0_i64 = arith.constant 0 : i64
  %c64_i64 = arith.constant 64 : i64
  %cst = arith.constant 0.000000e+00 : f32
  %true = arith.constant true
  %11 = llvm.mlir.constant(16 : index) : i64
  %12 = llvm.mlir.constant(1 : index) : i64
  %13 = llvm.mlir.null : !llvm.ptr
  %14 = llvm.getelementptr %13[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
  %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
  %17 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %20 = llvm.mlir.constant(0 : index) : i64
  %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %22 = llvm.insertvalue %11, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %23 = llvm.insertvalue %12, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %24 = builtin.unrealized_conversion_cast %23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %25 = llvm.mlir.constant(16 : index) : i64
  %26 = llvm.mlir.constant(1 : index) : i64
  %27 = llvm.mlir.null : !llvm.ptr
  %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
  %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
  %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %34 = llvm.mlir.constant(0 : index) : i64
  %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %36 = llvm.insertvalue %25, %35[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %37 = llvm.insertvalue %26, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %38 = builtin.unrealized_conversion_cast %37 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %39 = llvm.mlir.constant(16 : index) : i64
  %40 = llvm.mlir.constant(1 : index) : i64
  %41 = llvm.mlir.null : !llvm.ptr
  %42 = llvm.getelementptr %41[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %43 = llvm.ptrtoint %42 : !llvm.ptr to i64
  %44 = llvm.call @malloc(%43) : (i64) -> !llvm.ptr
  %45 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %48 = llvm.mlir.constant(0 : index) : i64
  %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %50 = llvm.insertvalue %39, %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %51 = llvm.insertvalue %40, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = builtin.unrealized_conversion_cast %51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %53 = llvm.mlir.constant(16 : index) : i64
  %54 = llvm.mlir.constant(1 : index) : i64
  %55 = llvm.mlir.null : !llvm.ptr
  %56 = llvm.getelementptr %55[16] : (!llvm.ptr) -> !llvm.ptr, i64
  %57 = llvm.ptrtoint %56 : !llvm.ptr to i64
  %58 = llvm.call @malloc(%57) : (i64) -> !llvm.ptr
  %59 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %62 = llvm.mlir.constant(0 : index) : i64
  %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %64 = llvm.insertvalue %53, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %65 = llvm.insertvalue %54, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %66 = builtin.unrealized_conversion_cast %65 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  %67 = llvm.mlir.constant(16 : index) : i64
  %68 = llvm.mlir.constant(1 : index) : i64
  %69 = llvm.mlir.null : !llvm.ptr
  %70 = llvm.getelementptr %69[16] : (!llvm.ptr) -> !llvm.ptr, f32
  %71 = llvm.ptrtoint %70 : !llvm.ptr to i64
  %72 = llvm.call @malloc(%71) : (i64) -> !llvm.ptr
  %73 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %76 = llvm.mlir.constant(0 : index) : i64
  %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %78 = llvm.insertvalue %67, %77[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %79 = llvm.insertvalue %68, %78[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %80 = builtin.unrealized_conversion_cast %79 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %81 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  %82 = llvm.insertvalue %c0_i64, %81[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %83 = llvm.insertvalue %c0_i64, %82[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %84 = llvm.insertvalue %c0_i64, %83[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %85 = llvm.insertvalue %c0_i64, %84[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %86 = llvm.insertvalue %c0_i64, %85[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %87 = llvm.insertvalue %c128_i64, %86[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %88 = llvm.getelementptr %16[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %88 : i64, !llvm.ptr
  %89 = llvm.insertvalue %c1_i64, %87[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %90 = llvm.insertvalue %c128_i64, %89[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %91 = llvm.getelementptr %44[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %91 : i64, !llvm.ptr
  %92 = llvm.insertvalue %c1_i64, %90[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %93 = llvm.insertvalue %c32_i64, %92[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %94 = llvm.getelementptr %16[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %9, %94 : i64, !llvm.ptr
  %95 = llvm.insertvalue %c2_i64, %93[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %96 = llvm.mlir.constant(32 : index) : i64
  %97 = llvm.mlir.constant(1 : index) : i64
  %98 = llvm.mlir.null : !llvm.ptr
  %99 = llvm.getelementptr %98[32] : (!llvm.ptr) -> !llvm.ptr, f32
  %100 = llvm.ptrtoint %99 : !llvm.ptr to i64
  %101 = llvm.call @malloc(%100) : (i64) -> !llvm.ptr
  %102 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %103 = llvm.insertvalue %101, %102[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %104 = llvm.insertvalue %101, %103[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %105 = llvm.mlir.constant(0 : index) : i64
  %106 = llvm.insertvalue %105, %104[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %107 = llvm.insertvalue %96, %106[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %108 = llvm.insertvalue %97, %107[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %109 = llvm.mlir.constant(32 : index) : i64
  %110 = llvm.mlir.constant(1 : index) : i64
  %111 = llvm.mlir.null : !llvm.ptr
  %112 = llvm.getelementptr %111[32] : (!llvm.ptr) -> !llvm.ptr, i1
  %113 = llvm.ptrtoint %112 : !llvm.ptr to i64
  %114 = llvm.call @malloc(%113) : (i64) -> !llvm.ptr
  %115 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %116 = llvm.insertvalue %114, %115[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %117 = llvm.insertvalue %114, %116[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %118 = llvm.mlir.constant(0 : index) : i64
  %119 = llvm.insertvalue %118, %117[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %120 = llvm.insertvalue %109, %119[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %121 = llvm.insertvalue %110, %120[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %122 = llvm.mlir.constant(32 : index) : i64
  %123 = llvm.mlir.constant(1 : index) : i64
  %124 = llvm.mlir.null : !llvm.ptr
  %125 = llvm.getelementptr %124[32] : (!llvm.ptr) -> !llvm.ptr, i64
  %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
  %127 = llvm.call @malloc(%126) : (i64) -> !llvm.ptr
  %128 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %129 = llvm.insertvalue %127, %128[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %130 = llvm.insertvalue %127, %129[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %131 = llvm.mlir.constant(0 : index) : i64
  %132 = llvm.insertvalue %131, %130[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %133 = llvm.insertvalue %122, %132[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %134 = llvm.insertvalue %123, %133[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %135 = builtin.unrealized_conversion_cast %134 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
  cf.br ^bb1(%c0 : index)
^bb1(%136: index):  // 2 preds: ^bb0, ^bb2
  %137 = builtin.unrealized_conversion_cast %136 : index to i64
  %138 = arith.cmpi slt, %136, %c32 : index
  cf.cond_br %138, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %139 = llvm.getelementptr %101[%137] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %139 : f32, !llvm.ptr
  %140 = arith.addi %136, %c1 : index
  cf.br ^bb1(%140 : index)
^bb3:  // pred: ^bb1
  cf.br ^bb4(%c0 : index)
^bb4(%141: index):  // 2 preds: ^bb3, ^bb5
  %142 = builtin.unrealized_conversion_cast %141 : index to i64
  %143 = arith.cmpi slt, %141, %c32 : index
  cf.cond_br %143, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %144 = llvm.getelementptr %114[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %false, %144 : i1, !llvm.ptr
  %145 = arith.addi %141, %c1 : index
  cf.br ^bb4(%145 : index)
^bb6:  // pred: ^bb4
  %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %147 = llvm.getelementptr %146[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %148 = llvm.load %147 : !llvm.ptr -> i64
  %149 = builtin.unrealized_conversion_cast %148 : i64 to index
  %150 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %151 = llvm.getelementptr %150[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %152 = llvm.load %151 : !llvm.ptr -> i64
  %153 = builtin.unrealized_conversion_cast %152 : i64 to index
  cf.br ^bb7(%149, %24, %38, %52, %66, %80, %95 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb7(%154: index, %155: memref<?xindex>, %156: memref<?xindex>, %157: memref<?xindex>, %158: memref<?xindex>, %159: memref<?xf32>, %160: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
  %161 = builtin.unrealized_conversion_cast %154 : index to i64
  %162 = builtin.unrealized_conversion_cast %157 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %163 = builtin.unrealized_conversion_cast %155 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %164 = builtin.unrealized_conversion_cast %156 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %165 = builtin.unrealized_conversion_cast %158 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %166 = builtin.unrealized_conversion_cast %159 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %167 = arith.cmpi slt, %154, %153 : index
  cf.cond_br %167, ^bb8, ^bb25
^bb8:  // pred: ^bb7
  %168 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %169 = llvm.getelementptr %168[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %170 = llvm.load %169 : !llvm.ptr -> i64
  %171 = builtin.unrealized_conversion_cast %170 : i64 to index
  %172 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %173 = llvm.getelementptr %172[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %174 = llvm.load %173 : !llvm.ptr -> i64
  %175 = builtin.unrealized_conversion_cast %174 : i64 to index
  %176 = arith.addi %154, %c1 : index
  %177 = builtin.unrealized_conversion_cast %176 : index to i64
  %178 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %179 = llvm.getelementptr %178[%177] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %180 = llvm.load %179 : !llvm.ptr -> i64
  %181 = builtin.unrealized_conversion_cast %180 : i64 to index
  cf.br ^bb9(%175, %155, %156, %157, %158, %159, %160 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb9(%182: index, %183: memref<?xindex>, %184: memref<?xindex>, %185: memref<?xindex>, %186: memref<?xindex>, %187: memref<?xf32>, %188: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
  %189 = builtin.unrealized_conversion_cast %182 : index to i64
  %190 = arith.cmpi slt, %182, %181 : index
  cf.cond_br %190, ^bb10, ^bb24
^bb10:  // pred: ^bb9
  %191 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %192 = llvm.getelementptr %191[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %193 = llvm.load %192 : !llvm.ptr -> i64
  %194 = builtin.unrealized_conversion_cast %193 : i64 to index
  %195 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %196 = llvm.getelementptr %195[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %197 = llvm.load %196 : !llvm.ptr -> i64
  %198 = builtin.unrealized_conversion_cast %197 : i64 to index
  %199 = arith.addi %182, %c1 : index
  %200 = builtin.unrealized_conversion_cast %199 : index to i64
  %201 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %203 = llvm.load %202 : !llvm.ptr -> i64
  %204 = builtin.unrealized_conversion_cast %203 : i64 to index
  cf.br ^bb11(%198, %c0 : index, index)
^bb11(%205: index, %206: index):  // 2 preds: ^bb10, ^bb19
  %207 = builtin.unrealized_conversion_cast %205 : index to i64
  %208 = arith.cmpi slt, %205, %204 : index
  cf.cond_br %208, ^bb12, ^bb20
^bb12:  // pred: ^bb11
  %209 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %210 = llvm.getelementptr %209[%207] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %211 = llvm.load %210 : !llvm.ptr -> i64
  %212 = builtin.unrealized_conversion_cast %211 : i64 to index
  %213 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %214 = llvm.getelementptr %213[%207] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %215 = llvm.load %214 : !llvm.ptr -> f32
  cf.br ^bb13(%c0, %206 : index, index)
^bb13(%216: index, %217: index):  // 2 preds: ^bb12, ^bb18
  %218 = builtin.unrealized_conversion_cast %216 : index to i64
  %219 = builtin.unrealized_conversion_cast %217 : index to i64
  %220 = arith.cmpi slt, %216, %c32 : index
  cf.cond_br %220, ^bb14, ^bb19
^bb14:  // pred: ^bb13
  %221 = arith.muli %212, %c32 : index
  %222 = arith.addi %221, %216 : index
  %223 = builtin.unrealized_conversion_cast %222 : index to i64
  %224 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %225 = llvm.load %224 : !llvm.ptr -> f32
  %226 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %227 = llvm.getelementptr %226[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %228 = llvm.load %227 : !llvm.ptr -> f32
  %229 = arith.mulf %215, %228 : f32
  %230 = arith.addf %225, %229 : f32
  %231 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  %232 = llvm.load %231 : !llvm.ptr -> i1
  %233 = arith.cmpi eq, %232, %false : i1
  cf.cond_br %233, ^bb15, ^bb16
^bb15:  // pred: ^bb14
  %234 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %true, %234 : i1, !llvm.ptr
  %235 = llvm.getelementptr %127[%219] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %218, %235 : i64, !llvm.ptr
  %236 = arith.addi %217, %c1 : index
  cf.br ^bb17(%236 : index)
^bb16:  // pred: ^bb14
  cf.br ^bb17(%217 : index)
^bb17(%237: index):  // 2 preds: ^bb15, ^bb16
  cf.br ^bb18
^bb18:  // pred: ^bb17
  %238 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %230, %238 : f32, !llvm.ptr
  %239 = arith.addi %216, %c1 : index
  cf.br ^bb13(%239, %237 : index, index)
^bb19:  // pred: ^bb13
  %240 = arith.addi %205, %c1 : index
  cf.br ^bb11(%240, %217 : index, index)
^bb20:  // pred: ^bb11
  %241 = arith.index_cast %206 : index to i64
  %242 = "llvm.intr.ctlz"(%241) <{is_zero_poison = false}> : (i64) -> i64
  %243 = arith.subi %c64_i64, %242 : i64
  call @_sparse_hybrid_qsort_1_index(%c0, %206, %135, %243) : (index, index, memref<?xindex>, i64) -> ()
  cf.br ^bb21(%c0, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb21(%244: index, %245: memref<?xindex>, %246: memref<?xindex>, %247: memref<?xindex>, %248: memref<?xindex>, %249: memref<?xf32>, %250: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
  %251 = builtin.unrealized_conversion_cast %244 : index to i64
  %252 = arith.cmpi slt, %244, %206 : index
  cf.cond_br %252, ^bb22, ^bb23
^bb22:  // pred: ^bb21
  %253 = llvm.getelementptr %127[%251] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %254 = llvm.load %253 : !llvm.ptr -> i64
  %255 = builtin.unrealized_conversion_cast %254 : i64 to index
  %256 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %257 = llvm.load %256 : !llvm.ptr -> f32
  %258:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%245, %246, %247, %248, %249, %250, %171, %194, %255, %257) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  %259 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %259 : f32, !llvm.ptr
  %260 = llvm.getelementptr %114[%254] : (!llvm.ptr, i64) -> !llvm.ptr, i1
  llvm.store %false, %260 : i1, !llvm.ptr
  %261 = arith.addi %244, %c1 : index
  cf.br ^bb21(%261, %258#0, %258#1, %258#2, %258#3, %258#4, %258#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb23:  // pred: ^bb21
  %262 = arith.addi %182, %c1 : index
  cf.br ^bb9(%262, %245, %246, %247, %248, %249, %250 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb24:  // pred: ^bb9
  %263 = arith.addi %154, %c1 : index
  cf.br ^bb7(%263, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
^bb25:  // pred: ^bb7
  llvm.call @free(%101) : (!llvm.ptr) -> ()
  llvm.call @free(%114) : (!llvm.ptr) -> ()
  llvm.call @free(%127) : (!llvm.ptr) -> ()
  %264 = llvm.extractvalue %160[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
  %265 = arith.index_cast %264 : i64 to index
  %266 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %267 = llvm.getelementptr %266[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %268 = llvm.load %267 : !llvm.ptr -> i64
  %269 = builtin.unrealized_conversion_cast %268 : i64 to index
  cf.br ^bb26(%c1, %269 : index, index)
^bb26(%270: index, %271: index):  // 2 preds: ^bb25, ^bb29
  %272 = builtin.unrealized_conversion_cast %270 : index to i64
  %273 = builtin.unrealized_conversion_cast %271 : index to i64
  %274 = arith.cmpi slt, %270, %265 : index
  cf.cond_br %274, ^bb27, ^bb30
^bb27:  // pred: ^bb26
  %275 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %276 = llvm.getelementptr %275[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %277 = llvm.load %276 : !llvm.ptr -> i64
  %278 = builtin.unrealized_conversion_cast %277 : i64 to index
  %279 = arith.cmpi eq, %278, %c0 : index
  %280 = arith.select %279, %271, %278 : index
  cf.cond_br %279, ^bb28, ^bb29
^bb28:  // pred: ^bb27
  %281 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %282 = llvm.getelementptr %281[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  llvm.store %273, %282 : i64, !llvm.ptr
  cf.br ^bb29
^bb29:  // 2 preds: ^bb27, ^bb28
  %283 = arith.addi %270, %c1 : index
  cf.br ^bb26(%283, %280 : index, index)
^bb30:  // pred: ^bb26
  %284 = llvm.mlir.constant(4096 : index) : i64
  %285 = llvm.mlir.constant(1 : index) : i64
  %286 = llvm.mlir.null : !llvm.ptr
  %287 = llvm.getelementptr %286[4096] : (!llvm.ptr) -> !llvm.ptr, f32
  %288 = llvm.ptrtoint %287 : !llvm.ptr to i64
  %289 = llvm.call @malloc(%288) : (i64) -> !llvm.ptr
  %290 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %291 = llvm.insertvalue %289, %290[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %292 = llvm.insertvalue %289, %291[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %293 = llvm.mlir.constant(0 : index) : i64
  %294 = llvm.insertvalue %293, %292[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %295 = llvm.insertvalue %284, %294[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %296 = llvm.insertvalue %285, %295[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %297 = builtin.unrealized_conversion_cast %296 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
  %298 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  %299 = llvm.insertvalue %c0_i64, %298[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %300 = llvm.insertvalue %c128_i64, %299[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %301 = llvm.insertvalue %c32_i64, %300[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  cf.br ^bb31(%c0 : index)
^bb31(%302: index):  // 2 preds: ^bb30, ^bb32
  %303 = builtin.unrealized_conversion_cast %302 : index to i64
  %304 = arith.cmpi slt, %302, %c4096 : index
  cf.cond_br %304, ^bb32, ^bb33
^bb32:  // pred: ^bb31
  %305 = llvm.getelementptr %289[%303] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  llvm.store %cst, %305 : f32, !llvm.ptr
  %306 = arith.addi %302, %c1 : index
  cf.br ^bb31(%306 : index)
^bb33:  // pred: ^bb31
  %307 = llvm.insertvalue %c4096_i64, %301[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
  %308 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %309 = llvm.getelementptr %308[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %310 = llvm.load %309 : !llvm.ptr -> i64
  %311 = builtin.unrealized_conversion_cast %310 : i64 to index
  %312 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %313 = llvm.getelementptr %312[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %314 = llvm.load %313 : !llvm.ptr -> i64
  %315 = builtin.unrealized_conversion_cast %314 : i64 to index
  omp.parallel   {
    omp.wsloop   for  (%arg12) : index = (%311) to (%315) step (%c1) {
      %316 = builtin.unrealized_conversion_cast %arg12 : index to i64
      %317 = llvm.extractvalue %164[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %318 = llvm.getelementptr %317[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %319 = llvm.load %318 : !llvm.ptr -> i64
      %320 = builtin.unrealized_conversion_cast %319 : i64 to index
      %321 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %322 = llvm.getelementptr %321[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %323 = llvm.load %322 : !llvm.ptr -> i64
      %324 = builtin.unrealized_conversion_cast %323 : i64 to index
      %325 = arith.addi %arg12, %c1 : index
      %326 = builtin.unrealized_conversion_cast %325 : index to i64
      %327 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
      %328 = llvm.getelementptr %327[%326] : (!llvm.ptr, i64) -> !llvm.ptr, i64
      %329 = llvm.load %328 : !llvm.ptr -> i64
      %330 = builtin.unrealized_conversion_cast %329 : i64 to index
      omp.parallel   {
        omp.wsloop   for  (%arg13) : index = (%324) to (%330) step (%c1) {
          %331 = builtin.unrealized_conversion_cast %arg13 : index to i64
          %332 = llvm.extractvalue %165[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
          %333 = llvm.getelementptr %332[%331] : (!llvm.ptr, i64) -> !llvm.ptr, i64
          %334 = llvm.load %333 : !llvm.ptr -> i64
          %335 = builtin.unrealized_conversion_cast %334 : i64 to index
          omp.parallel   {
            omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
              %336 = arith.muli %arg13, %c32 : index
              %337 = arith.addi %336, %arg14 : index
              %338 = builtin.unrealized_conversion_cast %337 : index to i64
              %339 = arith.muli %335, %c32 : index
              %340 = arith.addi %339, %arg14 : index
              %341 = builtin.unrealized_conversion_cast %340 : index to i64
              %342 = arith.muli %320, %c32 : index
              %343 = arith.addi %342, %arg14 : index
              %344 = builtin.unrealized_conversion_cast %343 : index to i64
              %345 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %346 = llvm.load %345 : !llvm.ptr -> f32
              %347 = llvm.extractvalue %166[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
              %348 = llvm.getelementptr %347[%338] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %349 = llvm.load %348 : !llvm.ptr -> f32
              %350 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
              %351 = llvm.getelementptr %350[%341] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              %352 = llvm.load %351 : !llvm.ptr -> f32
              %353 = arith.mulf %349, %352 : f32
              %354 = arith.addf %346, %353 : f32
              %355 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
              llvm.store %354, %355 : f32, !llvm.ptr
              omp.yield
            }
            omp.terminator
          }
          omp.yield
        }
        omp.terminator
      }
      omp.yield
    }
    omp.terminator
  }
  return %297, %307 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
}

// -----// IR Dump After ConvertMathToLibm (convert-math-to-libm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
    %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c1 = arith.constant 1 : index
    %7 = builtin.unrealized_conversion_cast %c1 : index to i64
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.subi %16, %c1 : index
    %20 = builtin.unrealized_conversion_cast %19 : index to i64
    %21 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %21, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = arith.cmpi eq, %25, %arg6 : index
    cf.br ^bb3(%26 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %28 = arith.select %27, %19, %18 : index
    %29 = builtin.unrealized_conversion_cast %28 : index to i64
    cf.cond_br %27, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %30 = arith.addi %18, %c1 : index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %31, %33 : i64, !llvm.ptr
    %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = builtin.unrealized_conversion_cast %35 : index to i64
    %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %35, %c1 : index
    %40 = arith.cmpi ugt, %39, %38 : index
    cf.cond_br %40, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %41 = arith.muli %38, %c2 : index
    %42 = builtin.unrealized_conversion_cast %41 : index to i64
    %43 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = builtin.unrealized_conversion_cast %41 : index to i64
    %45 = llvm.icmp "ugt" %44, %43 : i64
    llvm.cond_br %45, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %46 = llvm.mlir.null : !llvm.ptr
    %47 = llvm.getelementptr %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
    %49 = llvm.mul %44, %48  : i64
    %50 = llvm.mul %43, %48  : i64
    %51 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %52 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%51, %52, %50) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %53 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%53) : (!llvm.ptr) -> ()
    %54 = llvm.insertvalue %51, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %51, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%55 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%56: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %57 = llvm.insertvalue %44, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = builtin.unrealized_conversion_cast %57 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb11(%58 : memref<?xindex>)
  ^bb10:  // pred: ^bb6
    cf.br ^bb11(%arg1 : memref<?xindex>)
  ^bb11(%59: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
    %60 = builtin.unrealized_conversion_cast %59 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    %61 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.getelementptr %61[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %5, %62 : i64, !llvm.ptr
    %63 = arith.index_cast %39 : index to i64
    %64 = llvm.insertvalue %63, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %65 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %66 = arith.index_cast %65 : i64 to index
    %67 = builtin.unrealized_conversion_cast %66 : index to i64
    %68 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : i64 to index
    %70 = arith.addi %66, %c1 : index
    %71 = arith.cmpi ugt, %70, %69 : index
    cf.cond_br %71, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %72 = arith.muli %69, %c2 : index
    %73 = builtin.unrealized_conversion_cast %72 : index to i64
    %74 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = builtin.unrealized_conversion_cast %72 : index to i64
    %76 = llvm.icmp "ugt" %75, %74 : i64
    llvm.cond_br %76, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %77 = llvm.mlir.null : !llvm.ptr
    %78 = llvm.getelementptr %77[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mul %75, %79  : i64
    %81 = llvm.mul %74, %79  : i64
    %82 = llvm.call @malloc(%80) : (i64) -> !llvm.ptr
    %83 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%82, %83, %81) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %84 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%84) : (!llvm.ptr) -> ()
    %85 = llvm.insertvalue %82, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %86 = llvm.insertvalue %82, %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%87: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %88 = llvm.insertvalue %75, %87[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = builtin.unrealized_conversion_cast %88 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb17(%89 : memref<?xindex>)
  ^bb16:  // pred: ^bb12
    cf.br ^bb17(%arg2 : memref<?xindex>)
  ^bb17(%90: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
    %91 = builtin.unrealized_conversion_cast %90 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %92 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %93 = llvm.getelementptr %92[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %8, %93 : i64, !llvm.ptr
    %94 = arith.index_cast %70 : index to i64
    %95 = llvm.insertvalue %94, %64[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb19(%59, %90, %95 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%96: memref<?xindex>, %97: memref<?xindex>, %98: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %99 = builtin.unrealized_conversion_cast %97 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %100 = arith.addi %28, %c1 : index
    %101 = builtin.unrealized_conversion_cast %100 : index to i64
    %102 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.getelementptr %102[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %104 = llvm.load %103 : !llvm.ptr -> i64
    %105 = builtin.unrealized_conversion_cast %104 : i64 to index
    %106 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %108 = llvm.load %107 : !llvm.ptr -> i64
    %109 = builtin.unrealized_conversion_cast %108 : i64 to index
    %110 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %111 = arith.index_cast %110 : i64 to index
    %112 = builtin.unrealized_conversion_cast %111 : index to i64
    %113 = arith.subi %109, %c1 : index
    %114 = builtin.unrealized_conversion_cast %113 : index to i64
    %115 = arith.cmpi ult, %105, %109 : index
    cf.cond_br %115, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %116 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %118 = llvm.load %117 : !llvm.ptr -> i64
    %119 = builtin.unrealized_conversion_cast %118 : i64 to index
    %120 = arith.cmpi eq, %119, %arg7 : index
    cf.br ^bb23(%120 : i1)
  ^bb22:  // pred: ^bb20
    %121 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.getelementptr %121[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %112, %122 : i64, !llvm.ptr
    cf.br ^bb23(%false : i1)
  ^bb23(%123: i1):  // 2 preds: ^bb21, ^bb22
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    %124 = arith.select %123, %113, %111 : index
    cf.cond_br %123, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    cf.br ^bb44(%arg3, %arg4, %98 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %125 = arith.addi %111, %c1 : index
    %126 = builtin.unrealized_conversion_cast %125 : index to i64
    %127 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %126, %128 : i64, !llvm.ptr
    %129 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %130 = arith.index_cast %129 : i64 to index
    %131 = builtin.unrealized_conversion_cast %130 : index to i64
    %132 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = builtin.unrealized_conversion_cast %132 : i64 to index
    %134 = arith.addi %130, %c1 : index
    %135 = arith.cmpi ugt, %134, %133 : index
    cf.cond_br %135, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %136 = arith.muli %133, %c2 : index
    %137 = builtin.unrealized_conversion_cast %136 : index to i64
    %138 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = builtin.unrealized_conversion_cast %136 : index to i64
    %140 = llvm.icmp "ugt" %139, %138 : i64
    llvm.cond_br %140, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %141 = llvm.mlir.null : !llvm.ptr
    %142 = llvm.getelementptr %141[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %143 = llvm.ptrtoint %142 : !llvm.ptr to i64
    %144 = llvm.mul %139, %143  : i64
    %145 = llvm.mul %138, %143  : i64
    %146 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
    %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%146, %147, %145) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %148 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%148) : (!llvm.ptr) -> ()
    %149 = llvm.insertvalue %146, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %150 = llvm.insertvalue %146, %149[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%150 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%151: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %152 = llvm.insertvalue %139, %151[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = builtin.unrealized_conversion_cast %152 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb31(%153 : memref<?xindex>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg3 : memref<?xindex>)
  ^bb31(%154: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
    %155 = builtin.unrealized_conversion_cast %154 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %156 = llvm.extractvalue %155[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %157 = llvm.getelementptr %156[%131] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %3, %157 : i64, !llvm.ptr
    %158 = arith.index_cast %134 : index to i64
    %159 = llvm.insertvalue %158, %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = llvm.extractvalue %98[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %161 = arith.index_cast %160 : i64 to index
    %162 = builtin.unrealized_conversion_cast %161 : index to i64
    %163 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = builtin.unrealized_conversion_cast %163 : i64 to index
    %165 = arith.addi %161, %c32 : index
    %166 = arith.cmpi ugt, %165, %164 : index
    cf.cond_br %166, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%164 : index)
  ^bb34(%167: index):  // 2 preds: ^bb33, ^bb34
    %168 = arith.muli %167, %c2 : index
    %169 = builtin.unrealized_conversion_cast %168 : index to i64
    %170 = arith.cmpi ugt, %165, %168 : index
    cf.cond_br %170, ^bb34(%168 : index), ^bb35
  ^bb35:  // pred: ^bb34
    %171 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = builtin.unrealized_conversion_cast %168 : index to i64
    %173 = llvm.icmp "ugt" %172, %171 : i64
    llvm.cond_br %173, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %174 = llvm.mlir.null : !llvm.ptr
    %175 = llvm.getelementptr %174[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %176 = llvm.ptrtoint %175 : !llvm.ptr to i64
    %177 = llvm.mul %172, %176  : i64
    %178 = llvm.mul %171, %176  : i64
    %179 = llvm.call @malloc(%177) : (i64) -> !llvm.ptr
    %180 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%179, %180, %178) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %181 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%181) : (!llvm.ptr) -> ()
    %182 = llvm.insertvalue %179, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.insertvalue %179, %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%183 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%184: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %185 = llvm.insertvalue %172, %184[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %186 = builtin.unrealized_conversion_cast %185 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    cf.br ^bb39(%186 : memref<?xf32>)
  ^bb38:  // pred: ^bb32
    cf.br ^bb39(%arg4 : memref<?xf32>)
  ^bb39(%187: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
    %188 = builtin.unrealized_conversion_cast %187 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %189 = llvm.extractvalue %188[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %190 = llvm.extractvalue %188[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %192 = llvm.insertvalue %189, %191[0] : !llvm.struct<(ptr, ptr, i64)> 
    %193 = llvm.insertvalue %190, %192[1] : !llvm.struct<(ptr, ptr, i64)> 
    %194 = llvm.mlir.constant(0 : index) : i64
    %195 = llvm.insertvalue %194, %193[2] : !llvm.struct<(ptr, ptr, i64)> 
    %196 = llvm.extractvalue %188[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.extractvalue %188[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %198 = llvm.extractvalue %188[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %200 = llvm.insertvalue %189, %199[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.insertvalue %190, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.insertvalue %162, %201[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %203 = llvm.mlir.constant(32 : index) : i64
    %204 = llvm.insertvalue %203, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %205 = llvm.mlir.constant(1 : index) : i64
    %206 = llvm.insertvalue %205, %204[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    cf.br ^bb41(%c0 : index)
  ^bb41(%207: index):  // 2 preds: ^bb40, ^bb42
    %208 = builtin.unrealized_conversion_cast %207 : index to i64
    %209 = arith.cmpi slt, %207, %c32 : index
    cf.cond_br %209, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %210 = llvm.getelementptr %190[%162] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %211 = llvm.getelementptr %210[%208] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %211 : f32, !llvm.ptr
    %212 = arith.addi %207, %c1 : index
    cf.br ^bb41(%212 : index)
  ^bb43:  // pred: ^bb41
    %213 = arith.index_cast %165 : index to i64
    %214 = llvm.insertvalue %213, %159[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb44(%154, %187, %214 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%215: memref<?xindex>, %216: memref<?xf32>, %217: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %218 = builtin.unrealized_conversion_cast %216 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb45
  ^bb45:  // pred: ^bb44
    %219 = arith.muli %124, %c32 : index
    %220 = arith.addi %219, %arg8 : index
    %221 = builtin.unrealized_conversion_cast %220 : index to i64
    %222 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%221] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg9, %223 : f32, !llvm.ptr
    return %arg0, %96, %97, %215, %216, %217 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
    %c1 = arith.constant 1 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
    %4 = arith.cmpi ult, %2, %3 : index
    cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
  ^bb2(%5: index, %6: index):  // pred: ^bb1
    %7 = arith.addi %5, %6 : index
    %8 = arith.shrui %7, %c1 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %8, %c1 : index
    %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %13 = llvm.load %12 : !llvm.ptr -> i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = arith.cmpi ult, %14, %18 : index
    %20 = arith.select %19, %5, %10 : index
    %21 = arith.select %19, %8, %6 : index
    cf.br ^bb1(%20, %21 : index, index)
  ^bb3:  // pred: ^bb1
    return %2 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %1 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%1 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
    %3 = builtin.unrealized_conversion_cast %2 : index to i64
    %4 = arith.cmpi slt, %2, %arg1 : index
    cf.cond_br %4, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %9 = llvm.load %8 : !llvm.ptr -> i64
    %10 = arith.subi %2, %5 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
    %12 = arith.cmpi slt, %11, %10 : index
    cf.cond_br %12, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %13 = arith.subi %2, %11 : index
    %14 = builtin.unrealized_conversion_cast %13 : index to i64
    %15 = arith.subi %13, %c1 : index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %19, %21 : i64, !llvm.ptr
    %22 = arith.addi %11, %c1 : index
    cf.br ^bb3(%22 : index)
  ^bb5:  // pred: ^bb3
    %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %24 : i64, !llvm.ptr
    %25 = arith.addi %2, %c1 : index
    cf.br ^bb1(%25 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %1 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %1, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %arg3, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.cmpi uge, %4, %2 : index
    cf.cond_br %5, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %6 = arith.shli %2, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = arith.addi %7, %arg0 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %6, %c2 : index
    %11 = arith.cmpi ult, %10, %arg3 : index
    cf.cond_br %11, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %12 = arith.addi %10, %arg0 : index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = builtin.unrealized_conversion_cast %16 : i64 to index
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = arith.cmpi ult, %17, %21 : index
    %23 = arith.select %22, %10, %7 : index
    %24 = arith.select %22, %12, %8 : index
    cf.br ^bb5(%23, %24, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%7, %8, %arg1 : index, index, index)
  ^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%27, %25, %26 : index, index, index)
  ^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
    cf.br ^bb7(%28, %29, %30 : index, index, index)
  ^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
    %34 = builtin.unrealized_conversion_cast %31 : index to i64
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = builtin.unrealized_conversion_cast %38 : i64 to index
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = arith.cmpi ult, %39, %43 : index
    cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
  ^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = builtin.unrealized_conversion_cast %47 : index to i64
    %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = arith.cmpi uge, %4, %46 : index
    cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
  ^bb9:  // pred: ^bb8
    %61 = arith.shli %46, %c1 : index
    %62 = arith.addi %61, %c1 : index
    %63 = arith.addi %62, %arg0 : index
    %64 = builtin.unrealized_conversion_cast %63 : index to i64
    %65 = arith.addi %61, %c2 : index
    %66 = arith.cmpi ult, %65, %arg3 : index
    cf.cond_br %66, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %67 = arith.addi %65, %arg0 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %75 = llvm.load %74 : !llvm.ptr -> i64
    %76 = builtin.unrealized_conversion_cast %75 : i64 to index
    %77 = arith.cmpi ult, %72, %76 : index
    %78 = arith.select %77, %65, %62 : index
    %79 = arith.select %77, %67, %63 : index
    cf.br ^bb12(%78, %79 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%62, %63 : index, index)
  ^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%80, %81 : index, index)
  ^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%82, %83, %47 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %2, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.addi %4, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = arith.subi %4, %6 : index
    %9 = arith.addi %arg0, %8 : index
    call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
    %10 = arith.addi %6, %c1 : index
    cf.br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    %11 = arith.subi %2, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
    %13 = arith.cmpi slt, %12, %11 : index
    cf.cond_br %13, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %14 = arith.subi %2, %12 : index
    %15 = arith.addi %arg0, %14 : index
    %16 = arith.subi %15, %c1 : index
    %17 = builtin.unrealized_conversion_cast %16 : index to i64
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    %28 = arith.subi %14, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
    %29 = arith.addi %12, %c1 : index
    cf.br ^bb4(%29 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %2 = arith.addi %arg0, %arg1 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = builtin.unrealized_conversion_cast %3 : index to i64
    %5 = arith.subi %arg1, %c1 : index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = arith.subi %arg1, %arg0 : index
    %8 = arith.cmpi ult, %7, %c1000 : index
    cf.cond_br %8, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %30 = llvm.load %29 : !llvm.ptr -> i64
    %31 = builtin.unrealized_conversion_cast %30 : i64 to index
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %34 = llvm.load %33 : !llvm.ptr -> i64
    %35 = builtin.unrealized_conversion_cast %34 : i64 to index
    %36 = arith.cmpi ult, %31, %35 : index
    cf.cond_br %36, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %42, %44 : i64, !llvm.ptr
    %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %39, %46 : i64, !llvm.ptr
    %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    %55 = arith.cmpi ult, %50, %54 : index
    cf.cond_br %55, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %58 = llvm.load %57 : !llvm.ptr -> i64
    %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %61 = llvm.load %60 : !llvm.ptr -> i64
    %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %61, %63 : i64, !llvm.ptr
    %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %58, %65 : i64, !llvm.ptr
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %5, %3 : index, index, index)
  ^bb8:  // pred: ^bb0
    %66 = arith.addi %arg0, %arg1 : index
    %67 = arith.shrui %66, %c1 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = arith.addi %3, %arg1 : index
    %70 = arith.shrui %69, %c1 : index
    %71 = builtin.unrealized_conversion_cast %70 : index to i64
    %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = arith.cmpi ult, %75, %79 : index
    cf.cond_br %80, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %86, %88 : i64, !llvm.ptr
    %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %83, %90 : i64, !llvm.ptr
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    %99 = arith.cmpi ult, %94, %98 : index
    cf.cond_br %99, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %105, %107 : i64, !llvm.ptr
    %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %102, %109 : i64, !llvm.ptr
    %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %113, %117 : index
    cf.cond_br %118, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %124 = llvm.load %123 : !llvm.ptr -> i64
    %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %128 : i64, !llvm.ptr
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %135 = llvm.load %134 : !llvm.ptr -> i64
    %136 = builtin.unrealized_conversion_cast %135 : i64 to index
    %137 = arith.cmpi ult, %132, %136 : index
    cf.cond_br %137, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %140 = llvm.load %139 : !llvm.ptr -> i64
    %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %143, %145 : i64, !llvm.ptr
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %140, %147 : i64, !llvm.ptr
    %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %154 = llvm.load %153 : !llvm.ptr -> i64
    %155 = builtin.unrealized_conversion_cast %154 : i64 to index
    %156 = arith.cmpi ult, %151, %155 : index
    cf.cond_br %156, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %162, %164 : i64, !llvm.ptr
    %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %159, %166 : i64, !llvm.ptr
    %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = builtin.unrealized_conversion_cast %173 : i64 to index
    %175 = arith.cmpi ult, %170, %174 : index
    cf.cond_br %175, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %178 = llvm.load %177 : !llvm.ptr -> i64
    %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %181 = llvm.load %180 : !llvm.ptr -> i64
    %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %181, %183 : i64, !llvm.ptr
    %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %178, %185 : i64, !llvm.ptr
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %192 = llvm.load %191 : !llvm.ptr -> i64
    %193 = builtin.unrealized_conversion_cast %192 : i64 to index
    %194 = arith.cmpi ult, %189, %193 : index
    cf.cond_br %194, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = arith.cmpi ult, %208, %212 : index
    cf.cond_br %213, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %219 = llvm.load %218 : !llvm.ptr -> i64
    %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %219, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %216, %223 : i64, !llvm.ptr
    %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = arith.cmpi ult, %227, %231 : index
    cf.cond_br %232, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %235 = llvm.load %234 : !llvm.ptr -> i64
    %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %238 = llvm.load %237 : !llvm.ptr -> i64
    %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %238, %240 : i64, !llvm.ptr
    %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %235, %242 : i64, !llvm.ptr
    %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %249 = llvm.load %248 : !llvm.ptr -> i64
    %250 = builtin.unrealized_conversion_cast %249 : i64 to index
    %251 = arith.cmpi ult, %246, %250 : index
    cf.cond_br %251, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %257 = llvm.load %256 : !llvm.ptr -> i64
    %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %257, %259 : i64, !llvm.ptr
    %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %254, %261 : i64, !llvm.ptr
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%262, %263, %264 : index, index, index)
  ^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
    %268 = arith.cmpi ult, %265, %266 : index
    cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
  ^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
    %272 = builtin.unrealized_conversion_cast %271 : index to i64
    cf.br ^bb30(%269 : index)
  ^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
    %274 = builtin.unrealized_conversion_cast %273 : index to i64
    %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = builtin.unrealized_conversion_cast %281 : i64 to index
    %283 = arith.cmpi ult, %278, %282 : index
    cf.cond_br %283, ^bb31(%273 : index), ^bb32
  ^bb31(%284: index):  // pred: ^bb30
    %285 = arith.addi %284, %c1 : index
    cf.br ^bb30(%285 : index)
  ^bb32:  // pred: ^bb30
    %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %288 = llvm.load %287 : !llvm.ptr -> i64
    %289 = builtin.unrealized_conversion_cast %288 : i64 to index
    %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %292 = llvm.load %291 : !llvm.ptr -> i64
    %293 = builtin.unrealized_conversion_cast %292 : i64 to index
    %294 = arith.cmpi eq, %289, %293 : index
    cf.br ^bb33(%270 : index)
  ^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
    %296 = builtin.unrealized_conversion_cast %295 : index to i64
    %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %299 = llvm.load %298 : !llvm.ptr -> i64
    %300 = builtin.unrealized_conversion_cast %299 : i64 to index
    %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %303 = llvm.load %302 : !llvm.ptr -> i64
    %304 = builtin.unrealized_conversion_cast %303 : i64 to index
    %305 = arith.cmpi ult, %300, %304 : index
    cf.cond_br %305, ^bb34(%295 : index), ^bb35
  ^bb34(%306: index):  // pred: ^bb33
    %307 = arith.addi %306, %c-1 : index
    cf.br ^bb33(%307 : index)
  ^bb35:  // pred: ^bb33
    %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    %316 = arith.cmpi eq, %311, %315 : index
    %317 = arith.cmpi ult, %273, %295 : index
    cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
  ^bb36:  // pred: ^bb35
    %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %320 = llvm.load %319 : !llvm.ptr -> i64
    %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %323 = llvm.load %322 : !llvm.ptr -> i64
    %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %323, %325 : i64, !llvm.ptr
    %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %320, %327 : i64, !llvm.ptr
    %328 = arith.cmpi eq, %273, %271 : index
    cf.cond_br %328, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%295 : index)
  ^bb38:  // pred: ^bb36
    %329 = arith.cmpi eq, %295, %271 : index
    %330 = arith.select %329, %273, %271 : index
    cf.br ^bb39(%330 : index)
  ^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %332 = arith.andi %294, %316 : i1
    cf.cond_br %332, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %333 = arith.addi %273, %c1 : index
    %334 = arith.subi %295, %c1 : index
    cf.br ^bb43(%333, %334 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%273, %295 : index, index)
  ^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%335, %336, %331 : index, index, index)
  ^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%337, %338, %339 : index, index, index)
  ^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
    cf.br ^bb27(%340, %341, %342 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %267 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %9 = builtin.unrealized_conversion_cast %c0 : index to i64
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %10 = builtin.unrealized_conversion_cast %c1 : index to i64
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %11 = llvm.mlir.constant(16 : index) : i64
    %12 = llvm.mlir.constant(1 : index) : i64
    %13 = llvm.mlir.null : !llvm.ptr
    %14 = llvm.getelementptr %13[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
    %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
    %17 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.mlir.constant(0 : index) : i64
    %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %11, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %12, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = builtin.unrealized_conversion_cast %23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %25 = llvm.mlir.constant(16 : index) : i64
    %26 = llvm.mlir.constant(1 : index) : i64
    %27 = llvm.mlir.null : !llvm.ptr
    %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
    %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.mlir.constant(0 : index) : i64
    %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.insertvalue %25, %35[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %26, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %39 = llvm.mlir.constant(16 : index) : i64
    %40 = llvm.mlir.constant(1 : index) : i64
    %41 = llvm.mlir.null : !llvm.ptr
    %42 = llvm.getelementptr %41[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %43 = llvm.ptrtoint %42 : !llvm.ptr to i64
    %44 = llvm.call @malloc(%43) : (i64) -> !llvm.ptr
    %45 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.mlir.constant(0 : index) : i64
    %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.insertvalue %39, %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %40, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = builtin.unrealized_conversion_cast %51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %53 = llvm.mlir.constant(16 : index) : i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.mlir.null : !llvm.ptr
    %56 = llvm.getelementptr %55[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %57 = llvm.ptrtoint %56 : !llvm.ptr to i64
    %58 = llvm.call @malloc(%57) : (i64) -> !llvm.ptr
    %59 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.mlir.constant(0 : index) : i64
    %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %64 = llvm.insertvalue %53, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %54, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = builtin.unrealized_conversion_cast %65 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %67 = llvm.mlir.constant(16 : index) : i64
    %68 = llvm.mlir.constant(1 : index) : i64
    %69 = llvm.mlir.null : !llvm.ptr
    %70 = llvm.getelementptr %69[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %71 = llvm.ptrtoint %70 : !llvm.ptr to i64
    %72 = llvm.call @malloc(%71) : (i64) -> !llvm.ptr
    %73 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %76 = llvm.mlir.constant(0 : index) : i64
    %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %78 = llvm.insertvalue %67, %77[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.insertvalue %68, %78[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = builtin.unrealized_conversion_cast %79 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %81 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %82 = llvm.insertvalue %c0_i64, %81[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %83 = llvm.insertvalue %c0_i64, %82[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %84 = llvm.insertvalue %c0_i64, %83[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %85 = llvm.insertvalue %c0_i64, %84[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %86 = llvm.insertvalue %c0_i64, %85[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %87 = llvm.insertvalue %c128_i64, %86[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %88 = llvm.getelementptr %16[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %88 : i64, !llvm.ptr
    %89 = llvm.insertvalue %c1_i64, %87[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %90 = llvm.insertvalue %c128_i64, %89[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %91 = llvm.getelementptr %44[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %91 : i64, !llvm.ptr
    %92 = llvm.insertvalue %c1_i64, %90[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %93 = llvm.insertvalue %c32_i64, %92[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %94 = llvm.getelementptr %16[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %94 : i64, !llvm.ptr
    %95 = llvm.insertvalue %c2_i64, %93[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %96 = llvm.mlir.constant(32 : index) : i64
    %97 = llvm.mlir.constant(1 : index) : i64
    %98 = llvm.mlir.null : !llvm.ptr
    %99 = llvm.getelementptr %98[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %100 = llvm.ptrtoint %99 : !llvm.ptr to i64
    %101 = llvm.call @malloc(%100) : (i64) -> !llvm.ptr
    %102 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %103 = llvm.insertvalue %101, %102[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.insertvalue %101, %103[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.mlir.constant(0 : index) : i64
    %106 = llvm.insertvalue %105, %104[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.insertvalue %96, %106[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %108 = llvm.insertvalue %97, %107[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.mlir.constant(32 : index) : i64
    %110 = llvm.mlir.constant(1 : index) : i64
    %111 = llvm.mlir.null : !llvm.ptr
    %112 = llvm.getelementptr %111[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %113 = llvm.ptrtoint %112 : !llvm.ptr to i64
    %114 = llvm.call @malloc(%113) : (i64) -> !llvm.ptr
    %115 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %116 = llvm.insertvalue %114, %115[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.insertvalue %114, %116[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %118 = llvm.mlir.constant(0 : index) : i64
    %119 = llvm.insertvalue %118, %117[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.insertvalue %109, %119[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.insertvalue %110, %120[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.mlir.constant(32 : index) : i64
    %123 = llvm.mlir.constant(1 : index) : i64
    %124 = llvm.mlir.null : !llvm.ptr
    %125 = llvm.getelementptr %124[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
    %127 = llvm.call @malloc(%126) : (i64) -> !llvm.ptr
    %128 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %129 = llvm.insertvalue %127, %128[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.insertvalue %127, %129[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %131 = llvm.mlir.constant(0 : index) : i64
    %132 = llvm.insertvalue %131, %130[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = llvm.insertvalue %122, %132[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.insertvalue %123, %133[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %135 = builtin.unrealized_conversion_cast %134 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%136: index):  // 2 preds: ^bb0, ^bb2
    %137 = builtin.unrealized_conversion_cast %136 : index to i64
    %138 = arith.cmpi slt, %136, %c32 : index
    cf.cond_br %138, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %139 = llvm.getelementptr %101[%137] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %139 : f32, !llvm.ptr
    %140 = arith.addi %136, %c1 : index
    cf.br ^bb1(%140 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%141: index):  // 2 preds: ^bb3, ^bb5
    %142 = builtin.unrealized_conversion_cast %141 : index to i64
    %143 = arith.cmpi slt, %141, %c32 : index
    cf.cond_br %143, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %144 = llvm.getelementptr %114[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %144 : i1, !llvm.ptr
    %145 = arith.addi %141, %c1 : index
    cf.br ^bb4(%145 : index)
  ^bb6:  // pred: ^bb4
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %148 = llvm.load %147 : !llvm.ptr -> i64
    %149 = builtin.unrealized_conversion_cast %148 : i64 to index
    %150 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %151 = llvm.getelementptr %150[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %152 = llvm.load %151 : !llvm.ptr -> i64
    %153 = builtin.unrealized_conversion_cast %152 : i64 to index
    cf.br ^bb7(%149, %24, %38, %52, %66, %80, %95 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%154: index, %155: memref<?xindex>, %156: memref<?xindex>, %157: memref<?xindex>, %158: memref<?xindex>, %159: memref<?xf32>, %160: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %161 = builtin.unrealized_conversion_cast %154 : index to i64
    %162 = builtin.unrealized_conversion_cast %157 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %163 = builtin.unrealized_conversion_cast %155 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %164 = builtin.unrealized_conversion_cast %156 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %165 = builtin.unrealized_conversion_cast %158 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %166 = builtin.unrealized_conversion_cast %159 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %167 = arith.cmpi slt, %154, %153 : index
    cf.cond_br %167, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %168 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %169 = llvm.getelementptr %168[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %170 = llvm.load %169 : !llvm.ptr -> i64
    %171 = builtin.unrealized_conversion_cast %170 : i64 to index
    %172 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %173 = llvm.getelementptr %172[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %174 = llvm.load %173 : !llvm.ptr -> i64
    %175 = builtin.unrealized_conversion_cast %174 : i64 to index
    %176 = arith.addi %154, %c1 : index
    %177 = builtin.unrealized_conversion_cast %176 : index to i64
    %178 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%177] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    cf.br ^bb9(%175, %155, %156, %157, %158, %159, %160 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%182: index, %183: memref<?xindex>, %184: memref<?xindex>, %185: memref<?xindex>, %186: memref<?xindex>, %187: memref<?xf32>, %188: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %189 = builtin.unrealized_conversion_cast %182 : index to i64
    %190 = arith.cmpi slt, %182, %181 : index
    cf.cond_br %190, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %191 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %192 = llvm.getelementptr %191[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %193 = llvm.load %192 : !llvm.ptr -> i64
    %194 = builtin.unrealized_conversion_cast %193 : i64 to index
    %195 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = builtin.unrealized_conversion_cast %197 : i64 to index
    %199 = arith.addi %182, %c1 : index
    %200 = builtin.unrealized_conversion_cast %199 : index to i64
    %201 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %203 = llvm.load %202 : !llvm.ptr -> i64
    %204 = builtin.unrealized_conversion_cast %203 : i64 to index
    cf.br ^bb11(%198, %c0 : index, index)
  ^bb11(%205: index, %206: index):  // 2 preds: ^bb10, ^bb19
    %207 = builtin.unrealized_conversion_cast %205 : index to i64
    %208 = arith.cmpi slt, %205, %204 : index
    cf.cond_br %208, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %209 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%207] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %214 = llvm.getelementptr %213[%207] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %215 = llvm.load %214 : !llvm.ptr -> f32
    cf.br ^bb13(%c0, %206 : index, index)
  ^bb13(%216: index, %217: index):  // 2 preds: ^bb12, ^bb18
    %218 = builtin.unrealized_conversion_cast %216 : index to i64
    %219 = builtin.unrealized_conversion_cast %217 : index to i64
    %220 = arith.cmpi slt, %216, %c32 : index
    cf.cond_br %220, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %221 = arith.muli %212, %c32 : index
    %222 = arith.addi %221, %216 : index
    %223 = builtin.unrealized_conversion_cast %222 : index to i64
    %224 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %225 = llvm.load %224 : !llvm.ptr -> f32
    %226 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %227 = llvm.getelementptr %226[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %228 = llvm.load %227 : !llvm.ptr -> f32
    %229 = arith.mulf %215, %228 : f32
    %230 = arith.addf %225, %229 : f32
    %231 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %232 = llvm.load %231 : !llvm.ptr -> i1
    %233 = arith.cmpi eq, %232, %false : i1
    cf.cond_br %233, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %234 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %true, %234 : i1, !llvm.ptr
    %235 = llvm.getelementptr %127[%219] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %218, %235 : i64, !llvm.ptr
    %236 = arith.addi %217, %c1 : index
    cf.br ^bb17(%236 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%217 : index)
  ^bb17(%237: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %238 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %230, %238 : f32, !llvm.ptr
    %239 = arith.addi %216, %c1 : index
    cf.br ^bb13(%239, %237 : index, index)
  ^bb19:  // pred: ^bb13
    %240 = arith.addi %205, %c1 : index
    cf.br ^bb11(%240, %217 : index, index)
  ^bb20:  // pred: ^bb11
    %241 = arith.index_cast %206 : index to i64
    %242 = "llvm.intr.ctlz"(%241) <{is_zero_poison = false}> : (i64) -> i64
    %243 = arith.subi %c64_i64, %242 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %206, %135, %243) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%244: index, %245: memref<?xindex>, %246: memref<?xindex>, %247: memref<?xindex>, %248: memref<?xindex>, %249: memref<?xf32>, %250: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %251 = builtin.unrealized_conversion_cast %244 : index to i64
    %252 = arith.cmpi slt, %244, %206 : index
    cf.cond_br %252, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %253 = llvm.getelementptr %127[%251] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = builtin.unrealized_conversion_cast %254 : i64 to index
    %256 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %257 = llvm.load %256 : !llvm.ptr -> f32
    %258:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%245, %246, %247, %248, %249, %250, %171, %194, %255, %257) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    %259 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %259 : f32, !llvm.ptr
    %260 = llvm.getelementptr %114[%254] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %260 : i1, !llvm.ptr
    %261 = arith.addi %244, %c1 : index
    cf.br ^bb21(%261, %258#0, %258#1, %258#2, %258#3, %258#4, %258#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %262 = arith.addi %182, %c1 : index
    cf.br ^bb9(%262, %245, %246, %247, %248, %249, %250 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %263 = arith.addi %154, %c1 : index
    cf.br ^bb7(%263, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%101) : (!llvm.ptr) -> ()
    llvm.call @free(%114) : (!llvm.ptr) -> ()
    llvm.call @free(%127) : (!llvm.ptr) -> ()
    %264 = llvm.extractvalue %160[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %265 = arith.index_cast %264 : i64 to index
    %266 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %267 = llvm.getelementptr %266[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %268 = llvm.load %267 : !llvm.ptr -> i64
    %269 = builtin.unrealized_conversion_cast %268 : i64 to index
    cf.br ^bb26(%c1, %269 : index, index)
  ^bb26(%270: index, %271: index):  // 2 preds: ^bb25, ^bb29
    %272 = builtin.unrealized_conversion_cast %270 : index to i64
    %273 = builtin.unrealized_conversion_cast %271 : index to i64
    %274 = arith.cmpi slt, %270, %265 : index
    cf.cond_br %274, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %275 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = arith.cmpi eq, %278, %c0 : index
    %280 = arith.select %279, %271, %278 : index
    cf.cond_br %279, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %281 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %282 = llvm.getelementptr %281[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %273, %282 : i64, !llvm.ptr
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %283 = arith.addi %270, %c1 : index
    cf.br ^bb26(%283, %280 : index, index)
  ^bb30:  // pred: ^bb26
    %284 = llvm.mlir.constant(4096 : index) : i64
    %285 = llvm.mlir.constant(1 : index) : i64
    %286 = llvm.mlir.null : !llvm.ptr
    %287 = llvm.getelementptr %286[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %288 = llvm.ptrtoint %287 : !llvm.ptr to i64
    %289 = llvm.call @malloc(%288) : (i64) -> !llvm.ptr
    %290 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %291 = llvm.insertvalue %289, %290[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %292 = llvm.insertvalue %289, %291[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %293 = llvm.mlir.constant(0 : index) : i64
    %294 = llvm.insertvalue %293, %292[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %295 = llvm.insertvalue %284, %294[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %296 = llvm.insertvalue %285, %295[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %297 = builtin.unrealized_conversion_cast %296 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %298 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %299 = llvm.insertvalue %c0_i64, %298[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %300 = llvm.insertvalue %c128_i64, %299[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %301 = llvm.insertvalue %c32_i64, %300[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%302: index):  // 2 preds: ^bb30, ^bb32
    %303 = builtin.unrealized_conversion_cast %302 : index to i64
    %304 = arith.cmpi slt, %302, %c4096 : index
    cf.cond_br %304, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %305 = llvm.getelementptr %289[%303] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %305 : f32, !llvm.ptr
    %306 = arith.addi %302, %c1 : index
    cf.br ^bb31(%306 : index)
  ^bb33:  // pred: ^bb31
    %307 = llvm.insertvalue %c4096_i64, %301[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %308 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%311) to (%315) step (%c1) {
        %316 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %317 = llvm.extractvalue %164[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %318 = llvm.getelementptr %317[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %319 = llvm.load %318 : !llvm.ptr -> i64
        %320 = builtin.unrealized_conversion_cast %319 : i64 to index
        %321 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %322 = llvm.getelementptr %321[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %323 = llvm.load %322 : !llvm.ptr -> i64
        %324 = builtin.unrealized_conversion_cast %323 : i64 to index
        %325 = arith.addi %arg12, %c1 : index
        %326 = builtin.unrealized_conversion_cast %325 : index to i64
        %327 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %328 = llvm.getelementptr %327[%326] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %329 = llvm.load %328 : !llvm.ptr -> i64
        %330 = builtin.unrealized_conversion_cast %329 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%324) to (%330) step (%c1) {
            %331 = builtin.unrealized_conversion_cast %arg13 : index to i64
            %332 = llvm.extractvalue %165[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %333 = llvm.getelementptr %332[%331] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %334 = llvm.load %333 : !llvm.ptr -> i64
            %335 = builtin.unrealized_conversion_cast %334 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %336 = arith.muli %arg13, %c32 : index
                %337 = arith.addi %336, %arg14 : index
                %338 = builtin.unrealized_conversion_cast %337 : index to i64
                %339 = arith.muli %335, %c32 : index
                %340 = arith.addi %339, %arg14 : index
                %341 = builtin.unrealized_conversion_cast %340 : index to i64
                %342 = arith.muli %320, %c32 : index
                %343 = arith.addi %342, %arg14 : index
                %344 = builtin.unrealized_conversion_cast %343 : index to i64
                %345 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %346 = llvm.load %345 : !llvm.ptr -> f32
                %347 = llvm.extractvalue %166[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %348 = llvm.getelementptr %347[%338] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %349 = llvm.load %348 : !llvm.ptr -> f32
                %350 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %351 = llvm.getelementptr %350[%341] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %352 = llvm.load %351 : !llvm.ptr -> f32
                %353 = arith.mulf %349, %352 : f32
                %354 = arith.addf %346, %353 : f32
                %355 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %354, %355 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %297, %307 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToLibm (convert-complex-to-libm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
    %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c1 = arith.constant 1 : index
    %7 = builtin.unrealized_conversion_cast %c1 : index to i64
    %c2 = arith.constant 2 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c32 = arith.constant 32 : index
    %false = arith.constant false
    %c0 = arith.constant 0 : index
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.subi %16, %c1 : index
    %20 = builtin.unrealized_conversion_cast %19 : index to i64
    %21 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %21, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = arith.cmpi eq, %25, %arg6 : index
    cf.br ^bb3(%26 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %28 = arith.select %27, %19, %18 : index
    %29 = builtin.unrealized_conversion_cast %28 : index to i64
    cf.cond_br %27, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %30 = arith.addi %18, %c1 : index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %31, %33 : i64, !llvm.ptr
    %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = builtin.unrealized_conversion_cast %35 : index to i64
    %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %35, %c1 : index
    %40 = arith.cmpi ugt, %39, %38 : index
    cf.cond_br %40, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %41 = arith.muli %38, %c2 : index
    %42 = builtin.unrealized_conversion_cast %41 : index to i64
    %43 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = builtin.unrealized_conversion_cast %41 : index to i64
    %45 = llvm.icmp "ugt" %44, %43 : i64
    llvm.cond_br %45, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %46 = llvm.mlir.null : !llvm.ptr
    %47 = llvm.getelementptr %46[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %48 = llvm.ptrtoint %47 : !llvm.ptr to i64
    %49 = llvm.mul %44, %48  : i64
    %50 = llvm.mul %43, %48  : i64
    %51 = llvm.call @malloc(%49) : (i64) -> !llvm.ptr
    %52 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%51, %52, %50) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %53 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%53) : (!llvm.ptr) -> ()
    %54 = llvm.insertvalue %51, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %51, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%55 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%56: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %57 = llvm.insertvalue %44, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = builtin.unrealized_conversion_cast %57 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb11(%58 : memref<?xindex>)
  ^bb10:  // pred: ^bb6
    cf.br ^bb11(%arg1 : memref<?xindex>)
  ^bb11(%59: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
    %60 = builtin.unrealized_conversion_cast %59 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    %61 = llvm.extractvalue %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.getelementptr %61[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %5, %62 : i64, !llvm.ptr
    %63 = arith.index_cast %39 : index to i64
    %64 = llvm.insertvalue %63, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %65 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %66 = arith.index_cast %65 : i64 to index
    %67 = builtin.unrealized_conversion_cast %66 : index to i64
    %68 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : i64 to index
    %70 = arith.addi %66, %c1 : index
    %71 = arith.cmpi ugt, %70, %69 : index
    cf.cond_br %71, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %72 = arith.muli %69, %c2 : index
    %73 = builtin.unrealized_conversion_cast %72 : index to i64
    %74 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = builtin.unrealized_conversion_cast %72 : index to i64
    %76 = llvm.icmp "ugt" %75, %74 : i64
    llvm.cond_br %76, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %77 = llvm.mlir.null : !llvm.ptr
    %78 = llvm.getelementptr %77[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %79 = llvm.ptrtoint %78 : !llvm.ptr to i64
    %80 = llvm.mul %75, %79  : i64
    %81 = llvm.mul %74, %79  : i64
    %82 = llvm.call @malloc(%80) : (i64) -> !llvm.ptr
    %83 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%82, %83, %81) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %84 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%84) : (!llvm.ptr) -> ()
    %85 = llvm.insertvalue %82, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %86 = llvm.insertvalue %82, %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%87: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %88 = llvm.insertvalue %75, %87[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = builtin.unrealized_conversion_cast %88 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb17(%89 : memref<?xindex>)
  ^bb16:  // pred: ^bb12
    cf.br ^bb17(%arg2 : memref<?xindex>)
  ^bb17(%90: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
    %91 = builtin.unrealized_conversion_cast %90 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %92 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %93 = llvm.getelementptr %92[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %8, %93 : i64, !llvm.ptr
    %94 = arith.index_cast %70 : index to i64
    %95 = llvm.insertvalue %94, %64[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb19(%59, %90, %95 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%96: memref<?xindex>, %97: memref<?xindex>, %98: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %99 = builtin.unrealized_conversion_cast %97 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %100 = arith.addi %28, %c1 : index
    %101 = builtin.unrealized_conversion_cast %100 : index to i64
    %102 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.getelementptr %102[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %104 = llvm.load %103 : !llvm.ptr -> i64
    %105 = builtin.unrealized_conversion_cast %104 : i64 to index
    %106 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %108 = llvm.load %107 : !llvm.ptr -> i64
    %109 = builtin.unrealized_conversion_cast %108 : i64 to index
    %110 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %111 = arith.index_cast %110 : i64 to index
    %112 = builtin.unrealized_conversion_cast %111 : index to i64
    %113 = arith.subi %109, %c1 : index
    %114 = builtin.unrealized_conversion_cast %113 : index to i64
    %115 = arith.cmpi ult, %105, %109 : index
    cf.cond_br %115, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %116 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %118 = llvm.load %117 : !llvm.ptr -> i64
    %119 = builtin.unrealized_conversion_cast %118 : i64 to index
    %120 = arith.cmpi eq, %119, %arg7 : index
    cf.br ^bb23(%120 : i1)
  ^bb22:  // pred: ^bb20
    %121 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.getelementptr %121[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %112, %122 : i64, !llvm.ptr
    cf.br ^bb23(%false : i1)
  ^bb23(%123: i1):  // 2 preds: ^bb21, ^bb22
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    %124 = arith.select %123, %113, %111 : index
    cf.cond_br %123, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    cf.br ^bb44(%arg3, %arg4, %98 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %125 = arith.addi %111, %c1 : index
    %126 = builtin.unrealized_conversion_cast %125 : index to i64
    %127 = llvm.extractvalue %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%101] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %126, %128 : i64, !llvm.ptr
    %129 = llvm.extractvalue %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %130 = arith.index_cast %129 : i64 to index
    %131 = builtin.unrealized_conversion_cast %130 : index to i64
    %132 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = builtin.unrealized_conversion_cast %132 : i64 to index
    %134 = arith.addi %130, %c1 : index
    %135 = arith.cmpi ugt, %134, %133 : index
    cf.cond_br %135, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %136 = arith.muli %133, %c2 : index
    %137 = builtin.unrealized_conversion_cast %136 : index to i64
    %138 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = builtin.unrealized_conversion_cast %136 : index to i64
    %140 = llvm.icmp "ugt" %139, %138 : i64
    llvm.cond_br %140, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %141 = llvm.mlir.null : !llvm.ptr
    %142 = llvm.getelementptr %141[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %143 = llvm.ptrtoint %142 : !llvm.ptr to i64
    %144 = llvm.mul %139, %143  : i64
    %145 = llvm.mul %138, %143  : i64
    %146 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
    %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%146, %147, %145) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %148 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%148) : (!llvm.ptr) -> ()
    %149 = llvm.insertvalue %146, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %150 = llvm.insertvalue %146, %149[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%150 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%151: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %152 = llvm.insertvalue %139, %151[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = builtin.unrealized_conversion_cast %152 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb31(%153 : memref<?xindex>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg3 : memref<?xindex>)
  ^bb31(%154: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
    %155 = builtin.unrealized_conversion_cast %154 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %156 = llvm.extractvalue %155[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %157 = llvm.getelementptr %156[%131] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %3, %157 : i64, !llvm.ptr
    %158 = arith.index_cast %134 : index to i64
    %159 = llvm.insertvalue %158, %98[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = llvm.extractvalue %98[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %161 = arith.index_cast %160 : i64 to index
    %162 = builtin.unrealized_conversion_cast %161 : index to i64
    %163 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = builtin.unrealized_conversion_cast %163 : i64 to index
    %165 = arith.addi %161, %c32 : index
    %166 = arith.cmpi ugt, %165, %164 : index
    cf.cond_br %166, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%164 : index)
  ^bb34(%167: index):  // 2 preds: ^bb33, ^bb34
    %168 = arith.muli %167, %c2 : index
    %169 = builtin.unrealized_conversion_cast %168 : index to i64
    %170 = arith.cmpi ugt, %165, %168 : index
    cf.cond_br %170, ^bb34(%168 : index), ^bb35
  ^bb35:  // pred: ^bb34
    %171 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = builtin.unrealized_conversion_cast %168 : index to i64
    %173 = llvm.icmp "ugt" %172, %171 : i64
    llvm.cond_br %173, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %174 = llvm.mlir.null : !llvm.ptr
    %175 = llvm.getelementptr %174[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %176 = llvm.ptrtoint %175 : !llvm.ptr to i64
    %177 = llvm.mul %172, %176  : i64
    %178 = llvm.mul %171, %176  : i64
    %179 = llvm.call @malloc(%177) : (i64) -> !llvm.ptr
    %180 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%179, %180, %178) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %181 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%181) : (!llvm.ptr) -> ()
    %182 = llvm.insertvalue %179, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.insertvalue %179, %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%183 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%184: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %185 = llvm.insertvalue %172, %184[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %186 = builtin.unrealized_conversion_cast %185 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    cf.br ^bb39(%186 : memref<?xf32>)
  ^bb38:  // pred: ^bb32
    cf.br ^bb39(%arg4 : memref<?xf32>)
  ^bb39(%187: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
    %188 = builtin.unrealized_conversion_cast %187 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %189 = llvm.extractvalue %188[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %190 = llvm.extractvalue %188[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %192 = llvm.insertvalue %189, %191[0] : !llvm.struct<(ptr, ptr, i64)> 
    %193 = llvm.insertvalue %190, %192[1] : !llvm.struct<(ptr, ptr, i64)> 
    %194 = llvm.mlir.constant(0 : index) : i64
    %195 = llvm.insertvalue %194, %193[2] : !llvm.struct<(ptr, ptr, i64)> 
    %196 = llvm.extractvalue %188[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.extractvalue %188[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %198 = llvm.extractvalue %188[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %200 = llvm.insertvalue %189, %199[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.insertvalue %190, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.insertvalue %162, %201[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %203 = llvm.mlir.constant(32 : index) : i64
    %204 = llvm.insertvalue %203, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %205 = llvm.mlir.constant(1 : index) : i64
    %206 = llvm.insertvalue %205, %204[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    cf.br ^bb41(%c0 : index)
  ^bb41(%207: index):  // 2 preds: ^bb40, ^bb42
    %208 = builtin.unrealized_conversion_cast %207 : index to i64
    %209 = arith.cmpi slt, %207, %c32 : index
    cf.cond_br %209, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %210 = llvm.getelementptr %190[%162] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %211 = llvm.getelementptr %210[%208] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %211 : f32, !llvm.ptr
    %212 = arith.addi %207, %c1 : index
    cf.br ^bb41(%212 : index)
  ^bb43:  // pred: ^bb41
    %213 = arith.index_cast %165 : index to i64
    %214 = llvm.insertvalue %213, %159[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb44(%154, %187, %214 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%215: memref<?xindex>, %216: memref<?xf32>, %217: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %218 = builtin.unrealized_conversion_cast %216 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb45
  ^bb45:  // pred: ^bb44
    %219 = arith.muli %124, %c32 : index
    %220 = arith.addi %219, %arg8 : index
    %221 = builtin.unrealized_conversion_cast %220 : index to i64
    %222 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%221] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg9, %223 : f32, !llvm.ptr
    return %arg0, %96, %97, %215, %216, %217 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
    %c1 = arith.constant 1 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
    %4 = arith.cmpi ult, %2, %3 : index
    cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
  ^bb2(%5: index, %6: index):  // pred: ^bb1
    %7 = arith.addi %5, %6 : index
    %8 = arith.shrui %7, %c1 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %8, %c1 : index
    %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %13 = llvm.load %12 : !llvm.ptr -> i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = arith.cmpi ult, %14, %18 : index
    %20 = arith.select %19, %5, %10 : index
    %21 = arith.select %19, %8, %6 : index
    cf.br ^bb1(%20, %21 : index, index)
  ^bb3:  // pred: ^bb1
    return %2 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %1 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%1 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
    %3 = builtin.unrealized_conversion_cast %2 : index to i64
    %4 = arith.cmpi slt, %2, %arg1 : index
    cf.cond_br %4, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %9 = llvm.load %8 : !llvm.ptr -> i64
    %10 = arith.subi %2, %5 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
    %12 = arith.cmpi slt, %11, %10 : index
    cf.cond_br %12, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %13 = arith.subi %2, %11 : index
    %14 = builtin.unrealized_conversion_cast %13 : index to i64
    %15 = arith.subi %13, %c1 : index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %19, %21 : i64, !llvm.ptr
    %22 = arith.addi %11, %c1 : index
    cf.br ^bb3(%22 : index)
  ^bb5:  // pred: ^bb3
    %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %24 : i64, !llvm.ptr
    %25 = arith.addi %2, %c1 : index
    cf.br ^bb1(%25 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %1 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %1, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %arg3, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.cmpi uge, %4, %2 : index
    cf.cond_br %5, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %6 = arith.shli %2, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = arith.addi %7, %arg0 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %6, %c2 : index
    %11 = arith.cmpi ult, %10, %arg3 : index
    cf.cond_br %11, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %12 = arith.addi %10, %arg0 : index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = builtin.unrealized_conversion_cast %16 : i64 to index
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = arith.cmpi ult, %17, %21 : index
    %23 = arith.select %22, %10, %7 : index
    %24 = arith.select %22, %12, %8 : index
    cf.br ^bb5(%23, %24, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%7, %8, %arg1 : index, index, index)
  ^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%27, %25, %26 : index, index, index)
  ^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
    cf.br ^bb7(%28, %29, %30 : index, index, index)
  ^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
    %34 = builtin.unrealized_conversion_cast %31 : index to i64
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = builtin.unrealized_conversion_cast %38 : i64 to index
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = arith.cmpi ult, %39, %43 : index
    cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
  ^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = builtin.unrealized_conversion_cast %47 : index to i64
    %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = arith.cmpi uge, %4, %46 : index
    cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
  ^bb9:  // pred: ^bb8
    %61 = arith.shli %46, %c1 : index
    %62 = arith.addi %61, %c1 : index
    %63 = arith.addi %62, %arg0 : index
    %64 = builtin.unrealized_conversion_cast %63 : index to i64
    %65 = arith.addi %61, %c2 : index
    %66 = arith.cmpi ult, %65, %arg3 : index
    cf.cond_br %66, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %67 = arith.addi %65, %arg0 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %75 = llvm.load %74 : !llvm.ptr -> i64
    %76 = builtin.unrealized_conversion_cast %75 : i64 to index
    %77 = arith.cmpi ult, %72, %76 : index
    %78 = arith.select %77, %65, %62 : index
    %79 = arith.select %77, %67, %63 : index
    cf.br ^bb12(%78, %79 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%62, %63 : index, index)
  ^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%80, %81 : index, index)
  ^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%82, %83, %47 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %2, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.addi %4, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = arith.subi %4, %6 : index
    %9 = arith.addi %arg0, %8 : index
    call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
    %10 = arith.addi %6, %c1 : index
    cf.br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    %11 = arith.subi %2, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
    %13 = arith.cmpi slt, %12, %11 : index
    cf.cond_br %13, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %14 = arith.subi %2, %12 : index
    %15 = arith.addi %arg0, %14 : index
    %16 = arith.subi %15, %c1 : index
    %17 = builtin.unrealized_conversion_cast %16 : index to i64
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    %28 = arith.subi %14, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
    %29 = arith.addi %12, %c1 : index
    cf.br ^bb4(%29 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %c1 = arith.constant 1 : index
    %c1000 = arith.constant 1000 : index
    %c-1 = arith.constant -1 : index
    %2 = arith.addi %arg0, %arg1 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = builtin.unrealized_conversion_cast %3 : index to i64
    %5 = arith.subi %arg1, %c1 : index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = arith.subi %arg1, %arg0 : index
    %8 = arith.cmpi ult, %7, %c1000 : index
    cf.cond_br %8, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %30 = llvm.load %29 : !llvm.ptr -> i64
    %31 = builtin.unrealized_conversion_cast %30 : i64 to index
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %34 = llvm.load %33 : !llvm.ptr -> i64
    %35 = builtin.unrealized_conversion_cast %34 : i64 to index
    %36 = arith.cmpi ult, %31, %35 : index
    cf.cond_br %36, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %42, %44 : i64, !llvm.ptr
    %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %39, %46 : i64, !llvm.ptr
    %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    %55 = arith.cmpi ult, %50, %54 : index
    cf.cond_br %55, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %58 = llvm.load %57 : !llvm.ptr -> i64
    %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %61 = llvm.load %60 : !llvm.ptr -> i64
    %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %61, %63 : i64, !llvm.ptr
    %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %58, %65 : i64, !llvm.ptr
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %5, %3 : index, index, index)
  ^bb8:  // pred: ^bb0
    %66 = arith.addi %arg0, %arg1 : index
    %67 = arith.shrui %66, %c1 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = arith.addi %3, %arg1 : index
    %70 = arith.shrui %69, %c1 : index
    %71 = builtin.unrealized_conversion_cast %70 : index to i64
    %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = arith.cmpi ult, %75, %79 : index
    cf.cond_br %80, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %86, %88 : i64, !llvm.ptr
    %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %83, %90 : i64, !llvm.ptr
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    %99 = arith.cmpi ult, %94, %98 : index
    cf.cond_br %99, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %105, %107 : i64, !llvm.ptr
    %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %102, %109 : i64, !llvm.ptr
    %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %113, %117 : index
    cf.cond_br %118, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %124 = llvm.load %123 : !llvm.ptr -> i64
    %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %128 : i64, !llvm.ptr
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %135 = llvm.load %134 : !llvm.ptr -> i64
    %136 = builtin.unrealized_conversion_cast %135 : i64 to index
    %137 = arith.cmpi ult, %132, %136 : index
    cf.cond_br %137, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %140 = llvm.load %139 : !llvm.ptr -> i64
    %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %143, %145 : i64, !llvm.ptr
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %140, %147 : i64, !llvm.ptr
    %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %154 = llvm.load %153 : !llvm.ptr -> i64
    %155 = builtin.unrealized_conversion_cast %154 : i64 to index
    %156 = arith.cmpi ult, %151, %155 : index
    cf.cond_br %156, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %162, %164 : i64, !llvm.ptr
    %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %159, %166 : i64, !llvm.ptr
    %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = builtin.unrealized_conversion_cast %173 : i64 to index
    %175 = arith.cmpi ult, %170, %174 : index
    cf.cond_br %175, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %178 = llvm.load %177 : !llvm.ptr -> i64
    %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %181 = llvm.load %180 : !llvm.ptr -> i64
    %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %181, %183 : i64, !llvm.ptr
    %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %178, %185 : i64, !llvm.ptr
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %192 = llvm.load %191 : !llvm.ptr -> i64
    %193 = builtin.unrealized_conversion_cast %192 : i64 to index
    %194 = arith.cmpi ult, %189, %193 : index
    cf.cond_br %194, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = arith.cmpi ult, %208, %212 : index
    cf.cond_br %213, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %219 = llvm.load %218 : !llvm.ptr -> i64
    %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %219, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %216, %223 : i64, !llvm.ptr
    %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = arith.cmpi ult, %227, %231 : index
    cf.cond_br %232, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %235 = llvm.load %234 : !llvm.ptr -> i64
    %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %238 = llvm.load %237 : !llvm.ptr -> i64
    %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %238, %240 : i64, !llvm.ptr
    %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %235, %242 : i64, !llvm.ptr
    %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %249 = llvm.load %248 : !llvm.ptr -> i64
    %250 = builtin.unrealized_conversion_cast %249 : i64 to index
    %251 = arith.cmpi ult, %246, %250 : index
    cf.cond_br %251, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %257 = llvm.load %256 : !llvm.ptr -> i64
    %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %257, %259 : i64, !llvm.ptr
    %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %254, %261 : i64, !llvm.ptr
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%262, %263, %264 : index, index, index)
  ^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
    %268 = arith.cmpi ult, %265, %266 : index
    cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
  ^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
    %272 = builtin.unrealized_conversion_cast %271 : index to i64
    cf.br ^bb30(%269 : index)
  ^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
    %274 = builtin.unrealized_conversion_cast %273 : index to i64
    %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = builtin.unrealized_conversion_cast %281 : i64 to index
    %283 = arith.cmpi ult, %278, %282 : index
    cf.cond_br %283, ^bb31(%273 : index), ^bb32
  ^bb31(%284: index):  // pred: ^bb30
    %285 = arith.addi %284, %c1 : index
    cf.br ^bb30(%285 : index)
  ^bb32:  // pred: ^bb30
    %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %288 = llvm.load %287 : !llvm.ptr -> i64
    %289 = builtin.unrealized_conversion_cast %288 : i64 to index
    %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %292 = llvm.load %291 : !llvm.ptr -> i64
    %293 = builtin.unrealized_conversion_cast %292 : i64 to index
    %294 = arith.cmpi eq, %289, %293 : index
    cf.br ^bb33(%270 : index)
  ^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
    %296 = builtin.unrealized_conversion_cast %295 : index to i64
    %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %299 = llvm.load %298 : !llvm.ptr -> i64
    %300 = builtin.unrealized_conversion_cast %299 : i64 to index
    %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %303 = llvm.load %302 : !llvm.ptr -> i64
    %304 = builtin.unrealized_conversion_cast %303 : i64 to index
    %305 = arith.cmpi ult, %300, %304 : index
    cf.cond_br %305, ^bb34(%295 : index), ^bb35
  ^bb34(%306: index):  // pred: ^bb33
    %307 = arith.addi %306, %c-1 : index
    cf.br ^bb33(%307 : index)
  ^bb35:  // pred: ^bb33
    %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    %316 = arith.cmpi eq, %311, %315 : index
    %317 = arith.cmpi ult, %273, %295 : index
    cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
  ^bb36:  // pred: ^bb35
    %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %320 = llvm.load %319 : !llvm.ptr -> i64
    %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %323 = llvm.load %322 : !llvm.ptr -> i64
    %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %323, %325 : i64, !llvm.ptr
    %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %320, %327 : i64, !llvm.ptr
    %328 = arith.cmpi eq, %273, %271 : index
    cf.cond_br %328, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%295 : index)
  ^bb38:  // pred: ^bb36
    %329 = arith.cmpi eq, %295, %271 : index
    %330 = arith.select %329, %273, %271 : index
    cf.br ^bb39(%330 : index)
  ^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %332 = arith.andi %294, %316 : i1
    cf.cond_br %332, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %333 = arith.addi %273, %c1 : index
    %334 = arith.subi %295, %c1 : index
    cf.br ^bb43(%333, %334 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%273, %295 : index, index)
  ^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%335, %336, %331 : index, index, index)
  ^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%337, %338, %339 : index, index, index)
  ^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
    cf.br ^bb27(%340, %341, %342 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %267 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c0 = arith.constant 0 : index
    %9 = builtin.unrealized_conversion_cast %c0 : index to i64
    %c32 = arith.constant 32 : index
    %c1 = arith.constant 1 : index
    %10 = builtin.unrealized_conversion_cast %c1 : index to i64
    %c4096 = arith.constant 4096 : index
    %c4096_i64 = arith.constant 4096 : i64
    %false = arith.constant false
    %c32_i64 = arith.constant 32 : i64
    %c128_i64 = arith.constant 128 : i64
    %c2_i64 = arith.constant 2 : i64
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c64_i64 = arith.constant 64 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %true = arith.constant true
    %11 = llvm.mlir.constant(16 : index) : i64
    %12 = llvm.mlir.constant(1 : index) : i64
    %13 = llvm.mlir.null : !llvm.ptr
    %14 = llvm.getelementptr %13[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
    %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
    %17 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.mlir.constant(0 : index) : i64
    %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %11, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %12, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = builtin.unrealized_conversion_cast %23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %25 = llvm.mlir.constant(16 : index) : i64
    %26 = llvm.mlir.constant(1 : index) : i64
    %27 = llvm.mlir.null : !llvm.ptr
    %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
    %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.mlir.constant(0 : index) : i64
    %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.insertvalue %25, %35[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %26, %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %39 = llvm.mlir.constant(16 : index) : i64
    %40 = llvm.mlir.constant(1 : index) : i64
    %41 = llvm.mlir.null : !llvm.ptr
    %42 = llvm.getelementptr %41[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %43 = llvm.ptrtoint %42 : !llvm.ptr to i64
    %44 = llvm.call @malloc(%43) : (i64) -> !llvm.ptr
    %45 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %46 = llvm.insertvalue %44, %45[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %44, %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.mlir.constant(0 : index) : i64
    %49 = llvm.insertvalue %48, %47[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.insertvalue %39, %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %40, %50[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = builtin.unrealized_conversion_cast %51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %53 = llvm.mlir.constant(16 : index) : i64
    %54 = llvm.mlir.constant(1 : index) : i64
    %55 = llvm.mlir.null : !llvm.ptr
    %56 = llvm.getelementptr %55[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %57 = llvm.ptrtoint %56 : !llvm.ptr to i64
    %58 = llvm.call @malloc(%57) : (i64) -> !llvm.ptr
    %59 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %60 = llvm.insertvalue %58, %59[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %58, %60[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.mlir.constant(0 : index) : i64
    %63 = llvm.insertvalue %62, %61[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %64 = llvm.insertvalue %53, %63[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %54, %64[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = builtin.unrealized_conversion_cast %65 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %67 = llvm.mlir.constant(16 : index) : i64
    %68 = llvm.mlir.constant(1 : index) : i64
    %69 = llvm.mlir.null : !llvm.ptr
    %70 = llvm.getelementptr %69[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %71 = llvm.ptrtoint %70 : !llvm.ptr to i64
    %72 = llvm.call @malloc(%71) : (i64) -> !llvm.ptr
    %73 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %74 = llvm.insertvalue %72, %73[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = llvm.insertvalue %72, %74[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %76 = llvm.mlir.constant(0 : index) : i64
    %77 = llvm.insertvalue %76, %75[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %78 = llvm.insertvalue %67, %77[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.insertvalue %68, %78[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = builtin.unrealized_conversion_cast %79 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %81 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %82 = llvm.insertvalue %c0_i64, %81[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %83 = llvm.insertvalue %c0_i64, %82[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %84 = llvm.insertvalue %c0_i64, %83[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %85 = llvm.insertvalue %c0_i64, %84[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %86 = llvm.insertvalue %c0_i64, %85[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %87 = llvm.insertvalue %c128_i64, %86[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %88 = llvm.getelementptr %16[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %88 : i64, !llvm.ptr
    %89 = llvm.insertvalue %c1_i64, %87[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %90 = llvm.insertvalue %c128_i64, %89[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %91 = llvm.getelementptr %44[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %91 : i64, !llvm.ptr
    %92 = llvm.insertvalue %c1_i64, %90[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %93 = llvm.insertvalue %c32_i64, %92[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %94 = llvm.getelementptr %16[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %94 : i64, !llvm.ptr
    %95 = llvm.insertvalue %c2_i64, %93[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %96 = llvm.mlir.constant(32 : index) : i64
    %97 = llvm.mlir.constant(1 : index) : i64
    %98 = llvm.mlir.null : !llvm.ptr
    %99 = llvm.getelementptr %98[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %100 = llvm.ptrtoint %99 : !llvm.ptr to i64
    %101 = llvm.call @malloc(%100) : (i64) -> !llvm.ptr
    %102 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %103 = llvm.insertvalue %101, %102[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.insertvalue %101, %103[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.mlir.constant(0 : index) : i64
    %106 = llvm.insertvalue %105, %104[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.insertvalue %96, %106[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %108 = llvm.insertvalue %97, %107[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.mlir.constant(32 : index) : i64
    %110 = llvm.mlir.constant(1 : index) : i64
    %111 = llvm.mlir.null : !llvm.ptr
    %112 = llvm.getelementptr %111[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %113 = llvm.ptrtoint %112 : !llvm.ptr to i64
    %114 = llvm.call @malloc(%113) : (i64) -> !llvm.ptr
    %115 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %116 = llvm.insertvalue %114, %115[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.insertvalue %114, %116[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %118 = llvm.mlir.constant(0 : index) : i64
    %119 = llvm.insertvalue %118, %117[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.insertvalue %109, %119[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.insertvalue %110, %120[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.mlir.constant(32 : index) : i64
    %123 = llvm.mlir.constant(1 : index) : i64
    %124 = llvm.mlir.null : !llvm.ptr
    %125 = llvm.getelementptr %124[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
    %127 = llvm.call @malloc(%126) : (i64) -> !llvm.ptr
    %128 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %129 = llvm.insertvalue %127, %128[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.insertvalue %127, %129[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %131 = llvm.mlir.constant(0 : index) : i64
    %132 = llvm.insertvalue %131, %130[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = llvm.insertvalue %122, %132[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.insertvalue %123, %133[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %135 = builtin.unrealized_conversion_cast %134 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%136: index):  // 2 preds: ^bb0, ^bb2
    %137 = builtin.unrealized_conversion_cast %136 : index to i64
    %138 = arith.cmpi slt, %136, %c32 : index
    cf.cond_br %138, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %139 = llvm.getelementptr %101[%137] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %139 : f32, !llvm.ptr
    %140 = arith.addi %136, %c1 : index
    cf.br ^bb1(%140 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%141: index):  // 2 preds: ^bb3, ^bb5
    %142 = builtin.unrealized_conversion_cast %141 : index to i64
    %143 = arith.cmpi slt, %141, %c32 : index
    cf.cond_br %143, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %144 = llvm.getelementptr %114[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %144 : i1, !llvm.ptr
    %145 = arith.addi %141, %c1 : index
    cf.br ^bb4(%145 : index)
  ^bb6:  // pred: ^bb4
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %148 = llvm.load %147 : !llvm.ptr -> i64
    %149 = builtin.unrealized_conversion_cast %148 : i64 to index
    %150 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %151 = llvm.getelementptr %150[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %152 = llvm.load %151 : !llvm.ptr -> i64
    %153 = builtin.unrealized_conversion_cast %152 : i64 to index
    cf.br ^bb7(%149, %24, %38, %52, %66, %80, %95 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%154: index, %155: memref<?xindex>, %156: memref<?xindex>, %157: memref<?xindex>, %158: memref<?xindex>, %159: memref<?xf32>, %160: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %161 = builtin.unrealized_conversion_cast %154 : index to i64
    %162 = builtin.unrealized_conversion_cast %157 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %163 = builtin.unrealized_conversion_cast %155 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %164 = builtin.unrealized_conversion_cast %156 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %165 = builtin.unrealized_conversion_cast %158 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %166 = builtin.unrealized_conversion_cast %159 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %167 = arith.cmpi slt, %154, %153 : index
    cf.cond_br %167, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %168 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %169 = llvm.getelementptr %168[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %170 = llvm.load %169 : !llvm.ptr -> i64
    %171 = builtin.unrealized_conversion_cast %170 : i64 to index
    %172 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %173 = llvm.getelementptr %172[%161] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %174 = llvm.load %173 : !llvm.ptr -> i64
    %175 = builtin.unrealized_conversion_cast %174 : i64 to index
    %176 = arith.addi %154, %c1 : index
    %177 = builtin.unrealized_conversion_cast %176 : index to i64
    %178 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%177] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    cf.br ^bb9(%175, %155, %156, %157, %158, %159, %160 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%182: index, %183: memref<?xindex>, %184: memref<?xindex>, %185: memref<?xindex>, %186: memref<?xindex>, %187: memref<?xf32>, %188: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %189 = builtin.unrealized_conversion_cast %182 : index to i64
    %190 = arith.cmpi slt, %182, %181 : index
    cf.cond_br %190, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %191 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %192 = llvm.getelementptr %191[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %193 = llvm.load %192 : !llvm.ptr -> i64
    %194 = builtin.unrealized_conversion_cast %193 : i64 to index
    %195 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%189] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = builtin.unrealized_conversion_cast %197 : i64 to index
    %199 = arith.addi %182, %c1 : index
    %200 = builtin.unrealized_conversion_cast %199 : index to i64
    %201 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %203 = llvm.load %202 : !llvm.ptr -> i64
    %204 = builtin.unrealized_conversion_cast %203 : i64 to index
    cf.br ^bb11(%198, %c0 : index, index)
  ^bb11(%205: index, %206: index):  // 2 preds: ^bb10, ^bb19
    %207 = builtin.unrealized_conversion_cast %205 : index to i64
    %208 = arith.cmpi slt, %205, %204 : index
    cf.cond_br %208, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %209 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%207] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %214 = llvm.getelementptr %213[%207] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %215 = llvm.load %214 : !llvm.ptr -> f32
    cf.br ^bb13(%c0, %206 : index, index)
  ^bb13(%216: index, %217: index):  // 2 preds: ^bb12, ^bb18
    %218 = builtin.unrealized_conversion_cast %216 : index to i64
    %219 = builtin.unrealized_conversion_cast %217 : index to i64
    %220 = arith.cmpi slt, %216, %c32 : index
    cf.cond_br %220, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %221 = arith.muli %212, %c32 : index
    %222 = arith.addi %221, %216 : index
    %223 = builtin.unrealized_conversion_cast %222 : index to i64
    %224 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %225 = llvm.load %224 : !llvm.ptr -> f32
    %226 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %227 = llvm.getelementptr %226[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %228 = llvm.load %227 : !llvm.ptr -> f32
    %229 = arith.mulf %215, %228 : f32
    %230 = arith.addf %225, %229 : f32
    %231 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %232 = llvm.load %231 : !llvm.ptr -> i1
    %233 = arith.cmpi eq, %232, %false : i1
    cf.cond_br %233, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %234 = llvm.getelementptr %114[%218] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %true, %234 : i1, !llvm.ptr
    %235 = llvm.getelementptr %127[%219] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %218, %235 : i64, !llvm.ptr
    %236 = arith.addi %217, %c1 : index
    cf.br ^bb17(%236 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%217 : index)
  ^bb17(%237: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %238 = llvm.getelementptr %101[%218] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %230, %238 : f32, !llvm.ptr
    %239 = arith.addi %216, %c1 : index
    cf.br ^bb13(%239, %237 : index, index)
  ^bb19:  // pred: ^bb13
    %240 = arith.addi %205, %c1 : index
    cf.br ^bb11(%240, %217 : index, index)
  ^bb20:  // pred: ^bb11
    %241 = arith.index_cast %206 : index to i64
    %242 = "llvm.intr.ctlz"(%241) <{is_zero_poison = false}> : (i64) -> i64
    %243 = arith.subi %c64_i64, %242 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %206, %135, %243) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%244: index, %245: memref<?xindex>, %246: memref<?xindex>, %247: memref<?xindex>, %248: memref<?xindex>, %249: memref<?xf32>, %250: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %251 = builtin.unrealized_conversion_cast %244 : index to i64
    %252 = arith.cmpi slt, %244, %206 : index
    cf.cond_br %252, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %253 = llvm.getelementptr %127[%251] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = builtin.unrealized_conversion_cast %254 : i64 to index
    %256 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %257 = llvm.load %256 : !llvm.ptr -> f32
    %258:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%245, %246, %247, %248, %249, %250, %171, %194, %255, %257) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    %259 = llvm.getelementptr %101[%254] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %259 : f32, !llvm.ptr
    %260 = llvm.getelementptr %114[%254] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %260 : i1, !llvm.ptr
    %261 = arith.addi %244, %c1 : index
    cf.br ^bb21(%261, %258#0, %258#1, %258#2, %258#3, %258#4, %258#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %262 = arith.addi %182, %c1 : index
    cf.br ^bb9(%262, %245, %246, %247, %248, %249, %250 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %263 = arith.addi %154, %c1 : index
    cf.br ^bb7(%263, %183, %184, %185, %186, %187, %188 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%101) : (!llvm.ptr) -> ()
    llvm.call @free(%114) : (!llvm.ptr) -> ()
    llvm.call @free(%127) : (!llvm.ptr) -> ()
    %264 = llvm.extractvalue %160[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %265 = arith.index_cast %264 : i64 to index
    %266 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %267 = llvm.getelementptr %266[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %268 = llvm.load %267 : !llvm.ptr -> i64
    %269 = builtin.unrealized_conversion_cast %268 : i64 to index
    cf.br ^bb26(%c1, %269 : index, index)
  ^bb26(%270: index, %271: index):  // 2 preds: ^bb25, ^bb29
    %272 = builtin.unrealized_conversion_cast %270 : index to i64
    %273 = builtin.unrealized_conversion_cast %271 : index to i64
    %274 = arith.cmpi slt, %270, %265 : index
    cf.cond_br %274, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %275 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = arith.cmpi eq, %278, %c0 : index
    %280 = arith.select %279, %271, %278 : index
    cf.cond_br %279, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %281 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %282 = llvm.getelementptr %281[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %273, %282 : i64, !llvm.ptr
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %283 = arith.addi %270, %c1 : index
    cf.br ^bb26(%283, %280 : index, index)
  ^bb30:  // pred: ^bb26
    %284 = llvm.mlir.constant(4096 : index) : i64
    %285 = llvm.mlir.constant(1 : index) : i64
    %286 = llvm.mlir.null : !llvm.ptr
    %287 = llvm.getelementptr %286[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %288 = llvm.ptrtoint %287 : !llvm.ptr to i64
    %289 = llvm.call @malloc(%288) : (i64) -> !llvm.ptr
    %290 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %291 = llvm.insertvalue %289, %290[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %292 = llvm.insertvalue %289, %291[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %293 = llvm.mlir.constant(0 : index) : i64
    %294 = llvm.insertvalue %293, %292[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %295 = llvm.insertvalue %284, %294[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %296 = llvm.insertvalue %285, %295[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %297 = builtin.unrealized_conversion_cast %296 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %298 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %299 = llvm.insertvalue %c0_i64, %298[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %300 = llvm.insertvalue %c128_i64, %299[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %301 = llvm.insertvalue %c32_i64, %300[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%302: index):  // 2 preds: ^bb30, ^bb32
    %303 = builtin.unrealized_conversion_cast %302 : index to i64
    %304 = arith.cmpi slt, %302, %c4096 : index
    cf.cond_br %304, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %305 = llvm.getelementptr %289[%303] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %305 : f32, !llvm.ptr
    %306 = arith.addi %302, %c1 : index
    cf.br ^bb31(%306 : index)
  ^bb33:  // pred: ^bb31
    %307 = llvm.insertvalue %c4096_i64, %301[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %308 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %163[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%311) to (%315) step (%c1) {
        %316 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %317 = llvm.extractvalue %164[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %318 = llvm.getelementptr %317[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %319 = llvm.load %318 : !llvm.ptr -> i64
        %320 = builtin.unrealized_conversion_cast %319 : i64 to index
        %321 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %322 = llvm.getelementptr %321[%316] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %323 = llvm.load %322 : !llvm.ptr -> i64
        %324 = builtin.unrealized_conversion_cast %323 : i64 to index
        %325 = arith.addi %arg12, %c1 : index
        %326 = builtin.unrealized_conversion_cast %325 : index to i64
        %327 = llvm.extractvalue %162[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %328 = llvm.getelementptr %327[%326] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %329 = llvm.load %328 : !llvm.ptr -> i64
        %330 = builtin.unrealized_conversion_cast %329 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%324) to (%330) step (%c1) {
            %331 = builtin.unrealized_conversion_cast %arg13 : index to i64
            %332 = llvm.extractvalue %165[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %333 = llvm.getelementptr %332[%331] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %334 = llvm.load %333 : !llvm.ptr -> i64
            %335 = builtin.unrealized_conversion_cast %334 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %336 = arith.muli %arg13, %c32 : index
                %337 = arith.addi %336, %arg14 : index
                %338 = builtin.unrealized_conversion_cast %337 : index to i64
                %339 = arith.muli %335, %c32 : index
                %340 = arith.addi %339, %arg14 : index
                %341 = builtin.unrealized_conversion_cast %340 : index to i64
                %342 = arith.muli %320, %c32 : index
                %343 = arith.addi %342, %arg14 : index
                %344 = builtin.unrealized_conversion_cast %343 : index to i64
                %345 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %346 = llvm.load %345 : !llvm.ptr -> f32
                %347 = llvm.extractvalue %166[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %348 = llvm.getelementptr %347[%338] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %349 = llvm.load %348 : !llvm.ptr -> f32
                %350 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %351 = llvm.getelementptr %350[%341] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %352 = llvm.load %351 : !llvm.ptr -> f32
                %353 = arith.mulf %349, %352 : f32
                %354 = arith.addf %346, %353 : f32
                %355 = llvm.getelementptr %289[%344] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %354, %355 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %297, %307 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c0 = arith.constant 0 : index
    %false = arith.constant false
    %c32 = arith.constant 32 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
    %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %c1 : index to i64
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.subi %16, %c1 : index
    %20 = builtin.unrealized_conversion_cast %19 : index to i64
    %21 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %21, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = arith.cmpi eq, %25, %arg6 : index
    cf.br ^bb3(%26 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %28 = arith.select %27, %19, %18 : index
    %29 = builtin.unrealized_conversion_cast %28 : index to i64
    cf.cond_br %27, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %30 = arith.addi %18, %c1 : index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %31, %33 : i64, !llvm.ptr
    %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = builtin.unrealized_conversion_cast %35 : index to i64
    %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %35, %c1 : index
    %40 = arith.cmpi ugt, %39, %38 : index
    cf.cond_br %40, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %41 = arith.muli %38, %c2 : index
    %42 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %43 = builtin.unrealized_conversion_cast %41 : index to i64
    %44 = llvm.icmp "ugt" %43, %42 : i64
    llvm.cond_br %44, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %45 = llvm.mlir.null : !llvm.ptr
    %46 = llvm.getelementptr %45[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mul %43, %47  : i64
    %49 = llvm.mul %42, %47  : i64
    %50 = llvm.call @malloc(%48) : (i64) -> !llvm.ptr
    %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%50, %51, %49) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %52 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%52) : (!llvm.ptr) -> ()
    %53 = llvm.insertvalue %50, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %50, %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%55: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %56 = llvm.insertvalue %43, %55[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = builtin.unrealized_conversion_cast %56 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb11(%57 : memref<?xindex>)
  ^bb10:  // pred: ^bb6
    cf.br ^bb11(%arg1 : memref<?xindex>)
  ^bb11(%58: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
    %59 = builtin.unrealized_conversion_cast %58 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    %60 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.getelementptr %60[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %5, %61 : i64, !llvm.ptr
    %62 = arith.index_cast %39 : index to i64
    %63 = llvm.insertvalue %62, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %64 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %65 = arith.index_cast %64 : i64 to index
    %66 = builtin.unrealized_conversion_cast %65 : index to i64
    %67 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = builtin.unrealized_conversion_cast %67 : i64 to index
    %69 = arith.addi %65, %c1 : index
    %70 = arith.cmpi ugt, %69, %68 : index
    cf.cond_br %70, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %71 = arith.muli %68, %c2 : index
    %72 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = builtin.unrealized_conversion_cast %71 : index to i64
    %74 = llvm.icmp "ugt" %73, %72 : i64
    llvm.cond_br %74, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %75 = llvm.mlir.null : !llvm.ptr
    %76 = llvm.getelementptr %75[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %77 = llvm.ptrtoint %76 : !llvm.ptr to i64
    %78 = llvm.mul %73, %77  : i64
    %79 = llvm.mul %72, %77  : i64
    %80 = llvm.call @malloc(%78) : (i64) -> !llvm.ptr
    %81 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%80, %81, %79) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %82 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%82) : (!llvm.ptr) -> ()
    %83 = llvm.insertvalue %80, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %84 = llvm.insertvalue %80, %83[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%84 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%85: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %86 = llvm.insertvalue %73, %85[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = builtin.unrealized_conversion_cast %86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb17(%87 : memref<?xindex>)
  ^bb16:  // pred: ^bb12
    cf.br ^bb17(%arg2 : memref<?xindex>)
  ^bb17(%88: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
    %89 = builtin.unrealized_conversion_cast %88 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %90 = llvm.extractvalue %89[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.getelementptr %90[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %8, %91 : i64, !llvm.ptr
    %92 = arith.index_cast %69 : index to i64
    %93 = llvm.insertvalue %92, %63[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb19(%58, %88, %93 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%94: memref<?xindex>, %95: memref<?xindex>, %96: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %97 = builtin.unrealized_conversion_cast %95 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %98 = arith.addi %28, %c1 : index
    %99 = builtin.unrealized_conversion_cast %98 : index to i64
    %100 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = builtin.unrealized_conversion_cast %102 : i64 to index
    %104 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.getelementptr %104[%99] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %106 = llvm.load %105 : !llvm.ptr -> i64
    %107 = builtin.unrealized_conversion_cast %106 : i64 to index
    %108 = llvm.extractvalue %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %109 = arith.index_cast %108 : i64 to index
    %110 = builtin.unrealized_conversion_cast %109 : index to i64
    %111 = arith.subi %107, %c1 : index
    %112 = builtin.unrealized_conversion_cast %111 : index to i64
    %113 = arith.cmpi ult, %103, %107 : index
    cf.cond_br %113, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %114 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%112] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi eq, %117, %arg7 : index
    cf.br ^bb23(%118 : i1)
  ^bb22:  // pred: ^bb20
    %119 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %110, %120 : i64, !llvm.ptr
    cf.br ^bb23(%false : i1)
  ^bb23(%121: i1):  // 2 preds: ^bb21, ^bb22
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    %122 = arith.select %121, %111, %109 : index
    cf.cond_br %121, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    cf.br ^bb44(%arg3, %arg4, %96 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %123 = arith.addi %109, %c1 : index
    %124 = builtin.unrealized_conversion_cast %123 : index to i64
    %125 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%99] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %128 = arith.index_cast %127 : i64 to index
    %129 = builtin.unrealized_conversion_cast %128 : index to i64
    %130 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %131 = builtin.unrealized_conversion_cast %130 : i64 to index
    %132 = arith.addi %128, %c1 : index
    %133 = arith.cmpi ugt, %132, %131 : index
    cf.cond_br %133, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %134 = arith.muli %131, %c2 : index
    %135 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = builtin.unrealized_conversion_cast %134 : index to i64
    %137 = llvm.icmp "ugt" %136, %135 : i64
    llvm.cond_br %137, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %138 = llvm.mlir.null : !llvm.ptr
    %139 = llvm.getelementptr %138[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %140 = llvm.ptrtoint %139 : !llvm.ptr to i64
    %141 = llvm.mul %136, %140  : i64
    %142 = llvm.mul %135, %140  : i64
    %143 = llvm.call @malloc(%141) : (i64) -> !llvm.ptr
    %144 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%143, %144, %142) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %145 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%145) : (!llvm.ptr) -> ()
    %146 = llvm.insertvalue %143, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.insertvalue %143, %146[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%147 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%148: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %149 = llvm.insertvalue %136, %148[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %150 = builtin.unrealized_conversion_cast %149 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb31(%150 : memref<?xindex>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg3 : memref<?xindex>)
  ^bb31(%151: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
    %152 = builtin.unrealized_conversion_cast %151 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %153 = llvm.extractvalue %152[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %154 = llvm.getelementptr %153[%129] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %3, %154 : i64, !llvm.ptr
    %155 = arith.index_cast %132 : index to i64
    %156 = llvm.insertvalue %155, %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %157 = llvm.extractvalue %96[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %158 = arith.index_cast %157 : i64 to index
    %159 = builtin.unrealized_conversion_cast %158 : index to i64
    %160 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = builtin.unrealized_conversion_cast %160 : i64 to index
    %162 = arith.addi %158, %c32 : index
    %163 = arith.cmpi ugt, %162, %161 : index
    cf.cond_br %163, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%161 : index)
  ^bb34(%164: index):  // 2 preds: ^bb33, ^bb34
    %165 = arith.muli %164, %c2 : index
    %166 = arith.cmpi ugt, %162, %165 : index
    cf.cond_br %166, ^bb34(%165 : index), ^bb35
  ^bb35:  // pred: ^bb34
    %167 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = builtin.unrealized_conversion_cast %165 : index to i64
    %169 = llvm.icmp "ugt" %168, %167 : i64
    llvm.cond_br %169, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %170 = llvm.mlir.null : !llvm.ptr
    %171 = llvm.getelementptr %170[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %172 = llvm.ptrtoint %171 : !llvm.ptr to i64
    %173 = llvm.mul %168, %172  : i64
    %174 = llvm.mul %167, %172  : i64
    %175 = llvm.call @malloc(%173) : (i64) -> !llvm.ptr
    %176 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%175, %176, %174) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %177 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%177) : (!llvm.ptr) -> ()
    %178 = llvm.insertvalue %175, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.insertvalue %175, %178[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%179 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%180: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %181 = llvm.insertvalue %168, %180[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = builtin.unrealized_conversion_cast %181 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    cf.br ^bb39(%182 : memref<?xf32>)
  ^bb38:  // pred: ^bb32
    cf.br ^bb39(%arg4 : memref<?xf32>)
  ^bb39(%183: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
    %184 = builtin.unrealized_conversion_cast %183 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %185 = llvm.extractvalue %184[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    cf.br ^bb41(%c0 : index)
  ^bb41(%186: index):  // 2 preds: ^bb40, ^bb42
    %187 = builtin.unrealized_conversion_cast %186 : index to i64
    %188 = arith.cmpi slt, %186, %c32 : index
    cf.cond_br %188, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %189 = llvm.getelementptr %185[%159] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %190 = llvm.getelementptr %189[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %190 : f32, !llvm.ptr
    %191 = arith.addi %186, %c1 : index
    cf.br ^bb41(%191 : index)
  ^bb43:  // pred: ^bb41
    %192 = arith.index_cast %162 : index to i64
    %193 = llvm.insertvalue %192, %156[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb44(%151, %183, %193 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%194: memref<?xindex>, %195: memref<?xf32>, %196: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %197 = builtin.unrealized_conversion_cast %195 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb45
  ^bb45:  // pred: ^bb44
    %198 = arith.muli %122, %c32 : index
    %199 = arith.addi %198, %arg8 : index
    %200 = builtin.unrealized_conversion_cast %199 : index to i64
    %201 = llvm.extractvalue %197[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg9, %202 : f32, !llvm.ptr
    return %arg0, %94, %95, %194, %195, %196 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
    %4 = arith.cmpi ult, %2, %3 : index
    cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
  ^bb2(%5: index, %6: index):  // pred: ^bb1
    %7 = arith.addi %5, %6 : index
    %8 = arith.shrui %7, %c1 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %8, %c1 : index
    %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %13 = llvm.load %12 : !llvm.ptr -> i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = arith.cmpi ult, %14, %18 : index
    %20 = arith.select %19, %5, %10 : index
    %21 = arith.select %19, %8, %6 : index
    cf.br ^bb1(%20, %21 : index, index)
  ^bb3:  // pred: ^bb1
    return %2 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%1 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
    %3 = builtin.unrealized_conversion_cast %2 : index to i64
    %4 = arith.cmpi slt, %2, %arg1 : index
    cf.cond_br %4, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %9 = llvm.load %8 : !llvm.ptr -> i64
    %10 = arith.subi %2, %5 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
    %12 = arith.cmpi slt, %11, %10 : index
    cf.cond_br %12, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %13 = arith.subi %2, %11 : index
    %14 = builtin.unrealized_conversion_cast %13 : index to i64
    %15 = arith.subi %13, %c1 : index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %19, %21 : i64, !llvm.ptr
    %22 = arith.addi %11, %c1 : index
    cf.br ^bb3(%22 : index)
  ^bb5:  // pred: ^bb3
    %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %24 : i64, !llvm.ptr
    %25 = arith.addi %2, %c1 : index
    cf.br ^bb1(%25 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %1, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %arg3, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.cmpi uge, %4, %2 : index
    cf.cond_br %5, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %6 = arith.shli %2, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = arith.addi %7, %arg0 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %6, %c2 : index
    %11 = arith.cmpi ult, %10, %arg3 : index
    cf.cond_br %11, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %12 = arith.addi %10, %arg0 : index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = builtin.unrealized_conversion_cast %16 : i64 to index
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = arith.cmpi ult, %17, %21 : index
    %23 = arith.select %22, %10, %7 : index
    %24 = arith.select %22, %12, %8 : index
    cf.br ^bb5(%23, %24, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%7, %8, %arg1 : index, index, index)
  ^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%27, %25, %26 : index, index, index)
  ^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
    cf.br ^bb7(%28, %29, %30 : index, index, index)
  ^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
    %34 = builtin.unrealized_conversion_cast %31 : index to i64
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = builtin.unrealized_conversion_cast %38 : i64 to index
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = arith.cmpi ult, %39, %43 : index
    cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
  ^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = builtin.unrealized_conversion_cast %47 : index to i64
    %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = arith.cmpi uge, %4, %46 : index
    cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
  ^bb9:  // pred: ^bb8
    %61 = arith.shli %46, %c1 : index
    %62 = arith.addi %61, %c1 : index
    %63 = arith.addi %62, %arg0 : index
    %64 = builtin.unrealized_conversion_cast %63 : index to i64
    %65 = arith.addi %61, %c2 : index
    %66 = arith.cmpi ult, %65, %arg3 : index
    cf.cond_br %66, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %67 = arith.addi %65, %arg0 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %75 = llvm.load %74 : !llvm.ptr -> i64
    %76 = builtin.unrealized_conversion_cast %75 : i64 to index
    %77 = arith.cmpi ult, %72, %76 : index
    %78 = arith.select %77, %65, %62 : index
    %79 = arith.select %77, %67, %63 : index
    cf.br ^bb12(%78, %79 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%62, %63 : index, index)
  ^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%80, %81 : index, index)
  ^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%82, %83, %47 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %2, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.addi %4, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = arith.subi %4, %6 : index
    %9 = arith.addi %arg0, %8 : index
    call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
    %10 = arith.addi %6, %c1 : index
    cf.br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    %11 = arith.subi %2, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
    %13 = arith.cmpi slt, %12, %11 : index
    cf.cond_br %13, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %14 = arith.subi %2, %12 : index
    %15 = arith.addi %arg0, %14 : index
    %16 = arith.subi %15, %c1 : index
    %17 = builtin.unrealized_conversion_cast %16 : index to i64
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    %28 = arith.subi %14, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
    %29 = arith.addi %12, %c1 : index
    cf.br ^bb4(%29 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c-1 = arith.constant -1 : index
    %c1000 = arith.constant 1000 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %2 = arith.addi %arg0, %arg1 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = builtin.unrealized_conversion_cast %3 : index to i64
    %5 = arith.subi %arg1, %c1 : index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = arith.subi %arg1, %arg0 : index
    %8 = arith.cmpi ult, %7, %c1000 : index
    cf.cond_br %8, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %30 = llvm.load %29 : !llvm.ptr -> i64
    %31 = builtin.unrealized_conversion_cast %30 : i64 to index
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %34 = llvm.load %33 : !llvm.ptr -> i64
    %35 = builtin.unrealized_conversion_cast %34 : i64 to index
    %36 = arith.cmpi ult, %31, %35 : index
    cf.cond_br %36, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %42, %44 : i64, !llvm.ptr
    %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %39, %46 : i64, !llvm.ptr
    %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    %55 = arith.cmpi ult, %50, %54 : index
    cf.cond_br %55, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %58 = llvm.load %57 : !llvm.ptr -> i64
    %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %61 = llvm.load %60 : !llvm.ptr -> i64
    %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %61, %63 : i64, !llvm.ptr
    %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %58, %65 : i64, !llvm.ptr
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %5, %3 : index, index, index)
  ^bb8:  // pred: ^bb0
    %66 = arith.addi %arg0, %arg1 : index
    %67 = arith.shrui %66, %c1 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = arith.addi %3, %arg1 : index
    %70 = arith.shrui %69, %c1 : index
    %71 = builtin.unrealized_conversion_cast %70 : index to i64
    %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = arith.cmpi ult, %75, %79 : index
    cf.cond_br %80, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %86, %88 : i64, !llvm.ptr
    %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %83, %90 : i64, !llvm.ptr
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    %99 = arith.cmpi ult, %94, %98 : index
    cf.cond_br %99, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %105, %107 : i64, !llvm.ptr
    %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %102, %109 : i64, !llvm.ptr
    %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %113, %117 : index
    cf.cond_br %118, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %124 = llvm.load %123 : !llvm.ptr -> i64
    %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %128 : i64, !llvm.ptr
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %135 = llvm.load %134 : !llvm.ptr -> i64
    %136 = builtin.unrealized_conversion_cast %135 : i64 to index
    %137 = arith.cmpi ult, %132, %136 : index
    cf.cond_br %137, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %140 = llvm.load %139 : !llvm.ptr -> i64
    %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %143, %145 : i64, !llvm.ptr
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %140, %147 : i64, !llvm.ptr
    %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %154 = llvm.load %153 : !llvm.ptr -> i64
    %155 = builtin.unrealized_conversion_cast %154 : i64 to index
    %156 = arith.cmpi ult, %151, %155 : index
    cf.cond_br %156, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %162, %164 : i64, !llvm.ptr
    %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %159, %166 : i64, !llvm.ptr
    %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = builtin.unrealized_conversion_cast %173 : i64 to index
    %175 = arith.cmpi ult, %170, %174 : index
    cf.cond_br %175, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %178 = llvm.load %177 : !llvm.ptr -> i64
    %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %181 = llvm.load %180 : !llvm.ptr -> i64
    %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %181, %183 : i64, !llvm.ptr
    %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %178, %185 : i64, !llvm.ptr
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %192 = llvm.load %191 : !llvm.ptr -> i64
    %193 = builtin.unrealized_conversion_cast %192 : i64 to index
    %194 = arith.cmpi ult, %189, %193 : index
    cf.cond_br %194, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = arith.cmpi ult, %208, %212 : index
    cf.cond_br %213, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %219 = llvm.load %218 : !llvm.ptr -> i64
    %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %219, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %216, %223 : i64, !llvm.ptr
    %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = arith.cmpi ult, %227, %231 : index
    cf.cond_br %232, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %235 = llvm.load %234 : !llvm.ptr -> i64
    %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %238 = llvm.load %237 : !llvm.ptr -> i64
    %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %238, %240 : i64, !llvm.ptr
    %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %235, %242 : i64, !llvm.ptr
    %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %249 = llvm.load %248 : !llvm.ptr -> i64
    %250 = builtin.unrealized_conversion_cast %249 : i64 to index
    %251 = arith.cmpi ult, %246, %250 : index
    cf.cond_br %251, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %257 = llvm.load %256 : !llvm.ptr -> i64
    %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %257, %259 : i64, !llvm.ptr
    %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %254, %261 : i64, !llvm.ptr
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%262, %263, %264 : index, index, index)
  ^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
    %268 = arith.cmpi ult, %265, %266 : index
    cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
  ^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
    %272 = builtin.unrealized_conversion_cast %271 : index to i64
    cf.br ^bb30(%269 : index)
  ^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
    %274 = builtin.unrealized_conversion_cast %273 : index to i64
    %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = builtin.unrealized_conversion_cast %281 : i64 to index
    %283 = arith.cmpi ult, %278, %282 : index
    cf.cond_br %283, ^bb31(%273 : index), ^bb32
  ^bb31(%284: index):  // pred: ^bb30
    %285 = arith.addi %284, %c1 : index
    cf.br ^bb30(%285 : index)
  ^bb32:  // pred: ^bb30
    %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %288 = llvm.load %287 : !llvm.ptr -> i64
    %289 = builtin.unrealized_conversion_cast %288 : i64 to index
    %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %292 = llvm.load %291 : !llvm.ptr -> i64
    %293 = builtin.unrealized_conversion_cast %292 : i64 to index
    %294 = arith.cmpi eq, %289, %293 : index
    cf.br ^bb33(%270 : index)
  ^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
    %296 = builtin.unrealized_conversion_cast %295 : index to i64
    %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %299 = llvm.load %298 : !llvm.ptr -> i64
    %300 = builtin.unrealized_conversion_cast %299 : i64 to index
    %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %303 = llvm.load %302 : !llvm.ptr -> i64
    %304 = builtin.unrealized_conversion_cast %303 : i64 to index
    %305 = arith.cmpi ult, %300, %304 : index
    cf.cond_br %305, ^bb34(%295 : index), ^bb35
  ^bb34(%306: index):  // pred: ^bb33
    %307 = arith.addi %306, %c-1 : index
    cf.br ^bb33(%307 : index)
  ^bb35:  // pred: ^bb33
    %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    %316 = arith.cmpi eq, %311, %315 : index
    %317 = arith.cmpi ult, %273, %295 : index
    cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
  ^bb36:  // pred: ^bb35
    %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %320 = llvm.load %319 : !llvm.ptr -> i64
    %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %323 = llvm.load %322 : !llvm.ptr -> i64
    %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %323, %325 : i64, !llvm.ptr
    %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %320, %327 : i64, !llvm.ptr
    %328 = arith.cmpi eq, %273, %271 : index
    cf.cond_br %328, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%295 : index)
  ^bb38:  // pred: ^bb36
    %329 = arith.cmpi eq, %295, %271 : index
    %330 = arith.select %329, %273, %271 : index
    cf.br ^bb39(%330 : index)
  ^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %332 = arith.andi %294, %316 : i1
    cf.cond_br %332, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %333 = arith.addi %273, %c1 : index
    %334 = arith.subi %295, %c1 : index
    cf.br ^bb43(%333, %334 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%273, %295 : index, index)
  ^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%335, %336, %331 : index, index, index)
  ^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%337, %338, %339 : index, index, index)
  ^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
    cf.br ^bb27(%340, %341, %342 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %267 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(4096 : index) : i64
    %1 = llvm.mlir.constant(32 : index) : i64
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.mlir.constant(16 : index) : i64
    %true = arith.constant true
    %cst = arith.constant 0.000000e+00 : f32
    %c64_i64 = arith.constant 64 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1_i64 = arith.constant 1 : i64
    %c2_i64 = arith.constant 2 : i64
    %c128_i64 = arith.constant 128 : i64
    %c32_i64 = arith.constant 32 : i64
    %false = arith.constant false
    %c4096_i64 = arith.constant 4096 : i64
    %c4096 = arith.constant 4096 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %5 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = builtin.unrealized_conversion_cast %c0 : index to i64
    %15 = builtin.unrealized_conversion_cast %c1 : index to i64
    %16 = llvm.mlir.null : !llvm.ptr
    %17 = llvm.getelementptr %16[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %18 = llvm.ptrtoint %17 : !llvm.ptr to i64
    %19 = llvm.call @malloc(%18) : (i64) -> !llvm.ptr
    %20 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %19, %20[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %19, %21[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %2, %22[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %4, %23[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %3, %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = builtin.unrealized_conversion_cast %25 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %27 = llvm.mlir.null : !llvm.ptr
    %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
    %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %2, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %4, %34[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.insertvalue %3, %35[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = builtin.unrealized_conversion_cast %36 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %38 = llvm.mlir.null : !llvm.ptr
    %39 = llvm.getelementptr %38[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %40 = llvm.ptrtoint %39 : !llvm.ptr to i64
    %41 = llvm.call @malloc(%40) : (i64) -> !llvm.ptr
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %41, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %41, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %2, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %4, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %3, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %49 = llvm.mlir.null : !llvm.ptr
    %50 = llvm.getelementptr %49[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %54 = llvm.insertvalue %52, %53[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %52, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.insertvalue %2, %55[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.insertvalue %4, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %3, %57[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = builtin.unrealized_conversion_cast %58 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %60 = llvm.mlir.null : !llvm.ptr
    %61 = llvm.getelementptr %60[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %62 = llvm.ptrtoint %61 : !llvm.ptr to i64
    %63 = llvm.call @malloc(%62) : (i64) -> !llvm.ptr
    %64 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %65 = llvm.insertvalue %63, %64[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %63, %65[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %2, %66[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %4, %67[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.insertvalue %3, %68[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = builtin.unrealized_conversion_cast %69 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %71 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %72 = llvm.insertvalue %c0_i64, %71[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %73 = llvm.insertvalue %c0_i64, %72[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %74 = llvm.insertvalue %c0_i64, %73[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %75 = llvm.insertvalue %c0_i64, %74[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %76 = llvm.insertvalue %c0_i64, %75[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %77 = llvm.insertvalue %c128_i64, %76[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %78 = llvm.getelementptr %19[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %78 : i64, !llvm.ptr
    %79 = llvm.insertvalue %c1_i64, %77[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %80 = llvm.insertvalue %c128_i64, %79[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %81 = llvm.getelementptr %41[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %81 : i64, !llvm.ptr
    %82 = llvm.insertvalue %c1_i64, %80[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %83 = llvm.insertvalue %c32_i64, %82[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %84 = llvm.getelementptr %19[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %84 : i64, !llvm.ptr
    %85 = llvm.insertvalue %c2_i64, %83[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %86 = llvm.mlir.null : !llvm.ptr
    %87 = llvm.getelementptr %86[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %88 = llvm.ptrtoint %87 : !llvm.ptr to i64
    %89 = llvm.call @malloc(%88) : (i64) -> !llvm.ptr
    %90 = llvm.mlir.null : !llvm.ptr
    %91 = llvm.getelementptr %90[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %92 = llvm.ptrtoint %91 : !llvm.ptr to i64
    %93 = llvm.call @malloc(%92) : (i64) -> !llvm.ptr
    %94 = llvm.mlir.null : !llvm.ptr
    %95 = llvm.getelementptr %94[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %96 = llvm.ptrtoint %95 : !llvm.ptr to i64
    %97 = llvm.call @malloc(%96) : (i64) -> !llvm.ptr
    %98 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %99 = llvm.insertvalue %97, %98[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.insertvalue %97, %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.insertvalue %2, %100[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %1, %101[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.insertvalue %3, %102[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = builtin.unrealized_conversion_cast %103 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%105: index):  // 2 preds: ^bb0, ^bb2
    %106 = builtin.unrealized_conversion_cast %105 : index to i64
    %107 = arith.cmpi slt, %105, %c32 : index
    cf.cond_br %107, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %108 = llvm.getelementptr %89[%106] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %108 : f32, !llvm.ptr
    %109 = arith.addi %105, %c1 : index
    cf.br ^bb1(%109 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%110: index):  // 2 preds: ^bb3, ^bb5
    %111 = builtin.unrealized_conversion_cast %110 : index to i64
    %112 = arith.cmpi slt, %110, %c32 : index
    cf.cond_br %112, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %113 = llvm.getelementptr %93[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %113 : i1, !llvm.ptr
    %114 = arith.addi %110, %c1 : index
    cf.br ^bb4(%114 : index)
  ^bb6:  // pred: ^bb4
    %115 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = llvm.getelementptr %115[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %117 = llvm.load %116 : !llvm.ptr -> i64
    %118 = builtin.unrealized_conversion_cast %117 : i64 to index
    %119 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = builtin.unrealized_conversion_cast %121 : i64 to index
    cf.br ^bb7(%118, %26, %37, %48, %59, %70, %85 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%123: index, %124: memref<?xindex>, %125: memref<?xindex>, %126: memref<?xindex>, %127: memref<?xindex>, %128: memref<?xf32>, %129: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %130 = builtin.unrealized_conversion_cast %123 : index to i64
    %131 = builtin.unrealized_conversion_cast %126 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %132 = builtin.unrealized_conversion_cast %124 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %133 = builtin.unrealized_conversion_cast %125 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %134 = builtin.unrealized_conversion_cast %127 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %135 = builtin.unrealized_conversion_cast %128 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %136 = arith.cmpi slt, %123, %122 : index
    cf.cond_br %136, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %137 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = llvm.getelementptr %137[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %139 = llvm.load %138 : !llvm.ptr -> i64
    %140 = builtin.unrealized_conversion_cast %139 : i64 to index
    %141 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = builtin.unrealized_conversion_cast %143 : i64 to index
    %145 = arith.addi %123, %c1 : index
    %146 = builtin.unrealized_conversion_cast %145 : index to i64
    %147 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %148 = llvm.getelementptr %147[%146] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %149 = llvm.load %148 : !llvm.ptr -> i64
    %150 = builtin.unrealized_conversion_cast %149 : i64 to index
    cf.br ^bb9(%144, %124, %125, %126, %127, %128, %129 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%151: index, %152: memref<?xindex>, %153: memref<?xindex>, %154: memref<?xindex>, %155: memref<?xindex>, %156: memref<?xf32>, %157: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %158 = builtin.unrealized_conversion_cast %151 : index to i64
    %159 = arith.cmpi slt, %151, %150 : index
    cf.cond_br %159, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %160 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%158] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = builtin.unrealized_conversion_cast %162 : i64 to index
    %164 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%158] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = builtin.unrealized_conversion_cast %166 : i64 to index
    %168 = arith.addi %151, %c1 : index
    %169 = builtin.unrealized_conversion_cast %168 : index to i64
    %170 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %171 = llvm.getelementptr %170[%169] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %172 = llvm.load %171 : !llvm.ptr -> i64
    %173 = builtin.unrealized_conversion_cast %172 : i64 to index
    cf.br ^bb11(%167, %c0 : index, index)
  ^bb11(%174: index, %175: index):  // 2 preds: ^bb10, ^bb19
    %176 = builtin.unrealized_conversion_cast %174 : index to i64
    %177 = arith.cmpi slt, %174, %173 : index
    cf.cond_br %177, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %178 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%176] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    %182 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%176] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %184 = llvm.load %183 : !llvm.ptr -> f32
    cf.br ^bb13(%c0, %175 : index, index)
  ^bb13(%185: index, %186: index):  // 2 preds: ^bb12, ^bb18
    %187 = builtin.unrealized_conversion_cast %185 : index to i64
    %188 = builtin.unrealized_conversion_cast %186 : index to i64
    %189 = arith.cmpi slt, %185, %c32 : index
    cf.cond_br %189, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %190 = arith.muli %181, %c32 : index
    %191 = arith.addi %190, %185 : index
    %192 = builtin.unrealized_conversion_cast %191 : index to i64
    %193 = llvm.getelementptr %89[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %194 = llvm.load %193 : !llvm.ptr -> f32
    %195 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%192] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %197 = llvm.load %196 : !llvm.ptr -> f32
    %198 = arith.mulf %184, %197 : f32
    %199 = arith.addf %194, %198 : f32
    %200 = llvm.getelementptr %93[%187] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %201 = llvm.load %200 : !llvm.ptr -> i1
    %202 = arith.cmpi eq, %201, %false : i1
    cf.cond_br %202, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %203 = llvm.getelementptr %93[%187] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %true, %203 : i1, !llvm.ptr
    %204 = llvm.getelementptr %97[%188] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %187, %204 : i64, !llvm.ptr
    %205 = arith.addi %186, %c1 : index
    cf.br ^bb17(%205 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%186 : index)
  ^bb17(%206: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %207 = llvm.getelementptr %89[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %199, %207 : f32, !llvm.ptr
    %208 = arith.addi %185, %c1 : index
    cf.br ^bb13(%208, %206 : index, index)
  ^bb19:  // pred: ^bb13
    %209 = arith.addi %174, %c1 : index
    cf.br ^bb11(%209, %186 : index, index)
  ^bb20:  // pred: ^bb11
    %210 = arith.index_cast %175 : index to i64
    %211 = "llvm.intr.ctlz"(%210) <{is_zero_poison = false}> : (i64) -> i64
    %212 = arith.subi %c64_i64, %211 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %175, %104, %212) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %152, %153, %154, %155, %156, %157 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%213: index, %214: memref<?xindex>, %215: memref<?xindex>, %216: memref<?xindex>, %217: memref<?xindex>, %218: memref<?xf32>, %219: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %220 = builtin.unrealized_conversion_cast %213 : index to i64
    %221 = arith.cmpi slt, %213, %175 : index
    cf.cond_br %221, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %222 = llvm.getelementptr %97[%220] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %223 = llvm.load %222 : !llvm.ptr -> i64
    %224 = builtin.unrealized_conversion_cast %223 : i64 to index
    %225 = llvm.getelementptr %89[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %226 = llvm.load %225 : !llvm.ptr -> f32
    %227:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%214, %215, %216, %217, %218, %219, %140, %163, %224, %226) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    %228 = llvm.getelementptr %89[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %228 : f32, !llvm.ptr
    %229 = llvm.getelementptr %93[%223] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %229 : i1, !llvm.ptr
    %230 = arith.addi %213, %c1 : index
    cf.br ^bb21(%230, %227#0, %227#1, %227#2, %227#3, %227#4, %227#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %231 = arith.addi %151, %c1 : index
    cf.br ^bb9(%231, %214, %215, %216, %217, %218, %219 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %232 = arith.addi %123, %c1 : index
    cf.br ^bb7(%232, %152, %153, %154, %155, %156, %157 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%89) : (!llvm.ptr) -> ()
    llvm.call @free(%93) : (!llvm.ptr) -> ()
    llvm.call @free(%97) : (!llvm.ptr) -> ()
    %233 = llvm.extractvalue %129[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %234 = arith.index_cast %233 : i64 to index
    %235 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %237 = llvm.load %236 : !llvm.ptr -> i64
    %238 = builtin.unrealized_conversion_cast %237 : i64 to index
    cf.br ^bb26(%c1, %238 : index, index)
  ^bb26(%239: index, %240: index):  // 2 preds: ^bb25, ^bb29
    %241 = builtin.unrealized_conversion_cast %239 : index to i64
    %242 = builtin.unrealized_conversion_cast %240 : index to i64
    %243 = arith.cmpi slt, %239, %234 : index
    cf.cond_br %243, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %244 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %245 = llvm.getelementptr %244[%241] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %246 = llvm.load %245 : !llvm.ptr -> i64
    %247 = builtin.unrealized_conversion_cast %246 : i64 to index
    %248 = arith.cmpi eq, %247, %c0 : index
    %249 = arith.select %248, %240, %247 : index
    cf.cond_br %248, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %250 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %251 = llvm.getelementptr %250[%241] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %242, %251 : i64, !llvm.ptr
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %252 = arith.addi %239, %c1 : index
    cf.br ^bb26(%252, %249 : index, index)
  ^bb30:  // pred: ^bb26
    %253 = llvm.mlir.null : !llvm.ptr
    %254 = llvm.getelementptr %253[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %255 = llvm.ptrtoint %254 : !llvm.ptr to i64
    %256 = llvm.call @malloc(%255) : (i64) -> !llvm.ptr
    %257 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %258 = llvm.insertvalue %256, %257[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.insertvalue %256, %258[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.insertvalue %2, %259[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.insertvalue %0, %260[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %262 = llvm.insertvalue %3, %261[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = builtin.unrealized_conversion_cast %262 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %264 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %265 = llvm.insertvalue %c0_i64, %264[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %266 = llvm.insertvalue %c128_i64, %265[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %267 = llvm.insertvalue %c32_i64, %266[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%268: index):  // 2 preds: ^bb30, ^bb32
    %269 = builtin.unrealized_conversion_cast %268 : index to i64
    %270 = arith.cmpi slt, %268, %c4096 : index
    cf.cond_br %270, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %271 = llvm.getelementptr %256[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %271 : f32, !llvm.ptr
    %272 = arith.addi %268, %c1 : index
    cf.br ^bb31(%272 : index)
  ^bb33:  // pred: ^bb31
    %273 = llvm.insertvalue %c4096_i64, %267[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %274 = llvm.extractvalue %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %275 = llvm.getelementptr %274[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %276 = llvm.load %275 : !llvm.ptr -> i64
    %277 = builtin.unrealized_conversion_cast %276 : i64 to index
    %278 = llvm.extractvalue %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %279 = llvm.getelementptr %278[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %280 = llvm.load %279 : !llvm.ptr -> i64
    %281 = builtin.unrealized_conversion_cast %280 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%277) to (%281) step (%c1) {
        %282 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %283 = llvm.extractvalue %133[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %284 = llvm.getelementptr %283[%282] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %285 = llvm.load %284 : !llvm.ptr -> i64
        %286 = builtin.unrealized_conversion_cast %285 : i64 to index
        %287 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %288 = llvm.getelementptr %287[%282] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %289 = llvm.load %288 : !llvm.ptr -> i64
        %290 = builtin.unrealized_conversion_cast %289 : i64 to index
        %291 = arith.addi %arg12, %c1 : index
        %292 = builtin.unrealized_conversion_cast %291 : index to i64
        %293 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %294 = llvm.getelementptr %293[%292] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %295 = llvm.load %294 : !llvm.ptr -> i64
        %296 = builtin.unrealized_conversion_cast %295 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%290) to (%296) step (%c1) {
            %297 = builtin.unrealized_conversion_cast %arg13 : index to i64
            %298 = llvm.extractvalue %134[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %299 = llvm.getelementptr %298[%297] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %300 = llvm.load %299 : !llvm.ptr -> i64
            %301 = builtin.unrealized_conversion_cast %300 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %302 = arith.muli %arg13, %c32 : index
                %303 = arith.addi %302, %arg14 : index
                %304 = builtin.unrealized_conversion_cast %303 : index to i64
                %305 = arith.muli %301, %c32 : index
                %306 = arith.addi %305, %arg14 : index
                %307 = builtin.unrealized_conversion_cast %306 : index to i64
                %308 = arith.muli %286, %c32 : index
                %309 = arith.addi %308, %arg14 : index
                %310 = builtin.unrealized_conversion_cast %309 : index to i64
                %311 = llvm.getelementptr %256[%310] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %312 = llvm.load %311 : !llvm.ptr -> f32
                %313 = llvm.extractvalue %135[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %314 = llvm.getelementptr %313[%304] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %315 = llvm.load %314 : !llvm.ptr -> f32
                %316 = llvm.extractvalue %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %317 = llvm.getelementptr %316[%307] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %318 = llvm.load %317 : !llvm.ptr -> f32
                %319 = arith.mulf %315, %318 : f32
                %320 = arith.addf %312, %319 : f32
                %321 = llvm.getelementptr %256[%310] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %320, %321 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %263, %273 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertComplexToLLVMPass (convert-complex-to-llvm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c0 = arith.constant 0 : index
    %false = arith.constant false
    %c32 = arith.constant 32 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
    %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %c1 : index to i64
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.subi %16, %c1 : index
    %20 = builtin.unrealized_conversion_cast %19 : index to i64
    %21 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %21, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = arith.cmpi eq, %25, %arg6 : index
    cf.br ^bb3(%26 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %28 = arith.select %27, %19, %18 : index
    %29 = builtin.unrealized_conversion_cast %28 : index to i64
    cf.cond_br %27, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %30 = arith.addi %18, %c1 : index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %31, %33 : i64, !llvm.ptr
    %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = builtin.unrealized_conversion_cast %35 : index to i64
    %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %35, %c1 : index
    %40 = arith.cmpi ugt, %39, %38 : index
    cf.cond_br %40, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %41 = arith.muli %38, %c2 : index
    %42 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %43 = builtin.unrealized_conversion_cast %41 : index to i64
    %44 = llvm.icmp "ugt" %43, %42 : i64
    llvm.cond_br %44, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %45 = llvm.mlir.null : !llvm.ptr
    %46 = llvm.getelementptr %45[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mul %43, %47  : i64
    %49 = llvm.mul %42, %47  : i64
    %50 = llvm.call @malloc(%48) : (i64) -> !llvm.ptr
    %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%50, %51, %49) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %52 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%52) : (!llvm.ptr) -> ()
    %53 = llvm.insertvalue %50, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %50, %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%55: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %56 = llvm.insertvalue %43, %55[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = builtin.unrealized_conversion_cast %56 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb11(%57 : memref<?xindex>)
  ^bb10:  // pred: ^bb6
    cf.br ^bb11(%arg1 : memref<?xindex>)
  ^bb11(%58: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
    %59 = builtin.unrealized_conversion_cast %58 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    %60 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.getelementptr %60[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %5, %61 : i64, !llvm.ptr
    %62 = arith.index_cast %39 : index to i64
    %63 = llvm.insertvalue %62, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %64 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %65 = arith.index_cast %64 : i64 to index
    %66 = builtin.unrealized_conversion_cast %65 : index to i64
    %67 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = builtin.unrealized_conversion_cast %67 : i64 to index
    %69 = arith.addi %65, %c1 : index
    %70 = arith.cmpi ugt, %69, %68 : index
    cf.cond_br %70, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %71 = arith.muli %68, %c2 : index
    %72 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = builtin.unrealized_conversion_cast %71 : index to i64
    %74 = llvm.icmp "ugt" %73, %72 : i64
    llvm.cond_br %74, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %75 = llvm.mlir.null : !llvm.ptr
    %76 = llvm.getelementptr %75[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %77 = llvm.ptrtoint %76 : !llvm.ptr to i64
    %78 = llvm.mul %73, %77  : i64
    %79 = llvm.mul %72, %77  : i64
    %80 = llvm.call @malloc(%78) : (i64) -> !llvm.ptr
    %81 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%80, %81, %79) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %82 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%82) : (!llvm.ptr) -> ()
    %83 = llvm.insertvalue %80, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %84 = llvm.insertvalue %80, %83[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%84 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%85: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %86 = llvm.insertvalue %73, %85[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = builtin.unrealized_conversion_cast %86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb17(%87 : memref<?xindex>)
  ^bb16:  // pred: ^bb12
    cf.br ^bb17(%arg2 : memref<?xindex>)
  ^bb17(%88: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
    %89 = builtin.unrealized_conversion_cast %88 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %90 = llvm.extractvalue %89[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.getelementptr %90[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %8, %91 : i64, !llvm.ptr
    %92 = arith.index_cast %69 : index to i64
    %93 = llvm.insertvalue %92, %63[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb19(%58, %88, %93 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%94: memref<?xindex>, %95: memref<?xindex>, %96: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %97 = builtin.unrealized_conversion_cast %95 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %98 = arith.addi %28, %c1 : index
    %99 = builtin.unrealized_conversion_cast %98 : index to i64
    %100 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = builtin.unrealized_conversion_cast %102 : i64 to index
    %104 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.getelementptr %104[%99] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %106 = llvm.load %105 : !llvm.ptr -> i64
    %107 = builtin.unrealized_conversion_cast %106 : i64 to index
    %108 = llvm.extractvalue %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %109 = arith.index_cast %108 : i64 to index
    %110 = builtin.unrealized_conversion_cast %109 : index to i64
    %111 = arith.subi %107, %c1 : index
    %112 = builtin.unrealized_conversion_cast %111 : index to i64
    %113 = arith.cmpi ult, %103, %107 : index
    cf.cond_br %113, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %114 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%112] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi eq, %117, %arg7 : index
    cf.br ^bb23(%118 : i1)
  ^bb22:  // pred: ^bb20
    %119 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %110, %120 : i64, !llvm.ptr
    cf.br ^bb23(%false : i1)
  ^bb23(%121: i1):  // 2 preds: ^bb21, ^bb22
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    %122 = arith.select %121, %111, %109 : index
    cf.cond_br %121, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    cf.br ^bb44(%arg3, %arg4, %96 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %123 = arith.addi %109, %c1 : index
    %124 = builtin.unrealized_conversion_cast %123 : index to i64
    %125 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%99] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %128 = arith.index_cast %127 : i64 to index
    %129 = builtin.unrealized_conversion_cast %128 : index to i64
    %130 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %131 = builtin.unrealized_conversion_cast %130 : i64 to index
    %132 = arith.addi %128, %c1 : index
    %133 = arith.cmpi ugt, %132, %131 : index
    cf.cond_br %133, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %134 = arith.muli %131, %c2 : index
    %135 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = builtin.unrealized_conversion_cast %134 : index to i64
    %137 = llvm.icmp "ugt" %136, %135 : i64
    llvm.cond_br %137, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %138 = llvm.mlir.null : !llvm.ptr
    %139 = llvm.getelementptr %138[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %140 = llvm.ptrtoint %139 : !llvm.ptr to i64
    %141 = llvm.mul %136, %140  : i64
    %142 = llvm.mul %135, %140  : i64
    %143 = llvm.call @malloc(%141) : (i64) -> !llvm.ptr
    %144 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%143, %144, %142) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %145 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%145) : (!llvm.ptr) -> ()
    %146 = llvm.insertvalue %143, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.insertvalue %143, %146[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%147 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%148: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %149 = llvm.insertvalue %136, %148[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %150 = builtin.unrealized_conversion_cast %149 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb31(%150 : memref<?xindex>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg3 : memref<?xindex>)
  ^bb31(%151: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
    %152 = builtin.unrealized_conversion_cast %151 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %153 = llvm.extractvalue %152[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %154 = llvm.getelementptr %153[%129] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %3, %154 : i64, !llvm.ptr
    %155 = arith.index_cast %132 : index to i64
    %156 = llvm.insertvalue %155, %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %157 = llvm.extractvalue %96[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %158 = arith.index_cast %157 : i64 to index
    %159 = builtin.unrealized_conversion_cast %158 : index to i64
    %160 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = builtin.unrealized_conversion_cast %160 : i64 to index
    %162 = arith.addi %158, %c32 : index
    %163 = arith.cmpi ugt, %162, %161 : index
    cf.cond_br %163, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%161 : index)
  ^bb34(%164: index):  // 2 preds: ^bb33, ^bb34
    %165 = arith.muli %164, %c2 : index
    %166 = arith.cmpi ugt, %162, %165 : index
    cf.cond_br %166, ^bb34(%165 : index), ^bb35
  ^bb35:  // pred: ^bb34
    %167 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = builtin.unrealized_conversion_cast %165 : index to i64
    %169 = llvm.icmp "ugt" %168, %167 : i64
    llvm.cond_br %169, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %170 = llvm.mlir.null : !llvm.ptr
    %171 = llvm.getelementptr %170[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %172 = llvm.ptrtoint %171 : !llvm.ptr to i64
    %173 = llvm.mul %168, %172  : i64
    %174 = llvm.mul %167, %172  : i64
    %175 = llvm.call @malloc(%173) : (i64) -> !llvm.ptr
    %176 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%175, %176, %174) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %177 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%177) : (!llvm.ptr) -> ()
    %178 = llvm.insertvalue %175, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.insertvalue %175, %178[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%179 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%180: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %181 = llvm.insertvalue %168, %180[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = builtin.unrealized_conversion_cast %181 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    cf.br ^bb39(%182 : memref<?xf32>)
  ^bb38:  // pred: ^bb32
    cf.br ^bb39(%arg4 : memref<?xf32>)
  ^bb39(%183: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
    %184 = builtin.unrealized_conversion_cast %183 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %185 = llvm.extractvalue %184[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    cf.br ^bb41(%c0 : index)
  ^bb41(%186: index):  // 2 preds: ^bb40, ^bb42
    %187 = builtin.unrealized_conversion_cast %186 : index to i64
    %188 = arith.cmpi slt, %186, %c32 : index
    cf.cond_br %188, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %189 = llvm.getelementptr %185[%159] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %190 = llvm.getelementptr %189[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %190 : f32, !llvm.ptr
    %191 = arith.addi %186, %c1 : index
    cf.br ^bb41(%191 : index)
  ^bb43:  // pred: ^bb41
    %192 = arith.index_cast %162 : index to i64
    %193 = llvm.insertvalue %192, %156[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb44(%151, %183, %193 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%194: memref<?xindex>, %195: memref<?xf32>, %196: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %197 = builtin.unrealized_conversion_cast %195 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb45
  ^bb45:  // pred: ^bb44
    %198 = arith.muli %122, %c32 : index
    %199 = arith.addi %198, %arg8 : index
    %200 = builtin.unrealized_conversion_cast %199 : index to i64
    %201 = llvm.extractvalue %197[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg9, %202 : f32, !llvm.ptr
    return %arg0, %94, %95, %194, %195, %196 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
    %4 = arith.cmpi ult, %2, %3 : index
    cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
  ^bb2(%5: index, %6: index):  // pred: ^bb1
    %7 = arith.addi %5, %6 : index
    %8 = arith.shrui %7, %c1 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %8, %c1 : index
    %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %13 = llvm.load %12 : !llvm.ptr -> i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = arith.cmpi ult, %14, %18 : index
    %20 = arith.select %19, %5, %10 : index
    %21 = arith.select %19, %8, %6 : index
    cf.br ^bb1(%20, %21 : index, index)
  ^bb3:  // pred: ^bb1
    return %2 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%1 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
    %3 = builtin.unrealized_conversion_cast %2 : index to i64
    %4 = arith.cmpi slt, %2, %arg1 : index
    cf.cond_br %4, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %9 = llvm.load %8 : !llvm.ptr -> i64
    %10 = arith.subi %2, %5 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
    %12 = arith.cmpi slt, %11, %10 : index
    cf.cond_br %12, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %13 = arith.subi %2, %11 : index
    %14 = builtin.unrealized_conversion_cast %13 : index to i64
    %15 = arith.subi %13, %c1 : index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %19, %21 : i64, !llvm.ptr
    %22 = arith.addi %11, %c1 : index
    cf.br ^bb3(%22 : index)
  ^bb5:  // pred: ^bb3
    %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %24 : i64, !llvm.ptr
    %25 = arith.addi %2, %c1 : index
    cf.br ^bb1(%25 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %1, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %arg3, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.cmpi uge, %4, %2 : index
    cf.cond_br %5, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %6 = arith.shli %2, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = arith.addi %7, %arg0 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %6, %c2 : index
    %11 = arith.cmpi ult, %10, %arg3 : index
    cf.cond_br %11, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %12 = arith.addi %10, %arg0 : index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = builtin.unrealized_conversion_cast %16 : i64 to index
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = arith.cmpi ult, %17, %21 : index
    %23 = arith.select %22, %10, %7 : index
    %24 = arith.select %22, %12, %8 : index
    cf.br ^bb5(%23, %24, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%7, %8, %arg1 : index, index, index)
  ^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%27, %25, %26 : index, index, index)
  ^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
    cf.br ^bb7(%28, %29, %30 : index, index, index)
  ^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
    %34 = builtin.unrealized_conversion_cast %31 : index to i64
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = builtin.unrealized_conversion_cast %38 : i64 to index
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = arith.cmpi ult, %39, %43 : index
    cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
  ^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = builtin.unrealized_conversion_cast %47 : index to i64
    %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = arith.cmpi uge, %4, %46 : index
    cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
  ^bb9:  // pred: ^bb8
    %61 = arith.shli %46, %c1 : index
    %62 = arith.addi %61, %c1 : index
    %63 = arith.addi %62, %arg0 : index
    %64 = builtin.unrealized_conversion_cast %63 : index to i64
    %65 = arith.addi %61, %c2 : index
    %66 = arith.cmpi ult, %65, %arg3 : index
    cf.cond_br %66, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %67 = arith.addi %65, %arg0 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %75 = llvm.load %74 : !llvm.ptr -> i64
    %76 = builtin.unrealized_conversion_cast %75 : i64 to index
    %77 = arith.cmpi ult, %72, %76 : index
    %78 = arith.select %77, %65, %62 : index
    %79 = arith.select %77, %67, %63 : index
    cf.br ^bb12(%78, %79 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%62, %63 : index, index)
  ^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%80, %81 : index, index)
  ^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%82, %83, %47 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %2, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.addi %4, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = arith.subi %4, %6 : index
    %9 = arith.addi %arg0, %8 : index
    call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
    %10 = arith.addi %6, %c1 : index
    cf.br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    %11 = arith.subi %2, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
    %13 = arith.cmpi slt, %12, %11 : index
    cf.cond_br %13, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %14 = arith.subi %2, %12 : index
    %15 = arith.addi %arg0, %14 : index
    %16 = arith.subi %15, %c1 : index
    %17 = builtin.unrealized_conversion_cast %16 : index to i64
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    %28 = arith.subi %14, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
    %29 = arith.addi %12, %c1 : index
    cf.br ^bb4(%29 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c-1 = arith.constant -1 : index
    %c1000 = arith.constant 1000 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %2 = arith.addi %arg0, %arg1 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = builtin.unrealized_conversion_cast %3 : index to i64
    %5 = arith.subi %arg1, %c1 : index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = arith.subi %arg1, %arg0 : index
    %8 = arith.cmpi ult, %7, %c1000 : index
    cf.cond_br %8, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %30 = llvm.load %29 : !llvm.ptr -> i64
    %31 = builtin.unrealized_conversion_cast %30 : i64 to index
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %34 = llvm.load %33 : !llvm.ptr -> i64
    %35 = builtin.unrealized_conversion_cast %34 : i64 to index
    %36 = arith.cmpi ult, %31, %35 : index
    cf.cond_br %36, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %42, %44 : i64, !llvm.ptr
    %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %39, %46 : i64, !llvm.ptr
    %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    %55 = arith.cmpi ult, %50, %54 : index
    cf.cond_br %55, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %58 = llvm.load %57 : !llvm.ptr -> i64
    %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %61 = llvm.load %60 : !llvm.ptr -> i64
    %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %61, %63 : i64, !llvm.ptr
    %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %58, %65 : i64, !llvm.ptr
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %5, %3 : index, index, index)
  ^bb8:  // pred: ^bb0
    %66 = arith.addi %arg0, %arg1 : index
    %67 = arith.shrui %66, %c1 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = arith.addi %3, %arg1 : index
    %70 = arith.shrui %69, %c1 : index
    %71 = builtin.unrealized_conversion_cast %70 : index to i64
    %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = arith.cmpi ult, %75, %79 : index
    cf.cond_br %80, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %86, %88 : i64, !llvm.ptr
    %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %83, %90 : i64, !llvm.ptr
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    %99 = arith.cmpi ult, %94, %98 : index
    cf.cond_br %99, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %105, %107 : i64, !llvm.ptr
    %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %102, %109 : i64, !llvm.ptr
    %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %113, %117 : index
    cf.cond_br %118, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %124 = llvm.load %123 : !llvm.ptr -> i64
    %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %128 : i64, !llvm.ptr
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %135 = llvm.load %134 : !llvm.ptr -> i64
    %136 = builtin.unrealized_conversion_cast %135 : i64 to index
    %137 = arith.cmpi ult, %132, %136 : index
    cf.cond_br %137, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %140 = llvm.load %139 : !llvm.ptr -> i64
    %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %143, %145 : i64, !llvm.ptr
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %140, %147 : i64, !llvm.ptr
    %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %154 = llvm.load %153 : !llvm.ptr -> i64
    %155 = builtin.unrealized_conversion_cast %154 : i64 to index
    %156 = arith.cmpi ult, %151, %155 : index
    cf.cond_br %156, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %162, %164 : i64, !llvm.ptr
    %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %159, %166 : i64, !llvm.ptr
    %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = builtin.unrealized_conversion_cast %173 : i64 to index
    %175 = arith.cmpi ult, %170, %174 : index
    cf.cond_br %175, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %178 = llvm.load %177 : !llvm.ptr -> i64
    %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %181 = llvm.load %180 : !llvm.ptr -> i64
    %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %181, %183 : i64, !llvm.ptr
    %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %178, %185 : i64, !llvm.ptr
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %192 = llvm.load %191 : !llvm.ptr -> i64
    %193 = builtin.unrealized_conversion_cast %192 : i64 to index
    %194 = arith.cmpi ult, %189, %193 : index
    cf.cond_br %194, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = arith.cmpi ult, %208, %212 : index
    cf.cond_br %213, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %219 = llvm.load %218 : !llvm.ptr -> i64
    %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %219, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %216, %223 : i64, !llvm.ptr
    %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = arith.cmpi ult, %227, %231 : index
    cf.cond_br %232, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %235 = llvm.load %234 : !llvm.ptr -> i64
    %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %238 = llvm.load %237 : !llvm.ptr -> i64
    %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %238, %240 : i64, !llvm.ptr
    %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %235, %242 : i64, !llvm.ptr
    %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %249 = llvm.load %248 : !llvm.ptr -> i64
    %250 = builtin.unrealized_conversion_cast %249 : i64 to index
    %251 = arith.cmpi ult, %246, %250 : index
    cf.cond_br %251, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %257 = llvm.load %256 : !llvm.ptr -> i64
    %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %257, %259 : i64, !llvm.ptr
    %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %254, %261 : i64, !llvm.ptr
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%262, %263, %264 : index, index, index)
  ^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
    %268 = arith.cmpi ult, %265, %266 : index
    cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
  ^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
    %272 = builtin.unrealized_conversion_cast %271 : index to i64
    cf.br ^bb30(%269 : index)
  ^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
    %274 = builtin.unrealized_conversion_cast %273 : index to i64
    %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = builtin.unrealized_conversion_cast %281 : i64 to index
    %283 = arith.cmpi ult, %278, %282 : index
    cf.cond_br %283, ^bb31(%273 : index), ^bb32
  ^bb31(%284: index):  // pred: ^bb30
    %285 = arith.addi %284, %c1 : index
    cf.br ^bb30(%285 : index)
  ^bb32:  // pred: ^bb30
    %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %288 = llvm.load %287 : !llvm.ptr -> i64
    %289 = builtin.unrealized_conversion_cast %288 : i64 to index
    %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %292 = llvm.load %291 : !llvm.ptr -> i64
    %293 = builtin.unrealized_conversion_cast %292 : i64 to index
    %294 = arith.cmpi eq, %289, %293 : index
    cf.br ^bb33(%270 : index)
  ^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
    %296 = builtin.unrealized_conversion_cast %295 : index to i64
    %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %299 = llvm.load %298 : !llvm.ptr -> i64
    %300 = builtin.unrealized_conversion_cast %299 : i64 to index
    %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %303 = llvm.load %302 : !llvm.ptr -> i64
    %304 = builtin.unrealized_conversion_cast %303 : i64 to index
    %305 = arith.cmpi ult, %300, %304 : index
    cf.cond_br %305, ^bb34(%295 : index), ^bb35
  ^bb34(%306: index):  // pred: ^bb33
    %307 = arith.addi %306, %c-1 : index
    cf.br ^bb33(%307 : index)
  ^bb35:  // pred: ^bb33
    %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    %316 = arith.cmpi eq, %311, %315 : index
    %317 = arith.cmpi ult, %273, %295 : index
    cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
  ^bb36:  // pred: ^bb35
    %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %320 = llvm.load %319 : !llvm.ptr -> i64
    %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %323 = llvm.load %322 : !llvm.ptr -> i64
    %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %323, %325 : i64, !llvm.ptr
    %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %320, %327 : i64, !llvm.ptr
    %328 = arith.cmpi eq, %273, %271 : index
    cf.cond_br %328, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%295 : index)
  ^bb38:  // pred: ^bb36
    %329 = arith.cmpi eq, %295, %271 : index
    %330 = arith.select %329, %273, %271 : index
    cf.br ^bb39(%330 : index)
  ^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %332 = arith.andi %294, %316 : i1
    cf.cond_br %332, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %333 = arith.addi %273, %c1 : index
    %334 = arith.subi %295, %c1 : index
    cf.br ^bb43(%333, %334 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%273, %295 : index, index)
  ^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%335, %336, %331 : index, index, index)
  ^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%337, %338, %339 : index, index, index)
  ^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
    cf.br ^bb27(%340, %341, %342 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %267 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(4096 : index) : i64
    %1 = llvm.mlir.constant(32 : index) : i64
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.mlir.constant(16 : index) : i64
    %true = arith.constant true
    %cst = arith.constant 0.000000e+00 : f32
    %c64_i64 = arith.constant 64 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1_i64 = arith.constant 1 : i64
    %c2_i64 = arith.constant 2 : i64
    %c128_i64 = arith.constant 128 : i64
    %c32_i64 = arith.constant 32 : i64
    %false = arith.constant false
    %c4096_i64 = arith.constant 4096 : i64
    %c4096 = arith.constant 4096 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %5 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = builtin.unrealized_conversion_cast %c0 : index to i64
    %15 = builtin.unrealized_conversion_cast %c1 : index to i64
    %16 = llvm.mlir.null : !llvm.ptr
    %17 = llvm.getelementptr %16[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %18 = llvm.ptrtoint %17 : !llvm.ptr to i64
    %19 = llvm.call @malloc(%18) : (i64) -> !llvm.ptr
    %20 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %19, %20[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %19, %21[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %2, %22[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %4, %23[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %3, %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = builtin.unrealized_conversion_cast %25 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %27 = llvm.mlir.null : !llvm.ptr
    %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
    %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %2, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %4, %34[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.insertvalue %3, %35[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = builtin.unrealized_conversion_cast %36 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %38 = llvm.mlir.null : !llvm.ptr
    %39 = llvm.getelementptr %38[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %40 = llvm.ptrtoint %39 : !llvm.ptr to i64
    %41 = llvm.call @malloc(%40) : (i64) -> !llvm.ptr
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %41, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %41, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %2, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %4, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %3, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %49 = llvm.mlir.null : !llvm.ptr
    %50 = llvm.getelementptr %49[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %54 = llvm.insertvalue %52, %53[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %52, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.insertvalue %2, %55[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.insertvalue %4, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %3, %57[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = builtin.unrealized_conversion_cast %58 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %60 = llvm.mlir.null : !llvm.ptr
    %61 = llvm.getelementptr %60[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %62 = llvm.ptrtoint %61 : !llvm.ptr to i64
    %63 = llvm.call @malloc(%62) : (i64) -> !llvm.ptr
    %64 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %65 = llvm.insertvalue %63, %64[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %63, %65[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %2, %66[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %4, %67[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.insertvalue %3, %68[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = builtin.unrealized_conversion_cast %69 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %71 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %72 = llvm.insertvalue %c0_i64, %71[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %73 = llvm.insertvalue %c0_i64, %72[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %74 = llvm.insertvalue %c0_i64, %73[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %75 = llvm.insertvalue %c0_i64, %74[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %76 = llvm.insertvalue %c0_i64, %75[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %77 = llvm.insertvalue %c128_i64, %76[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %78 = llvm.getelementptr %19[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %78 : i64, !llvm.ptr
    %79 = llvm.insertvalue %c1_i64, %77[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %80 = llvm.insertvalue %c128_i64, %79[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %81 = llvm.getelementptr %41[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %81 : i64, !llvm.ptr
    %82 = llvm.insertvalue %c1_i64, %80[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %83 = llvm.insertvalue %c32_i64, %82[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %84 = llvm.getelementptr %19[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %84 : i64, !llvm.ptr
    %85 = llvm.insertvalue %c2_i64, %83[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %86 = llvm.mlir.null : !llvm.ptr
    %87 = llvm.getelementptr %86[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %88 = llvm.ptrtoint %87 : !llvm.ptr to i64
    %89 = llvm.call @malloc(%88) : (i64) -> !llvm.ptr
    %90 = llvm.mlir.null : !llvm.ptr
    %91 = llvm.getelementptr %90[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %92 = llvm.ptrtoint %91 : !llvm.ptr to i64
    %93 = llvm.call @malloc(%92) : (i64) -> !llvm.ptr
    %94 = llvm.mlir.null : !llvm.ptr
    %95 = llvm.getelementptr %94[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %96 = llvm.ptrtoint %95 : !llvm.ptr to i64
    %97 = llvm.call @malloc(%96) : (i64) -> !llvm.ptr
    %98 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %99 = llvm.insertvalue %97, %98[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.insertvalue %97, %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.insertvalue %2, %100[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %1, %101[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.insertvalue %3, %102[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = builtin.unrealized_conversion_cast %103 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%105: index):  // 2 preds: ^bb0, ^bb2
    %106 = builtin.unrealized_conversion_cast %105 : index to i64
    %107 = arith.cmpi slt, %105, %c32 : index
    cf.cond_br %107, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %108 = llvm.getelementptr %89[%106] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %108 : f32, !llvm.ptr
    %109 = arith.addi %105, %c1 : index
    cf.br ^bb1(%109 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%110: index):  // 2 preds: ^bb3, ^bb5
    %111 = builtin.unrealized_conversion_cast %110 : index to i64
    %112 = arith.cmpi slt, %110, %c32 : index
    cf.cond_br %112, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %113 = llvm.getelementptr %93[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %113 : i1, !llvm.ptr
    %114 = arith.addi %110, %c1 : index
    cf.br ^bb4(%114 : index)
  ^bb6:  // pred: ^bb4
    %115 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = llvm.getelementptr %115[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %117 = llvm.load %116 : !llvm.ptr -> i64
    %118 = builtin.unrealized_conversion_cast %117 : i64 to index
    %119 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = builtin.unrealized_conversion_cast %121 : i64 to index
    cf.br ^bb7(%118, %26, %37, %48, %59, %70, %85 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%123: index, %124: memref<?xindex>, %125: memref<?xindex>, %126: memref<?xindex>, %127: memref<?xindex>, %128: memref<?xf32>, %129: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %130 = builtin.unrealized_conversion_cast %123 : index to i64
    %131 = builtin.unrealized_conversion_cast %126 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %132 = builtin.unrealized_conversion_cast %124 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %133 = builtin.unrealized_conversion_cast %125 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %134 = builtin.unrealized_conversion_cast %127 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %135 = builtin.unrealized_conversion_cast %128 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %136 = arith.cmpi slt, %123, %122 : index
    cf.cond_br %136, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %137 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = llvm.getelementptr %137[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %139 = llvm.load %138 : !llvm.ptr -> i64
    %140 = builtin.unrealized_conversion_cast %139 : i64 to index
    %141 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = builtin.unrealized_conversion_cast %143 : i64 to index
    %145 = arith.addi %123, %c1 : index
    %146 = builtin.unrealized_conversion_cast %145 : index to i64
    %147 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %148 = llvm.getelementptr %147[%146] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %149 = llvm.load %148 : !llvm.ptr -> i64
    %150 = builtin.unrealized_conversion_cast %149 : i64 to index
    cf.br ^bb9(%144, %124, %125, %126, %127, %128, %129 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%151: index, %152: memref<?xindex>, %153: memref<?xindex>, %154: memref<?xindex>, %155: memref<?xindex>, %156: memref<?xf32>, %157: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %158 = builtin.unrealized_conversion_cast %151 : index to i64
    %159 = arith.cmpi slt, %151, %150 : index
    cf.cond_br %159, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %160 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%158] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = builtin.unrealized_conversion_cast %162 : i64 to index
    %164 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%158] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = builtin.unrealized_conversion_cast %166 : i64 to index
    %168 = arith.addi %151, %c1 : index
    %169 = builtin.unrealized_conversion_cast %168 : index to i64
    %170 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %171 = llvm.getelementptr %170[%169] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %172 = llvm.load %171 : !llvm.ptr -> i64
    %173 = builtin.unrealized_conversion_cast %172 : i64 to index
    cf.br ^bb11(%167, %c0 : index, index)
  ^bb11(%174: index, %175: index):  // 2 preds: ^bb10, ^bb19
    %176 = builtin.unrealized_conversion_cast %174 : index to i64
    %177 = arith.cmpi slt, %174, %173 : index
    cf.cond_br %177, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %178 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%176] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    %182 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%176] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %184 = llvm.load %183 : !llvm.ptr -> f32
    cf.br ^bb13(%c0, %175 : index, index)
  ^bb13(%185: index, %186: index):  // 2 preds: ^bb12, ^bb18
    %187 = builtin.unrealized_conversion_cast %185 : index to i64
    %188 = builtin.unrealized_conversion_cast %186 : index to i64
    %189 = arith.cmpi slt, %185, %c32 : index
    cf.cond_br %189, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %190 = arith.muli %181, %c32 : index
    %191 = arith.addi %190, %185 : index
    %192 = builtin.unrealized_conversion_cast %191 : index to i64
    %193 = llvm.getelementptr %89[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %194 = llvm.load %193 : !llvm.ptr -> f32
    %195 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%192] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %197 = llvm.load %196 : !llvm.ptr -> f32
    %198 = arith.mulf %184, %197 : f32
    %199 = arith.addf %194, %198 : f32
    %200 = llvm.getelementptr %93[%187] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %201 = llvm.load %200 : !llvm.ptr -> i1
    %202 = arith.cmpi eq, %201, %false : i1
    cf.cond_br %202, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %203 = llvm.getelementptr %93[%187] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %true, %203 : i1, !llvm.ptr
    %204 = llvm.getelementptr %97[%188] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %187, %204 : i64, !llvm.ptr
    %205 = arith.addi %186, %c1 : index
    cf.br ^bb17(%205 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%186 : index)
  ^bb17(%206: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %207 = llvm.getelementptr %89[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %199, %207 : f32, !llvm.ptr
    %208 = arith.addi %185, %c1 : index
    cf.br ^bb13(%208, %206 : index, index)
  ^bb19:  // pred: ^bb13
    %209 = arith.addi %174, %c1 : index
    cf.br ^bb11(%209, %186 : index, index)
  ^bb20:  // pred: ^bb11
    %210 = arith.index_cast %175 : index to i64
    %211 = "llvm.intr.ctlz"(%210) <{is_zero_poison = false}> : (i64) -> i64
    %212 = arith.subi %c64_i64, %211 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %175, %104, %212) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %152, %153, %154, %155, %156, %157 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%213: index, %214: memref<?xindex>, %215: memref<?xindex>, %216: memref<?xindex>, %217: memref<?xindex>, %218: memref<?xf32>, %219: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %220 = builtin.unrealized_conversion_cast %213 : index to i64
    %221 = arith.cmpi slt, %213, %175 : index
    cf.cond_br %221, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %222 = llvm.getelementptr %97[%220] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %223 = llvm.load %222 : !llvm.ptr -> i64
    %224 = builtin.unrealized_conversion_cast %223 : i64 to index
    %225 = llvm.getelementptr %89[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %226 = llvm.load %225 : !llvm.ptr -> f32
    %227:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%214, %215, %216, %217, %218, %219, %140, %163, %224, %226) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    %228 = llvm.getelementptr %89[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %228 : f32, !llvm.ptr
    %229 = llvm.getelementptr %93[%223] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %229 : i1, !llvm.ptr
    %230 = arith.addi %213, %c1 : index
    cf.br ^bb21(%230, %227#0, %227#1, %227#2, %227#3, %227#4, %227#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %231 = arith.addi %151, %c1 : index
    cf.br ^bb9(%231, %214, %215, %216, %217, %218, %219 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %232 = arith.addi %123, %c1 : index
    cf.br ^bb7(%232, %152, %153, %154, %155, %156, %157 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%89) : (!llvm.ptr) -> ()
    llvm.call @free(%93) : (!llvm.ptr) -> ()
    llvm.call @free(%97) : (!llvm.ptr) -> ()
    %233 = llvm.extractvalue %129[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %234 = arith.index_cast %233 : i64 to index
    %235 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %237 = llvm.load %236 : !llvm.ptr -> i64
    %238 = builtin.unrealized_conversion_cast %237 : i64 to index
    cf.br ^bb26(%c1, %238 : index, index)
  ^bb26(%239: index, %240: index):  // 2 preds: ^bb25, ^bb29
    %241 = builtin.unrealized_conversion_cast %239 : index to i64
    %242 = builtin.unrealized_conversion_cast %240 : index to i64
    %243 = arith.cmpi slt, %239, %234 : index
    cf.cond_br %243, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %244 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %245 = llvm.getelementptr %244[%241] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %246 = llvm.load %245 : !llvm.ptr -> i64
    %247 = builtin.unrealized_conversion_cast %246 : i64 to index
    %248 = arith.cmpi eq, %247, %c0 : index
    %249 = arith.select %248, %240, %247 : index
    cf.cond_br %248, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %250 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %251 = llvm.getelementptr %250[%241] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %242, %251 : i64, !llvm.ptr
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %252 = arith.addi %239, %c1 : index
    cf.br ^bb26(%252, %249 : index, index)
  ^bb30:  // pred: ^bb26
    %253 = llvm.mlir.null : !llvm.ptr
    %254 = llvm.getelementptr %253[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %255 = llvm.ptrtoint %254 : !llvm.ptr to i64
    %256 = llvm.call @malloc(%255) : (i64) -> !llvm.ptr
    %257 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %258 = llvm.insertvalue %256, %257[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.insertvalue %256, %258[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.insertvalue %2, %259[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.insertvalue %0, %260[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %262 = llvm.insertvalue %3, %261[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = builtin.unrealized_conversion_cast %262 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %264 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %265 = llvm.insertvalue %c0_i64, %264[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %266 = llvm.insertvalue %c128_i64, %265[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %267 = llvm.insertvalue %c32_i64, %266[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%268: index):  // 2 preds: ^bb30, ^bb32
    %269 = builtin.unrealized_conversion_cast %268 : index to i64
    %270 = arith.cmpi slt, %268, %c4096 : index
    cf.cond_br %270, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %271 = llvm.getelementptr %256[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %271 : f32, !llvm.ptr
    %272 = arith.addi %268, %c1 : index
    cf.br ^bb31(%272 : index)
  ^bb33:  // pred: ^bb31
    %273 = llvm.insertvalue %c4096_i64, %267[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %274 = llvm.extractvalue %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %275 = llvm.getelementptr %274[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %276 = llvm.load %275 : !llvm.ptr -> i64
    %277 = builtin.unrealized_conversion_cast %276 : i64 to index
    %278 = llvm.extractvalue %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %279 = llvm.getelementptr %278[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %280 = llvm.load %279 : !llvm.ptr -> i64
    %281 = builtin.unrealized_conversion_cast %280 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%277) to (%281) step (%c1) {
        %282 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %283 = llvm.extractvalue %133[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %284 = llvm.getelementptr %283[%282] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %285 = llvm.load %284 : !llvm.ptr -> i64
        %286 = builtin.unrealized_conversion_cast %285 : i64 to index
        %287 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %288 = llvm.getelementptr %287[%282] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %289 = llvm.load %288 : !llvm.ptr -> i64
        %290 = builtin.unrealized_conversion_cast %289 : i64 to index
        %291 = arith.addi %arg12, %c1 : index
        %292 = builtin.unrealized_conversion_cast %291 : index to i64
        %293 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %294 = llvm.getelementptr %293[%292] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %295 = llvm.load %294 : !llvm.ptr -> i64
        %296 = builtin.unrealized_conversion_cast %295 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%290) to (%296) step (%c1) {
            %297 = builtin.unrealized_conversion_cast %arg13 : index to i64
            %298 = llvm.extractvalue %134[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %299 = llvm.getelementptr %298[%297] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %300 = llvm.load %299 : !llvm.ptr -> i64
            %301 = builtin.unrealized_conversion_cast %300 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %302 = arith.muli %arg13, %c32 : index
                %303 = arith.addi %302, %arg14 : index
                %304 = builtin.unrealized_conversion_cast %303 : index to i64
                %305 = arith.muli %301, %c32 : index
                %306 = arith.addi %305, %arg14 : index
                %307 = builtin.unrealized_conversion_cast %306 : index to i64
                %308 = arith.muli %286, %c32 : index
                %309 = arith.addi %308, %arg14 : index
                %310 = builtin.unrealized_conversion_cast %309 : index to i64
                %311 = llvm.getelementptr %256[%310] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %312 = llvm.load %311 : !llvm.ptr -> f32
                %313 = llvm.extractvalue %135[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %314 = llvm.getelementptr %313[%304] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %315 = llvm.load %314 : !llvm.ptr -> f32
                %316 = llvm.extractvalue %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %317 = llvm.getelementptr %316[%307] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %318 = llvm.load %317 : !llvm.ptr -> f32
                %319 = arith.mulf %315, %318 : f32
                %320 = arith.addf %312, %319 : f32
                %321 = llvm.getelementptr %256[%310] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %320, %321 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %263, %273 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func private @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: index, %arg7: index, %arg8: index, %arg9: f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) {
    %c0 = arith.constant 0 : index
    %false = arith.constant false
    %c32 = arith.constant 32 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : index to i64
    %4 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg6 : index to i64
    %6 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %c1 : index to i64
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%8] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %18 = arith.index_cast %17 : i64 to index
    %19 = arith.subi %16, %c1 : index
    %20 = builtin.unrealized_conversion_cast %19 : index to i64
    %21 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %21, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%20] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = arith.cmpi eq, %25, %arg6 : index
    cf.br ^bb3(%26 : i1)
  ^bb2:  // pred: ^bb0
    cf.br ^bb3(%false : i1)
  ^bb3(%27: i1):  // 2 preds: ^bb1, ^bb2
    cf.br ^bb4
  ^bb4:  // pred: ^bb3
    %28 = arith.select %27, %19, %18 : index
    %29 = builtin.unrealized_conversion_cast %28 : index to i64
    cf.cond_br %27, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    cf.br ^bb19(%arg1, %arg2, %arg5 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %30 = arith.addi %18, %c1 : index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%7] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %31, %33 : i64, !llvm.ptr
    %34 = llvm.extractvalue %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %35 = arith.index_cast %34 : i64 to index
    %36 = builtin.unrealized_conversion_cast %35 : index to i64
    %37 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %35, %c1 : index
    %40 = arith.cmpi ugt, %39, %38 : index
    cf.cond_br %40, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %41 = arith.muli %38, %c2 : index
    %42 = llvm.extractvalue %1[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %43 = builtin.unrealized_conversion_cast %41 : index to i64
    %44 = llvm.icmp "ugt" %43, %42 : i64
    llvm.cond_br %44, ^bb8, ^bb9(%1 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %45 = llvm.mlir.null : !llvm.ptr
    %46 = llvm.getelementptr %45[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %47 = llvm.ptrtoint %46 : !llvm.ptr to i64
    %48 = llvm.mul %43, %47  : i64
    %49 = llvm.mul %42, %47  : i64
    %50 = llvm.call @malloc(%48) : (i64) -> !llvm.ptr
    %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%50, %51, %49) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %52 = llvm.extractvalue %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%52) : (!llvm.ptr) -> ()
    %53 = llvm.insertvalue %50, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %50, %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%55: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %56 = llvm.insertvalue %43, %55[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = builtin.unrealized_conversion_cast %56 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb11(%57 : memref<?xindex>)
  ^bb10:  // pred: ^bb6
    cf.br ^bb11(%arg1 : memref<?xindex>)
  ^bb11(%58: memref<?xindex>):  // 2 preds: ^bb9, ^bb10
    %59 = builtin.unrealized_conversion_cast %58 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    %60 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.getelementptr %60[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %5, %61 : i64, !llvm.ptr
    %62 = arith.index_cast %39 : index to i64
    %63 = llvm.insertvalue %62, %arg5[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %64 = llvm.extractvalue %arg5[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %65 = arith.index_cast %64 : i64 to index
    %66 = builtin.unrealized_conversion_cast %65 : index to i64
    %67 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = builtin.unrealized_conversion_cast %67 : i64 to index
    %69 = arith.addi %65, %c1 : index
    %70 = arith.cmpi ugt, %69, %68 : index
    cf.cond_br %70, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %71 = arith.muli %68, %c2 : index
    %72 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = builtin.unrealized_conversion_cast %71 : index to i64
    %74 = llvm.icmp "ugt" %73, %72 : i64
    llvm.cond_br %74, ^bb14, ^bb15(%6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %75 = llvm.mlir.null : !llvm.ptr
    %76 = llvm.getelementptr %75[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %77 = llvm.ptrtoint %76 : !llvm.ptr to i64
    %78 = llvm.mul %73, %77  : i64
    %79 = llvm.mul %72, %77  : i64
    %80 = llvm.call @malloc(%78) : (i64) -> !llvm.ptr
    %81 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%80, %81, %79) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %82 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%82) : (!llvm.ptr) -> ()
    %83 = llvm.insertvalue %80, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %84 = llvm.insertvalue %80, %83[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%84 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%85: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %86 = llvm.insertvalue %73, %85[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = builtin.unrealized_conversion_cast %86 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb17(%87 : memref<?xindex>)
  ^bb16:  // pred: ^bb12
    cf.br ^bb17(%arg2 : memref<?xindex>)
  ^bb17(%88: memref<?xindex>):  // 2 preds: ^bb15, ^bb16
    %89 = builtin.unrealized_conversion_cast %88 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %90 = llvm.extractvalue %89[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.getelementptr %90[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %8, %91 : i64, !llvm.ptr
    %92 = arith.index_cast %69 : index to i64
    %93 = llvm.insertvalue %92, %63[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb19(%58, %88, %93 : memref<?xindex>, memref<?xindex>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%94: memref<?xindex>, %95: memref<?xindex>, %96: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %97 = builtin.unrealized_conversion_cast %95 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb20
  ^bb20:  // pred: ^bb19
    %98 = arith.addi %28, %c1 : index
    %99 = builtin.unrealized_conversion_cast %98 : index to i64
    %100 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = builtin.unrealized_conversion_cast %102 : i64 to index
    %104 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.getelementptr %104[%99] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %106 = llvm.load %105 : !llvm.ptr -> i64
    %107 = builtin.unrealized_conversion_cast %106 : i64 to index
    %108 = llvm.extractvalue %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %109 = arith.index_cast %108 : i64 to index
    %110 = builtin.unrealized_conversion_cast %109 : index to i64
    %111 = arith.subi %107, %c1 : index
    %112 = builtin.unrealized_conversion_cast %111 : index to i64
    %113 = arith.cmpi ult, %103, %107 : index
    cf.cond_br %113, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %114 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%112] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi eq, %117, %arg7 : index
    cf.br ^bb23(%118 : i1)
  ^bb22:  // pred: ^bb20
    %119 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%29] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %110, %120 : i64, !llvm.ptr
    cf.br ^bb23(%false : i1)
  ^bb23(%121: i1):  // 2 preds: ^bb21, ^bb22
    cf.br ^bb24
  ^bb24:  // pred: ^bb23
    %122 = arith.select %121, %111, %109 : index
    cf.cond_br %121, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    cf.br ^bb44(%arg3, %arg4, %96 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %123 = arith.addi %109, %c1 : index
    %124 = builtin.unrealized_conversion_cast %123 : index to i64
    %125 = llvm.extractvalue %97[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%99] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %128 = arith.index_cast %127 : i64 to index
    %129 = builtin.unrealized_conversion_cast %128 : index to i64
    %130 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %131 = builtin.unrealized_conversion_cast %130 : i64 to index
    %132 = arith.addi %128, %c1 : index
    %133 = arith.cmpi ugt, %132, %131 : index
    cf.cond_br %133, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %134 = arith.muli %131, %c2 : index
    %135 = llvm.extractvalue %2[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = builtin.unrealized_conversion_cast %134 : index to i64
    %137 = llvm.icmp "ugt" %136, %135 : i64
    llvm.cond_br %137, ^bb28, ^bb29(%2 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %138 = llvm.mlir.null : !llvm.ptr
    %139 = llvm.getelementptr %138[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %140 = llvm.ptrtoint %139 : !llvm.ptr to i64
    %141 = llvm.mul %136, %140  : i64
    %142 = llvm.mul %135, %140  : i64
    %143 = llvm.call @malloc(%141) : (i64) -> !llvm.ptr
    %144 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%143, %144, %142) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %145 = llvm.extractvalue %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%145) : (!llvm.ptr) -> ()
    %146 = llvm.insertvalue %143, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.insertvalue %143, %146[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%147 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%148: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %149 = llvm.insertvalue %136, %148[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %150 = builtin.unrealized_conversion_cast %149 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb31(%150 : memref<?xindex>)
  ^bb30:  // pred: ^bb26
    cf.br ^bb31(%arg3 : memref<?xindex>)
  ^bb31(%151: memref<?xindex>):  // 2 preds: ^bb29, ^bb30
    %152 = builtin.unrealized_conversion_cast %151 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb32
  ^bb32:  // pred: ^bb31
    %153 = llvm.extractvalue %152[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %154 = llvm.getelementptr %153[%129] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %3, %154 : i64, !llvm.ptr
    %155 = arith.index_cast %132 : index to i64
    %156 = llvm.insertvalue %155, %96[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %157 = llvm.extractvalue %96[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %158 = arith.index_cast %157 : i64 to index
    %159 = builtin.unrealized_conversion_cast %158 : index to i64
    %160 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = builtin.unrealized_conversion_cast %160 : i64 to index
    %162 = arith.addi %158, %c32 : index
    %163 = arith.cmpi ugt, %162, %161 : index
    cf.cond_br %163, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    cf.br ^bb34(%161 : index)
  ^bb34(%164: index):  // 2 preds: ^bb33, ^bb34
    %165 = arith.muli %164, %c2 : index
    %166 = arith.cmpi ugt, %162, %165 : index
    cf.cond_br %166, ^bb34(%165 : index), ^bb35
  ^bb35:  // pred: ^bb34
    %167 = llvm.extractvalue %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = builtin.unrealized_conversion_cast %165 : index to i64
    %169 = llvm.icmp "ugt" %168, %167 : i64
    llvm.cond_br %169, ^bb36, ^bb37(%4 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %170 = llvm.mlir.null : !llvm.ptr
    %171 = llvm.getelementptr %170[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %172 = llvm.ptrtoint %171 : !llvm.ptr to i64
    %173 = llvm.mul %168, %172  : i64
    %174 = llvm.mul %167, %172  : i64
    %175 = llvm.call @malloc(%173) : (i64) -> !llvm.ptr
    %176 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%175, %176, %174) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %177 = llvm.extractvalue %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%177) : (!llvm.ptr) -> ()
    %178 = llvm.insertvalue %175, %4[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.insertvalue %175, %178[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%179 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%180: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %181 = llvm.insertvalue %168, %180[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = builtin.unrealized_conversion_cast %181 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    cf.br ^bb39(%182 : memref<?xf32>)
  ^bb38:  // pred: ^bb32
    cf.br ^bb39(%arg4 : memref<?xf32>)
  ^bb39(%183: memref<?xf32>):  // 2 preds: ^bb37, ^bb38
    %184 = builtin.unrealized_conversion_cast %183 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %185 = llvm.extractvalue %184[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    cf.br ^bb41(%c0 : index)
  ^bb41(%186: index):  // 2 preds: ^bb40, ^bb42
    %187 = builtin.unrealized_conversion_cast %186 : index to i64
    %188 = arith.cmpi slt, %186, %c32 : index
    cf.cond_br %188, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %189 = llvm.getelementptr %185[%159] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %190 = llvm.getelementptr %189[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %190 : f32, !llvm.ptr
    %191 = arith.addi %186, %c1 : index
    cf.br ^bb41(%191 : index)
  ^bb43:  // pred: ^bb41
    %192 = arith.index_cast %162 : index to i64
    %193 = llvm.insertvalue %192, %156[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    cf.br ^bb44(%151, %183, %193 : memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%194: memref<?xindex>, %195: memref<?xf32>, %196: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %197 = builtin.unrealized_conversion_cast %195 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    cf.br ^bb45
  ^bb45:  // pred: ^bb44
    %198 = arith.muli %122, %c32 : index
    %199 = arith.addi %198, %arg8 : index
    %200 = builtin.unrealized_conversion_cast %199 : index to i64
    %201 = llvm.extractvalue %197[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%200] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg9, %202 : f32, !llvm.ptr
    return %arg0, %94, %95, %194, %195, %196 : memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>
  }
  func.func private @_sparse_binary_search_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : index to i64
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%2: index, %3: index):  // 2 preds: ^bb0, ^bb2
    %4 = arith.cmpi ult, %2, %3 : index
    cf.cond_br %4, ^bb2(%2, %3 : index, index), ^bb3
  ^bb2(%5: index, %6: index):  // pred: ^bb1
    %7 = arith.addi %5, %6 : index
    %8 = arith.shrui %7, %c1 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %8, %c1 : index
    %11 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.getelementptr %11[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %13 = llvm.load %12 : !llvm.ptr -> i64
    %14 = builtin.unrealized_conversion_cast %13 : i64 to index
    %15 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = arith.cmpi ult, %14, %18 : index
    %20 = arith.select %19, %5, %10 : index
    %21 = arith.select %19, %8, %6 : index
    cf.br ^bb1(%20, %21 : index, index)
  ^bb3:  // pred: ^bb1
    return %2 : index
  }
  func.func private @_sparse_sort_stable_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = arith.addi %arg0, %c1 : index
    cf.br ^bb1(%1 : index)
  ^bb1(%2: index):  // 2 preds: ^bb0, ^bb5
    %3 = builtin.unrealized_conversion_cast %2 : index to i64
    %4 = arith.cmpi slt, %2, %arg1 : index
    cf.cond_br %4, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %5 = call @_sparse_binary_search_1_index(%arg0, %2, %arg2) : (index, index, memref<?xindex>) -> index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.getelementptr %7[%3] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %9 = llvm.load %8 : !llvm.ptr -> i64
    %10 = arith.subi %2, %5 : index
    cf.br ^bb3(%c0 : index)
  ^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
    %12 = arith.cmpi slt, %11, %10 : index
    cf.cond_br %12, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %13 = arith.subi %2, %11 : index
    %14 = builtin.unrealized_conversion_cast %13 : index to i64
    %15 = arith.subi %13, %c1 : index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %19, %21 : i64, !llvm.ptr
    %22 = arith.addi %11, %c1 : index
    cf.br ^bb3(%22 : index)
  ^bb5:  // pred: ^bb3
    %23 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %9, %24 : i64, !llvm.ptr
    %25 = arith.addi %2, %c1 : index
    cf.br ^bb1(%25 : index)
  ^bb6:  // pred: ^bb1
    return
  }
  func.func private @_sparse_shift_down_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: index) {
    %c1 = arith.constant 1 : index
    %c2 = arith.constant 2 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = arith.cmpi uge, %arg3, %c2 : index
    cf.cond_br %1, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %arg3, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.cmpi uge, %4, %2 : index
    cf.cond_br %5, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %6 = arith.shli %2, %c1 : index
    %7 = arith.addi %6, %c1 : index
    %8 = arith.addi %7, %arg0 : index
    %9 = builtin.unrealized_conversion_cast %8 : index to i64
    %10 = arith.addi %6, %c2 : index
    %11 = arith.cmpi ult, %10, %arg3 : index
    cf.cond_br %11, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %12 = arith.addi %10, %arg0 : index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = builtin.unrealized_conversion_cast %16 : i64 to index
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = arith.cmpi ult, %17, %21 : index
    %23 = arith.select %22, %10, %7 : index
    %24 = arith.select %22, %12, %8 : index
    cf.br ^bb5(%23, %24, %arg1 : index, index, index)
  ^bb4:  // pred: ^bb2
    cf.br ^bb5(%7, %8, %arg1 : index, index, index)
  ^bb5(%25: index, %26: index, %27: index):  // 3 preds: ^bb3, ^bb4, ^bb13
    cf.br ^bb6(%27, %25, %26 : index, index, index)
  ^bb6(%28: index, %29: index, %30: index):  // pred: ^bb5
    cf.br ^bb7(%28, %29, %30 : index, index, index)
  ^bb7(%31: index, %32: index, %33: index):  // pred: ^bb6
    %34 = builtin.unrealized_conversion_cast %31 : index to i64
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = builtin.unrealized_conversion_cast %38 : i64 to index
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = arith.cmpi ult, %39, %43 : index
    cf.cond_br %44, ^bb8(%31, %32, %33 : index, index, index), ^bb14
  ^bb8(%45: index, %46: index, %47: index):  // pred: ^bb7
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = builtin.unrealized_conversion_cast %47 : index to i64
    %50 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = arith.cmpi uge, %4, %46 : index
    cf.cond_br %60, ^bb9, ^bb13(%46, %47 : index, index)
  ^bb9:  // pred: ^bb8
    %61 = arith.shli %46, %c1 : index
    %62 = arith.addi %61, %c1 : index
    %63 = arith.addi %62, %arg0 : index
    %64 = builtin.unrealized_conversion_cast %63 : index to i64
    %65 = arith.addi %61, %c2 : index
    %66 = arith.cmpi ult, %65, %arg3 : index
    cf.cond_br %66, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %67 = arith.addi %65, %arg0 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %75 = llvm.load %74 : !llvm.ptr -> i64
    %76 = builtin.unrealized_conversion_cast %75 : i64 to index
    %77 = arith.cmpi ult, %72, %76 : index
    %78 = arith.select %77, %65, %62 : index
    %79 = arith.select %77, %67, %63 : index
    cf.br ^bb12(%78, %79 : index, index)
  ^bb11:  // pred: ^bb9
    cf.br ^bb12(%62, %63 : index, index)
  ^bb12(%80: index, %81: index):  // 2 preds: ^bb10, ^bb11
    cf.br ^bb13(%80, %81 : index, index)
  ^bb13(%82: index, %83: index):  // 2 preds: ^bb8, ^bb12
    cf.br ^bb5(%82, %83, %47 : index, index, index)
  ^bb14:  // pred: ^bb7
    cf.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    cf.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    return
  }
  func.func private @_sparse_heap_sort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %2 = arith.subi %arg1, %arg0 : index
    %3 = arith.subi %2, %c2 : index
    %4 = arith.shrui %3, %c1 : index
    %5 = arith.addi %4, %c1 : index
    cf.br ^bb1(%c0 : index)
  ^bb1(%6: index):  // 2 preds: ^bb0, ^bb2
    %7 = arith.cmpi slt, %6, %5 : index
    cf.cond_br %7, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %8 = arith.subi %4, %6 : index
    %9 = arith.addi %arg0, %8 : index
    call @_sparse_shift_down_1_index(%arg0, %9, %arg2, %2) : (index, index, memref<?xindex>, index) -> ()
    %10 = arith.addi %6, %c1 : index
    cf.br ^bb1(%10 : index)
  ^bb3:  // pred: ^bb1
    %11 = arith.subi %2, %c1 : index
    cf.br ^bb4(%c0 : index)
  ^bb4(%12: index):  // 2 preds: ^bb3, ^bb5
    %13 = arith.cmpi slt, %12, %11 : index
    cf.cond_br %13, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %14 = arith.subi %2, %12 : index
    %15 = arith.addi %arg0, %14 : index
    %16 = arith.subi %15, %c1 : index
    %17 = builtin.unrealized_conversion_cast %16 : index to i64
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    %28 = arith.subi %14, %c1 : index
    call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %28) : (index, index, memref<?xindex>, index) -> ()
    %29 = arith.addi %12, %c1 : index
    cf.br ^bb4(%29 : index)
  ^bb6:  // pred: ^bb4
    return
  }
  func.func private @_sparse_partition_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>) -> index {
    %c-1 = arith.constant -1 : index
    %c1000 = arith.constant 1000 : index
    %c1 = arith.constant 1 : index
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg0 : index to i64
    %2 = arith.addi %arg0, %arg1 : index
    %3 = arith.shrui %2, %c1 : index
    %4 = builtin.unrealized_conversion_cast %3 : index to i64
    %5 = arith.subi %arg1, %c1 : index
    %6 = builtin.unrealized_conversion_cast %5 : index to i64
    %7 = arith.subi %arg1, %arg0 : index
    %8 = arith.cmpi ult, %7, %c1000 : index
    cf.cond_br %8, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %9 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.getelementptr %9[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %11 = llvm.load %10 : !llvm.ptr -> i64
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.getelementptr %13[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %15 = llvm.load %14 : !llvm.ptr -> i64
    %16 = builtin.unrealized_conversion_cast %15 : i64 to index
    %17 = arith.cmpi ult, %12, %16 : index
    cf.cond_br %17, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %18 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %25 : i64, !llvm.ptr
    %26 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %20, %27 : i64, !llvm.ptr
    cf.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %28 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.getelementptr %28[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %30 = llvm.load %29 : !llvm.ptr -> i64
    %31 = builtin.unrealized_conversion_cast %30 : i64 to index
    %32 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %34 = llvm.load %33 : !llvm.ptr -> i64
    %35 = builtin.unrealized_conversion_cast %34 : i64 to index
    %36 = arith.cmpi ult, %31, %35 : index
    cf.cond_br %36, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %42, %44 : i64, !llvm.ptr
    %45 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %39, %46 : i64, !llvm.ptr
    %47 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    %55 = arith.cmpi ult, %50, %54 : index
    cf.cond_br %55, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %56 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %58 = llvm.load %57 : !llvm.ptr -> i64
    %59 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.getelementptr %59[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %61 = llvm.load %60 : !llvm.ptr -> i64
    %62 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %63 = llvm.getelementptr %62[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %61, %63 : i64, !llvm.ptr
    %64 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %58, %65 : i64, !llvm.ptr
    cf.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    cf.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    cf.br ^bb27(%arg0, %5, %3 : index, index, index)
  ^bb8:  // pred: ^bb0
    %66 = arith.addi %arg0, %arg1 : index
    %67 = arith.shrui %66, %c1 : index
    %68 = builtin.unrealized_conversion_cast %67 : index to i64
    %69 = arith.addi %3, %arg1 : index
    %70 = arith.shrui %69, %c1 : index
    %71 = builtin.unrealized_conversion_cast %70 : index to i64
    %72 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = arith.cmpi ult, %75, %79 : index
    cf.cond_br %80, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %81 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %86, %88 : i64, !llvm.ptr
    %89 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %83, %90 : i64, !llvm.ptr
    cf.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %91 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    %99 = arith.cmpi ult, %94, %98 : index
    cf.cond_br %99, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %100 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.getelementptr %100[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %102 = llvm.load %101 : !llvm.ptr -> i64
    %103 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %105, %107 : i64, !llvm.ptr
    %108 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.getelementptr %108[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %102, %109 : i64, !llvm.ptr
    %110 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %113, %117 : index
    cf.cond_br %118, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %119 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %124 = llvm.load %123 : !llvm.ptr -> i64
    %125 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %124, %126 : i64, !llvm.ptr
    %127 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %128 : i64, !llvm.ptr
    cf.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    cf.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %129 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %135 = llvm.load %134 : !llvm.ptr -> i64
    %136 = builtin.unrealized_conversion_cast %135 : i64 to index
    %137 = arith.cmpi ult, %132, %136 : index
    cf.cond_br %137, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %138 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %139 = llvm.getelementptr %138[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %140 = llvm.load %139 : !llvm.ptr -> i64
    %141 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %143, %145 : i64, !llvm.ptr
    %146 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %140, %147 : i64, !llvm.ptr
    %148 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %154 = llvm.load %153 : !llvm.ptr -> i64
    %155 = builtin.unrealized_conversion_cast %154 : i64 to index
    %156 = arith.cmpi ult, %151, %155 : index
    cf.cond_br %156, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %157 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %162, %164 : i64, !llvm.ptr
    %165 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %166 = llvm.getelementptr %165[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %159, %166 : i64, !llvm.ptr
    %167 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = builtin.unrealized_conversion_cast %173 : i64 to index
    %175 = arith.cmpi ult, %170, %174 : index
    cf.cond_br %175, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %176 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %177 = llvm.getelementptr %176[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %178 = llvm.load %177 : !llvm.ptr -> i64
    %179 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.getelementptr %179[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %181 = llvm.load %180 : !llvm.ptr -> i64
    %182 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %181, %183 : i64, !llvm.ptr
    %184 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %178, %185 : i64, !llvm.ptr
    cf.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    cf.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    cf.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %186 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %191 = llvm.getelementptr %190[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %192 = llvm.load %191 : !llvm.ptr -> i64
    %193 = builtin.unrealized_conversion_cast %192 : i64 to index
    %194 = arith.cmpi ult, %189, %193 : index
    cf.cond_br %194, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %195 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%6] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = arith.cmpi ult, %208, %212 : index
    cf.cond_br %213, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %214 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = llvm.getelementptr %214[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %216 = llvm.load %215 : !llvm.ptr -> i64
    %217 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %218 = llvm.getelementptr %217[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %219 = llvm.load %218 : !llvm.ptr -> i64
    %220 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%71] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %219, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %216, %223 : i64, !llvm.ptr
    %224 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = arith.cmpi ult, %227, %231 : index
    cf.cond_br %232, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %233 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.getelementptr %233[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %235 = llvm.load %234 : !llvm.ptr -> i64
    %236 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = llvm.getelementptr %236[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %238 = llvm.load %237 : !llvm.ptr -> i64
    %239 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%4] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %238, %240 : i64, !llvm.ptr
    %241 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %242 = llvm.getelementptr %241[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %235, %242 : i64, !llvm.ptr
    %243 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %248 = llvm.getelementptr %247[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %249 = llvm.load %248 : !llvm.ptr -> i64
    %250 = builtin.unrealized_conversion_cast %249 : i64 to index
    %251 = arith.cmpi ult, %246, %250 : index
    cf.cond_br %251, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %252 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.getelementptr %252[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %254 = llvm.load %253 : !llvm.ptr -> i64
    %255 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.getelementptr %255[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %257 = llvm.load %256 : !llvm.ptr -> i64
    %258 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %257, %259 : i64, !llvm.ptr
    %260 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %254, %261 : i64, !llvm.ptr
    cf.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    cf.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    cf.br ^bb6
  ^bb27(%262: index, %263: index, %264: index):  // 2 preds: ^bb7, ^bb45
    cf.br ^bb28(%262, %263, %264 : index, index, index)
  ^bb28(%265: index, %266: index, %267: index):  // pred: ^bb27
    %268 = arith.cmpi ult, %265, %266 : index
    cf.cond_br %268, ^bb29(%265, %266, %267 : index, index, index), ^bb46
  ^bb29(%269: index, %270: index, %271: index):  // pred: ^bb28
    %272 = builtin.unrealized_conversion_cast %271 : index to i64
    cf.br ^bb30(%269 : index)
  ^bb30(%273: index):  // 2 preds: ^bb29, ^bb31
    %274 = builtin.unrealized_conversion_cast %273 : index to i64
    %275 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %277 = llvm.load %276 : !llvm.ptr -> i64
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = builtin.unrealized_conversion_cast %281 : i64 to index
    %283 = arith.cmpi ult, %278, %282 : index
    cf.cond_br %283, ^bb31(%273 : index), ^bb32
  ^bb31(%284: index):  // pred: ^bb30
    %285 = arith.addi %284, %c1 : index
    cf.br ^bb30(%285 : index)
  ^bb32:  // pred: ^bb30
    %286 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %287 = llvm.getelementptr %286[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %288 = llvm.load %287 : !llvm.ptr -> i64
    %289 = builtin.unrealized_conversion_cast %288 : i64 to index
    %290 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %292 = llvm.load %291 : !llvm.ptr -> i64
    %293 = builtin.unrealized_conversion_cast %292 : i64 to index
    %294 = arith.cmpi eq, %289, %293 : index
    cf.br ^bb33(%270 : index)
  ^bb33(%295: index):  // 2 preds: ^bb32, ^bb34
    %296 = builtin.unrealized_conversion_cast %295 : index to i64
    %297 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %298 = llvm.getelementptr %297[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %299 = llvm.load %298 : !llvm.ptr -> i64
    %300 = builtin.unrealized_conversion_cast %299 : i64 to index
    %301 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %302 = llvm.getelementptr %301[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %303 = llvm.load %302 : !llvm.ptr -> i64
    %304 = builtin.unrealized_conversion_cast %303 : i64 to index
    %305 = arith.cmpi ult, %300, %304 : index
    cf.cond_br %305, ^bb34(%295 : index), ^bb35
  ^bb34(%306: index):  // pred: ^bb33
    %307 = arith.addi %306, %c-1 : index
    cf.br ^bb33(%307 : index)
  ^bb35:  // pred: ^bb33
    %308 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.getelementptr %308[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %310 = llvm.load %309 : !llvm.ptr -> i64
    %311 = builtin.unrealized_conversion_cast %310 : i64 to index
    %312 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.getelementptr %312[%272] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %314 = llvm.load %313 : !llvm.ptr -> i64
    %315 = builtin.unrealized_conversion_cast %314 : i64 to index
    %316 = arith.cmpi eq, %311, %315 : index
    %317 = arith.cmpi ult, %273, %295 : index
    cf.cond_br %317, ^bb36, ^bb44(%273, %295, %271 : index, index, index)
  ^bb36:  // pred: ^bb35
    %318 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %319 = llvm.getelementptr %318[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %320 = llvm.load %319 : !llvm.ptr -> i64
    %321 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %322 = llvm.getelementptr %321[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %323 = llvm.load %322 : !llvm.ptr -> i64
    %324 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %325 = llvm.getelementptr %324[%274] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %323, %325 : i64, !llvm.ptr
    %326 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%296] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %320, %327 : i64, !llvm.ptr
    %328 = arith.cmpi eq, %273, %271 : index
    cf.cond_br %328, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    cf.br ^bb39(%295 : index)
  ^bb38:  // pred: ^bb36
    %329 = arith.cmpi eq, %295, %271 : index
    %330 = arith.select %329, %273, %271 : index
    cf.br ^bb39(%330 : index)
  ^bb39(%331: index):  // 2 preds: ^bb37, ^bb38
    cf.br ^bb40
  ^bb40:  // pred: ^bb39
    %332 = arith.andi %294, %316 : i1
    cf.cond_br %332, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %333 = arith.addi %273, %c1 : index
    %334 = arith.subi %295, %c1 : index
    cf.br ^bb43(%333, %334 : index, index)
  ^bb42:  // pred: ^bb40
    cf.br ^bb43(%273, %295 : index, index)
  ^bb43(%335: index, %336: index):  // 2 preds: ^bb41, ^bb42
    cf.br ^bb44(%335, %336, %331 : index, index, index)
  ^bb44(%337: index, %338: index, %339: index):  // 2 preds: ^bb35, ^bb43
    cf.br ^bb45(%337, %338, %339 : index, index, index)
  ^bb45(%340: index, %341: index, %342: index):  // pred: ^bb44
    cf.br ^bb27(%340, %341, %342 : index, index, index)
  ^bb46:  // pred: ^bb28
    return %267 : index
  }
  func.func private @_sparse_hybrid_qsort_1_index(%arg0: index, %arg1: index, %arg2: memref<?xindex>, %arg3: i64) {
    %c30 = arith.constant 30 : index
    %c1_i64 = arith.constant 1 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    cf.br ^bb1(%arg0, %arg1 : index, index)
  ^bb1(%0: index, %1: index):  // 2 preds: ^bb0, ^bb14
    %2 = arith.addi %0, %c1 : index
    %3 = arith.cmpi ult, %2, %1 : index
    cf.cond_br %3, ^bb2(%0, %1 : index, index), ^bb15
  ^bb2(%4: index, %5: index):  // pred: ^bb1
    %6 = arith.subi %5, %4 : index
    %7 = arith.cmpi ule, %6, %c30 : index
    cf.cond_br %7, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    call @_sparse_sort_stable_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb13(%4, %4 : index, index)
  ^bb4:  // pred: ^bb2
    %8 = arith.subi %arg3, %c1_i64 : i64
    %9 = arith.cmpi ule, %8, %c0_i64 : i64
    cf.cond_br %9, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    call @_sparse_heap_sort_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> ()
    cf.br ^bb11(%4, %4 : index, index)
  ^bb6:  // pred: ^bb4
    %10 = call @_sparse_partition_1_index(%4, %5, %arg2) : (index, index, memref<?xindex>) -> index
    %11 = arith.addi %10, %c1 : index
    %12 = arith.subi %10, %4 : index
    %13 = arith.subi %5, %10 : index
    %14 = arith.cmpi ule, %12, %13 : index
    %15 = arith.select %14, %11, %4 : index
    %16 = arith.select %14, %5, %10 : index
    cf.cond_br %14, ^bb7(%12, %4, %10 : index, index, index), ^bb7(%13, %11, %5 : index, index, index)
  ^bb7(%17: index, %18: index, %19: index):  // 2 preds: ^bb6, ^bb6
    %20 = arith.cmpi ne, %17, %c0 : index
    cf.cond_br %20, ^bb8(%18, %19 : index, index), ^bb9
  ^bb8(%21: index, %22: index):  // pred: ^bb7
    call @_sparse_hybrid_qsort_1_index(%21, %22, %arg2, %8) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    cf.br ^bb10
  ^bb10:  // pred: ^bb9
    cf.br ^bb11(%15, %16 : index, index)
  ^bb11(%23: index, %24: index):  // 2 preds: ^bb5, ^bb10
    cf.br ^bb12
  ^bb12:  // pred: ^bb11
    cf.br ^bb13(%23, %24 : index, index)
  ^bb13(%25: index, %26: index):  // 2 preds: ^bb3, ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    cf.br ^bb1(%25, %26 : index, index)
  ^bb15:  // pred: ^bb1
    return
  }
  func.func @MTTKRP.A.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xindex>, %arg5: memref<?xindex>, %arg6: memref<?xf32>, %arg7: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg8: memref<?xf32>, %arg9: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> (memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(4096 : index) : i64
    %1 = llvm.mlir.constant(32 : index) : i64
    %2 = llvm.mlir.constant(0 : index) : i64
    %3 = llvm.mlir.constant(1 : index) : i64
    %4 = llvm.mlir.constant(16 : index) : i64
    %true = arith.constant true
    %cst = arith.constant 0.000000e+00 : f32
    %c64_i64 = arith.constant 64 : i64
    %c0_i64 = arith.constant 0 : i64
    %c1_i64 = arith.constant 1 : i64
    %c2_i64 = arith.constant 2 : i64
    %c128_i64 = arith.constant 128 : i64
    %c32_i64 = arith.constant 32 : i64
    %false = arith.constant false
    %c4096_i64 = arith.constant 4096 : i64
    %c4096 = arith.constant 4096 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %5 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg4 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %arg5 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = builtin.unrealized_conversion_cast %arg6 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %arg8 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %14 = builtin.unrealized_conversion_cast %c0 : index to i64
    %15 = builtin.unrealized_conversion_cast %c1 : index to i64
    %16 = llvm.mlir.null : !llvm.ptr
    %17 = llvm.getelementptr %16[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %18 = llvm.ptrtoint %17 : !llvm.ptr to i64
    %19 = llvm.call @malloc(%18) : (i64) -> !llvm.ptr
    %20 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %21 = llvm.insertvalue %19, %20[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %19, %21[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %2, %22[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %4, %23[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %3, %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = builtin.unrealized_conversion_cast %25 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %27 = llvm.mlir.null : !llvm.ptr
    %28 = llvm.getelementptr %27[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %29 = llvm.ptrtoint %28 : !llvm.ptr to i64
    %30 = llvm.call @malloc(%29) : (i64) -> !llvm.ptr
    %31 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %2, %33[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %4, %34[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.insertvalue %3, %35[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = builtin.unrealized_conversion_cast %36 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %38 = llvm.mlir.null : !llvm.ptr
    %39 = llvm.getelementptr %38[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %40 = llvm.ptrtoint %39 : !llvm.ptr to i64
    %41 = llvm.call @malloc(%40) : (i64) -> !llvm.ptr
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %41, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %41, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %2, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %4, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %3, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %49 = llvm.mlir.null : !llvm.ptr
    %50 = llvm.getelementptr %49[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %51 = llvm.ptrtoint %50 : !llvm.ptr to i64
    %52 = llvm.call @malloc(%51) : (i64) -> !llvm.ptr
    %53 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %54 = llvm.insertvalue %52, %53[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.insertvalue %52, %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.insertvalue %2, %55[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.insertvalue %4, %56[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %3, %57[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = builtin.unrealized_conversion_cast %58 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %60 = llvm.mlir.null : !llvm.ptr
    %61 = llvm.getelementptr %60[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %62 = llvm.ptrtoint %61 : !llvm.ptr to i64
    %63 = llvm.call @malloc(%62) : (i64) -> !llvm.ptr
    %64 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %65 = llvm.insertvalue %63, %64[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %63, %65[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %2, %66[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %4, %67[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.insertvalue %3, %68[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = builtin.unrealized_conversion_cast %69 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %71 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %72 = llvm.insertvalue %c0_i64, %71[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %73 = llvm.insertvalue %c0_i64, %72[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %74 = llvm.insertvalue %c0_i64, %73[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %75 = llvm.insertvalue %c0_i64, %74[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %76 = llvm.insertvalue %c0_i64, %75[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %77 = llvm.insertvalue %c128_i64, %76[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %78 = llvm.getelementptr %19[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %78 : i64, !llvm.ptr
    %79 = llvm.insertvalue %c1_i64, %77[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %80 = llvm.insertvalue %c128_i64, %79[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %81 = llvm.getelementptr %41[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %81 : i64, !llvm.ptr
    %82 = llvm.insertvalue %c1_i64, %80[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %83 = llvm.insertvalue %c32_i64, %82[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %84 = llvm.getelementptr %19[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %84 : i64, !llvm.ptr
    %85 = llvm.insertvalue %c2_i64, %83[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %86 = llvm.mlir.null : !llvm.ptr
    %87 = llvm.getelementptr %86[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %88 = llvm.ptrtoint %87 : !llvm.ptr to i64
    %89 = llvm.call @malloc(%88) : (i64) -> !llvm.ptr
    %90 = llvm.mlir.null : !llvm.ptr
    %91 = llvm.getelementptr %90[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %92 = llvm.ptrtoint %91 : !llvm.ptr to i64
    %93 = llvm.call @malloc(%92) : (i64) -> !llvm.ptr
    %94 = llvm.mlir.null : !llvm.ptr
    %95 = llvm.getelementptr %94[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %96 = llvm.ptrtoint %95 : !llvm.ptr to i64
    %97 = llvm.call @malloc(%96) : (i64) -> !llvm.ptr
    %98 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %99 = llvm.insertvalue %97, %98[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.insertvalue %97, %99[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.insertvalue %2, %100[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %1, %101[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.insertvalue %3, %102[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = builtin.unrealized_conversion_cast %103 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    cf.br ^bb1(%c0 : index)
  ^bb1(%105: index):  // 2 preds: ^bb0, ^bb2
    %106 = builtin.unrealized_conversion_cast %105 : index to i64
    %107 = arith.cmpi slt, %105, %c32 : index
    cf.cond_br %107, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %108 = llvm.getelementptr %89[%106] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %108 : f32, !llvm.ptr
    %109 = arith.addi %105, %c1 : index
    cf.br ^bb1(%109 : index)
  ^bb3:  // pred: ^bb1
    cf.br ^bb4(%c0 : index)
  ^bb4(%110: index):  // 2 preds: ^bb3, ^bb5
    %111 = builtin.unrealized_conversion_cast %110 : index to i64
    %112 = arith.cmpi slt, %110, %c32 : index
    cf.cond_br %112, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %113 = llvm.getelementptr %93[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %113 : i1, !llvm.ptr
    %114 = arith.addi %110, %c1 : index
    cf.br ^bb4(%114 : index)
  ^bb6:  // pred: ^bb4
    %115 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = llvm.getelementptr %115[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %117 = llvm.load %116 : !llvm.ptr -> i64
    %118 = builtin.unrealized_conversion_cast %117 : i64 to index
    %119 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.getelementptr %119[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %121 = llvm.load %120 : !llvm.ptr -> i64
    %122 = builtin.unrealized_conversion_cast %121 : i64 to index
    cf.br ^bb7(%118, %26, %37, %48, %59, %70, %85 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%123: index, %124: memref<?xindex>, %125: memref<?xindex>, %126: memref<?xindex>, %127: memref<?xindex>, %128: memref<?xf32>, %129: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %130 = builtin.unrealized_conversion_cast %123 : index to i64
    %131 = builtin.unrealized_conversion_cast %126 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %132 = builtin.unrealized_conversion_cast %124 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %133 = builtin.unrealized_conversion_cast %125 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %134 = builtin.unrealized_conversion_cast %127 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %135 = builtin.unrealized_conversion_cast %128 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %136 = arith.cmpi slt, %123, %122 : index
    cf.cond_br %136, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %137 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = llvm.getelementptr %137[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %139 = llvm.load %138 : !llvm.ptr -> i64
    %140 = builtin.unrealized_conversion_cast %139 : i64 to index
    %141 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %142 = llvm.getelementptr %141[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %143 = llvm.load %142 : !llvm.ptr -> i64
    %144 = builtin.unrealized_conversion_cast %143 : i64 to index
    %145 = arith.addi %123, %c1 : index
    %146 = builtin.unrealized_conversion_cast %145 : index to i64
    %147 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %148 = llvm.getelementptr %147[%146] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %149 = llvm.load %148 : !llvm.ptr -> i64
    %150 = builtin.unrealized_conversion_cast %149 : i64 to index
    cf.br ^bb9(%144, %124, %125, %126, %127, %128, %129 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%151: index, %152: memref<?xindex>, %153: memref<?xindex>, %154: memref<?xindex>, %155: memref<?xindex>, %156: memref<?xf32>, %157: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %158 = builtin.unrealized_conversion_cast %151 : index to i64
    %159 = arith.cmpi slt, %151, %150 : index
    cf.cond_br %159, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %160 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %161 = llvm.getelementptr %160[%158] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %162 = llvm.load %161 : !llvm.ptr -> i64
    %163 = builtin.unrealized_conversion_cast %162 : i64 to index
    %164 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%158] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = builtin.unrealized_conversion_cast %166 : i64 to index
    %168 = arith.addi %151, %c1 : index
    %169 = builtin.unrealized_conversion_cast %168 : index to i64
    %170 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %171 = llvm.getelementptr %170[%169] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %172 = llvm.load %171 : !llvm.ptr -> i64
    %173 = builtin.unrealized_conversion_cast %172 : i64 to index
    cf.br ^bb11(%167, %c0 : index, index)
  ^bb11(%174: index, %175: index):  // 2 preds: ^bb10, ^bb19
    %176 = builtin.unrealized_conversion_cast %174 : index to i64
    %177 = arith.cmpi slt, %174, %173 : index
    cf.cond_br %177, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %178 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%176] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    %182 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%176] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %184 = llvm.load %183 : !llvm.ptr -> f32
    cf.br ^bb13(%c0, %175 : index, index)
  ^bb13(%185: index, %186: index):  // 2 preds: ^bb12, ^bb18
    %187 = builtin.unrealized_conversion_cast %185 : index to i64
    %188 = builtin.unrealized_conversion_cast %186 : index to i64
    %189 = arith.cmpi slt, %185, %c32 : index
    cf.cond_br %189, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %190 = arith.muli %181, %c32 : index
    %191 = arith.addi %190, %185 : index
    %192 = builtin.unrealized_conversion_cast %191 : index to i64
    %193 = llvm.getelementptr %89[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %194 = llvm.load %193 : !llvm.ptr -> f32
    %195 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%192] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %197 = llvm.load %196 : !llvm.ptr -> f32
    %198 = arith.mulf %184, %197 : f32
    %199 = arith.addf %194, %198 : f32
    %200 = llvm.getelementptr %93[%187] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %201 = llvm.load %200 : !llvm.ptr -> i1
    %202 = arith.cmpi eq, %201, %false : i1
    cf.cond_br %202, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %203 = llvm.getelementptr %93[%187] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %true, %203 : i1, !llvm.ptr
    %204 = llvm.getelementptr %97[%188] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %187, %204 : i64, !llvm.ptr
    %205 = arith.addi %186, %c1 : index
    cf.br ^bb17(%205 : index)
  ^bb16:  // pred: ^bb14
    cf.br ^bb17(%186 : index)
  ^bb17(%206: index):  // 2 preds: ^bb15, ^bb16
    cf.br ^bb18
  ^bb18:  // pred: ^bb17
    %207 = llvm.getelementptr %89[%187] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %199, %207 : f32, !llvm.ptr
    %208 = arith.addi %185, %c1 : index
    cf.br ^bb13(%208, %206 : index, index)
  ^bb19:  // pred: ^bb13
    %209 = arith.addi %174, %c1 : index
    cf.br ^bb11(%209, %186 : index, index)
  ^bb20:  // pred: ^bb11
    %210 = arith.index_cast %175 : index to i64
    %211 = "llvm.intr.ctlz"(%210) <{is_zero_poison = false}> : (i64) -> i64
    %212 = arith.subi %c64_i64, %211 : i64
    call @_sparse_hybrid_qsort_1_index(%c0, %175, %104, %212) : (index, index, memref<?xindex>, i64) -> ()
    cf.br ^bb21(%c0, %152, %153, %154, %155, %156, %157 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%213: index, %214: memref<?xindex>, %215: memref<?xindex>, %216: memref<?xindex>, %217: memref<?xindex>, %218: memref<?xf32>, %219: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %220 = builtin.unrealized_conversion_cast %213 : index to i64
    %221 = arith.cmpi slt, %213, %175 : index
    cf.cond_br %221, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %222 = llvm.getelementptr %97[%220] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %223 = llvm.load %222 : !llvm.ptr -> i64
    %224 = builtin.unrealized_conversion_cast %223 : i64 to index
    %225 = llvm.getelementptr %89[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %226 = llvm.load %225 : !llvm.ptr -> f32
    %227:6 = call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%214, %215, %216, %217, %218, %219, %140, %163, %224, %226) : (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, index, index, index, f32) -> (memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
    %228 = llvm.getelementptr %89[%223] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %228 : f32, !llvm.ptr
    %229 = llvm.getelementptr %93[%223] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %false, %229 : i1, !llvm.ptr
    %230 = arith.addi %213, %c1 : index
    cf.br ^bb21(%230, %227#0, %227#1, %227#2, %227#3, %227#4, %227#5 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %231 = arith.addi %151, %c1 : index
    cf.br ^bb9(%231, %214, %215, %216, %217, %218, %219 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %232 = arith.addi %123, %c1 : index
    cf.br ^bb7(%232, %152, %153, %154, %155, %156, %157 : index, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xindex>, memref<?xf32>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%89) : (!llvm.ptr) -> ()
    llvm.call @free(%93) : (!llvm.ptr) -> ()
    llvm.call @free(%97) : (!llvm.ptr) -> ()
    %233 = llvm.extractvalue %129[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %234 = arith.index_cast %233 : i64 to index
    %235 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %237 = llvm.load %236 : !llvm.ptr -> i64
    %238 = builtin.unrealized_conversion_cast %237 : i64 to index
    cf.br ^bb26(%c1, %238 : index, index)
  ^bb26(%239: index, %240: index):  // 2 preds: ^bb25, ^bb29
    %241 = builtin.unrealized_conversion_cast %239 : index to i64
    %242 = builtin.unrealized_conversion_cast %240 : index to i64
    %243 = arith.cmpi slt, %239, %234 : index
    cf.cond_br %243, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %244 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %245 = llvm.getelementptr %244[%241] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %246 = llvm.load %245 : !llvm.ptr -> i64
    %247 = builtin.unrealized_conversion_cast %246 : i64 to index
    %248 = arith.cmpi eq, %247, %c0 : index
    %249 = arith.select %248, %240, %247 : index
    cf.cond_br %248, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %250 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %251 = llvm.getelementptr %250[%241] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %242, %251 : i64, !llvm.ptr
    cf.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %252 = arith.addi %239, %c1 : index
    cf.br ^bb26(%252, %249 : index, index)
  ^bb30:  // pred: ^bb26
    %253 = llvm.mlir.null : !llvm.ptr
    %254 = llvm.getelementptr %253[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %255 = llvm.ptrtoint %254 : !llvm.ptr to i64
    %256 = llvm.call @malloc(%255) : (i64) -> !llvm.ptr
    %257 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %258 = llvm.insertvalue %256, %257[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.insertvalue %256, %258[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.insertvalue %2, %259[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.insertvalue %0, %260[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %262 = llvm.insertvalue %3, %261[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = builtin.unrealized_conversion_cast %262 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %264 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %265 = llvm.insertvalue %c0_i64, %264[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %266 = llvm.insertvalue %c128_i64, %265[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %267 = llvm.insertvalue %c32_i64, %266[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    cf.br ^bb31(%c0 : index)
  ^bb31(%268: index):  // 2 preds: ^bb30, ^bb32
    %269 = builtin.unrealized_conversion_cast %268 : index to i64
    %270 = arith.cmpi slt, %268, %c4096 : index
    cf.cond_br %270, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %271 = llvm.getelementptr %256[%269] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %cst, %271 : f32, !llvm.ptr
    %272 = arith.addi %268, %c1 : index
    cf.br ^bb31(%272 : index)
  ^bb33:  // pred: ^bb31
    %273 = llvm.insertvalue %c4096_i64, %267[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %274 = llvm.extractvalue %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %275 = llvm.getelementptr %274[%14] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %276 = llvm.load %275 : !llvm.ptr -> i64
    %277 = builtin.unrealized_conversion_cast %276 : i64 to index
    %278 = llvm.extractvalue %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %279 = llvm.getelementptr %278[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %280 = llvm.load %279 : !llvm.ptr -> i64
    %281 = builtin.unrealized_conversion_cast %280 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg12) : index = (%277) to (%281) step (%c1) {
        %282 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %283 = llvm.extractvalue %133[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %284 = llvm.getelementptr %283[%282] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %285 = llvm.load %284 : !llvm.ptr -> i64
        %286 = builtin.unrealized_conversion_cast %285 : i64 to index
        %287 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %288 = llvm.getelementptr %287[%282] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %289 = llvm.load %288 : !llvm.ptr -> i64
        %290 = builtin.unrealized_conversion_cast %289 : i64 to index
        %291 = arith.addi %arg12, %c1 : index
        %292 = builtin.unrealized_conversion_cast %291 : index to i64
        %293 = llvm.extractvalue %131[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %294 = llvm.getelementptr %293[%292] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %295 = llvm.load %294 : !llvm.ptr -> i64
        %296 = builtin.unrealized_conversion_cast %295 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg13) : index = (%290) to (%296) step (%c1) {
            %297 = builtin.unrealized_conversion_cast %arg13 : index to i64
            %298 = llvm.extractvalue %134[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %299 = llvm.getelementptr %298[%297] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %300 = llvm.load %299 : !llvm.ptr -> i64
            %301 = builtin.unrealized_conversion_cast %300 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg14) : index = (%c0) to (%c32) step (%c1) {
                %302 = arith.muli %arg13, %c32 : index
                %303 = arith.addi %302, %arg14 : index
                %304 = builtin.unrealized_conversion_cast %303 : index to i64
                %305 = arith.muli %301, %c32 : index
                %306 = arith.addi %305, %arg14 : index
                %307 = builtin.unrealized_conversion_cast %306 : index to i64
                %308 = arith.muli %286, %c32 : index
                %309 = arith.addi %308, %arg14 : index
                %310 = builtin.unrealized_conversion_cast %309 : index to i64
                %311 = llvm.getelementptr %256[%310] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %312 = llvm.load %311 : !llvm.ptr -> f32
                %313 = llvm.extractvalue %135[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %314 = llvm.getelementptr %313[%304] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %315 = llvm.load %314 : !llvm.ptr -> f32
                %316 = llvm.extractvalue %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %317 = llvm.getelementptr %316[%307] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %318 = llvm.load %317 : !llvm.ptr -> f32
                %319 = arith.mulf %315, %318 : f32
                %320 = arith.addf %312, %319 : f32
                %321 = llvm.getelementptr %256[%310] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %320, %321 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    return %263, %273 : memref<?xf32>, !llvm.struct<(array<2 x i64>, array<1 x i64>)>
  }
}


// -----// IR Dump After ConvertOpenMPToLLVMPass (convert-openmp-to-llvm) //----- //
module {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg26: i64, %arg27: i64, %arg28: i64, %arg29: f32) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg27 : i64 to index
    %1 = builtin.unrealized_conversion_cast %arg26 : i64 to index
    %2 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = llvm.insertvalue %arg0, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg1, %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg2, %4[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg3, %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = llvm.insertvalue %arg4, %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %9 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.insertvalue %arg5, %9[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg6, %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg7, %11[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = llvm.insertvalue %arg8, %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg9, %13[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = builtin.unrealized_conversion_cast %14 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %16 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %17 = llvm.insertvalue %arg10, %16[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg11, %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg12, %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg13, %19[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg14, %20[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = builtin.unrealized_conversion_cast %21 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %23 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %24 = llvm.insertvalue %arg15, %23[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg16, %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg17, %25[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg18, %26[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg19, %27[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %30 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.insertvalue %arg20, %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg21, %31[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg22, %32[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %arg23, %33[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %arg24, %34[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = builtin.unrealized_conversion_cast %35 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = llvm.mlir.constant(false) : i1
    %40 = llvm.mlir.constant(32 : index) : i64
    %41 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %42 = llvm.mlir.constant(2 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = builtin.unrealized_conversion_cast %43 : i64 to index
    %45 = builtin.unrealized_conversion_cast %8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %46 = builtin.unrealized_conversion_cast %15 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %47 = builtin.unrealized_conversion_cast %29 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %48 = builtin.unrealized_conversion_cast %0 : index to i64
    %49 = builtin.unrealized_conversion_cast %36 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %50 = builtin.unrealized_conversion_cast %1 : index to i64
    %51 = builtin.unrealized_conversion_cast %22 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %52 = builtin.unrealized_conversion_cast %44 : index to i64
    %53 = builtin.unrealized_conversion_cast %38 : index to i64
    %54 = llvm.extractvalue %45[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.getelementptr %54[%53] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %56 = llvm.load %55 : !llvm.ptr -> i64
    %57 = builtin.unrealized_conversion_cast %56 : i64 to index
    %58 = llvm.extractvalue %45[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %60 = llvm.load %59 : !llvm.ptr -> i64
    %61 = builtin.unrealized_conversion_cast %60 : i64 to index
    %62 = llvm.extractvalue %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %63 = llvm.sub %60, %43  : i64
    %64 = builtin.unrealized_conversion_cast %63 : i64 to index
    %65 = builtin.unrealized_conversion_cast %64 : index to i64
    %66 = llvm.icmp "ult" %56, %60 : i64
    llvm.cond_br %66, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %67 = llvm.extractvalue %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.getelementptr %67[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %69 = llvm.load %68 : !llvm.ptr -> i64
    %70 = builtin.unrealized_conversion_cast %69 : i64 to index
    %71 = llvm.icmp "eq" %69, %arg26 : i64
    llvm.br ^bb3(%71 : i1)
  ^bb2:  // pred: ^bb0
    llvm.br ^bb3(%39 : i1)
  ^bb3(%72: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %73 = llvm.select %72, %63, %62 : i1, i64
    %74 = builtin.unrealized_conversion_cast %73 : i64 to index
    %75 = builtin.unrealized_conversion_cast %74 : index to i64
    llvm.cond_br %72, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    llvm.br ^bb19(%14, %21, %arg25 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %76 = llvm.add %62, %43  : i64
    %77 = builtin.unrealized_conversion_cast %76 : i64 to index
    %78 = builtin.unrealized_conversion_cast %77 : index to i64
    %79 = llvm.extractvalue %45[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = llvm.getelementptr %79[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %78, %80 : i64, !llvm.ptr
    %81 = llvm.extractvalue %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %82 = builtin.unrealized_conversion_cast %81 : i64 to index
    %83 = builtin.unrealized_conversion_cast %82 : index to i64
    %84 = llvm.extractvalue %46[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = builtin.unrealized_conversion_cast %84 : i64 to index
    %86 = llvm.add %81, %43  : i64
    %87 = llvm.icmp "ugt" %86, %84 : i64
    llvm.cond_br %87, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %88 = llvm.mul %84, %42  : i64
    %89 = builtin.unrealized_conversion_cast %88 : i64 to index
    %90 = llvm.extractvalue %46[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = builtin.unrealized_conversion_cast %89 : index to i64
    %92 = llvm.icmp "ugt" %91, %90 : i64
    llvm.cond_br %92, ^bb8, ^bb9(%46 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %93 = llvm.mlir.null : !llvm.ptr
    %94 = llvm.getelementptr %93[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %95 = llvm.ptrtoint %94 : !llvm.ptr to i64
    %96 = llvm.mul %91, %95  : i64
    %97 = llvm.mul %90, %95  : i64
    %98 = llvm.call @malloc(%96) : (i64) -> !llvm.ptr
    %99 = llvm.extractvalue %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%98, %99, %97) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %100 = llvm.extractvalue %46[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%100) : (!llvm.ptr) -> ()
    %101 = llvm.insertvalue %98, %46[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %98, %101[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%102 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%103: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %104 = llvm.insertvalue %91, %103[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = builtin.unrealized_conversion_cast %104 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb11(%104 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb10:  // pred: ^bb6
    llvm.br ^bb11(%14 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb11(%106: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb9, ^bb10
    %107 = builtin.unrealized_conversion_cast %106 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %108 = builtin.unrealized_conversion_cast %107 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb12
  ^bb12:  // pred: ^bb11
    %109 = llvm.extractvalue %108[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %50, %110 : i64, !llvm.ptr
    %111 = llvm.insertvalue %86, %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %112 = llvm.extractvalue %arg25[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = builtin.unrealized_conversion_cast %113 : index to i64
    %115 = llvm.extractvalue %51[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = builtin.unrealized_conversion_cast %115 : i64 to index
    %117 = llvm.add %112, %43  : i64
    %118 = llvm.icmp "ugt" %117, %115 : i64
    llvm.cond_br %118, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %119 = llvm.mul %115, %42  : i64
    %120 = builtin.unrealized_conversion_cast %119 : i64 to index
    %121 = llvm.extractvalue %51[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = builtin.unrealized_conversion_cast %120 : index to i64
    %123 = llvm.icmp "ugt" %122, %121 : i64
    llvm.cond_br %123, ^bb14, ^bb15(%51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %124 = llvm.mlir.null : !llvm.ptr
    %125 = llvm.getelementptr %124[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
    %127 = llvm.mul %122, %126  : i64
    %128 = llvm.mul %121, %126  : i64
    %129 = llvm.call @malloc(%127) : (i64) -> !llvm.ptr
    %130 = llvm.extractvalue %51[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%129, %130, %128) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %131 = llvm.extractvalue %51[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%131) : (!llvm.ptr) -> ()
    %132 = llvm.insertvalue %129, %51[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = llvm.insertvalue %129, %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%133 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%134: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %135 = llvm.insertvalue %122, %134[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = builtin.unrealized_conversion_cast %135 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb17(%135 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb16:  // pred: ^bb12
    llvm.br ^bb17(%21 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb17(%137: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb15, ^bb16
    %138 = builtin.unrealized_conversion_cast %137 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %139 = builtin.unrealized_conversion_cast %138 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb18
  ^bb18:  // pred: ^bb17
    %140 = llvm.extractvalue %139[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %141 = llvm.getelementptr %140[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %53, %141 : i64, !llvm.ptr
    %142 = llvm.insertvalue %117, %111[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    llvm.br ^bb19(%106, %137, %142 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%143: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %144: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %145: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %146 = builtin.unrealized_conversion_cast %144 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %147 = builtin.unrealized_conversion_cast %146 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb20
  ^bb20:  // pred: ^bb19
    %148 = llvm.add %73, %43  : i64
    %149 = builtin.unrealized_conversion_cast %148 : i64 to index
    %150 = builtin.unrealized_conversion_cast %149 : index to i64
    %151 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %152 = llvm.getelementptr %151[%75] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %153 = llvm.load %152 : !llvm.ptr -> i64
    %154 = builtin.unrealized_conversion_cast %153 : i64 to index
    %155 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %156 = llvm.getelementptr %155[%150] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %157 = llvm.load %156 : !llvm.ptr -> i64
    %158 = builtin.unrealized_conversion_cast %157 : i64 to index
    %159 = llvm.extractvalue %145[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = builtin.unrealized_conversion_cast %159 : i64 to index
    %161 = builtin.unrealized_conversion_cast %160 : index to i64
    %162 = llvm.sub %157, %43  : i64
    %163 = builtin.unrealized_conversion_cast %162 : i64 to index
    %164 = builtin.unrealized_conversion_cast %163 : index to i64
    %165 = llvm.icmp "ult" %153, %157 : i64
    llvm.cond_br %165, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %166 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %167 = llvm.getelementptr %166[%164] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %168 = llvm.load %167 : !llvm.ptr -> i64
    %169 = builtin.unrealized_conversion_cast %168 : i64 to index
    %170 = llvm.icmp "eq" %168, %arg27 : i64
    llvm.br ^bb23(%170 : i1)
  ^bb22:  // pred: ^bb20
    %171 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%75] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %161, %172 : i64, !llvm.ptr
    llvm.br ^bb23(%39 : i1)
  ^bb23(%173: i1):  // 2 preds: ^bb21, ^bb22
    llvm.br ^bb24
  ^bb24:  // pred: ^bb23
    %174 = llvm.select %173, %162, %159 : i1, i64
    llvm.cond_br %173, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    llvm.br ^bb44(%28, %35, %145 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %175 = llvm.add %159, %43  : i64
    %176 = builtin.unrealized_conversion_cast %175 : i64 to index
    %177 = builtin.unrealized_conversion_cast %176 : index to i64
    %178 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%150] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %177, %179 : i64, !llvm.ptr
    %180 = llvm.extractvalue %145[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    %182 = builtin.unrealized_conversion_cast %181 : index to i64
    %183 = llvm.extractvalue %47[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %184 = builtin.unrealized_conversion_cast %183 : i64 to index
    %185 = llvm.add %180, %43  : i64
    %186 = llvm.icmp "ugt" %185, %183 : i64
    llvm.cond_br %186, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %187 = llvm.mul %183, %42  : i64
    %188 = builtin.unrealized_conversion_cast %187 : i64 to index
    %189 = llvm.extractvalue %47[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %190 = builtin.unrealized_conversion_cast %188 : index to i64
    %191 = llvm.icmp "ugt" %190, %189 : i64
    llvm.cond_br %191, ^bb28, ^bb29(%47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %192 = llvm.mlir.null : !llvm.ptr
    %193 = llvm.getelementptr %192[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %194 = llvm.ptrtoint %193 : !llvm.ptr to i64
    %195 = llvm.mul %190, %194  : i64
    %196 = llvm.mul %189, %194  : i64
    %197 = llvm.call @malloc(%195) : (i64) -> !llvm.ptr
    %198 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%197, %198, %196) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %199 = llvm.extractvalue %47[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%199) : (!llvm.ptr) -> ()
    %200 = llvm.insertvalue %197, %47[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.insertvalue %197, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%201 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%202: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %203 = llvm.insertvalue %190, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = builtin.unrealized_conversion_cast %203 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb31(%203 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb30:  // pred: ^bb26
    llvm.br ^bb31(%28 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb31(%205: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb29, ^bb30
    %206 = builtin.unrealized_conversion_cast %205 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %207 = builtin.unrealized_conversion_cast %206 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb32
  ^bb32:  // pred: ^bb31
    %208 = llvm.extractvalue %207[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %209 = llvm.getelementptr %208[%182] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %48, %209 : i64, !llvm.ptr
    %210 = llvm.insertvalue %185, %145[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %211 = llvm.extractvalue %145[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = builtin.unrealized_conversion_cast %212 : index to i64
    %214 = llvm.extractvalue %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = builtin.unrealized_conversion_cast %214 : i64 to index
    %216 = llvm.add %211, %40  : i64
    %217 = llvm.icmp "ugt" %216, %214 : i64
    llvm.cond_br %217, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    llvm.br ^bb34(%214 : i64)
  ^bb34(%218: i64):  // 2 preds: ^bb33, ^bb34
    %219 = llvm.mul %218, %42  : i64
    %220 = builtin.unrealized_conversion_cast %219 : i64 to index
    %221 = llvm.icmp "ugt" %216, %219 : i64
    llvm.cond_br %221, ^bb34(%219 : i64), ^bb35
  ^bb35:  // pred: ^bb34
    %222 = llvm.extractvalue %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = builtin.unrealized_conversion_cast %220 : index to i64
    %224 = llvm.icmp "ugt" %223, %222 : i64
    llvm.cond_br %224, ^bb36, ^bb37(%49 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %225 = llvm.mlir.null : !llvm.ptr
    %226 = llvm.getelementptr %225[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %227 = llvm.ptrtoint %226 : !llvm.ptr to i64
    %228 = llvm.mul %223, %227  : i64
    %229 = llvm.mul %222, %227  : i64
    %230 = llvm.call @malloc(%228) : (i64) -> !llvm.ptr
    %231 = llvm.extractvalue %49[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%230, %231, %229) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %232 = llvm.extractvalue %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%232) : (!llvm.ptr) -> ()
    %233 = llvm.insertvalue %230, %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.insertvalue %230, %233[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%234 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%235: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %236 = llvm.insertvalue %223, %235[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = builtin.unrealized_conversion_cast %236 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    llvm.br ^bb39(%236 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb38:  // pred: ^bb32
    llvm.br ^bb39(%35 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb39(%238: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb37, ^bb38
    %239 = builtin.unrealized_conversion_cast %238 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %240 = builtin.unrealized_conversion_cast %239 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb40
  ^bb40:  // pred: ^bb39
    %241 = llvm.extractvalue %240[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb41(%37 : i64)
  ^bb41(%242: i64):  // 2 preds: ^bb40, ^bb42
    %243 = builtin.unrealized_conversion_cast %242 : i64 to index
    %244 = builtin.unrealized_conversion_cast %243 : index to i64
    %245 = llvm.icmp "slt" %242, %40 : i64
    llvm.cond_br %245, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %246 = llvm.getelementptr %241[%213] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %247 = llvm.getelementptr %246[%244] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %41, %247 : f32, !llvm.ptr
    %248 = llvm.add %242, %43  : i64
    llvm.br ^bb41(%248 : i64)
  ^bb43:  // pred: ^bb41
    %249 = llvm.insertvalue %216, %210[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    llvm.br ^bb44(%205, %238, %249 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%250: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %251: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %252: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %253 = builtin.unrealized_conversion_cast %251 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %254 = builtin.unrealized_conversion_cast %253 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb45
  ^bb45:  // pred: ^bb44
    %255 = llvm.mul %174, %40  : i64
    %256 = llvm.add %255, %arg28  : i64
    %257 = builtin.unrealized_conversion_cast %256 : i64 to index
    %258 = builtin.unrealized_conversion_cast %257 : index to i64
    %259 = llvm.extractvalue %254[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.getelementptr %259[%258] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg29, %260 : f32, !llvm.ptr
    %261 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
    %262 = llvm.insertvalue %7, %261[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %263 = llvm.insertvalue %143, %262[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %264 = llvm.insertvalue %144, %263[2] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %265 = llvm.insertvalue %250, %264[3] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %266 = llvm.insertvalue %251, %265[4] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %267 = llvm.insertvalue %252, %266[5] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    llvm.return %267 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
  }
  llvm.func @_sparse_binary_search_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) -> i64 attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg1 : i64 to index
    %1 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = llvm.insertvalue %arg2, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg3, %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg4, %3[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg6, %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = builtin.unrealized_conversion_cast %7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %0 : index to i64
    llvm.br ^bb1(%arg0, %arg1 : i64, i64)
  ^bb1(%11: i64, %12: i64):  // 2 preds: ^bb0, ^bb2
    %13 = llvm.icmp "ult" %11, %12 : i64
    llvm.cond_br %13, ^bb2(%11, %12 : i64, i64), ^bb3
  ^bb2(%14: i64, %15: i64):  // pred: ^bb1
    %16 = llvm.add %14, %15  : i64
    %17 = llvm.lshr %16, %8  : i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = builtin.unrealized_conversion_cast %18 : index to i64
    %20 = llvm.add %17, %8  : i64
    %21 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = builtin.unrealized_conversion_cast %23 : i64 to index
    %25 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.getelementptr %25[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %27 = llvm.load %26 : !llvm.ptr -> i64
    %28 = builtin.unrealized_conversion_cast %27 : i64 to index
    %29 = llvm.icmp "ult" %23, %27 : i64
    %30 = llvm.select %29, %14, %20 : i1, i64
    %31 = llvm.select %29, %17, %15 : i1, i64
    llvm.br ^bb1(%30, %31 : i64, i64)
  ^bb3:  // pred: ^bb1
    llvm.return %11 : i64
  }
  llvm.func @_sparse_sort_stable_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.add %arg0, %8  : i64
    llvm.br ^bb1(%10 : i64)
  ^bb1(%11: i64):  // 2 preds: ^bb0, ^bb5
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.icmp "slt" %11, %arg1 : i64
    llvm.cond_br %14, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %15 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.call @_sparse_binary_search_1_index(%arg0, %11, %15, %16, %17, %18, %19) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = builtin.unrealized_conversion_cast %21 : index to i64
    %23 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %25 = llvm.load %24 : !llvm.ptr -> i64
    %26 = llvm.sub %11, %20  : i64
    llvm.br ^bb3(%7 : i64)
  ^bb3(%27: i64):  // 2 preds: ^bb2, ^bb4
    %28 = llvm.icmp "slt" %27, %26 : i64
    llvm.cond_br %28, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %29 = llvm.sub %11, %27  : i64
    %30 = builtin.unrealized_conversion_cast %29 : i64 to index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.sub %29, %8  : i64
    %33 = builtin.unrealized_conversion_cast %32 : i64 to index
    %34 = builtin.unrealized_conversion_cast %33 : index to i64
    %35 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.getelementptr %35[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %37 = llvm.load %36 : !llvm.ptr -> i64
    %38 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.getelementptr %38[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %37, %39 : i64, !llvm.ptr
    %40 = llvm.add %27, %8  : i64
    llvm.br ^bb3(%40 : i64)
  ^bb5:  // pred: ^bb3
    %41 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%22] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %25, %42 : i64, !llvm.ptr
    %43 = llvm.add %11, %8  : i64
    llvm.br ^bb1(%43 : i64)
  ^bb6:  // pred: ^bb1
    llvm.return
  }
  llvm.func @_sparse_shift_down_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.constant(2 : index) : i64
    %9 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.icmp "uge" %arg7, %8 : i64
    llvm.cond_br %10, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %11 = llvm.sub %arg1, %arg0  : i64
    %12 = llvm.sub %arg7, %8  : i64
    %13 = llvm.lshr %12, %7  : i64
    %14 = llvm.icmp "uge" %13, %11 : i64
    llvm.cond_br %14, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %15 = llvm.shl %11, %7  : i64
    %16 = llvm.add %15, %7  : i64
    %17 = llvm.add %16, %arg0  : i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = builtin.unrealized_conversion_cast %18 : index to i64
    %20 = llvm.add %15, %8  : i64
    %21 = llvm.icmp "ult" %20, %arg7 : i64
    llvm.cond_br %21, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %22 = llvm.add %20, %arg0  : i64
    %23 = builtin.unrealized_conversion_cast %22 : i64 to index
    %24 = builtin.unrealized_conversion_cast %23 : index to i64
    %25 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.getelementptr %25[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %27 = llvm.load %26 : !llvm.ptr -> i64
    %28 = builtin.unrealized_conversion_cast %27 : i64 to index
    %29 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.getelementptr %29[%24] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %31 = llvm.load %30 : !llvm.ptr -> i64
    %32 = builtin.unrealized_conversion_cast %31 : i64 to index
    %33 = llvm.icmp "ult" %27, %31 : i64
    %34 = llvm.select %33, %20, %16 : i1, i64
    %35 = llvm.select %33, %22, %17 : i1, i64
    llvm.br ^bb5(%34, %35, %arg1 : i64, i64, i64)
  ^bb4:  // pred: ^bb2
    llvm.br ^bb5(%16, %17, %arg1 : i64, i64, i64)
  ^bb5(%36: i64, %37: i64, %38: i64):  // 3 preds: ^bb3, ^bb4, ^bb13
    llvm.br ^bb6(%38, %36, %37 : i64, i64, i64)
  ^bb6(%39: i64, %40: i64, %41: i64):  // pred: ^bb5
    llvm.br ^bb7(%39, %40, %41 : i64, i64, i64)
  ^bb7(%42: i64, %43: i64, %44: i64):  // pred: ^bb6
    %45 = builtin.unrealized_conversion_cast %44 : i64 to index
    %46 = builtin.unrealized_conversion_cast %42 : i64 to index
    %47 = builtin.unrealized_conversion_cast %46 : index to i64
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.getelementptr %49[%47] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %51 = llvm.load %50 : !llvm.ptr -> i64
    %52 = builtin.unrealized_conversion_cast %51 : i64 to index
    %53 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = builtin.unrealized_conversion_cast %55 : i64 to index
    %57 = llvm.icmp "ult" %51, %55 : i64
    llvm.cond_br %57, ^bb8(%42, %43, %44 : i64, i64, i64), ^bb14
  ^bb8(%58: i64, %59: i64, %60: i64):  // pred: ^bb7
    %61 = builtin.unrealized_conversion_cast %60 : i64 to index
    %62 = builtin.unrealized_conversion_cast %58 : i64 to index
    %63 = builtin.unrealized_conversion_cast %62 : index to i64
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.getelementptr %65[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %67 = llvm.load %66 : !llvm.ptr -> i64
    %68 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.getelementptr %68[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %70 = llvm.load %69 : !llvm.ptr -> i64
    %71 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %72 = llvm.getelementptr %71[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %70, %72 : i64, !llvm.ptr
    %73 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %67, %74 : i64, !llvm.ptr
    %75 = llvm.icmp "uge" %13, %59 : i64
    llvm.cond_br %75, ^bb9, ^bb13(%59, %60 : i64, i64)
  ^bb9:  // pred: ^bb8
    %76 = llvm.shl %59, %7  : i64
    %77 = llvm.add %76, %7  : i64
    %78 = llvm.add %77, %arg0  : i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = builtin.unrealized_conversion_cast %79 : index to i64
    %81 = llvm.add %76, %8  : i64
    %82 = llvm.icmp "ult" %81, %arg7 : i64
    llvm.cond_br %82, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %83 = llvm.add %81, %arg0  : i64
    %84 = builtin.unrealized_conversion_cast %83 : i64 to index
    %85 = builtin.unrealized_conversion_cast %84 : index to i64
    %86 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = llvm.getelementptr %86[%80] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %88 = llvm.load %87 : !llvm.ptr -> i64
    %89 = builtin.unrealized_conversion_cast %88 : i64 to index
    %90 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.getelementptr %90[%85] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %92 = llvm.load %91 : !llvm.ptr -> i64
    %93 = builtin.unrealized_conversion_cast %92 : i64 to index
    %94 = llvm.icmp "ult" %88, %92 : i64
    %95 = llvm.select %94, %81, %77 : i1, i64
    %96 = llvm.select %94, %83, %78 : i1, i64
    llvm.br ^bb12(%95, %96 : i64, i64)
  ^bb11:  // pred: ^bb9
    llvm.br ^bb12(%77, %78 : i64, i64)
  ^bb12(%97: i64, %98: i64):  // 2 preds: ^bb10, ^bb11
    llvm.br ^bb13(%97, %98 : i64, i64)
  ^bb13(%99: i64, %100: i64):  // 2 preds: ^bb8, ^bb12
    llvm.br ^bb5(%99, %100, %60 : i64, i64, i64)
  ^bb14:  // pred: ^bb7
    llvm.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    llvm.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    llvm.return
  }
  llvm.func @_sparse_heap_sort_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg0 : i64 to index
    %1 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = llvm.insertvalue %arg2, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg3, %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg4, %3[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg6, %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %8 = llvm.mlir.constant(2 : index) : i64
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.mlir.constant(0 : index) : i64
    %11 = builtin.unrealized_conversion_cast %7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %0 : index to i64
    %13 = llvm.sub %arg1, %arg0  : i64
    %14 = llvm.sub %13, %8  : i64
    %15 = llvm.lshr %14, %9  : i64
    %16 = llvm.add %15, %9  : i64
    llvm.br ^bb1(%10 : i64)
  ^bb1(%17: i64):  // 2 preds: ^bb0, ^bb2
    %18 = llvm.icmp "slt" %17, %16 : i64
    llvm.cond_br %18, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %19 = llvm.sub %15, %17  : i64
    %20 = llvm.add %arg0, %19  : i64
    %21 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_shift_down_1_index(%arg0, %20, %21, %22, %23, %24, %25, %13) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    %26 = llvm.add %17, %9  : i64
    llvm.br ^bb1(%26 : i64)
  ^bb3:  // pred: ^bb1
    %27 = llvm.sub %13, %9  : i64
    llvm.br ^bb4(%10 : i64)
  ^bb4(%28: i64):  // 2 preds: ^bb3, ^bb5
    %29 = llvm.icmp "slt" %28, %27 : i64
    llvm.cond_br %29, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %30 = llvm.sub %13, %28  : i64
    %31 = llvm.add %arg0, %30  : i64
    %32 = llvm.sub %31, %9  : i64
    %33 = builtin.unrealized_conversion_cast %32 : i64 to index
    %34 = builtin.unrealized_conversion_cast %33 : index to i64
    %35 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.getelementptr %35[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %37 = llvm.load %36 : !llvm.ptr -> i64
    %38 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.getelementptr %38[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %40 = llvm.load %39 : !llvm.ptr -> i64
    %41 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %40, %42 : i64, !llvm.ptr
    %43 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %37, %44 : i64, !llvm.ptr
    %45 = llvm.sub %30, %9  : i64
    %46 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %49 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_shift_down_1_index(%arg0, %arg0, %46, %47, %48, %49, %50, %45) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    %51 = llvm.add %28, %9  : i64
    llvm.br ^bb4(%51 : i64)
  ^bb6:  // pred: ^bb4
    llvm.return
  }
  llvm.func @_sparse_partition_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) -> i64 attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg0 : i64 to index
    %1 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = llvm.insertvalue %arg2, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg3, %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg4, %3[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg6, %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %8 = llvm.mlir.constant(-1 : index) : i64
    %9 = llvm.mlir.constant(1000 : index) : i64
    %10 = llvm.mlir.constant(1 : index) : i64
    %11 = builtin.unrealized_conversion_cast %7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %0 : index to i64
    %13 = llvm.add %arg0, %arg1  : i64
    %14 = llvm.lshr %13, %10  : i64
    %15 = builtin.unrealized_conversion_cast %14 : i64 to index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.sub %arg1, %10  : i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = builtin.unrealized_conversion_cast %18 : index to i64
    %20 = llvm.sub %arg1, %arg0  : i64
    %21 = llvm.icmp "ult" %20, %9 : i64
    llvm.cond_br %21, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %28 = llvm.load %27 : !llvm.ptr -> i64
    %29 = builtin.unrealized_conversion_cast %28 : i64 to index
    %30 = llvm.icmp "ult" %24, %28 : i64
    llvm.cond_br %30, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %31 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.getelementptr %31[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %33 = llvm.load %32 : !llvm.ptr -> i64
    %34 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.getelementptr %34[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %36 = llvm.load %35 : !llvm.ptr -> i64
    %37 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %36, %38 : i64, !llvm.ptr
    %39 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.getelementptr %39[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %33, %40 : i64, !llvm.ptr
    llvm.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %41 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %43 = llvm.load %42 : !llvm.ptr -> i64
    %44 = builtin.unrealized_conversion_cast %43 : i64 to index
    %45 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %47 = llvm.load %46 : !llvm.ptr -> i64
    %48 = builtin.unrealized_conversion_cast %47 : i64 to index
    %49 = llvm.icmp "ult" %43, %47 : i64
    llvm.cond_br %49, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %50 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.getelementptr %60[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %62 = llvm.load %61 : !llvm.ptr -> i64
    %63 = builtin.unrealized_conversion_cast %62 : i64 to index
    %64 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %66 = llvm.load %65 : !llvm.ptr -> i64
    %67 = builtin.unrealized_conversion_cast %66 : i64 to index
    %68 = llvm.icmp "ult" %62, %66 : i64
    llvm.cond_br %68, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %69 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %76 = llvm.getelementptr %75[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %74, %76 : i64, !llvm.ptr
    %77 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %78 = llvm.getelementptr %77[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %71, %78 : i64, !llvm.ptr
    llvm.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    llvm.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    llvm.br ^bb27(%arg0, %17, %14 : i64, i64, i64)
  ^bb8:  // pred: ^bb0
    %79 = llvm.add %arg0, %arg1  : i64
    %80 = llvm.lshr %79, %10  : i64
    %81 = builtin.unrealized_conversion_cast %80 : i64 to index
    %82 = builtin.unrealized_conversion_cast %81 : index to i64
    %83 = llvm.add %14, %arg1  : i64
    %84 = llvm.lshr %83, %10  : i64
    %85 = builtin.unrealized_conversion_cast %84 : i64 to index
    %86 = builtin.unrealized_conversion_cast %85 : index to i64
    %87 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %89 = llvm.load %88 : !llvm.ptr -> i64
    %90 = builtin.unrealized_conversion_cast %89 : i64 to index
    %91 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.icmp "ult" %89, %93 : i64
    llvm.cond_br %95, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %96 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %97 = llvm.getelementptr %96[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %98 = llvm.load %97 : !llvm.ptr -> i64
    %99 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.getelementptr %99[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %101 = llvm.load %100 : !llvm.ptr -> i64
    %102 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.getelementptr %102[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %101, %103 : i64, !llvm.ptr
    %104 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.getelementptr %104[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %98, %105 : i64, !llvm.ptr
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %106 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %108 = llvm.load %107 : !llvm.ptr -> i64
    %109 = builtin.unrealized_conversion_cast %108 : i64 to index
    %110 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.icmp "ult" %108, %112 : i64
    llvm.cond_br %114, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %115 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = llvm.getelementptr %115[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %117 = llvm.load %116 : !llvm.ptr -> i64
    %118 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %119 = llvm.getelementptr %118[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %120 = llvm.load %119 : !llvm.ptr -> i64
    %121 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.getelementptr %121[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %120, %122 : i64, !llvm.ptr
    %123 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.getelementptr %123[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %117, %124 : i64, !llvm.ptr
    %125 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %127 = llvm.load %126 : !llvm.ptr -> i64
    %128 = builtin.unrealized_conversion_cast %127 : i64 to index
    %129 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.icmp "ult" %127, %131 : i64
    llvm.cond_br %133, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %134 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %135 = llvm.getelementptr %134[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %136 = llvm.load %135 : !llvm.ptr -> i64
    %137 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = llvm.getelementptr %137[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %139 = llvm.load %138 : !llvm.ptr -> i64
    %140 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %141 = llvm.getelementptr %140[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %139, %141 : i64, !llvm.ptr
    %142 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %143 = llvm.getelementptr %142[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %136, %143 : i64, !llvm.ptr
    llvm.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    llvm.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %144 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %146 = llvm.load %145 : !llvm.ptr -> i64
    %147 = builtin.unrealized_conversion_cast %146 : i64 to index
    %148 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.icmp "ult" %146, %150 : i64
    llvm.cond_br %152, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %153 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %154 = llvm.getelementptr %153[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %155 = llvm.load %154 : !llvm.ptr -> i64
    %156 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %157 = llvm.getelementptr %156[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %158 = llvm.load %157 : !llvm.ptr -> i64
    %159 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %160 = llvm.getelementptr %159[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %158, %160 : i64, !llvm.ptr
    %161 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %162 = llvm.getelementptr %161[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %155, %162 : i64, !llvm.ptr
    %163 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %165 = llvm.load %164 : !llvm.ptr -> i64
    %166 = builtin.unrealized_conversion_cast %165 : i64 to index
    %167 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.icmp "ult" %165, %169 : i64
    llvm.cond_br %171, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %172 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %173 = llvm.getelementptr %172[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %174 = llvm.load %173 : !llvm.ptr -> i64
    %175 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %176 = llvm.getelementptr %175[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %177 = llvm.load %176 : !llvm.ptr -> i64
    %178 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %177, %179 : i64, !llvm.ptr
    %180 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %181 = llvm.getelementptr %180[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %174, %181 : i64, !llvm.ptr
    %182 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %184 = llvm.load %183 : !llvm.ptr -> i64
    %185 = builtin.unrealized_conversion_cast %184 : i64 to index
    %186 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.icmp "ult" %184, %188 : i64
    llvm.cond_br %190, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %191 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %192 = llvm.getelementptr %191[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %193 = llvm.load %192 : !llvm.ptr -> i64
    %194 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %195 = llvm.getelementptr %194[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %196 = llvm.load %195 : !llvm.ptr -> i64
    %197 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %198 = llvm.getelementptr %197[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %196, %198 : i64, !llvm.ptr
    %199 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %200 = llvm.getelementptr %199[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %193, %200 : i64, !llvm.ptr
    llvm.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    llvm.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    llvm.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %201 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %203 = llvm.load %202 : !llvm.ptr -> i64
    %204 = builtin.unrealized_conversion_cast %203 : i64 to index
    %205 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.icmp "ult" %203, %207 : i64
    llvm.cond_br %209, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %210 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %211 = llvm.getelementptr %210[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %212 = llvm.load %211 : !llvm.ptr -> i64
    %213 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %214 = llvm.getelementptr %213[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %215 = llvm.load %214 : !llvm.ptr -> i64
    %216 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %217 = llvm.getelementptr %216[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %215, %217 : i64, !llvm.ptr
    %218 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %219 = llvm.getelementptr %218[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %212, %219 : i64, !llvm.ptr
    %220 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %222 = llvm.load %221 : !llvm.ptr -> i64
    %223 = builtin.unrealized_conversion_cast %222 : i64 to index
    %224 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.icmp "ult" %222, %226 : i64
    llvm.cond_br %228, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %229 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %230 = llvm.getelementptr %229[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %231 = llvm.load %230 : !llvm.ptr -> i64
    %232 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %233 = llvm.getelementptr %232[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %234 = llvm.load %233 : !llvm.ptr -> i64
    %235 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %234, %236 : i64, !llvm.ptr
    %237 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %238 = llvm.getelementptr %237[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %231, %238 : i64, !llvm.ptr
    %239 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %241 = llvm.load %240 : !llvm.ptr -> i64
    %242 = builtin.unrealized_conversion_cast %241 : i64 to index
    %243 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.icmp "ult" %241, %245 : i64
    llvm.cond_br %247, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %248 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %249 = llvm.getelementptr %248[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %250 = llvm.load %249 : !llvm.ptr -> i64
    %251 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %252 = llvm.getelementptr %251[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %253 = llvm.load %252 : !llvm.ptr -> i64
    %254 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %255 = llvm.getelementptr %254[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %253, %255 : i64, !llvm.ptr
    %256 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %257 = llvm.getelementptr %256[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %250, %257 : i64, !llvm.ptr
    %258 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %260 = llvm.load %259 : !llvm.ptr -> i64
    %261 = builtin.unrealized_conversion_cast %260 : i64 to index
    %262 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = llvm.getelementptr %262[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %264 = llvm.load %263 : !llvm.ptr -> i64
    %265 = builtin.unrealized_conversion_cast %264 : i64 to index
    %266 = llvm.icmp "ult" %260, %264 : i64
    llvm.cond_br %266, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %267 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %268 = llvm.getelementptr %267[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %269 = llvm.load %268 : !llvm.ptr -> i64
    %270 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %271 = llvm.getelementptr %270[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %272 = llvm.load %271 : !llvm.ptr -> i64
    %273 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %274 = llvm.getelementptr %273[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %272, %274 : i64, !llvm.ptr
    %275 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %269, %276 : i64, !llvm.ptr
    llvm.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    llvm.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    llvm.br ^bb6
  ^bb27(%277: i64, %278: i64, %279: i64):  // 2 preds: ^bb7, ^bb45
    llvm.br ^bb28(%277, %278, %279 : i64, i64, i64)
  ^bb28(%280: i64, %281: i64, %282: i64):  // pred: ^bb27
    %283 = llvm.icmp "ult" %280, %281 : i64
    llvm.cond_br %283, ^bb29(%280, %281, %282 : i64, i64, i64), ^bb46
  ^bb29(%284: i64, %285: i64, %286: i64):  // pred: ^bb28
    %287 = builtin.unrealized_conversion_cast %286 : i64 to index
    %288 = builtin.unrealized_conversion_cast %287 : index to i64
    llvm.br ^bb30(%284 : i64)
  ^bb30(%289: i64):  // 2 preds: ^bb29, ^bb31
    %290 = builtin.unrealized_conversion_cast %289 : i64 to index
    %291 = builtin.unrealized_conversion_cast %290 : index to i64
    %292 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %293 = llvm.getelementptr %292[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %294 = llvm.load %293 : !llvm.ptr -> i64
    %295 = builtin.unrealized_conversion_cast %294 : i64 to index
    %296 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %297 = llvm.getelementptr %296[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %298 = llvm.load %297 : !llvm.ptr -> i64
    %299 = builtin.unrealized_conversion_cast %298 : i64 to index
    %300 = llvm.icmp "ult" %294, %298 : i64
    llvm.cond_br %300, ^bb31(%289 : i64), ^bb32
  ^bb31(%301: i64):  // pred: ^bb30
    %302 = llvm.add %301, %10  : i64
    llvm.br ^bb30(%302 : i64)
  ^bb32:  // pred: ^bb30
    %303 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %304 = llvm.getelementptr %303[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %305 = llvm.load %304 : !llvm.ptr -> i64
    %306 = builtin.unrealized_conversion_cast %305 : i64 to index
    %307 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %308 = llvm.getelementptr %307[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %309 = llvm.load %308 : !llvm.ptr -> i64
    %310 = builtin.unrealized_conversion_cast %309 : i64 to index
    %311 = llvm.icmp "eq" %305, %309 : i64
    llvm.br ^bb33(%285 : i64)
  ^bb33(%312: i64):  // 2 preds: ^bb32, ^bb34
    %313 = builtin.unrealized_conversion_cast %312 : i64 to index
    %314 = builtin.unrealized_conversion_cast %313 : index to i64
    %315 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %316 = llvm.getelementptr %315[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %317 = llvm.load %316 : !llvm.ptr -> i64
    %318 = builtin.unrealized_conversion_cast %317 : i64 to index
    %319 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %320 = llvm.getelementptr %319[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %321 = llvm.load %320 : !llvm.ptr -> i64
    %322 = builtin.unrealized_conversion_cast %321 : i64 to index
    %323 = llvm.icmp "ult" %317, %321 : i64
    llvm.cond_br %323, ^bb34(%312 : i64), ^bb35
  ^bb34(%324: i64):  // pred: ^bb33
    %325 = llvm.add %324, %8  : i64
    llvm.br ^bb33(%325 : i64)
  ^bb35:  // pred: ^bb33
    %326 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %328 = llvm.load %327 : !llvm.ptr -> i64
    %329 = builtin.unrealized_conversion_cast %328 : i64 to index
    %330 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %331 = llvm.getelementptr %330[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %332 = llvm.load %331 : !llvm.ptr -> i64
    %333 = builtin.unrealized_conversion_cast %332 : i64 to index
    %334 = llvm.icmp "eq" %328, %332 : i64
    %335 = llvm.icmp "ult" %289, %312 : i64
    llvm.cond_br %335, ^bb36, ^bb44(%289, %312, %286 : i64, i64, i64)
  ^bb36:  // pred: ^bb35
    %336 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %337 = llvm.getelementptr %336[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %338 = llvm.load %337 : !llvm.ptr -> i64
    %339 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %340 = llvm.getelementptr %339[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %341 = llvm.load %340 : !llvm.ptr -> i64
    %342 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %343 = llvm.getelementptr %342[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %341, %343 : i64, !llvm.ptr
    %344 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %345 = llvm.getelementptr %344[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %338, %345 : i64, !llvm.ptr
    %346 = llvm.icmp "eq" %289, %286 : i64
    llvm.cond_br %346, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    llvm.br ^bb39(%312 : i64)
  ^bb38:  // pred: ^bb36
    %347 = llvm.icmp "eq" %312, %286 : i64
    %348 = llvm.select %347, %289, %286 : i1, i64
    llvm.br ^bb39(%348 : i64)
  ^bb39(%349: i64):  // 2 preds: ^bb37, ^bb38
    llvm.br ^bb40
  ^bb40:  // pred: ^bb39
    %350 = llvm.and %311, %334  : i1
    llvm.cond_br %350, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %351 = llvm.add %289, %10  : i64
    %352 = llvm.sub %312, %10  : i64
    llvm.br ^bb43(%351, %352 : i64, i64)
  ^bb42:  // pred: ^bb40
    llvm.br ^bb43(%289, %312 : i64, i64)
  ^bb43(%353: i64, %354: i64):  // 2 preds: ^bb41, ^bb42
    llvm.br ^bb44(%353, %354, %349 : i64, i64, i64)
  ^bb44(%355: i64, %356: i64, %357: i64):  // 2 preds: ^bb35, ^bb43
    llvm.br ^bb45(%355, %356, %357 : i64, i64, i64)
  ^bb45(%358: i64, %359: i64, %360: i64):  // pred: ^bb44
    llvm.br ^bb27(%358, %359, %360 : i64, i64, i64)
  ^bb46:  // pred: ^bb28
    llvm.return %282 : i64
  }
  llvm.func @_sparse_hybrid_qsort_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(30 : index) : i64
    %7 = llvm.mlir.constant(1 : i64) : i64
    %8 = llvm.mlir.constant(0 : i64) : i64
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.mlir.constant(0 : index) : i64
    llvm.br ^bb1(%arg0, %arg1 : i64, i64)
  ^bb1(%11: i64, %12: i64):  // 2 preds: ^bb0, ^bb14
    %13 = llvm.add %11, %9  : i64
    %14 = llvm.icmp "ult" %13, %12 : i64
    llvm.cond_br %14, ^bb2(%11, %12 : i64, i64), ^bb15
  ^bb2(%15: i64, %16: i64):  // pred: ^bb1
    %17 = llvm.sub %16, %15  : i64
    %18 = llvm.icmp "ule" %17, %6 : i64
    llvm.cond_br %18, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %19 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_sort_stable_1_index(%15, %16, %19, %20, %21, %22, %23) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> ()
    llvm.br ^bb13(%15, %15 : i64, i64)
  ^bb4:  // pred: ^bb2
    %24 = llvm.sub %arg7, %7  : i64
    %25 = llvm.icmp "ule" %24, %8 : i64
    llvm.cond_br %25, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %26 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_heap_sort_1_index(%15, %16, %26, %27, %28, %29, %30) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> ()
    llvm.br ^bb11(%15, %15 : i64, i64)
  ^bb6:  // pred: ^bb4
    %31 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @_sparse_partition_1_index(%15, %16, %31, %32, %33, %34, %35) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> i64
    %37 = llvm.add %36, %9  : i64
    %38 = llvm.sub %36, %15  : i64
    %39 = llvm.sub %16, %36  : i64
    %40 = llvm.icmp "ule" %38, %39 : i64
    %41 = llvm.select %40, %37, %15 : i1, i64
    %42 = llvm.select %40, %16, %36 : i1, i64
    llvm.cond_br %40, ^bb7(%38, %15, %36 : i64, i64, i64), ^bb7(%39, %37, %16 : i64, i64, i64)
  ^bb7(%43: i64, %44: i64, %45: i64):  // 2 preds: ^bb6, ^bb6
    %46 = llvm.icmp "ne" %43, %10 : i64
    llvm.cond_br %46, ^bb8(%44, %45 : i64, i64), ^bb9
  ^bb8(%47: i64, %48: i64):  // pred: ^bb7
    %49 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_hybrid_qsort_1_index(%47, %48, %49, %50, %51, %52, %53, %24) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    llvm.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    llvm.br ^bb10
  ^bb10:  // pred: ^bb9
    llvm.br ^bb11(%41, %42 : i64, i64)
  ^bb11(%54: i64, %55: i64):  // 2 preds: ^bb5, ^bb10
    llvm.br ^bb12
  ^bb12:  // pred: ^bb11
    llvm.br ^bb13(%54, %55 : i64, i64)
  ^bb13(%56: i64, %57: i64):  // 2 preds: ^bb3, ^bb12
    llvm.br ^bb14
  ^bb14:  // pred: ^bb13
    llvm.br ^bb1(%56, %57 : i64, i64)
  ^bb15:  // pred: ^bb1
    llvm.return
  }
  llvm.func @MTTKRP.A.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.ptr, %arg26: !llvm.ptr, %arg27: i64, %arg28: i64, %arg29: i64, %arg30: !llvm.ptr, %arg31: !llvm.ptr, %arg32: i64, %arg33: i64, %arg34: i64, %arg35: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg36: !llvm.ptr, %arg37: !llvm.ptr, %arg38: i64, %arg39: i64, %arg40: i64, %arg41: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg42: !llvm.ptr, %arg43: !llvm.ptr, %arg44: i64, %arg45: i64, %arg46: i64, %arg47: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg15, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg16, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg17, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg18, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg19, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg20, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg21, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg22, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg23, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg24, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg25, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg26, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg27, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg28, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg29, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %arg30, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %arg31, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %arg32, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %arg33, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %arg34, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %49 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %50 = llvm.insertvalue %arg36, %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %arg37, %50[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.insertvalue %arg38, %51[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %arg39, %52[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %arg40, %53[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = builtin.unrealized_conversion_cast %54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %56 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = llvm.insertvalue %arg42, %56[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %arg43, %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.insertvalue %arg44, %58[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.insertvalue %arg45, %59[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %arg46, %60[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = builtin.unrealized_conversion_cast %61 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %63 = llvm.mlir.constant(4096 : index) : i64
    %64 = llvm.mlir.constant(32 : index) : i64
    %65 = llvm.mlir.constant(0 : index) : i64
    %66 = llvm.mlir.constant(1 : index) : i64
    %67 = llvm.mlir.constant(16 : index) : i64
    %68 = llvm.mlir.constant(true) : i1
    %69 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %70 = llvm.mlir.constant(64 : i64) : i64
    %71 = llvm.mlir.constant(0 : i64) : i64
    %72 = llvm.mlir.constant(1 : i64) : i64
    %73 = llvm.mlir.constant(2 : i64) : i64
    %74 = llvm.mlir.constant(128 : i64) : i64
    %75 = llvm.mlir.constant(32 : i64) : i64
    %76 = llvm.mlir.constant(false) : i1
    %77 = llvm.mlir.constant(4096 : i64) : i64
    %78 = llvm.mlir.constant(4096 : index) : i64
    %79 = llvm.mlir.constant(1 : index) : i64
    %80 = builtin.unrealized_conversion_cast %79 : i64 to index
    %81 = llvm.mlir.constant(32 : index) : i64
    %82 = llvm.mlir.constant(0 : index) : i64
    %83 = builtin.unrealized_conversion_cast %82 : i64 to index
    %84 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %85 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %86 = builtin.unrealized_conversion_cast %20 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %87 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %88 = builtin.unrealized_conversion_cast %34 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %89 = builtin.unrealized_conversion_cast %41 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %90 = builtin.unrealized_conversion_cast %48 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %91 = builtin.unrealized_conversion_cast %55 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %92 = builtin.unrealized_conversion_cast %62 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %93 = builtin.unrealized_conversion_cast %83 : index to i64
    %94 = builtin.unrealized_conversion_cast %80 : index to i64
    %95 = llvm.mlir.null : !llvm.ptr
    %96 = llvm.getelementptr %95[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %97 = llvm.ptrtoint %96 : !llvm.ptr to i64
    %98 = llvm.call @malloc(%97) : (i64) -> !llvm.ptr
    %99 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %100 = llvm.insertvalue %98, %99[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.insertvalue %98, %100[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %65, %101[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.insertvalue %67, %102[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.insertvalue %66, %103[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = builtin.unrealized_conversion_cast %104 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %106 = llvm.mlir.null : !llvm.ptr
    %107 = llvm.getelementptr %106[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %108 = llvm.ptrtoint %107 : !llvm.ptr to i64
    %109 = llvm.call @malloc(%108) : (i64) -> !llvm.ptr
    %110 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %111 = llvm.insertvalue %109, %110[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %112 = llvm.insertvalue %109, %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %113 = llvm.insertvalue %65, %112[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.insertvalue %67, %113[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.insertvalue %66, %114[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = builtin.unrealized_conversion_cast %115 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %117 = llvm.mlir.null : !llvm.ptr
    %118 = llvm.getelementptr %117[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %119 = llvm.ptrtoint %118 : !llvm.ptr to i64
    %120 = llvm.call @malloc(%119) : (i64) -> !llvm.ptr
    %121 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %122 = llvm.insertvalue %120, %121[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.insertvalue %120, %122[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.insertvalue %65, %123[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %125 = llvm.insertvalue %67, %124[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.insertvalue %66, %125[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %127 = builtin.unrealized_conversion_cast %126 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %128 = llvm.mlir.null : !llvm.ptr
    %129 = llvm.getelementptr %128[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %130 = llvm.ptrtoint %129 : !llvm.ptr to i64
    %131 = llvm.call @malloc(%130) : (i64) -> !llvm.ptr
    %132 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %133 = llvm.insertvalue %131, %132[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.insertvalue %131, %133[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %135 = llvm.insertvalue %65, %134[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = llvm.insertvalue %67, %135[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %137 = llvm.insertvalue %66, %136[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = builtin.unrealized_conversion_cast %137 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %139 = llvm.mlir.null : !llvm.ptr
    %140 = llvm.getelementptr %139[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %141 = llvm.ptrtoint %140 : !llvm.ptr to i64
    %142 = llvm.call @malloc(%141) : (i64) -> !llvm.ptr
    %143 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %144 = llvm.insertvalue %142, %143[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.insertvalue %142, %144[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %146 = llvm.insertvalue %65, %145[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.insertvalue %67, %146[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %148 = llvm.insertvalue %66, %147[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = builtin.unrealized_conversion_cast %148 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %150 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %151 = llvm.insertvalue %71, %150[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %152 = llvm.insertvalue %71, %151[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %153 = llvm.insertvalue %71, %152[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %154 = llvm.insertvalue %71, %153[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %155 = llvm.insertvalue %71, %154[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %156 = llvm.insertvalue %74, %155[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %157 = llvm.getelementptr %98[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %93, %157 : i64, !llvm.ptr
    %158 = llvm.insertvalue %72, %156[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %159 = llvm.insertvalue %74, %158[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = llvm.getelementptr %120[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %93, %160 : i64, !llvm.ptr
    %161 = llvm.insertvalue %72, %159[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %162 = llvm.insertvalue %75, %161[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %163 = llvm.getelementptr %98[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %93, %163 : i64, !llvm.ptr
    %164 = llvm.insertvalue %73, %162[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %165 = llvm.mlir.null : !llvm.ptr
    %166 = llvm.getelementptr %165[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %167 = llvm.ptrtoint %166 : !llvm.ptr to i64
    %168 = llvm.call @malloc(%167) : (i64) -> !llvm.ptr
    %169 = llvm.mlir.null : !llvm.ptr
    %170 = llvm.getelementptr %169[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %171 = llvm.ptrtoint %170 : !llvm.ptr to i64
    %172 = llvm.call @malloc(%171) : (i64) -> !llvm.ptr
    %173 = llvm.mlir.null : !llvm.ptr
    %174 = llvm.getelementptr %173[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %175 = llvm.ptrtoint %174 : !llvm.ptr to i64
    %176 = llvm.call @malloc(%175) : (i64) -> !llvm.ptr
    %177 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %178 = llvm.insertvalue %176, %177[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.insertvalue %176, %178[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.insertvalue %65, %179[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %181 = llvm.insertvalue %64, %180[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = llvm.insertvalue %66, %181[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = builtin.unrealized_conversion_cast %182 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb1(%82 : i64)
  ^bb1(%184: i64):  // 2 preds: ^bb0, ^bb2
    %185 = builtin.unrealized_conversion_cast %184 : i64 to index
    %186 = builtin.unrealized_conversion_cast %185 : index to i64
    %187 = llvm.icmp "slt" %184, %81 : i64
    llvm.cond_br %187, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %188 = llvm.getelementptr %168[%186] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %69, %188 : f32, !llvm.ptr
    %189 = llvm.add %184, %79  : i64
    llvm.br ^bb1(%189 : i64)
  ^bb3:  // pred: ^bb1
    llvm.br ^bb4(%82 : i64)
  ^bb4(%190: i64):  // 2 preds: ^bb3, ^bb5
    %191 = builtin.unrealized_conversion_cast %190 : i64 to index
    %192 = builtin.unrealized_conversion_cast %191 : index to i64
    %193 = llvm.icmp "slt" %190, %81 : i64
    llvm.cond_br %193, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %194 = llvm.getelementptr %172[%192] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %76, %194 : i1, !llvm.ptr
    %195 = llvm.add %190, %79  : i64
    llvm.br ^bb4(%195 : i64)
  ^bb6:  // pred: ^bb4
    %196 = llvm.extractvalue %84[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.getelementptr %196[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %198 = llvm.load %197 : !llvm.ptr -> i64
    %199 = builtin.unrealized_conversion_cast %198 : i64 to index
    %200 = llvm.extractvalue %84[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.getelementptr %200[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %202 = llvm.load %201 : !llvm.ptr -> i64
    %203 = builtin.unrealized_conversion_cast %202 : i64 to index
    llvm.br ^bb7(%198, %104, %115, %126, %137, %148, %164 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%204: i64, %205: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %206: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %207: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %208: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %209: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %210: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %211 = builtin.unrealized_conversion_cast %209 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %212 = builtin.unrealized_conversion_cast %208 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %213 = builtin.unrealized_conversion_cast %207 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %214 = builtin.unrealized_conversion_cast %206 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %215 = builtin.unrealized_conversion_cast %205 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %216 = builtin.unrealized_conversion_cast %204 : i64 to index
    %217 = builtin.unrealized_conversion_cast %216 : index to i64
    %218 = builtin.unrealized_conversion_cast %213 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %219 = builtin.unrealized_conversion_cast %215 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %220 = builtin.unrealized_conversion_cast %214 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %221 = builtin.unrealized_conversion_cast %212 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %222 = builtin.unrealized_conversion_cast %211 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %223 = llvm.icmp "slt" %204, %202 : i64
    llvm.cond_br %223, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %224 = llvm.extractvalue %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%217] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %86[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%217] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = llvm.add %204, %79  : i64
    %233 = builtin.unrealized_conversion_cast %232 : i64 to index
    %234 = builtin.unrealized_conversion_cast %233 : index to i64
    %235 = llvm.extractvalue %86[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%234] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %237 = llvm.load %236 : !llvm.ptr -> i64
    %238 = builtin.unrealized_conversion_cast %237 : i64 to index
    llvm.br ^bb9(%230, %205, %206, %207, %208, %209, %210 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%239: i64, %240: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %241: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %242: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %243: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %244: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %245: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %246 = builtin.unrealized_conversion_cast %239 : i64 to index
    %247 = builtin.unrealized_conversion_cast %246 : index to i64
    %248 = llvm.icmp "slt" %239, %237 : i64
    llvm.cond_br %248, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %249 = llvm.extractvalue %87[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %250 = llvm.getelementptr %249[%247] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %251 = llvm.load %250 : !llvm.ptr -> i64
    %252 = builtin.unrealized_conversion_cast %251 : i64 to index
    %253 = llvm.extractvalue %88[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %254 = llvm.getelementptr %253[%247] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %255 = llvm.load %254 : !llvm.ptr -> i64
    %256 = builtin.unrealized_conversion_cast %255 : i64 to index
    %257 = llvm.add %239, %79  : i64
    %258 = builtin.unrealized_conversion_cast %257 : i64 to index
    %259 = builtin.unrealized_conversion_cast %258 : index to i64
    %260 = llvm.extractvalue %88[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%259] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %262 = llvm.load %261 : !llvm.ptr -> i64
    %263 = builtin.unrealized_conversion_cast %262 : i64 to index
    llvm.br ^bb11(%255, %82 : i64, i64)
  ^bb11(%264: i64, %265: i64):  // 2 preds: ^bb10, ^bb19
    %266 = builtin.unrealized_conversion_cast %264 : i64 to index
    %267 = builtin.unrealized_conversion_cast %266 : index to i64
    %268 = llvm.icmp "slt" %264, %262 : i64
    llvm.cond_br %268, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %269 = llvm.extractvalue %89[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %270 = llvm.getelementptr %269[%267] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %271 = llvm.load %270 : !llvm.ptr -> i64
    %272 = builtin.unrealized_conversion_cast %271 : i64 to index
    %273 = llvm.extractvalue %90[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %274 = llvm.getelementptr %273[%267] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %275 = llvm.load %274 : !llvm.ptr -> f32
    llvm.br ^bb13(%82, %265 : i64, i64)
  ^bb13(%276: i64, %277: i64):  // 2 preds: ^bb12, ^bb18
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = builtin.unrealized_conversion_cast %276 : i64 to index
    %280 = builtin.unrealized_conversion_cast %279 : index to i64
    %281 = builtin.unrealized_conversion_cast %278 : index to i64
    %282 = llvm.icmp "slt" %276, %81 : i64
    llvm.cond_br %282, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %283 = llvm.mul %271, %81  : i64
    %284 = llvm.add %283, %276  : i64
    %285 = builtin.unrealized_conversion_cast %284 : i64 to index
    %286 = builtin.unrealized_conversion_cast %285 : index to i64
    %287 = llvm.getelementptr %168[%280] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %288 = llvm.load %287 : !llvm.ptr -> f32
    %289 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %290 = llvm.getelementptr %289[%286] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %291 = llvm.load %290 : !llvm.ptr -> f32
    %292 = llvm.fmul %275, %291  : f32
    %293 = llvm.fadd %288, %292  : f32
    %294 = llvm.getelementptr %172[%280] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %295 = llvm.load %294 : !llvm.ptr -> i1
    %296 = llvm.icmp "eq" %295, %76 : i1
    llvm.cond_br %296, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %297 = llvm.getelementptr %172[%280] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %68, %297 : i1, !llvm.ptr
    %298 = llvm.getelementptr %176[%281] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %280, %298 : i64, !llvm.ptr
    %299 = llvm.add %277, %79  : i64
    llvm.br ^bb17(%299 : i64)
  ^bb16:  // pred: ^bb14
    llvm.br ^bb17(%277 : i64)
  ^bb17(%300: i64):  // 2 preds: ^bb15, ^bb16
    llvm.br ^bb18
  ^bb18:  // pred: ^bb17
    %301 = llvm.getelementptr %168[%280] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %293, %301 : f32, !llvm.ptr
    %302 = llvm.add %276, %79  : i64
    llvm.br ^bb13(%302, %300 : i64, i64)
  ^bb19:  // pred: ^bb13
    %303 = llvm.add %264, %79  : i64
    llvm.br ^bb11(%303, %277 : i64, i64)
  ^bb20:  // pred: ^bb11
    %304 = "llvm.intr.ctlz"(%265) <{is_zero_poison = false}> : (i64) -> i64
    %305 = llvm.sub %70, %304  : i64
    %306 = llvm.extractvalue %182[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %307 = llvm.extractvalue %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %308 = llvm.extractvalue %182[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.extractvalue %182[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %310 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_hybrid_qsort_1_index(%82, %265, %306, %307, %308, %309, %310, %305) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    llvm.br ^bb21(%82, %240, %241, %242, %243, %244, %245 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%311: i64, %312: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %313: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %314: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %315: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %316: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %317: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %318 = builtin.unrealized_conversion_cast %311 : i64 to index
    %319 = builtin.unrealized_conversion_cast %318 : index to i64
    %320 = llvm.icmp "slt" %311, %265 : i64
    llvm.cond_br %320, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %321 = llvm.getelementptr %176[%319] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %322 = llvm.load %321 : !llvm.ptr -> i64
    %323 = builtin.unrealized_conversion_cast %322 : i64 to index
    %324 = llvm.getelementptr %168[%322] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %325 = llvm.load %324 : !llvm.ptr -> f32
    %326 = llvm.extractvalue %312[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.extractvalue %312[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %328 = llvm.extractvalue %312[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %329 = llvm.extractvalue %312[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %330 = llvm.extractvalue %312[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %331 = llvm.extractvalue %313[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %332 = llvm.extractvalue %313[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %333 = llvm.extractvalue %313[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %334 = llvm.extractvalue %313[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %335 = llvm.extractvalue %313[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %336 = llvm.extractvalue %314[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %337 = llvm.extractvalue %314[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %338 = llvm.extractvalue %314[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %339 = llvm.extractvalue %314[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %340 = llvm.extractvalue %314[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %341 = llvm.extractvalue %315[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %342 = llvm.extractvalue %315[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %343 = llvm.extractvalue %315[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %344 = llvm.extractvalue %315[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %345 = llvm.extractvalue %315[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %346 = llvm.extractvalue %316[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %347 = llvm.extractvalue %316[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %348 = llvm.extractvalue %316[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %349 = llvm.extractvalue %316[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %350 = llvm.extractvalue %316[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %351 = llvm.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%326, %327, %328, %329, %330, %331, %332, %333, %334, %335, %336, %337, %338, %339, %340, %341, %342, %343, %344, %345, %346, %347, %348, %349, %350, %317, %226, %251, %322, %325) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, i64, i64, i64, f32) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
    %352 = llvm.extractvalue %351[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %353 = llvm.extractvalue %351[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %354 = llvm.extractvalue %351[2] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %355 = llvm.extractvalue %351[3] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %356 = llvm.extractvalue %351[4] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %357 = llvm.extractvalue %351[5] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %358 = llvm.getelementptr %168[%322] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %69, %358 : f32, !llvm.ptr
    %359 = llvm.getelementptr %172[%322] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %76, %359 : i1, !llvm.ptr
    %360 = llvm.add %311, %79  : i64
    llvm.br ^bb21(%360, %352, %353, %354, %355, %356, %357 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %361 = llvm.add %239, %79  : i64
    llvm.br ^bb9(%361, %312, %313, %314, %315, %316, %317 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %362 = llvm.add %204, %79  : i64
    llvm.br ^bb7(%362, %240, %241, %242, %243, %244, %245 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%168) : (!llvm.ptr) -> ()
    llvm.call @free(%172) : (!llvm.ptr) -> ()
    llvm.call @free(%176) : (!llvm.ptr) -> ()
    %363 = llvm.extractvalue %210[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %364 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %365 = llvm.getelementptr %364[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %366 = llvm.load %365 : !llvm.ptr -> i64
    %367 = builtin.unrealized_conversion_cast %366 : i64 to index
    llvm.br ^bb26(%79, %366 : i64, i64)
  ^bb26(%368: i64, %369: i64):  // 2 preds: ^bb25, ^bb29
    %370 = builtin.unrealized_conversion_cast %369 : i64 to index
    %371 = builtin.unrealized_conversion_cast %368 : i64 to index
    %372 = builtin.unrealized_conversion_cast %371 : index to i64
    %373 = builtin.unrealized_conversion_cast %370 : index to i64
    %374 = llvm.icmp "slt" %368, %363 : i64
    llvm.cond_br %374, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %375 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %376 = llvm.getelementptr %375[%372] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %377 = llvm.load %376 : !llvm.ptr -> i64
    %378 = builtin.unrealized_conversion_cast %377 : i64 to index
    %379 = llvm.icmp "eq" %377, %82 : i64
    %380 = llvm.select %379, %369, %377 : i1, i64
    llvm.cond_br %379, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %381 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %382 = llvm.getelementptr %381[%372] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %373, %382 : i64, !llvm.ptr
    llvm.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %383 = llvm.add %368, %79  : i64
    llvm.br ^bb26(%383, %380 : i64, i64)
  ^bb30:  // pred: ^bb26
    %384 = llvm.mlir.null : !llvm.ptr
    %385 = llvm.getelementptr %384[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %386 = llvm.ptrtoint %385 : !llvm.ptr to i64
    %387 = llvm.call @malloc(%386) : (i64) -> !llvm.ptr
    %388 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %389 = llvm.insertvalue %387, %388[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %390 = llvm.insertvalue %387, %389[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %391 = llvm.insertvalue %65, %390[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %392 = llvm.insertvalue %63, %391[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %393 = llvm.insertvalue %66, %392[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %394 = builtin.unrealized_conversion_cast %393 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %395 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %396 = llvm.insertvalue %71, %395[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %397 = llvm.insertvalue %74, %396[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %398 = llvm.insertvalue %75, %397[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb31(%82 : i64)
  ^bb31(%399: i64):  // 2 preds: ^bb30, ^bb32
    %400 = builtin.unrealized_conversion_cast %399 : i64 to index
    %401 = builtin.unrealized_conversion_cast %400 : index to i64
    %402 = llvm.icmp "slt" %399, %78 : i64
    llvm.cond_br %402, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %403 = llvm.getelementptr %387[%401] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %69, %403 : f32, !llvm.ptr
    %404 = llvm.add %399, %79  : i64
    llvm.br ^bb31(%404 : i64)
  ^bb33:  // pred: ^bb31
    %405 = llvm.insertvalue %77, %398[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %406 = llvm.extractvalue %219[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %407 = llvm.getelementptr %406[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %408 = llvm.load %407 : !llvm.ptr -> i64
    %409 = builtin.unrealized_conversion_cast %408 : i64 to index
    %410 = llvm.extractvalue %219[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %411 = llvm.getelementptr %410[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %412 = llvm.load %411 : !llvm.ptr -> i64
    %413 = builtin.unrealized_conversion_cast %412 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg48) : i64 = (%408) to (%412) step (%79) {
        %417 = builtin.unrealized_conversion_cast %arg48 : i64 to index
        %418 = builtin.unrealized_conversion_cast %417 : index to i64
        %419 = llvm.extractvalue %220[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %420 = llvm.getelementptr %419[%418] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %421 = llvm.load %420 : !llvm.ptr -> i64
        %422 = builtin.unrealized_conversion_cast %421 : i64 to index
        %423 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %424 = llvm.getelementptr %423[%418] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %425 = llvm.load %424 : !llvm.ptr -> i64
        %426 = builtin.unrealized_conversion_cast %425 : i64 to index
        %427 = llvm.add %arg48, %79  : i64
        %428 = builtin.unrealized_conversion_cast %427 : i64 to index
        %429 = builtin.unrealized_conversion_cast %428 : index to i64
        %430 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %431 = llvm.getelementptr %430[%429] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %432 = llvm.load %431 : !llvm.ptr -> i64
        %433 = builtin.unrealized_conversion_cast %432 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg49) : i64 = (%425) to (%432) step (%79) {
            %434 = builtin.unrealized_conversion_cast %arg49 : i64 to index
            %435 = builtin.unrealized_conversion_cast %434 : index to i64
            %436 = llvm.extractvalue %221[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %437 = llvm.getelementptr %436[%435] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %438 = llvm.load %437 : !llvm.ptr -> i64
            %439 = builtin.unrealized_conversion_cast %438 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg50) : i64 = (%82) to (%81) step (%79) {
                %440 = llvm.mul %arg49, %81  : i64
                %441 = llvm.add %440, %arg50  : i64
                %442 = builtin.unrealized_conversion_cast %441 : i64 to index
                %443 = builtin.unrealized_conversion_cast %442 : index to i64
                %444 = llvm.mul %438, %81  : i64
                %445 = llvm.add %444, %arg50  : i64
                %446 = builtin.unrealized_conversion_cast %445 : i64 to index
                %447 = builtin.unrealized_conversion_cast %446 : index to i64
                %448 = llvm.mul %421, %81  : i64
                %449 = llvm.add %448, %arg50  : i64
                %450 = builtin.unrealized_conversion_cast %449 : i64 to index
                %451 = builtin.unrealized_conversion_cast %450 : index to i64
                %452 = llvm.getelementptr %387[%451] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %453 = llvm.load %452 : !llvm.ptr -> f32
                %454 = llvm.extractvalue %222[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %455 = llvm.getelementptr %454[%443] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %456 = llvm.load %455 : !llvm.ptr -> f32
                %457 = llvm.extractvalue %92[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %458 = llvm.getelementptr %457[%447] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %459 = llvm.load %458 : !llvm.ptr -> f32
                %460 = llvm.fmul %456, %459  : f32
                %461 = llvm.fadd %453, %460  : f32
                %462 = llvm.getelementptr %387[%451] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %461, %462 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    %414 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %415 = llvm.insertvalue %393, %414[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %416 = llvm.insertvalue %405, %415[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %416 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_MTTKRP.A.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.ptr, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg9: !llvm.ptr, %arg10: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg11: !llvm.ptr, %arg12: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg4 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.extractvalue %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.extractvalue %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.extractvalue %36[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.extractvalue %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.extractvalue %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.load %arg9 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.extractvalue %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.extractvalue %42[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.extractvalue %42[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.load %arg11 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.extractvalue %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %48[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %48[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.call @MTTKRP.A.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %37, %38, %39, %40, %41, %arg8, %43, %44, %45, %46, %47, %arg10, %49, %50, %51, %52, %53, %arg12) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<7 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<1 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %54, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ConvertFuncToLLVMPass (convert-func-to-llvm) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg26: i64, %arg27: i64, %arg28: i64, %arg29: f32) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg27 : i64 to index
    %1 = builtin.unrealized_conversion_cast %arg26 : i64 to index
    %2 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = llvm.insertvalue %arg0, %2[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg1, %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg2, %4[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg3, %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = llvm.insertvalue %arg4, %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = builtin.unrealized_conversion_cast %7 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %9 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.insertvalue %arg5, %9[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg6, %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg7, %11[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = llvm.insertvalue %arg8, %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg9, %13[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = builtin.unrealized_conversion_cast %14 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %16 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %17 = llvm.insertvalue %arg10, %16[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg11, %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg12, %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg13, %19[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg14, %20[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = builtin.unrealized_conversion_cast %21 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %23 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %24 = llvm.insertvalue %arg15, %23[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg16, %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg17, %25[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg18, %26[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg19, %27[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %30 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.insertvalue %arg20, %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg21, %31[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg22, %32[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %arg23, %33[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %arg24, %34[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = builtin.unrealized_conversion_cast %35 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = llvm.mlir.constant(false) : i1
    %40 = llvm.mlir.constant(32 : index) : i64
    %41 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %42 = llvm.mlir.constant(2 : index) : i64
    %43 = llvm.mlir.constant(1 : index) : i64
    %44 = builtin.unrealized_conversion_cast %43 : i64 to index
    %45 = builtin.unrealized_conversion_cast %8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %46 = builtin.unrealized_conversion_cast %15 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %47 = builtin.unrealized_conversion_cast %29 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %48 = builtin.unrealized_conversion_cast %0 : index to i64
    %49 = builtin.unrealized_conversion_cast %36 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %50 = builtin.unrealized_conversion_cast %1 : index to i64
    %51 = builtin.unrealized_conversion_cast %22 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %52 = builtin.unrealized_conversion_cast %44 : index to i64
    %53 = builtin.unrealized_conversion_cast %38 : index to i64
    %54 = llvm.extractvalue %45[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = llvm.getelementptr %54[%53] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %56 = llvm.load %55 : !llvm.ptr -> i64
    %57 = builtin.unrealized_conversion_cast %56 : i64 to index
    %58 = llvm.extractvalue %45[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %60 = llvm.load %59 : !llvm.ptr -> i64
    %61 = builtin.unrealized_conversion_cast %60 : i64 to index
    %62 = llvm.extractvalue %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %63 = llvm.sub %60, %43  : i64
    %64 = builtin.unrealized_conversion_cast %63 : i64 to index
    %65 = builtin.unrealized_conversion_cast %64 : index to i64
    %66 = llvm.icmp "ult" %56, %60 : i64
    llvm.cond_br %66, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %67 = llvm.extractvalue %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.getelementptr %67[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %69 = llvm.load %68 : !llvm.ptr -> i64
    %70 = builtin.unrealized_conversion_cast %69 : i64 to index
    %71 = llvm.icmp "eq" %69, %arg26 : i64
    llvm.br ^bb3(%71 : i1)
  ^bb2:  // pred: ^bb0
    llvm.br ^bb3(%39 : i1)
  ^bb3(%72: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %73 = llvm.select %72, %63, %62 : i1, i64
    %74 = builtin.unrealized_conversion_cast %73 : i64 to index
    %75 = builtin.unrealized_conversion_cast %74 : index to i64
    llvm.cond_br %72, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    llvm.br ^bb19(%14, %21, %arg25 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %76 = llvm.add %62, %43  : i64
    %77 = builtin.unrealized_conversion_cast %76 : i64 to index
    %78 = builtin.unrealized_conversion_cast %77 : index to i64
    %79 = llvm.extractvalue %45[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = llvm.getelementptr %79[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %78, %80 : i64, !llvm.ptr
    %81 = llvm.extractvalue %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %82 = builtin.unrealized_conversion_cast %81 : i64 to index
    %83 = builtin.unrealized_conversion_cast %82 : index to i64
    %84 = llvm.extractvalue %46[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = builtin.unrealized_conversion_cast %84 : i64 to index
    %86 = llvm.add %81, %43  : i64
    %87 = llvm.icmp "ugt" %86, %84 : i64
    llvm.cond_br %87, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %88 = llvm.mul %84, %42  : i64
    %89 = builtin.unrealized_conversion_cast %88 : i64 to index
    %90 = llvm.extractvalue %46[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = builtin.unrealized_conversion_cast %89 : index to i64
    %92 = llvm.icmp "ugt" %91, %90 : i64
    llvm.cond_br %92, ^bb8, ^bb9(%46 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %93 = llvm.mlir.null : !llvm.ptr
    %94 = llvm.getelementptr %93[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %95 = llvm.ptrtoint %94 : !llvm.ptr to i64
    %96 = llvm.mul %91, %95  : i64
    %97 = llvm.mul %90, %95  : i64
    %98 = llvm.call @malloc(%96) : (i64) -> !llvm.ptr
    %99 = llvm.extractvalue %46[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%98, %99, %97) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %100 = llvm.extractvalue %46[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%100) : (!llvm.ptr) -> ()
    %101 = llvm.insertvalue %98, %46[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %98, %101[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%102 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%103: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %104 = llvm.insertvalue %91, %103[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = builtin.unrealized_conversion_cast %104 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb11(%104 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb10:  // pred: ^bb6
    llvm.br ^bb11(%14 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb11(%106: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb9, ^bb10
    %107 = builtin.unrealized_conversion_cast %106 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %108 = builtin.unrealized_conversion_cast %107 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb12
  ^bb12:  // pred: ^bb11
    %109 = llvm.extractvalue %108[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %50, %110 : i64, !llvm.ptr
    %111 = llvm.insertvalue %86, %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %112 = llvm.extractvalue %arg25[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = builtin.unrealized_conversion_cast %113 : index to i64
    %115 = llvm.extractvalue %51[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = builtin.unrealized_conversion_cast %115 : i64 to index
    %117 = llvm.add %112, %43  : i64
    %118 = llvm.icmp "ugt" %117, %115 : i64
    llvm.cond_br %118, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %119 = llvm.mul %115, %42  : i64
    %120 = builtin.unrealized_conversion_cast %119 : i64 to index
    %121 = llvm.extractvalue %51[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = builtin.unrealized_conversion_cast %120 : index to i64
    %123 = llvm.icmp "ugt" %122, %121 : i64
    llvm.cond_br %123, ^bb14, ^bb15(%51 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %124 = llvm.mlir.null : !llvm.ptr
    %125 = llvm.getelementptr %124[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %126 = llvm.ptrtoint %125 : !llvm.ptr to i64
    %127 = llvm.mul %122, %126  : i64
    %128 = llvm.mul %121, %126  : i64
    %129 = llvm.call @malloc(%127) : (i64) -> !llvm.ptr
    %130 = llvm.extractvalue %51[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%129, %130, %128) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %131 = llvm.extractvalue %51[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%131) : (!llvm.ptr) -> ()
    %132 = llvm.insertvalue %129, %51[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %133 = llvm.insertvalue %129, %132[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%133 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%134: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %135 = llvm.insertvalue %122, %134[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = builtin.unrealized_conversion_cast %135 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb17(%135 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb16:  // pred: ^bb12
    llvm.br ^bb17(%21 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb17(%137: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb15, ^bb16
    %138 = builtin.unrealized_conversion_cast %137 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %139 = builtin.unrealized_conversion_cast %138 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb18
  ^bb18:  // pred: ^bb17
    %140 = llvm.extractvalue %139[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %141 = llvm.getelementptr %140[%114] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %53, %141 : i64, !llvm.ptr
    %142 = llvm.insertvalue %117, %111[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    llvm.br ^bb19(%106, %137, %142 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%143: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %144: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %145: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    %146 = builtin.unrealized_conversion_cast %144 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %147 = builtin.unrealized_conversion_cast %146 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb20
  ^bb20:  // pred: ^bb19
    %148 = llvm.add %73, %43  : i64
    %149 = builtin.unrealized_conversion_cast %148 : i64 to index
    %150 = builtin.unrealized_conversion_cast %149 : index to i64
    %151 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %152 = llvm.getelementptr %151[%75] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %153 = llvm.load %152 : !llvm.ptr -> i64
    %154 = builtin.unrealized_conversion_cast %153 : i64 to index
    %155 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %156 = llvm.getelementptr %155[%150] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %157 = llvm.load %156 : !llvm.ptr -> i64
    %158 = builtin.unrealized_conversion_cast %157 : i64 to index
    %159 = llvm.extractvalue %145[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = builtin.unrealized_conversion_cast %159 : i64 to index
    %161 = builtin.unrealized_conversion_cast %160 : index to i64
    %162 = llvm.sub %157, %43  : i64
    %163 = builtin.unrealized_conversion_cast %162 : i64 to index
    %164 = builtin.unrealized_conversion_cast %163 : index to i64
    %165 = llvm.icmp "ult" %153, %157 : i64
    llvm.cond_br %165, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %166 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %167 = llvm.getelementptr %166[%164] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %168 = llvm.load %167 : !llvm.ptr -> i64
    %169 = builtin.unrealized_conversion_cast %168 : i64 to index
    %170 = llvm.icmp "eq" %168, %arg27 : i64
    llvm.br ^bb23(%170 : i1)
  ^bb22:  // pred: ^bb20
    %171 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%75] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %161, %172 : i64, !llvm.ptr
    llvm.br ^bb23(%39 : i1)
  ^bb23(%173: i1):  // 2 preds: ^bb21, ^bb22
    llvm.br ^bb24
  ^bb24:  // pred: ^bb23
    %174 = llvm.select %173, %162, %159 : i1, i64
    llvm.cond_br %173, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    llvm.br ^bb44(%28, %35, %145 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %175 = llvm.add %159, %43  : i64
    %176 = builtin.unrealized_conversion_cast %175 : i64 to index
    %177 = builtin.unrealized_conversion_cast %176 : index to i64
    %178 = llvm.extractvalue %147[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%150] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %177, %179 : i64, !llvm.ptr
    %180 = llvm.extractvalue %145[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %181 = builtin.unrealized_conversion_cast %180 : i64 to index
    %182 = builtin.unrealized_conversion_cast %181 : index to i64
    %183 = llvm.extractvalue %47[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %184 = builtin.unrealized_conversion_cast %183 : i64 to index
    %185 = llvm.add %180, %43  : i64
    %186 = llvm.icmp "ugt" %185, %183 : i64
    llvm.cond_br %186, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %187 = llvm.mul %183, %42  : i64
    %188 = builtin.unrealized_conversion_cast %187 : i64 to index
    %189 = llvm.extractvalue %47[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %190 = builtin.unrealized_conversion_cast %188 : index to i64
    %191 = llvm.icmp "ugt" %190, %189 : i64
    llvm.cond_br %191, ^bb28, ^bb29(%47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %192 = llvm.mlir.null : !llvm.ptr
    %193 = llvm.getelementptr %192[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %194 = llvm.ptrtoint %193 : !llvm.ptr to i64
    %195 = llvm.mul %190, %194  : i64
    %196 = llvm.mul %189, %194  : i64
    %197 = llvm.call @malloc(%195) : (i64) -> !llvm.ptr
    %198 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%197, %198, %196) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %199 = llvm.extractvalue %47[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%199) : (!llvm.ptr) -> ()
    %200 = llvm.insertvalue %197, %47[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.insertvalue %197, %200[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%201 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%202: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %203 = llvm.insertvalue %190, %202[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = builtin.unrealized_conversion_cast %203 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb31(%203 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb30:  // pred: ^bb26
    llvm.br ^bb31(%28 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb31(%205: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb29, ^bb30
    %206 = builtin.unrealized_conversion_cast %205 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %207 = builtin.unrealized_conversion_cast %206 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb32
  ^bb32:  // pred: ^bb31
    %208 = llvm.extractvalue %207[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %209 = llvm.getelementptr %208[%182] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %48, %209 : i64, !llvm.ptr
    %210 = llvm.insertvalue %185, %145[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %211 = llvm.extractvalue %145[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %212 = builtin.unrealized_conversion_cast %211 : i64 to index
    %213 = builtin.unrealized_conversion_cast %212 : index to i64
    %214 = llvm.extractvalue %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %215 = builtin.unrealized_conversion_cast %214 : i64 to index
    %216 = llvm.add %211, %40  : i64
    %217 = llvm.icmp "ugt" %216, %214 : i64
    llvm.cond_br %217, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    llvm.br ^bb34(%214 : i64)
  ^bb34(%218: i64):  // 2 preds: ^bb33, ^bb34
    %219 = llvm.mul %218, %42  : i64
    %220 = builtin.unrealized_conversion_cast %219 : i64 to index
    %221 = llvm.icmp "ugt" %216, %219 : i64
    llvm.cond_br %221, ^bb34(%219 : i64), ^bb35
  ^bb35:  // pred: ^bb34
    %222 = llvm.extractvalue %49[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = builtin.unrealized_conversion_cast %220 : index to i64
    %224 = llvm.icmp "ugt" %223, %222 : i64
    llvm.cond_br %224, ^bb36, ^bb37(%49 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %225 = llvm.mlir.null : !llvm.ptr
    %226 = llvm.getelementptr %225[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %227 = llvm.ptrtoint %226 : !llvm.ptr to i64
    %228 = llvm.mul %223, %227  : i64
    %229 = llvm.mul %222, %227  : i64
    %230 = llvm.call @malloc(%228) : (i64) -> !llvm.ptr
    %231 = llvm.extractvalue %49[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%230, %231, %229) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %232 = llvm.extractvalue %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%232) : (!llvm.ptr) -> ()
    %233 = llvm.insertvalue %230, %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %234 = llvm.insertvalue %230, %233[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%234 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%235: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %236 = llvm.insertvalue %223, %235[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %237 = builtin.unrealized_conversion_cast %236 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    llvm.br ^bb39(%236 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb38:  // pred: ^bb32
    llvm.br ^bb39(%35 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb39(%238: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb37, ^bb38
    %239 = builtin.unrealized_conversion_cast %238 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %240 = builtin.unrealized_conversion_cast %239 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb40
  ^bb40:  // pred: ^bb39
    %241 = llvm.extractvalue %240[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb41(%37 : i64)
  ^bb41(%242: i64):  // 2 preds: ^bb40, ^bb42
    %243 = builtin.unrealized_conversion_cast %242 : i64 to index
    %244 = builtin.unrealized_conversion_cast %243 : index to i64
    %245 = llvm.icmp "slt" %242, %40 : i64
    llvm.cond_br %245, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %246 = llvm.getelementptr %241[%213] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %247 = llvm.getelementptr %246[%244] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %41, %247 : f32, !llvm.ptr
    %248 = llvm.add %242, %43  : i64
    llvm.br ^bb41(%248 : i64)
  ^bb43:  // pred: ^bb41
    %249 = llvm.insertvalue %216, %210[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    llvm.br ^bb44(%205, %238, %249 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%250: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %251: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %252: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    %253 = builtin.unrealized_conversion_cast %251 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %254 = builtin.unrealized_conversion_cast %253 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    llvm.br ^bb45
  ^bb45:  // pred: ^bb44
    %255 = llvm.mul %174, %40  : i64
    %256 = llvm.add %255, %arg28  : i64
    %257 = builtin.unrealized_conversion_cast %256 : i64 to index
    %258 = builtin.unrealized_conversion_cast %257 : index to i64
    %259 = llvm.extractvalue %254[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.getelementptr %259[%258] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg29, %260 : f32, !llvm.ptr
    %261 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
    %262 = llvm.insertvalue %7, %261[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %263 = llvm.insertvalue %143, %262[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %264 = llvm.insertvalue %144, %263[2] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %265 = llvm.insertvalue %250, %264[3] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %266 = llvm.insertvalue %251, %265[4] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %267 = llvm.insertvalue %252, %266[5] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    llvm.return %267 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
  }
  llvm.func @_sparse_binary_search_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) -> i64 attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg1 : i64 to index
    %1 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = llvm.insertvalue %arg2, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg3, %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg4, %3[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg6, %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = builtin.unrealized_conversion_cast %7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %0 : index to i64
    llvm.br ^bb1(%arg0, %arg1 : i64, i64)
  ^bb1(%11: i64, %12: i64):  // 2 preds: ^bb0, ^bb2
    %13 = llvm.icmp "ult" %11, %12 : i64
    llvm.cond_br %13, ^bb2(%11, %12 : i64, i64), ^bb3
  ^bb2(%14: i64, %15: i64):  // pred: ^bb1
    %16 = llvm.add %14, %15  : i64
    %17 = llvm.lshr %16, %8  : i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = builtin.unrealized_conversion_cast %18 : index to i64
    %20 = llvm.add %17, %8  : i64
    %21 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = builtin.unrealized_conversion_cast %23 : i64 to index
    %25 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.getelementptr %25[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %27 = llvm.load %26 : !llvm.ptr -> i64
    %28 = builtin.unrealized_conversion_cast %27 : i64 to index
    %29 = llvm.icmp "ult" %23, %27 : i64
    %30 = llvm.select %29, %14, %20 : i1, i64
    %31 = llvm.select %29, %17, %15 : i1, i64
    llvm.br ^bb1(%30, %31 : i64, i64)
  ^bb3:  // pred: ^bb1
    llvm.return %11 : i64
  }
  llvm.func @_sparse_sort_stable_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.constant(0 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.add %arg0, %8  : i64
    llvm.br ^bb1(%10 : i64)
  ^bb1(%11: i64):  // 2 preds: ^bb0, ^bb5
    %12 = builtin.unrealized_conversion_cast %11 : i64 to index
    %13 = builtin.unrealized_conversion_cast %12 : index to i64
    %14 = llvm.icmp "slt" %11, %arg1 : i64
    llvm.cond_br %14, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %15 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.call @_sparse_binary_search_1_index(%arg0, %11, %15, %16, %17, %18, %19) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> i64
    %21 = builtin.unrealized_conversion_cast %20 : i64 to index
    %22 = builtin.unrealized_conversion_cast %21 : index to i64
    %23 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %25 = llvm.load %24 : !llvm.ptr -> i64
    %26 = llvm.sub %11, %20  : i64
    llvm.br ^bb3(%7 : i64)
  ^bb3(%27: i64):  // 2 preds: ^bb2, ^bb4
    %28 = llvm.icmp "slt" %27, %26 : i64
    llvm.cond_br %28, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %29 = llvm.sub %11, %27  : i64
    %30 = builtin.unrealized_conversion_cast %29 : i64 to index
    %31 = builtin.unrealized_conversion_cast %30 : index to i64
    %32 = llvm.sub %29, %8  : i64
    %33 = builtin.unrealized_conversion_cast %32 : i64 to index
    %34 = builtin.unrealized_conversion_cast %33 : index to i64
    %35 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.getelementptr %35[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %37 = llvm.load %36 : !llvm.ptr -> i64
    %38 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.getelementptr %38[%31] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %37, %39 : i64, !llvm.ptr
    %40 = llvm.add %27, %8  : i64
    llvm.br ^bb3(%40 : i64)
  ^bb5:  // pred: ^bb3
    %41 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%22] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %25, %42 : i64, !llvm.ptr
    %43 = llvm.add %11, %8  : i64
    llvm.br ^bb1(%43 : i64)
  ^bb6:  // pred: ^bb1
    llvm.return
  }
  llvm.func @_sparse_shift_down_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.constant(2 : index) : i64
    %9 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = llvm.icmp "uge" %arg7, %8 : i64
    llvm.cond_br %10, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %11 = llvm.sub %arg1, %arg0  : i64
    %12 = llvm.sub %arg7, %8  : i64
    %13 = llvm.lshr %12, %7  : i64
    %14 = llvm.icmp "uge" %13, %11 : i64
    llvm.cond_br %14, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %15 = llvm.shl %11, %7  : i64
    %16 = llvm.add %15, %7  : i64
    %17 = llvm.add %16, %arg0  : i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = builtin.unrealized_conversion_cast %18 : index to i64
    %20 = llvm.add %15, %8  : i64
    %21 = llvm.icmp "ult" %20, %arg7 : i64
    llvm.cond_br %21, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %22 = llvm.add %20, %arg0  : i64
    %23 = builtin.unrealized_conversion_cast %22 : i64 to index
    %24 = builtin.unrealized_conversion_cast %23 : index to i64
    %25 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.getelementptr %25[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %27 = llvm.load %26 : !llvm.ptr -> i64
    %28 = builtin.unrealized_conversion_cast %27 : i64 to index
    %29 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.getelementptr %29[%24] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %31 = llvm.load %30 : !llvm.ptr -> i64
    %32 = builtin.unrealized_conversion_cast %31 : i64 to index
    %33 = llvm.icmp "ult" %27, %31 : i64
    %34 = llvm.select %33, %20, %16 : i1, i64
    %35 = llvm.select %33, %22, %17 : i1, i64
    llvm.br ^bb5(%34, %35, %arg1 : i64, i64, i64)
  ^bb4:  // pred: ^bb2
    llvm.br ^bb5(%16, %17, %arg1 : i64, i64, i64)
  ^bb5(%36: i64, %37: i64, %38: i64):  // 3 preds: ^bb3, ^bb4, ^bb13
    llvm.br ^bb6(%38, %36, %37 : i64, i64, i64)
  ^bb6(%39: i64, %40: i64, %41: i64):  // pred: ^bb5
    llvm.br ^bb7(%39, %40, %41 : i64, i64, i64)
  ^bb7(%42: i64, %43: i64, %44: i64):  // pred: ^bb6
    %45 = builtin.unrealized_conversion_cast %44 : i64 to index
    %46 = builtin.unrealized_conversion_cast %42 : i64 to index
    %47 = builtin.unrealized_conversion_cast %46 : index to i64
    %48 = builtin.unrealized_conversion_cast %45 : index to i64
    %49 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.getelementptr %49[%47] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %51 = llvm.load %50 : !llvm.ptr -> i64
    %52 = builtin.unrealized_conversion_cast %51 : i64 to index
    %53 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = builtin.unrealized_conversion_cast %55 : i64 to index
    %57 = llvm.icmp "ult" %51, %55 : i64
    llvm.cond_br %57, ^bb8(%42, %43, %44 : i64, i64, i64), ^bb14
  ^bb8(%58: i64, %59: i64, %60: i64):  // pred: ^bb7
    %61 = builtin.unrealized_conversion_cast %60 : i64 to index
    %62 = builtin.unrealized_conversion_cast %58 : i64 to index
    %63 = builtin.unrealized_conversion_cast %62 : index to i64
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.getelementptr %65[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %67 = llvm.load %66 : !llvm.ptr -> i64
    %68 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.getelementptr %68[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %70 = llvm.load %69 : !llvm.ptr -> i64
    %71 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %72 = llvm.getelementptr %71[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %70, %72 : i64, !llvm.ptr
    %73 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %74 = llvm.getelementptr %73[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %67, %74 : i64, !llvm.ptr
    %75 = llvm.icmp "uge" %13, %59 : i64
    llvm.cond_br %75, ^bb9, ^bb13(%59, %60 : i64, i64)
  ^bb9:  // pred: ^bb8
    %76 = llvm.shl %59, %7  : i64
    %77 = llvm.add %76, %7  : i64
    %78 = llvm.add %77, %arg0  : i64
    %79 = builtin.unrealized_conversion_cast %78 : i64 to index
    %80 = builtin.unrealized_conversion_cast %79 : index to i64
    %81 = llvm.add %76, %8  : i64
    %82 = llvm.icmp "ult" %81, %arg7 : i64
    llvm.cond_br %82, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %83 = llvm.add %81, %arg0  : i64
    %84 = builtin.unrealized_conversion_cast %83 : i64 to index
    %85 = builtin.unrealized_conversion_cast %84 : index to i64
    %86 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = llvm.getelementptr %86[%80] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %88 = llvm.load %87 : !llvm.ptr -> i64
    %89 = builtin.unrealized_conversion_cast %88 : i64 to index
    %90 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.getelementptr %90[%85] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %92 = llvm.load %91 : !llvm.ptr -> i64
    %93 = builtin.unrealized_conversion_cast %92 : i64 to index
    %94 = llvm.icmp "ult" %88, %92 : i64
    %95 = llvm.select %94, %81, %77 : i1, i64
    %96 = llvm.select %94, %83, %78 : i1, i64
    llvm.br ^bb12(%95, %96 : i64, i64)
  ^bb11:  // pred: ^bb9
    llvm.br ^bb12(%77, %78 : i64, i64)
  ^bb12(%97: i64, %98: i64):  // 2 preds: ^bb10, ^bb11
    llvm.br ^bb13(%97, %98 : i64, i64)
  ^bb13(%99: i64, %100: i64):  // 2 preds: ^bb8, ^bb12
    llvm.br ^bb5(%99, %100, %60 : i64, i64, i64)
  ^bb14:  // pred: ^bb7
    llvm.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    llvm.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    llvm.return
  }
  llvm.func @_sparse_heap_sort_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg0 : i64 to index
    %1 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = llvm.insertvalue %arg2, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg3, %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg4, %3[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg6, %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %8 = llvm.mlir.constant(2 : index) : i64
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.mlir.constant(0 : index) : i64
    %11 = builtin.unrealized_conversion_cast %7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %0 : index to i64
    %13 = llvm.sub %arg1, %arg0  : i64
    %14 = llvm.sub %13, %8  : i64
    %15 = llvm.lshr %14, %9  : i64
    %16 = llvm.add %15, %9  : i64
    llvm.br ^bb1(%10 : i64)
  ^bb1(%17: i64):  // 2 preds: ^bb0, ^bb2
    %18 = llvm.icmp "slt" %17, %16 : i64
    llvm.cond_br %18, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %19 = llvm.sub %15, %17  : i64
    %20 = llvm.add %arg0, %19  : i64
    %21 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_shift_down_1_index(%arg0, %20, %21, %22, %23, %24, %25, %13) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    %26 = llvm.add %17, %9  : i64
    llvm.br ^bb1(%26 : i64)
  ^bb3:  // pred: ^bb1
    %27 = llvm.sub %13, %9  : i64
    llvm.br ^bb4(%10 : i64)
  ^bb4(%28: i64):  // 2 preds: ^bb3, ^bb5
    %29 = llvm.icmp "slt" %28, %27 : i64
    llvm.cond_br %29, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %30 = llvm.sub %13, %28  : i64
    %31 = llvm.add %arg0, %30  : i64
    %32 = llvm.sub %31, %9  : i64
    %33 = builtin.unrealized_conversion_cast %32 : i64 to index
    %34 = builtin.unrealized_conversion_cast %33 : index to i64
    %35 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.getelementptr %35[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %37 = llvm.load %36 : !llvm.ptr -> i64
    %38 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.getelementptr %38[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %40 = llvm.load %39 : !llvm.ptr -> i64
    %41 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %40, %42 : i64, !llvm.ptr
    %43 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %37, %44 : i64, !llvm.ptr
    %45 = llvm.sub %30, %9  : i64
    %46 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %49 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_shift_down_1_index(%arg0, %arg0, %46, %47, %48, %49, %50, %45) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    %51 = llvm.add %28, %9  : i64
    llvm.br ^bb4(%51 : i64)
  ^bb6:  // pred: ^bb4
    llvm.return
  }
  llvm.func @_sparse_partition_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) -> i64 attributes {sym_visibility = "private"} {
    %0 = builtin.unrealized_conversion_cast %arg0 : i64 to index
    %1 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = llvm.insertvalue %arg2, %1[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg3, %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg4, %3[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg5, %4[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.insertvalue %arg6, %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %7 = builtin.unrealized_conversion_cast %6 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %8 = llvm.mlir.constant(-1 : index) : i64
    %9 = llvm.mlir.constant(1000 : index) : i64
    %10 = llvm.mlir.constant(1 : index) : i64
    %11 = builtin.unrealized_conversion_cast %7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %0 : index to i64
    %13 = llvm.add %arg0, %arg1  : i64
    %14 = llvm.lshr %13, %10  : i64
    %15 = builtin.unrealized_conversion_cast %14 : i64 to index
    %16 = builtin.unrealized_conversion_cast %15 : index to i64
    %17 = llvm.sub %arg1, %10  : i64
    %18 = builtin.unrealized_conversion_cast %17 : i64 to index
    %19 = builtin.unrealized_conversion_cast %18 : index to i64
    %20 = llvm.sub %arg1, %arg0  : i64
    %21 = llvm.icmp "ult" %20, %9 : i64
    llvm.cond_br %21, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %22 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = builtin.unrealized_conversion_cast %24 : i64 to index
    %26 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %28 = llvm.load %27 : !llvm.ptr -> i64
    %29 = builtin.unrealized_conversion_cast %28 : i64 to index
    %30 = llvm.icmp "ult" %24, %28 : i64
    llvm.cond_br %30, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %31 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.getelementptr %31[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %33 = llvm.load %32 : !llvm.ptr -> i64
    %34 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.getelementptr %34[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %36 = llvm.load %35 : !llvm.ptr -> i64
    %37 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %36, %38 : i64, !llvm.ptr
    %39 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.getelementptr %39[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %33, %40 : i64, !llvm.ptr
    llvm.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %41 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %43 = llvm.load %42 : !llvm.ptr -> i64
    %44 = builtin.unrealized_conversion_cast %43 : i64 to index
    %45 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %47 = llvm.load %46 : !llvm.ptr -> i64
    %48 = builtin.unrealized_conversion_cast %47 : i64 to index
    %49 = llvm.icmp "ult" %43, %47 : i64
    llvm.cond_br %49, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %50 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.getelementptr %56[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %55, %57 : i64, !llvm.ptr
    %58 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %59 : i64, !llvm.ptr
    %60 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.getelementptr %60[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %62 = llvm.load %61 : !llvm.ptr -> i64
    %63 = builtin.unrealized_conversion_cast %62 : i64 to index
    %64 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %66 = llvm.load %65 : !llvm.ptr -> i64
    %67 = builtin.unrealized_conversion_cast %66 : i64 to index
    %68 = llvm.icmp "ult" %62, %66 : i64
    llvm.cond_br %68, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %69 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %76 = llvm.getelementptr %75[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %74, %76 : i64, !llvm.ptr
    %77 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %78 = llvm.getelementptr %77[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %71, %78 : i64, !llvm.ptr
    llvm.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    llvm.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    llvm.br ^bb27(%arg0, %17, %14 : i64, i64, i64)
  ^bb8:  // pred: ^bb0
    %79 = llvm.add %arg0, %arg1  : i64
    %80 = llvm.lshr %79, %10  : i64
    %81 = builtin.unrealized_conversion_cast %80 : i64 to index
    %82 = builtin.unrealized_conversion_cast %81 : index to i64
    %83 = llvm.add %14, %arg1  : i64
    %84 = llvm.lshr %83, %10  : i64
    %85 = builtin.unrealized_conversion_cast %84 : i64 to index
    %86 = builtin.unrealized_conversion_cast %85 : index to i64
    %87 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %89 = llvm.load %88 : !llvm.ptr -> i64
    %90 = builtin.unrealized_conversion_cast %89 : i64 to index
    %91 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = llvm.icmp "ult" %89, %93 : i64
    llvm.cond_br %95, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %96 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %97 = llvm.getelementptr %96[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %98 = llvm.load %97 : !llvm.ptr -> i64
    %99 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.getelementptr %99[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %101 = llvm.load %100 : !llvm.ptr -> i64
    %102 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.getelementptr %102[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %101, %103 : i64, !llvm.ptr
    %104 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.getelementptr %104[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %98, %105 : i64, !llvm.ptr
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %106 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %108 = llvm.load %107 : !llvm.ptr -> i64
    %109 = builtin.unrealized_conversion_cast %108 : i64 to index
    %110 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.icmp "ult" %108, %112 : i64
    llvm.cond_br %114, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %115 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = llvm.getelementptr %115[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %117 = llvm.load %116 : !llvm.ptr -> i64
    %118 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %119 = llvm.getelementptr %118[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %120 = llvm.load %119 : !llvm.ptr -> i64
    %121 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.getelementptr %121[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %120, %122 : i64, !llvm.ptr
    %123 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.getelementptr %123[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %117, %124 : i64, !llvm.ptr
    %125 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %127 = llvm.load %126 : !llvm.ptr -> i64
    %128 = builtin.unrealized_conversion_cast %127 : i64 to index
    %129 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.getelementptr %129[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %131 = llvm.load %130 : !llvm.ptr -> i64
    %132 = builtin.unrealized_conversion_cast %131 : i64 to index
    %133 = llvm.icmp "ult" %127, %131 : i64
    llvm.cond_br %133, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %134 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %135 = llvm.getelementptr %134[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %136 = llvm.load %135 : !llvm.ptr -> i64
    %137 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = llvm.getelementptr %137[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %139 = llvm.load %138 : !llvm.ptr -> i64
    %140 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %141 = llvm.getelementptr %140[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %139, %141 : i64, !llvm.ptr
    %142 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %143 = llvm.getelementptr %142[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %136, %143 : i64, !llvm.ptr
    llvm.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    llvm.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %144 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %146 = llvm.load %145 : !llvm.ptr -> i64
    %147 = builtin.unrealized_conversion_cast %146 : i64 to index
    %148 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.icmp "ult" %146, %150 : i64
    llvm.cond_br %152, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %153 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %154 = llvm.getelementptr %153[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %155 = llvm.load %154 : !llvm.ptr -> i64
    %156 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %157 = llvm.getelementptr %156[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %158 = llvm.load %157 : !llvm.ptr -> i64
    %159 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %160 = llvm.getelementptr %159[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %158, %160 : i64, !llvm.ptr
    %161 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %162 = llvm.getelementptr %161[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %155, %162 : i64, !llvm.ptr
    %163 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %164 = llvm.getelementptr %163[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %165 = llvm.load %164 : !llvm.ptr -> i64
    %166 = builtin.unrealized_conversion_cast %165 : i64 to index
    %167 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    %170 = builtin.unrealized_conversion_cast %169 : i64 to index
    %171 = llvm.icmp "ult" %165, %169 : i64
    llvm.cond_br %171, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %172 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %173 = llvm.getelementptr %172[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %174 = llvm.load %173 : !llvm.ptr -> i64
    %175 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %176 = llvm.getelementptr %175[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %177 = llvm.load %176 : !llvm.ptr -> i64
    %178 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %177, %179 : i64, !llvm.ptr
    %180 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %181 = llvm.getelementptr %180[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %174, %181 : i64, !llvm.ptr
    %182 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = llvm.getelementptr %182[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %184 = llvm.load %183 : !llvm.ptr -> i64
    %185 = builtin.unrealized_conversion_cast %184 : i64 to index
    %186 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %188 = llvm.load %187 : !llvm.ptr -> i64
    %189 = builtin.unrealized_conversion_cast %188 : i64 to index
    %190 = llvm.icmp "ult" %184, %188 : i64
    llvm.cond_br %190, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %191 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %192 = llvm.getelementptr %191[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %193 = llvm.load %192 : !llvm.ptr -> i64
    %194 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %195 = llvm.getelementptr %194[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %196 = llvm.load %195 : !llvm.ptr -> i64
    %197 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %198 = llvm.getelementptr %197[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %196, %198 : i64, !llvm.ptr
    %199 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %200 = llvm.getelementptr %199[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %193, %200 : i64, !llvm.ptr
    llvm.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    llvm.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    llvm.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %201 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %203 = llvm.load %202 : !llvm.ptr -> i64
    %204 = builtin.unrealized_conversion_cast %203 : i64 to index
    %205 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = builtin.unrealized_conversion_cast %207 : i64 to index
    %209 = llvm.icmp "ult" %203, %207 : i64
    llvm.cond_br %209, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %210 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %211 = llvm.getelementptr %210[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %212 = llvm.load %211 : !llvm.ptr -> i64
    %213 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %214 = llvm.getelementptr %213[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %215 = llvm.load %214 : !llvm.ptr -> i64
    %216 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %217 = llvm.getelementptr %216[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %215, %217 : i64, !llvm.ptr
    %218 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %219 = llvm.getelementptr %218[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %212, %219 : i64, !llvm.ptr
    %220 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %222 = llvm.load %221 : !llvm.ptr -> i64
    %223 = builtin.unrealized_conversion_cast %222 : i64 to index
    %224 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.icmp "ult" %222, %226 : i64
    llvm.cond_br %228, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %229 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %230 = llvm.getelementptr %229[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %231 = llvm.load %230 : !llvm.ptr -> i64
    %232 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %233 = llvm.getelementptr %232[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %234 = llvm.load %233 : !llvm.ptr -> i64
    %235 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %234, %236 : i64, !llvm.ptr
    %237 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %238 = llvm.getelementptr %237[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %231, %238 : i64, !llvm.ptr
    %239 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %240 = llvm.getelementptr %239[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %241 = llvm.load %240 : !llvm.ptr -> i64
    %242 = builtin.unrealized_conversion_cast %241 : i64 to index
    %243 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %244 = llvm.getelementptr %243[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %245 = llvm.load %244 : !llvm.ptr -> i64
    %246 = builtin.unrealized_conversion_cast %245 : i64 to index
    %247 = llvm.icmp "ult" %241, %245 : i64
    llvm.cond_br %247, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %248 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %249 = llvm.getelementptr %248[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %250 = llvm.load %249 : !llvm.ptr -> i64
    %251 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %252 = llvm.getelementptr %251[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %253 = llvm.load %252 : !llvm.ptr -> i64
    %254 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %255 = llvm.getelementptr %254[%16] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %253, %255 : i64, !llvm.ptr
    %256 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %257 = llvm.getelementptr %256[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %250, %257 : i64, !llvm.ptr
    %258 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.getelementptr %258[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %260 = llvm.load %259 : !llvm.ptr -> i64
    %261 = builtin.unrealized_conversion_cast %260 : i64 to index
    %262 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = llvm.getelementptr %262[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %264 = llvm.load %263 : !llvm.ptr -> i64
    %265 = builtin.unrealized_conversion_cast %264 : i64 to index
    %266 = llvm.icmp "ult" %260, %264 : i64
    llvm.cond_br %266, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %267 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %268 = llvm.getelementptr %267[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %269 = llvm.load %268 : !llvm.ptr -> i64
    %270 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %271 = llvm.getelementptr %270[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %272 = llvm.load %271 : !llvm.ptr -> i64
    %273 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %274 = llvm.getelementptr %273[%82] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %272, %274 : i64, !llvm.ptr
    %275 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.getelementptr %275[%12] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %269, %276 : i64, !llvm.ptr
    llvm.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    llvm.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    llvm.br ^bb6
  ^bb27(%277: i64, %278: i64, %279: i64):  // 2 preds: ^bb7, ^bb45
    llvm.br ^bb28(%277, %278, %279 : i64, i64, i64)
  ^bb28(%280: i64, %281: i64, %282: i64):  // pred: ^bb27
    %283 = llvm.icmp "ult" %280, %281 : i64
    llvm.cond_br %283, ^bb29(%280, %281, %282 : i64, i64, i64), ^bb46
  ^bb29(%284: i64, %285: i64, %286: i64):  // pred: ^bb28
    %287 = builtin.unrealized_conversion_cast %286 : i64 to index
    %288 = builtin.unrealized_conversion_cast %287 : index to i64
    llvm.br ^bb30(%284 : i64)
  ^bb30(%289: i64):  // 2 preds: ^bb29, ^bb31
    %290 = builtin.unrealized_conversion_cast %289 : i64 to index
    %291 = builtin.unrealized_conversion_cast %290 : index to i64
    %292 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %293 = llvm.getelementptr %292[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %294 = llvm.load %293 : !llvm.ptr -> i64
    %295 = builtin.unrealized_conversion_cast %294 : i64 to index
    %296 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %297 = llvm.getelementptr %296[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %298 = llvm.load %297 : !llvm.ptr -> i64
    %299 = builtin.unrealized_conversion_cast %298 : i64 to index
    %300 = llvm.icmp "ult" %294, %298 : i64
    llvm.cond_br %300, ^bb31(%289 : i64), ^bb32
  ^bb31(%301: i64):  // pred: ^bb30
    %302 = llvm.add %301, %10  : i64
    llvm.br ^bb30(%302 : i64)
  ^bb32:  // pred: ^bb30
    %303 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %304 = llvm.getelementptr %303[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %305 = llvm.load %304 : !llvm.ptr -> i64
    %306 = builtin.unrealized_conversion_cast %305 : i64 to index
    %307 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %308 = llvm.getelementptr %307[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %309 = llvm.load %308 : !llvm.ptr -> i64
    %310 = builtin.unrealized_conversion_cast %309 : i64 to index
    %311 = llvm.icmp "eq" %305, %309 : i64
    llvm.br ^bb33(%285 : i64)
  ^bb33(%312: i64):  // 2 preds: ^bb32, ^bb34
    %313 = builtin.unrealized_conversion_cast %312 : i64 to index
    %314 = builtin.unrealized_conversion_cast %313 : index to i64
    %315 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %316 = llvm.getelementptr %315[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %317 = llvm.load %316 : !llvm.ptr -> i64
    %318 = builtin.unrealized_conversion_cast %317 : i64 to index
    %319 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %320 = llvm.getelementptr %319[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %321 = llvm.load %320 : !llvm.ptr -> i64
    %322 = builtin.unrealized_conversion_cast %321 : i64 to index
    %323 = llvm.icmp "ult" %317, %321 : i64
    llvm.cond_br %323, ^bb34(%312 : i64), ^bb35
  ^bb34(%324: i64):  // pred: ^bb33
    %325 = llvm.add %324, %8  : i64
    llvm.br ^bb33(%325 : i64)
  ^bb35:  // pred: ^bb33
    %326 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.getelementptr %326[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %328 = llvm.load %327 : !llvm.ptr -> i64
    %329 = builtin.unrealized_conversion_cast %328 : i64 to index
    %330 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %331 = llvm.getelementptr %330[%288] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %332 = llvm.load %331 : !llvm.ptr -> i64
    %333 = builtin.unrealized_conversion_cast %332 : i64 to index
    %334 = llvm.icmp "eq" %328, %332 : i64
    %335 = llvm.icmp "ult" %289, %312 : i64
    llvm.cond_br %335, ^bb36, ^bb44(%289, %312, %286 : i64, i64, i64)
  ^bb36:  // pred: ^bb35
    %336 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %337 = llvm.getelementptr %336[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %338 = llvm.load %337 : !llvm.ptr -> i64
    %339 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %340 = llvm.getelementptr %339[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %341 = llvm.load %340 : !llvm.ptr -> i64
    %342 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %343 = llvm.getelementptr %342[%291] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %341, %343 : i64, !llvm.ptr
    %344 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %345 = llvm.getelementptr %344[%314] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %338, %345 : i64, !llvm.ptr
    %346 = llvm.icmp "eq" %289, %286 : i64
    llvm.cond_br %346, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    llvm.br ^bb39(%312 : i64)
  ^bb38:  // pred: ^bb36
    %347 = llvm.icmp "eq" %312, %286 : i64
    %348 = llvm.select %347, %289, %286 : i1, i64
    llvm.br ^bb39(%348 : i64)
  ^bb39(%349: i64):  // 2 preds: ^bb37, ^bb38
    llvm.br ^bb40
  ^bb40:  // pred: ^bb39
    %350 = llvm.and %311, %334  : i1
    llvm.cond_br %350, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %351 = llvm.add %289, %10  : i64
    %352 = llvm.sub %312, %10  : i64
    llvm.br ^bb43(%351, %352 : i64, i64)
  ^bb42:  // pred: ^bb40
    llvm.br ^bb43(%289, %312 : i64, i64)
  ^bb43(%353: i64, %354: i64):  // 2 preds: ^bb41, ^bb42
    llvm.br ^bb44(%353, %354, %349 : i64, i64, i64)
  ^bb44(%355: i64, %356: i64, %357: i64):  // 2 preds: ^bb35, ^bb43
    llvm.br ^bb45(%355, %356, %357 : i64, i64, i64)
  ^bb45(%358: i64, %359: i64, %360: i64):  // pred: ^bb44
    llvm.br ^bb27(%358, %359, %360 : i64, i64, i64)
  ^bb46:  // pred: ^bb28
    llvm.return %282 : i64
  }
  llvm.func @_sparse_hybrid_qsort_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(30 : index) : i64
    %7 = llvm.mlir.constant(1 : i64) : i64
    %8 = llvm.mlir.constant(0 : i64) : i64
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.mlir.constant(0 : index) : i64
    llvm.br ^bb1(%arg0, %arg1 : i64, i64)
  ^bb1(%11: i64, %12: i64):  // 2 preds: ^bb0, ^bb14
    %13 = llvm.add %11, %9  : i64
    %14 = llvm.icmp "ult" %13, %12 : i64
    llvm.cond_br %14, ^bb2(%11, %12 : i64, i64), ^bb15
  ^bb2(%15: i64, %16: i64):  // pred: ^bb1
    %17 = llvm.sub %16, %15  : i64
    %18 = llvm.icmp "ule" %17, %6 : i64
    llvm.cond_br %18, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %19 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_sort_stable_1_index(%15, %16, %19, %20, %21, %22, %23) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> ()
    llvm.br ^bb13(%15, %15 : i64, i64)
  ^bb4:  // pred: ^bb2
    %24 = llvm.sub %arg7, %7  : i64
    %25 = llvm.icmp "ule" %24, %8 : i64
    llvm.cond_br %25, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %26 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_heap_sort_1_index(%15, %16, %26, %27, %28, %29, %30) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> ()
    llvm.br ^bb11(%15, %15 : i64, i64)
  ^bb6:  // pred: ^bb4
    %31 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.call @_sparse_partition_1_index(%15, %16, %31, %32, %33, %34, %35) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> i64
    %37 = llvm.add %36, %9  : i64
    %38 = llvm.sub %36, %15  : i64
    %39 = llvm.sub %16, %36  : i64
    %40 = llvm.icmp "ule" %38, %39 : i64
    %41 = llvm.select %40, %37, %15 : i1, i64
    %42 = llvm.select %40, %16, %36 : i1, i64
    llvm.cond_br %40, ^bb7(%38, %15, %36 : i64, i64, i64), ^bb7(%39, %37, %16 : i64, i64, i64)
  ^bb7(%43: i64, %44: i64, %45: i64):  // 2 preds: ^bb6, ^bb6
    %46 = llvm.icmp "ne" %43, %10 : i64
    llvm.cond_br %46, ^bb8(%44, %45 : i64, i64), ^bb9
  ^bb8(%47: i64, %48: i64):  // pred: ^bb7
    %49 = llvm.extractvalue %5[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %5[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %5[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %5[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_hybrid_qsort_1_index(%47, %48, %49, %50, %51, %52, %53, %24) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    llvm.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    llvm.br ^bb10
  ^bb10:  // pred: ^bb9
    llvm.br ^bb11(%41, %42 : i64, i64)
  ^bb11(%54: i64, %55: i64):  // 2 preds: ^bb5, ^bb10
    llvm.br ^bb12
  ^bb12:  // pred: ^bb11
    llvm.br ^bb13(%54, %55 : i64, i64)
  ^bb13(%56: i64, %57: i64):  // 2 preds: ^bb3, ^bb12
    llvm.br ^bb14
  ^bb14:  // pred: ^bb13
    llvm.br ^bb1(%56, %57 : i64, i64)
  ^bb15:  // pred: ^bb1
    llvm.return
  }
  llvm.func @MTTKRP.A.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.ptr, %arg26: !llvm.ptr, %arg27: i64, %arg28: i64, %arg29: i64, %arg30: !llvm.ptr, %arg31: !llvm.ptr, %arg32: i64, %arg33: i64, %arg34: i64, %arg35: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg36: !llvm.ptr, %arg37: !llvm.ptr, %arg38: i64, %arg39: i64, %arg40: i64, %arg41: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg42: !llvm.ptr, %arg43: !llvm.ptr, %arg44: i64, %arg45: i64, %arg46: i64, %arg47: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg15, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg16, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg17, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg18, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg19, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg20, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg21, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg22, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg23, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg24, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg25, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg26, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg27, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg28, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg29, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %arg30, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %arg31, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %arg32, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %arg33, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %arg34, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %49 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %50 = llvm.insertvalue %arg36, %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %arg37, %50[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.insertvalue %arg38, %51[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %arg39, %52[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %arg40, %53[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = builtin.unrealized_conversion_cast %54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %56 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = llvm.insertvalue %arg42, %56[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %arg43, %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.insertvalue %arg44, %58[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.insertvalue %arg45, %59[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %arg46, %60[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = builtin.unrealized_conversion_cast %61 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %63 = llvm.mlir.constant(4096 : index) : i64
    %64 = llvm.mlir.constant(32 : index) : i64
    %65 = llvm.mlir.constant(0 : index) : i64
    %66 = llvm.mlir.constant(1 : index) : i64
    %67 = llvm.mlir.constant(16 : index) : i64
    %68 = llvm.mlir.constant(true) : i1
    %69 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %70 = llvm.mlir.constant(64 : i64) : i64
    %71 = llvm.mlir.constant(0 : i64) : i64
    %72 = llvm.mlir.constant(1 : i64) : i64
    %73 = llvm.mlir.constant(2 : i64) : i64
    %74 = llvm.mlir.constant(128 : i64) : i64
    %75 = llvm.mlir.constant(32 : i64) : i64
    %76 = llvm.mlir.constant(false) : i1
    %77 = llvm.mlir.constant(4096 : i64) : i64
    %78 = llvm.mlir.constant(4096 : index) : i64
    %79 = llvm.mlir.constant(1 : index) : i64
    %80 = builtin.unrealized_conversion_cast %79 : i64 to index
    %81 = llvm.mlir.constant(32 : index) : i64
    %82 = llvm.mlir.constant(0 : index) : i64
    %83 = builtin.unrealized_conversion_cast %82 : i64 to index
    %84 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %85 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %86 = builtin.unrealized_conversion_cast %20 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %87 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %88 = builtin.unrealized_conversion_cast %34 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %89 = builtin.unrealized_conversion_cast %41 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %90 = builtin.unrealized_conversion_cast %48 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %91 = builtin.unrealized_conversion_cast %55 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %92 = builtin.unrealized_conversion_cast %62 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %93 = builtin.unrealized_conversion_cast %83 : index to i64
    %94 = builtin.unrealized_conversion_cast %80 : index to i64
    %95 = llvm.mlir.null : !llvm.ptr
    %96 = llvm.getelementptr %95[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %97 = llvm.ptrtoint %96 : !llvm.ptr to i64
    %98 = llvm.call @malloc(%97) : (i64) -> !llvm.ptr
    %99 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %100 = llvm.insertvalue %98, %99[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.insertvalue %98, %100[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %65, %101[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.insertvalue %67, %102[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.insertvalue %66, %103[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = builtin.unrealized_conversion_cast %104 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %106 = llvm.mlir.null : !llvm.ptr
    %107 = llvm.getelementptr %106[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %108 = llvm.ptrtoint %107 : !llvm.ptr to i64
    %109 = llvm.call @malloc(%108) : (i64) -> !llvm.ptr
    %110 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %111 = llvm.insertvalue %109, %110[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %112 = llvm.insertvalue %109, %111[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %113 = llvm.insertvalue %65, %112[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.insertvalue %67, %113[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.insertvalue %66, %114[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %116 = builtin.unrealized_conversion_cast %115 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %117 = llvm.mlir.null : !llvm.ptr
    %118 = llvm.getelementptr %117[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %119 = llvm.ptrtoint %118 : !llvm.ptr to i64
    %120 = llvm.call @malloc(%119) : (i64) -> !llvm.ptr
    %121 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %122 = llvm.insertvalue %120, %121[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.insertvalue %120, %122[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.insertvalue %65, %123[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %125 = llvm.insertvalue %67, %124[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.insertvalue %66, %125[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %127 = builtin.unrealized_conversion_cast %126 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %128 = llvm.mlir.null : !llvm.ptr
    %129 = llvm.getelementptr %128[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %130 = llvm.ptrtoint %129 : !llvm.ptr to i64
    %131 = llvm.call @malloc(%130) : (i64) -> !llvm.ptr
    %132 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %133 = llvm.insertvalue %131, %132[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.insertvalue %131, %133[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %135 = llvm.insertvalue %65, %134[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = llvm.insertvalue %67, %135[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %137 = llvm.insertvalue %66, %136[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = builtin.unrealized_conversion_cast %137 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %139 = llvm.mlir.null : !llvm.ptr
    %140 = llvm.getelementptr %139[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %141 = llvm.ptrtoint %140 : !llvm.ptr to i64
    %142 = llvm.call @malloc(%141) : (i64) -> !llvm.ptr
    %143 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %144 = llvm.insertvalue %142, %143[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.insertvalue %142, %144[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %146 = llvm.insertvalue %65, %145[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.insertvalue %67, %146[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %148 = llvm.insertvalue %66, %147[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = builtin.unrealized_conversion_cast %148 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %150 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %151 = llvm.insertvalue %71, %150[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %152 = llvm.insertvalue %71, %151[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %153 = llvm.insertvalue %71, %152[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %154 = llvm.insertvalue %71, %153[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %155 = llvm.insertvalue %71, %154[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %156 = llvm.insertvalue %74, %155[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %157 = llvm.getelementptr %98[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %93, %157 : i64, !llvm.ptr
    %158 = llvm.insertvalue %72, %156[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %159 = llvm.insertvalue %74, %158[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %160 = llvm.getelementptr %120[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %93, %160 : i64, !llvm.ptr
    %161 = llvm.insertvalue %72, %159[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %162 = llvm.insertvalue %75, %161[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %163 = llvm.getelementptr %98[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %93, %163 : i64, !llvm.ptr
    %164 = llvm.insertvalue %73, %162[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %165 = llvm.mlir.null : !llvm.ptr
    %166 = llvm.getelementptr %165[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %167 = llvm.ptrtoint %166 : !llvm.ptr to i64
    %168 = llvm.call @malloc(%167) : (i64) -> !llvm.ptr
    %169 = llvm.mlir.null : !llvm.ptr
    %170 = llvm.getelementptr %169[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %171 = llvm.ptrtoint %170 : !llvm.ptr to i64
    %172 = llvm.call @malloc(%171) : (i64) -> !llvm.ptr
    %173 = llvm.mlir.null : !llvm.ptr
    %174 = llvm.getelementptr %173[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %175 = llvm.ptrtoint %174 : !llvm.ptr to i64
    %176 = llvm.call @malloc(%175) : (i64) -> !llvm.ptr
    %177 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %178 = llvm.insertvalue %176, %177[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.insertvalue %176, %178[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %180 = llvm.insertvalue %65, %179[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %181 = llvm.insertvalue %64, %180[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = llvm.insertvalue %66, %181[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %183 = builtin.unrealized_conversion_cast %182 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    llvm.br ^bb1(%82 : i64)
  ^bb1(%184: i64):  // 2 preds: ^bb0, ^bb2
    %185 = builtin.unrealized_conversion_cast %184 : i64 to index
    %186 = builtin.unrealized_conversion_cast %185 : index to i64
    %187 = llvm.icmp "slt" %184, %81 : i64
    llvm.cond_br %187, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %188 = llvm.getelementptr %168[%186] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %69, %188 : f32, !llvm.ptr
    %189 = llvm.add %184, %79  : i64
    llvm.br ^bb1(%189 : i64)
  ^bb3:  // pred: ^bb1
    llvm.br ^bb4(%82 : i64)
  ^bb4(%190: i64):  // 2 preds: ^bb3, ^bb5
    %191 = builtin.unrealized_conversion_cast %190 : i64 to index
    %192 = builtin.unrealized_conversion_cast %191 : index to i64
    %193 = llvm.icmp "slt" %190, %81 : i64
    llvm.cond_br %193, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %194 = llvm.getelementptr %172[%192] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %76, %194 : i1, !llvm.ptr
    %195 = llvm.add %190, %79  : i64
    llvm.br ^bb4(%195 : i64)
  ^bb6:  // pred: ^bb4
    %196 = llvm.extractvalue %84[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.getelementptr %196[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %198 = llvm.load %197 : !llvm.ptr -> i64
    %199 = builtin.unrealized_conversion_cast %198 : i64 to index
    %200 = llvm.extractvalue %84[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %201 = llvm.getelementptr %200[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %202 = llvm.load %201 : !llvm.ptr -> i64
    %203 = builtin.unrealized_conversion_cast %202 : i64 to index
    llvm.br ^bb7(%198, %104, %115, %126, %137, %148, %164 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%204: i64, %205: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %206: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %207: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %208: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %209: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %210: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %211 = builtin.unrealized_conversion_cast %209 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %212 = builtin.unrealized_conversion_cast %208 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %213 = builtin.unrealized_conversion_cast %207 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %214 = builtin.unrealized_conversion_cast %206 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %215 = builtin.unrealized_conversion_cast %205 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %216 = builtin.unrealized_conversion_cast %204 : i64 to index
    %217 = builtin.unrealized_conversion_cast %216 : index to i64
    %218 = builtin.unrealized_conversion_cast %213 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %219 = builtin.unrealized_conversion_cast %215 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %220 = builtin.unrealized_conversion_cast %214 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %221 = builtin.unrealized_conversion_cast %212 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %222 = builtin.unrealized_conversion_cast %211 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %223 = llvm.icmp "slt" %204, %202 : i64
    llvm.cond_br %223, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %224 = llvm.extractvalue %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %225 = llvm.getelementptr %224[%217] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %226 = llvm.load %225 : !llvm.ptr -> i64
    %227 = builtin.unrealized_conversion_cast %226 : i64 to index
    %228 = llvm.extractvalue %86[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %229 = llvm.getelementptr %228[%217] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %230 = llvm.load %229 : !llvm.ptr -> i64
    %231 = builtin.unrealized_conversion_cast %230 : i64 to index
    %232 = llvm.add %204, %79  : i64
    %233 = builtin.unrealized_conversion_cast %232 : i64 to index
    %234 = builtin.unrealized_conversion_cast %233 : index to i64
    %235 = llvm.extractvalue %86[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%234] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %237 = llvm.load %236 : !llvm.ptr -> i64
    %238 = builtin.unrealized_conversion_cast %237 : i64 to index
    llvm.br ^bb9(%230, %205, %206, %207, %208, %209, %210 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%239: i64, %240: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %241: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %242: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %243: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %244: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %245: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %246 = builtin.unrealized_conversion_cast %239 : i64 to index
    %247 = builtin.unrealized_conversion_cast %246 : index to i64
    %248 = llvm.icmp "slt" %239, %237 : i64
    llvm.cond_br %248, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %249 = llvm.extractvalue %87[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %250 = llvm.getelementptr %249[%247] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %251 = llvm.load %250 : !llvm.ptr -> i64
    %252 = builtin.unrealized_conversion_cast %251 : i64 to index
    %253 = llvm.extractvalue %88[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %254 = llvm.getelementptr %253[%247] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %255 = llvm.load %254 : !llvm.ptr -> i64
    %256 = builtin.unrealized_conversion_cast %255 : i64 to index
    %257 = llvm.add %239, %79  : i64
    %258 = builtin.unrealized_conversion_cast %257 : i64 to index
    %259 = builtin.unrealized_conversion_cast %258 : index to i64
    %260 = llvm.extractvalue %88[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.getelementptr %260[%259] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %262 = llvm.load %261 : !llvm.ptr -> i64
    %263 = builtin.unrealized_conversion_cast %262 : i64 to index
    llvm.br ^bb11(%255, %82 : i64, i64)
  ^bb11(%264: i64, %265: i64):  // 2 preds: ^bb10, ^bb19
    %266 = builtin.unrealized_conversion_cast %264 : i64 to index
    %267 = builtin.unrealized_conversion_cast %266 : index to i64
    %268 = llvm.icmp "slt" %264, %262 : i64
    llvm.cond_br %268, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %269 = llvm.extractvalue %89[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %270 = llvm.getelementptr %269[%267] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %271 = llvm.load %270 : !llvm.ptr -> i64
    %272 = builtin.unrealized_conversion_cast %271 : i64 to index
    %273 = llvm.extractvalue %90[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %274 = llvm.getelementptr %273[%267] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %275 = llvm.load %274 : !llvm.ptr -> f32
    llvm.br ^bb13(%82, %265 : i64, i64)
  ^bb13(%276: i64, %277: i64):  // 2 preds: ^bb12, ^bb18
    %278 = builtin.unrealized_conversion_cast %277 : i64 to index
    %279 = builtin.unrealized_conversion_cast %276 : i64 to index
    %280 = builtin.unrealized_conversion_cast %279 : index to i64
    %281 = builtin.unrealized_conversion_cast %278 : index to i64
    %282 = llvm.icmp "slt" %276, %81 : i64
    llvm.cond_br %282, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %283 = llvm.mul %271, %81  : i64
    %284 = llvm.add %283, %276  : i64
    %285 = builtin.unrealized_conversion_cast %284 : i64 to index
    %286 = builtin.unrealized_conversion_cast %285 : index to i64
    %287 = llvm.getelementptr %168[%280] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %288 = llvm.load %287 : !llvm.ptr -> f32
    %289 = llvm.extractvalue %91[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %290 = llvm.getelementptr %289[%286] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %291 = llvm.load %290 : !llvm.ptr -> f32
    %292 = llvm.fmul %275, %291  : f32
    %293 = llvm.fadd %288, %292  : f32
    %294 = llvm.getelementptr %172[%280] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %295 = llvm.load %294 : !llvm.ptr -> i1
    %296 = llvm.icmp "eq" %295, %76 : i1
    llvm.cond_br %296, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %297 = llvm.getelementptr %172[%280] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %68, %297 : i1, !llvm.ptr
    %298 = llvm.getelementptr %176[%281] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %280, %298 : i64, !llvm.ptr
    %299 = llvm.add %277, %79  : i64
    llvm.br ^bb17(%299 : i64)
  ^bb16:  // pred: ^bb14
    llvm.br ^bb17(%277 : i64)
  ^bb17(%300: i64):  // 2 preds: ^bb15, ^bb16
    llvm.br ^bb18
  ^bb18:  // pred: ^bb17
    %301 = llvm.getelementptr %168[%280] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %293, %301 : f32, !llvm.ptr
    %302 = llvm.add %276, %79  : i64
    llvm.br ^bb13(%302, %300 : i64, i64)
  ^bb19:  // pred: ^bb13
    %303 = llvm.add %264, %79  : i64
    llvm.br ^bb11(%303, %277 : i64, i64)
  ^bb20:  // pred: ^bb11
    %304 = "llvm.intr.ctlz"(%265) <{is_zero_poison = false}> : (i64) -> i64
    %305 = llvm.sub %70, %304  : i64
    %306 = llvm.extractvalue %182[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %307 = llvm.extractvalue %182[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %308 = llvm.extractvalue %182[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.extractvalue %182[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %310 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @_sparse_hybrid_qsort_1_index(%82, %265, %306, %307, %308, %309, %310, %305) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    llvm.br ^bb21(%82, %240, %241, %242, %243, %244, %245 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%311: i64, %312: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %313: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %314: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %315: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %316: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %317: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %318 = builtin.unrealized_conversion_cast %311 : i64 to index
    %319 = builtin.unrealized_conversion_cast %318 : index to i64
    %320 = llvm.icmp "slt" %311, %265 : i64
    llvm.cond_br %320, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %321 = llvm.getelementptr %176[%319] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %322 = llvm.load %321 : !llvm.ptr -> i64
    %323 = builtin.unrealized_conversion_cast %322 : i64 to index
    %324 = llvm.getelementptr %168[%322] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %325 = llvm.load %324 : !llvm.ptr -> f32
    %326 = llvm.extractvalue %312[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %327 = llvm.extractvalue %312[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %328 = llvm.extractvalue %312[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %329 = llvm.extractvalue %312[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %330 = llvm.extractvalue %312[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %331 = llvm.extractvalue %313[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %332 = llvm.extractvalue %313[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %333 = llvm.extractvalue %313[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %334 = llvm.extractvalue %313[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %335 = llvm.extractvalue %313[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %336 = llvm.extractvalue %314[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %337 = llvm.extractvalue %314[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %338 = llvm.extractvalue %314[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %339 = llvm.extractvalue %314[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %340 = llvm.extractvalue %314[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %341 = llvm.extractvalue %315[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %342 = llvm.extractvalue %315[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %343 = llvm.extractvalue %315[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %344 = llvm.extractvalue %315[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %345 = llvm.extractvalue %315[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %346 = llvm.extractvalue %316[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %347 = llvm.extractvalue %316[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %348 = llvm.extractvalue %316[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %349 = llvm.extractvalue %316[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %350 = llvm.extractvalue %316[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %351 = llvm.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%326, %327, %328, %329, %330, %331, %332, %333, %334, %335, %336, %337, %338, %339, %340, %341, %342, %343, %344, %345, %346, %347, %348, %349, %350, %317, %226, %251, %322, %325) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, i64, i64, i64, f32) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
    %352 = llvm.extractvalue %351[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %353 = llvm.extractvalue %351[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %354 = llvm.extractvalue %351[2] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %355 = llvm.extractvalue %351[3] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %356 = llvm.extractvalue %351[4] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %357 = llvm.extractvalue %351[5] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %358 = llvm.getelementptr %168[%322] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %69, %358 : f32, !llvm.ptr
    %359 = llvm.getelementptr %172[%322] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %76, %359 : i1, !llvm.ptr
    %360 = llvm.add %311, %79  : i64
    llvm.br ^bb21(%360, %352, %353, %354, %355, %356, %357 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %361 = llvm.add %239, %79  : i64
    llvm.br ^bb9(%361, %312, %313, %314, %315, %316, %317 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %362 = llvm.add %204, %79  : i64
    llvm.br ^bb7(%362, %240, %241, %242, %243, %244, %245 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%168) : (!llvm.ptr) -> ()
    llvm.call @free(%172) : (!llvm.ptr) -> ()
    llvm.call @free(%176) : (!llvm.ptr) -> ()
    %363 = llvm.extractvalue %210[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %364 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %365 = llvm.getelementptr %364[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %366 = llvm.load %365 : !llvm.ptr -> i64
    %367 = builtin.unrealized_conversion_cast %366 : i64 to index
    llvm.br ^bb26(%79, %366 : i64, i64)
  ^bb26(%368: i64, %369: i64):  // 2 preds: ^bb25, ^bb29
    %370 = builtin.unrealized_conversion_cast %369 : i64 to index
    %371 = builtin.unrealized_conversion_cast %368 : i64 to index
    %372 = builtin.unrealized_conversion_cast %371 : index to i64
    %373 = builtin.unrealized_conversion_cast %370 : index to i64
    %374 = llvm.icmp "slt" %368, %363 : i64
    llvm.cond_br %374, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %375 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %376 = llvm.getelementptr %375[%372] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %377 = llvm.load %376 : !llvm.ptr -> i64
    %378 = builtin.unrealized_conversion_cast %377 : i64 to index
    %379 = llvm.icmp "eq" %377, %82 : i64
    %380 = llvm.select %379, %369, %377 : i1, i64
    llvm.cond_br %379, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %381 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %382 = llvm.getelementptr %381[%372] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %373, %382 : i64, !llvm.ptr
    llvm.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %383 = llvm.add %368, %79  : i64
    llvm.br ^bb26(%383, %380 : i64, i64)
  ^bb30:  // pred: ^bb26
    %384 = llvm.mlir.null : !llvm.ptr
    %385 = llvm.getelementptr %384[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %386 = llvm.ptrtoint %385 : !llvm.ptr to i64
    %387 = llvm.call @malloc(%386) : (i64) -> !llvm.ptr
    %388 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %389 = llvm.insertvalue %387, %388[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %390 = llvm.insertvalue %387, %389[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %391 = llvm.insertvalue %65, %390[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %392 = llvm.insertvalue %63, %391[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %393 = llvm.insertvalue %66, %392[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %394 = builtin.unrealized_conversion_cast %393 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %395 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %396 = llvm.insertvalue %71, %395[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %397 = llvm.insertvalue %74, %396[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %398 = llvm.insertvalue %75, %397[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb31(%82 : i64)
  ^bb31(%399: i64):  // 2 preds: ^bb30, ^bb32
    %400 = builtin.unrealized_conversion_cast %399 : i64 to index
    %401 = builtin.unrealized_conversion_cast %400 : index to i64
    %402 = llvm.icmp "slt" %399, %78 : i64
    llvm.cond_br %402, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %403 = llvm.getelementptr %387[%401] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %69, %403 : f32, !llvm.ptr
    %404 = llvm.add %399, %79  : i64
    llvm.br ^bb31(%404 : i64)
  ^bb33:  // pred: ^bb31
    %405 = llvm.insertvalue %77, %398[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %406 = llvm.extractvalue %219[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %407 = llvm.getelementptr %406[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %408 = llvm.load %407 : !llvm.ptr -> i64
    %409 = builtin.unrealized_conversion_cast %408 : i64 to index
    %410 = llvm.extractvalue %219[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %411 = llvm.getelementptr %410[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %412 = llvm.load %411 : !llvm.ptr -> i64
    %413 = builtin.unrealized_conversion_cast %412 : i64 to index
    omp.parallel   {
      omp.wsloop   for  (%arg48) : i64 = (%408) to (%412) step (%79) {
        %417 = builtin.unrealized_conversion_cast %arg48 : i64 to index
        %418 = builtin.unrealized_conversion_cast %417 : index to i64
        %419 = llvm.extractvalue %220[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %420 = llvm.getelementptr %419[%418] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %421 = llvm.load %420 : !llvm.ptr -> i64
        %422 = builtin.unrealized_conversion_cast %421 : i64 to index
        %423 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %424 = llvm.getelementptr %423[%418] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %425 = llvm.load %424 : !llvm.ptr -> i64
        %426 = builtin.unrealized_conversion_cast %425 : i64 to index
        %427 = llvm.add %arg48, %79  : i64
        %428 = builtin.unrealized_conversion_cast %427 : i64 to index
        %429 = builtin.unrealized_conversion_cast %428 : index to i64
        %430 = llvm.extractvalue %218[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %431 = llvm.getelementptr %430[%429] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %432 = llvm.load %431 : !llvm.ptr -> i64
        %433 = builtin.unrealized_conversion_cast %432 : i64 to index
        omp.parallel   {
          omp.wsloop   for  (%arg49) : i64 = (%425) to (%432) step (%79) {
            %434 = builtin.unrealized_conversion_cast %arg49 : i64 to index
            %435 = builtin.unrealized_conversion_cast %434 : index to i64
            %436 = llvm.extractvalue %221[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %437 = llvm.getelementptr %436[%435] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %438 = llvm.load %437 : !llvm.ptr -> i64
            %439 = builtin.unrealized_conversion_cast %438 : i64 to index
            omp.parallel   {
              omp.wsloop   for  (%arg50) : i64 = (%82) to (%81) step (%79) {
                %440 = llvm.mul %arg49, %81  : i64
                %441 = llvm.add %440, %arg50  : i64
                %442 = builtin.unrealized_conversion_cast %441 : i64 to index
                %443 = builtin.unrealized_conversion_cast %442 : index to i64
                %444 = llvm.mul %438, %81  : i64
                %445 = llvm.add %444, %arg50  : i64
                %446 = builtin.unrealized_conversion_cast %445 : i64 to index
                %447 = builtin.unrealized_conversion_cast %446 : index to i64
                %448 = llvm.mul %421, %81  : i64
                %449 = llvm.add %448, %arg50  : i64
                %450 = builtin.unrealized_conversion_cast %449 : i64 to index
                %451 = builtin.unrealized_conversion_cast %450 : index to i64
                %452 = llvm.getelementptr %387[%451] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %453 = llvm.load %452 : !llvm.ptr -> f32
                %454 = llvm.extractvalue %222[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %455 = llvm.getelementptr %454[%443] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %456 = llvm.load %455 : !llvm.ptr -> f32
                %457 = llvm.extractvalue %92[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %458 = llvm.getelementptr %457[%447] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %459 = llvm.load %458 : !llvm.ptr -> f32
                %460 = llvm.fmul %456, %459  : f32
                %461 = llvm.fadd %453, %460  : f32
                %462 = llvm.getelementptr %387[%451] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %461, %462 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    %414 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %415 = llvm.insertvalue %393, %414[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %416 = llvm.insertvalue %405, %415[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %416 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_MTTKRP.A.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.ptr, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg9: !llvm.ptr, %arg10: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg11: !llvm.ptr, %arg12: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg4 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.extractvalue %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.extractvalue %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.extractvalue %36[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.extractvalue %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.extractvalue %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.load %arg9 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.extractvalue %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.extractvalue %42[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.extractvalue %42[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.load %arg11 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.extractvalue %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %48[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %48[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.call @MTTKRP.A.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %37, %38, %39, %40, %41, %arg8, %43, %44, %45, %46, %47, %arg10, %49, %50, %51, %52, %53, %arg12) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<7 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<1 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %54, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ReconcileUnrealizedCasts (reconcile-unrealized-casts) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @free(!llvm.ptr)
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg26: i64, %arg27: i64, %arg28: i64, %arg29: f32) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.insertvalue %arg5, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.insertvalue %arg6, %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg7, %8[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg8, %9[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg9, %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %arg12, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg13, %15[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg14, %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.insertvalue %arg15, %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg16, %19[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg17, %20[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %arg18, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg19, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.insertvalue %arg20, %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg21, %25[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg22, %26[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg23, %27[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.insertvalue %arg24, %28[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.mlir.constant(0 : index) : i64
    %31 = llvm.mlir.constant(false) : i1
    %32 = llvm.mlir.constant(32 : index) : i64
    %33 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %34 = llvm.mlir.constant(2 : index) : i64
    %35 = llvm.mlir.constant(1 : index) : i64
    %36 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.getelementptr %36[%30] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %38 = llvm.load %37 : !llvm.ptr -> i64
    %39 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.getelementptr %39[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %41 = llvm.load %40 : !llvm.ptr -> i64
    %42 = llvm.extractvalue %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %43 = llvm.sub %41, %35  : i64
    %44 = llvm.icmp "ult" %38, %41 : i64
    llvm.cond_br %44, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %45 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%43] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %47 = llvm.load %46 : !llvm.ptr -> i64
    %48 = llvm.icmp "eq" %47, %arg26 : i64
    llvm.br ^bb3(%48 : i1)
  ^bb2:  // pred: ^bb0
    llvm.br ^bb3(%31 : i1)
  ^bb3(%49: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %50 = llvm.select %49, %43, %42 : i1, i64
    llvm.cond_br %49, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    llvm.br ^bb19(%11, %17, %arg25 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb6:  // pred: ^bb4
    %51 = llvm.add %42, %35  : i64
    %52 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.getelementptr %52[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %51, %53 : i64, !llvm.ptr
    %54 = llvm.extractvalue %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %55 = llvm.extractvalue %11[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.add %54, %35  : i64
    %57 = llvm.icmp "ugt" %56, %55 : i64
    llvm.cond_br %57, ^bb7, ^bb10
  ^bb7:  // pred: ^bb6
    %58 = llvm.mul %55, %34  : i64
    %59 = llvm.extractvalue %11[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.icmp "ugt" %58, %59 : i64
    llvm.cond_br %60, ^bb8, ^bb9(%11 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb8:  // pred: ^bb7
    %61 = llvm.mlir.null : !llvm.ptr
    %62 = llvm.getelementptr %61[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %63 = llvm.ptrtoint %62 : !llvm.ptr to i64
    %64 = llvm.mul %58, %63  : i64
    %65 = llvm.mul %59, %63  : i64
    %66 = llvm.call @malloc(%64) : (i64) -> !llvm.ptr
    %67 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%66, %67, %65) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %68 = llvm.extractvalue %11[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%68) : (!llvm.ptr) -> ()
    %69 = llvm.insertvalue %66, %11[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.insertvalue %66, %69[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb9(%70 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb9(%71: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb7, ^bb8
    %72 = llvm.insertvalue %58, %71[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb11(%72 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb10:  // pred: ^bb6
    llvm.br ^bb11(%11 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb11(%73: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb9, ^bb10
    llvm.br ^bb12
  ^bb12:  // pred: ^bb11
    %74 = llvm.extractvalue %73[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %75 = llvm.getelementptr %74[%54] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %arg26, %75 : i64, !llvm.ptr
    %76 = llvm.insertvalue %56, %arg25[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %77 = llvm.extractvalue %arg25[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %78 = llvm.extractvalue %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.add %77, %35  : i64
    %80 = llvm.icmp "ugt" %79, %78 : i64
    llvm.cond_br %80, ^bb13, ^bb16
  ^bb13:  // pred: ^bb12
    %81 = llvm.mul %78, %34  : i64
    %82 = llvm.extractvalue %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %83 = llvm.icmp "ugt" %81, %82 : i64
    llvm.cond_br %83, ^bb14, ^bb15(%17 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb14:  // pred: ^bb13
    %84 = llvm.mlir.null : !llvm.ptr
    %85 = llvm.getelementptr %84[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %86 = llvm.ptrtoint %85 : !llvm.ptr to i64
    %87 = llvm.mul %81, %86  : i64
    %88 = llvm.mul %82, %86  : i64
    %89 = llvm.call @malloc(%87) : (i64) -> !llvm.ptr
    %90 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%89, %90, %88) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %91 = llvm.extractvalue %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%91) : (!llvm.ptr) -> ()
    %92 = llvm.insertvalue %89, %17[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %93 = llvm.insertvalue %89, %92[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb15(%93 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb15(%94: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb13, ^bb14
    %95 = llvm.insertvalue %81, %94[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb17(%95 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb16:  // pred: ^bb12
    llvm.br ^bb17(%17 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb17(%96: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb15, ^bb16
    llvm.br ^bb18
  ^bb18:  // pred: ^bb17
    %97 = llvm.extractvalue %96[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %98 = llvm.getelementptr %97[%77] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %30, %98 : i64, !llvm.ptr
    %99 = llvm.insertvalue %79, %76[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    llvm.br ^bb19(%73, %96, %99 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb19(%100: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %101: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %102: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb5, ^bb18
    llvm.br ^bb20
  ^bb20:  // pred: ^bb19
    %103 = llvm.add %50, %35  : i64
    %104 = llvm.extractvalue %101[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %105 = llvm.getelementptr %104[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %106 = llvm.load %105 : !llvm.ptr -> i64
    %107 = llvm.extractvalue %101[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %108 = llvm.getelementptr %107[%103] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %109 = llvm.load %108 : !llvm.ptr -> i64
    %110 = llvm.extractvalue %102[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %111 = llvm.sub %109, %35  : i64
    %112 = llvm.icmp "ult" %106, %109 : i64
    llvm.cond_br %112, ^bb21, ^bb22
  ^bb21:  // pred: ^bb20
    %113 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.getelementptr %113[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %115 = llvm.load %114 : !llvm.ptr -> i64
    %116 = llvm.icmp "eq" %115, %arg27 : i64
    llvm.br ^bb23(%116 : i1)
  ^bb22:  // pred: ^bb20
    %117 = llvm.extractvalue %101[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %118 = llvm.getelementptr %117[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %110, %118 : i64, !llvm.ptr
    llvm.br ^bb23(%31 : i1)
  ^bb23(%119: i1):  // 2 preds: ^bb21, ^bb22
    llvm.br ^bb24
  ^bb24:  // pred: ^bb23
    %120 = llvm.select %119, %111, %110 : i1, i64
    llvm.cond_br %119, ^bb25, ^bb26
  ^bb25:  // pred: ^bb24
    llvm.br ^bb44(%23, %29, %102 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb26:  // pred: ^bb24
    %121 = llvm.add %110, %35  : i64
    %122 = llvm.extractvalue %101[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%103] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %121, %123 : i64, !llvm.ptr
    %124 = llvm.extractvalue %102[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %125 = llvm.extractvalue %23[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.add %124, %35  : i64
    %127 = llvm.icmp "ugt" %126, %125 : i64
    llvm.cond_br %127, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %128 = llvm.mul %125, %34  : i64
    %129 = llvm.extractvalue %23[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %130 = llvm.icmp "ugt" %128, %129 : i64
    llvm.cond_br %130, ^bb28, ^bb29(%23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb28:  // pred: ^bb27
    %131 = llvm.mlir.null : !llvm.ptr
    %132 = llvm.getelementptr %131[1] : (!llvm.ptr) -> !llvm.ptr, i64
    %133 = llvm.ptrtoint %132 : !llvm.ptr to i64
    %134 = llvm.mul %128, %133  : i64
    %135 = llvm.mul %129, %133  : i64
    %136 = llvm.call @malloc(%134) : (i64) -> !llvm.ptr
    %137 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%136, %137, %135) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %138 = llvm.extractvalue %23[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%138) : (!llvm.ptr) -> ()
    %139 = llvm.insertvalue %136, %23[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %140 = llvm.insertvalue %136, %139[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb29(%140 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb29(%141: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb27, ^bb28
    %142 = llvm.insertvalue %128, %141[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb31(%142 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb30:  // pred: ^bb26
    llvm.br ^bb31(%23 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb31(%143: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb29, ^bb30
    llvm.br ^bb32
  ^bb32:  // pred: ^bb31
    %144 = llvm.extractvalue %143[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%124] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %arg27, %145 : i64, !llvm.ptr
    %146 = llvm.insertvalue %126, %102[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %147 = llvm.extractvalue %102[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %148 = llvm.extractvalue %29[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.add %147, %32  : i64
    %150 = llvm.icmp "ugt" %149, %148 : i64
    llvm.cond_br %150, ^bb33, ^bb38
  ^bb33:  // pred: ^bb32
    llvm.br ^bb34(%148 : i64)
  ^bb34(%151: i64):  // 2 preds: ^bb33, ^bb34
    %152 = llvm.mul %151, %34  : i64
    %153 = llvm.icmp "ugt" %149, %152 : i64
    llvm.cond_br %153, ^bb34(%152 : i64), ^bb35
  ^bb35:  // pred: ^bb34
    %154 = llvm.extractvalue %29[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %155 = llvm.icmp "ugt" %152, %154 : i64
    llvm.cond_br %155, ^bb36, ^bb37(%29 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb36:  // pred: ^bb35
    %156 = llvm.mlir.null : !llvm.ptr
    %157 = llvm.getelementptr %156[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %158 = llvm.ptrtoint %157 : !llvm.ptr to i64
    %159 = llvm.mul %152, %158  : i64
    %160 = llvm.mul %154, %158  : i64
    %161 = llvm.call @malloc(%159) : (i64) -> !llvm.ptr
    %162 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    "llvm.intr.memcpy"(%161, %162, %160) <{isVolatile = false}> : (!llvm.ptr, !llvm.ptr, i64) -> ()
    %163 = llvm.extractvalue %29[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.call @free(%163) : (!llvm.ptr) -> ()
    %164 = llvm.insertvalue %161, %29[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.insertvalue %161, %164[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb37(%165 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb37(%166: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb35, ^bb36
    %167 = llvm.insertvalue %152, %166[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb39(%167 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb38:  // pred: ^bb32
    llvm.br ^bb39(%29 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>)
  ^bb39(%168: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>):  // 2 preds: ^bb37, ^bb38
    llvm.br ^bb40
  ^bb40:  // pred: ^bb39
    %169 = llvm.extractvalue %168[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb41(%30 : i64)
  ^bb41(%170: i64):  // 2 preds: ^bb40, ^bb42
    %171 = llvm.icmp "slt" %170, %32 : i64
    llvm.cond_br %171, ^bb42, ^bb43
  ^bb42:  // pred: ^bb41
    %172 = llvm.getelementptr %169[%147] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %173 = llvm.getelementptr %172[%170] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %33, %173 : f32, !llvm.ptr
    %174 = llvm.add %170, %35  : i64
    llvm.br ^bb41(%174 : i64)
  ^bb43:  // pred: ^bb41
    %175 = llvm.insertvalue %149, %146[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    llvm.br ^bb44(%143, %168, %175 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb44(%176: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %177: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %178: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb25, ^bb43
    llvm.br ^bb45
  ^bb45:  // pred: ^bb44
    %179 = llvm.mul %120, %32  : i64
    %180 = llvm.add %179, %arg28  : i64
    %181 = llvm.extractvalue %177[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = llvm.getelementptr %181[%180] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %arg29, %182 : f32, !llvm.ptr
    %183 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
    %184 = llvm.insertvalue %5, %183[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %185 = llvm.insertvalue %100, %184[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %186 = llvm.insertvalue %101, %185[2] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %187 = llvm.insertvalue %176, %186[3] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %188 = llvm.insertvalue %177, %187[4] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %189 = llvm.insertvalue %178, %188[5] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    llvm.return %189 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
  }
  llvm.func @_sparse_binary_search_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) -> i64 attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(1 : index) : i64
    llvm.br ^bb1(%arg0, %arg1 : i64, i64)
  ^bb1(%7: i64, %8: i64):  // 2 preds: ^bb0, ^bb2
    %9 = llvm.icmp "ult" %7, %8 : i64
    llvm.cond_br %9, ^bb2(%7, %8 : i64, i64), ^bb3
  ^bb2(%10: i64, %11: i64):  // pred: ^bb1
    %12 = llvm.add %10, %11  : i64
    %13 = llvm.lshr %12, %6  : i64
    %14 = llvm.add %13, %6  : i64
    %15 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.getelementptr %15[%arg1] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %17 = llvm.load %16 : !llvm.ptr -> i64
    %18 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.getelementptr %18[%13] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %20 = llvm.load %19 : !llvm.ptr -> i64
    %21 = llvm.icmp "ult" %17, %20 : i64
    %22 = llvm.select %21, %10, %14 : i1, i64
    %23 = llvm.select %21, %13, %11 : i1, i64
    llvm.br ^bb1(%22, %23 : i64, i64)
  ^bb3:  // pred: ^bb1
    llvm.return %7 : i64
  }
  llvm.func @_sparse_sort_stable_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(0 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.add %arg0, %7  : i64
    llvm.br ^bb1(%8 : i64)
  ^bb1(%9: i64):  // 2 preds: ^bb0, ^bb5
    %10 = llvm.icmp "slt" %9, %arg1 : i64
    llvm.cond_br %10, ^bb2, ^bb6
  ^bb2:  // pred: ^bb1
    %11 = llvm.call @_sparse_binary_search_1_index(%arg0, %9, %arg2, %arg3, %arg4, %arg5, %arg6) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> i64
    %12 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = llvm.getelementptr %12[%9] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %14 = llvm.load %13 : !llvm.ptr -> i64
    %15 = llvm.sub %9, %11  : i64
    llvm.br ^bb3(%6 : i64)
  ^bb3(%16: i64):  // 2 preds: ^bb2, ^bb4
    %17 = llvm.icmp "slt" %16, %15 : i64
    llvm.cond_br %17, ^bb4, ^bb5
  ^bb4:  // pred: ^bb3
    %18 = llvm.sub %9, %16  : i64
    %19 = llvm.sub %18, %7  : i64
    %20 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.getelementptr %20[%19] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %22 = llvm.load %21 : !llvm.ptr -> i64
    %23 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.getelementptr %23[%18] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %22, %24 : i64, !llvm.ptr
    %25 = llvm.add %16, %7  : i64
    llvm.br ^bb3(%25 : i64)
  ^bb5:  // pred: ^bb3
    %26 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.getelementptr %26[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %14, %27 : i64, !llvm.ptr
    %28 = llvm.add %9, %7  : i64
    llvm.br ^bb1(%28 : i64)
  ^bb6:  // pred: ^bb1
    llvm.return
  }
  llvm.func @_sparse_shift_down_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(1 : index) : i64
    %7 = llvm.mlir.constant(2 : index) : i64
    %8 = llvm.icmp "uge" %arg7, %7 : i64
    llvm.cond_br %8, ^bb1, ^bb16
  ^bb1:  // pred: ^bb0
    %9 = llvm.sub %arg1, %arg0  : i64
    %10 = llvm.sub %arg7, %7  : i64
    %11 = llvm.lshr %10, %6  : i64
    %12 = llvm.icmp "uge" %11, %9 : i64
    llvm.cond_br %12, ^bb2, ^bb15
  ^bb2:  // pred: ^bb1
    %13 = llvm.shl %9, %6  : i64
    %14 = llvm.add %13, %6  : i64
    %15 = llvm.add %14, %arg0  : i64
    %16 = llvm.add %13, %7  : i64
    %17 = llvm.icmp "ult" %16, %arg7 : i64
    llvm.cond_br %17, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %18 = llvm.add %16, %arg0  : i64
    %19 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.getelementptr %19[%15] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %21 = llvm.load %20 : !llvm.ptr -> i64
    %22 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.getelementptr %22[%18] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %24 = llvm.load %23 : !llvm.ptr -> i64
    %25 = llvm.icmp "ult" %21, %24 : i64
    %26 = llvm.select %25, %16, %14 : i1, i64
    %27 = llvm.select %25, %18, %15 : i1, i64
    llvm.br ^bb5(%26, %27, %arg1 : i64, i64, i64)
  ^bb4:  // pred: ^bb2
    llvm.br ^bb5(%14, %15, %arg1 : i64, i64, i64)
  ^bb5(%28: i64, %29: i64, %30: i64):  // 3 preds: ^bb3, ^bb4, ^bb13
    llvm.br ^bb6(%30, %28, %29 : i64, i64, i64)
  ^bb6(%31: i64, %32: i64, %33: i64):  // pred: ^bb5
    llvm.br ^bb7(%31, %32, %33 : i64, i64, i64)
  ^bb7(%34: i64, %35: i64, %36: i64):  // pred: ^bb6
    %37 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%34] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%36] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = llvm.icmp "ult" %39, %42 : i64
    llvm.cond_br %43, ^bb8(%34, %35, %36 : i64, i64, i64), ^bb14
  ^bb8(%44: i64, %45: i64, %46: i64):  // pred: ^bb7
    %47 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%44] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%44] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %52, %54 : i64, !llvm.ptr
    %55 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.getelementptr %55[%46] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %49, %56 : i64, !llvm.ptr
    %57 = llvm.icmp "uge" %11, %45 : i64
    llvm.cond_br %57, ^bb9, ^bb13(%45, %46 : i64, i64)
  ^bb9:  // pred: ^bb8
    %58 = llvm.shl %45, %6  : i64
    %59 = llvm.add %58, %6  : i64
    %60 = llvm.add %59, %arg0  : i64
    %61 = llvm.add %58, %7  : i64
    %62 = llvm.icmp "ult" %61, %arg7 : i64
    llvm.cond_br %62, ^bb10, ^bb11
  ^bb10:  // pred: ^bb9
    %63 = llvm.add %61, %arg0  : i64
    %64 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.getelementptr %64[%60] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %66 = llvm.load %65 : !llvm.ptr -> i64
    %67 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.getelementptr %67[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %69 = llvm.load %68 : !llvm.ptr -> i64
    %70 = llvm.icmp "ult" %66, %69 : i64
    %71 = llvm.select %70, %61, %59 : i1, i64
    %72 = llvm.select %70, %63, %60 : i1, i64
    llvm.br ^bb12(%71, %72 : i64, i64)
  ^bb11:  // pred: ^bb9
    llvm.br ^bb12(%59, %60 : i64, i64)
  ^bb12(%73: i64, %74: i64):  // 2 preds: ^bb10, ^bb11
    llvm.br ^bb13(%73, %74 : i64, i64)
  ^bb13(%75: i64, %76: i64):  // 2 preds: ^bb8, ^bb12
    llvm.br ^bb5(%75, %76, %46 : i64, i64, i64)
  ^bb14:  // pred: ^bb7
    llvm.br ^bb15
  ^bb15:  // 2 preds: ^bb1, ^bb14
    llvm.br ^bb16
  ^bb16:  // 2 preds: ^bb0, ^bb15
    llvm.return
  }
  llvm.func @_sparse_heap_sort_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(2 : index) : i64
    %7 = llvm.mlir.constant(1 : index) : i64
    %8 = llvm.mlir.constant(0 : index) : i64
    %9 = llvm.sub %arg1, %arg0  : i64
    %10 = llvm.sub %9, %6  : i64
    %11 = llvm.lshr %10, %7  : i64
    %12 = llvm.add %11, %7  : i64
    llvm.br ^bb1(%8 : i64)
  ^bb1(%13: i64):  // 2 preds: ^bb0, ^bb2
    %14 = llvm.icmp "slt" %13, %12 : i64
    llvm.cond_br %14, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %15 = llvm.sub %11, %13  : i64
    %16 = llvm.add %arg0, %15  : i64
    llvm.call @_sparse_shift_down_1_index(%arg0, %16, %arg2, %arg3, %arg4, %arg5, %arg6, %9) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    %17 = llvm.add %13, %7  : i64
    llvm.br ^bb1(%17 : i64)
  ^bb3:  // pred: ^bb1
    %18 = llvm.sub %9, %7  : i64
    llvm.br ^bb4(%8 : i64)
  ^bb4(%19: i64):  // 2 preds: ^bb3, ^bb5
    %20 = llvm.icmp "slt" %19, %18 : i64
    llvm.cond_br %20, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %21 = llvm.sub %9, %19  : i64
    %22 = llvm.add %arg0, %21  : i64
    %23 = llvm.sub %22, %7  : i64
    %24 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %26 = llvm.load %25 : !llvm.ptr -> i64
    %27 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.getelementptr %27[%23] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %29 = llvm.load %28 : !llvm.ptr -> i64
    %30 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.getelementptr %30[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %29, %31 : i64, !llvm.ptr
    %32 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.getelementptr %32[%23] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %26, %33 : i64, !llvm.ptr
    %34 = llvm.sub %21, %7  : i64
    llvm.call @_sparse_shift_down_1_index(%arg0, %arg0, %arg2, %arg3, %arg4, %arg5, %arg6, %34) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    %35 = llvm.add %19, %7  : i64
    llvm.br ^bb4(%35 : i64)
  ^bb6:  // pred: ^bb4
    llvm.return
  }
  llvm.func @_sparse_partition_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64) -> i64 attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(-1 : index) : i64
    %7 = llvm.mlir.constant(1000 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = llvm.add %arg0, %arg1  : i64
    %10 = llvm.lshr %9, %8  : i64
    %11 = llvm.sub %arg1, %8  : i64
    %12 = llvm.sub %arg1, %arg0  : i64
    %13 = llvm.icmp "ult" %12, %7 : i64
    llvm.cond_br %13, ^bb1, ^bb8
  ^bb1:  // pred: ^bb0
    %14 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.getelementptr %14[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %16 = llvm.load %15 : !llvm.ptr -> i64
    %17 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.getelementptr %17[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %19 = llvm.load %18 : !llvm.ptr -> i64
    %20 = llvm.icmp "ult" %16, %19 : i64
    llvm.cond_br %20, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %21 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.getelementptr %21[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %23 = llvm.load %22 : !llvm.ptr -> i64
    %24 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.getelementptr %24[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %26 = llvm.load %25 : !llvm.ptr -> i64
    %27 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.getelementptr %27[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %26, %28 : i64, !llvm.ptr
    %29 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.getelementptr %29[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %23, %30 : i64, !llvm.ptr
    llvm.br ^bb3
  ^bb3:  // 2 preds: ^bb1, ^bb2
    %31 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.getelementptr %31[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %33 = llvm.load %32 : !llvm.ptr -> i64
    %34 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.getelementptr %34[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %36 = llvm.load %35 : !llvm.ptr -> i64
    %37 = llvm.icmp "ult" %33, %36 : i64
    llvm.cond_br %37, ^bb4, ^bb7
  ^bb4:  // pred: ^bb3
    %38 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.getelementptr %38[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %40 = llvm.load %39 : !llvm.ptr -> i64
    %41 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %43 = llvm.load %42 : !llvm.ptr -> i64
    %44 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.getelementptr %44[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %43, %45 : i64, !llvm.ptr
    %46 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.getelementptr %46[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %40, %47 : i64, !llvm.ptr
    %48 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %49 = llvm.getelementptr %48[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %50 = llvm.load %49 : !llvm.ptr -> i64
    %51 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = llvm.icmp "ult" %50, %53 : i64
    llvm.cond_br %54, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %55 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.getelementptr %55[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %57 = llvm.load %56 : !llvm.ptr -> i64
    %58 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.getelementptr %58[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %60 = llvm.load %59 : !llvm.ptr -> i64
    %61 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = llvm.getelementptr %61[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %60, %62 : i64, !llvm.ptr
    %63 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %64 = llvm.getelementptr %63[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %57, %64 : i64, !llvm.ptr
    llvm.br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb5, ^bb21, ^bb26
    llvm.br ^bb7
  ^bb7:  // 3 preds: ^bb3, ^bb6, ^bb20
    llvm.br ^bb27(%arg0, %11, %10 : i64, i64, i64)
  ^bb8:  // pred: ^bb0
    %65 = llvm.add %arg0, %arg1  : i64
    %66 = llvm.lshr %65, %8  : i64
    %67 = llvm.add %10, %arg1  : i64
    %68 = llvm.lshr %67, %8  : i64
    %69 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = llvm.icmp "ult" %71, %74 : i64
    llvm.cond_br %75, ^bb9, ^bb10
  ^bb9:  // pred: ^bb8
    %76 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %77 = llvm.getelementptr %76[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %78 = llvm.load %77 : !llvm.ptr -> i64
    %79 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = llvm.getelementptr %79[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %81 = llvm.load %80 : !llvm.ptr -> i64
    %82 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %83 = llvm.getelementptr %82[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %81, %83 : i64, !llvm.ptr
    %84 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %78, %85 : i64, !llvm.ptr
    llvm.br ^bb10
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %86 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = llvm.getelementptr %86[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %88 = llvm.load %87 : !llvm.ptr -> i64
    %89 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %91 = llvm.load %90 : !llvm.ptr -> i64
    %92 = llvm.icmp "ult" %88, %91 : i64
    llvm.cond_br %92, ^bb11, ^bb14
  ^bb11:  // pred: ^bb10
    %93 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %94 = llvm.getelementptr %93[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %95 = llvm.load %94 : !llvm.ptr -> i64
    %96 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %97 = llvm.getelementptr %96[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %98 = llvm.load %97 : !llvm.ptr -> i64
    %99 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.getelementptr %99[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %98, %100 : i64, !llvm.ptr
    %101 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.getelementptr %101[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %95, %102 : i64, !llvm.ptr
    %103 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %104 = llvm.getelementptr %103[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %105 = llvm.load %104 : !llvm.ptr -> i64
    %106 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %107 = llvm.getelementptr %106[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %108 = llvm.load %107 : !llvm.ptr -> i64
    %109 = llvm.icmp "ult" %105, %108 : i64
    llvm.cond_br %109, ^bb12, ^bb13
  ^bb12:  // pred: ^bb11
    %110 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.getelementptr %113[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %115 = llvm.load %114 : !llvm.ptr -> i64
    %116 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %115, %117 : i64, !llvm.ptr
    %118 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %119 = llvm.getelementptr %118[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %112, %119 : i64, !llvm.ptr
    llvm.br ^bb13
  ^bb13:  // 2 preds: ^bb11, ^bb12
    llvm.br ^bb14
  ^bb14:  // 2 preds: ^bb10, ^bb13
    %120 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.getelementptr %120[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %122 = llvm.load %121 : !llvm.ptr -> i64
    %123 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.getelementptr %123[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %125 = llvm.load %124 : !llvm.ptr -> i64
    %126 = llvm.icmp "ult" %122, %125 : i64
    llvm.cond_br %126, ^bb15, ^bb20
  ^bb15:  // pred: ^bb14
    %127 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %129 = llvm.load %128 : !llvm.ptr -> i64
    %130 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %131 = llvm.getelementptr %130[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %132 = llvm.load %131 : !llvm.ptr -> i64
    %133 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %134 = llvm.getelementptr %133[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %132, %134 : i64, !llvm.ptr
    %135 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %136 = llvm.getelementptr %135[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %129, %136 : i64, !llvm.ptr
    %137 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %138 = llvm.getelementptr %137[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %139 = llvm.load %138 : !llvm.ptr -> i64
    %140 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %141 = llvm.getelementptr %140[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %142 = llvm.load %141 : !llvm.ptr -> i64
    %143 = llvm.icmp "ult" %139, %142 : i64
    llvm.cond_br %143, ^bb16, ^bb19
  ^bb16:  // pred: ^bb15
    %144 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %146 = llvm.load %145 : !llvm.ptr -> i64
    %147 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %148 = llvm.getelementptr %147[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %149 = llvm.load %148 : !llvm.ptr -> i64
    %150 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %151 = llvm.getelementptr %150[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %149, %151 : i64, !llvm.ptr
    %152 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.getelementptr %152[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %146, %153 : i64, !llvm.ptr
    %154 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %155 = llvm.getelementptr %154[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %156 = llvm.load %155 : !llvm.ptr -> i64
    %157 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = llvm.icmp "ult" %156, %159 : i64
    llvm.cond_br %160, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %161 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %162 = llvm.getelementptr %161[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %163 = llvm.load %162 : !llvm.ptr -> i64
    %164 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %166, %168 : i64, !llvm.ptr
    %169 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %170 = llvm.getelementptr %169[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %163, %170 : i64, !llvm.ptr
    llvm.br ^bb18
  ^bb18:  // 2 preds: ^bb16, ^bb17
    llvm.br ^bb19
  ^bb19:  // 2 preds: ^bb15, ^bb18
    llvm.br ^bb20
  ^bb20:  // 2 preds: ^bb14, ^bb19
    %171 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %172 = llvm.getelementptr %171[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %173 = llvm.load %172 : !llvm.ptr -> i64
    %174 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %175 = llvm.getelementptr %174[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %176 = llvm.load %175 : !llvm.ptr -> i64
    %177 = llvm.icmp "ult" %173, %176 : i64
    llvm.cond_br %177, ^bb21, ^bb7
  ^bb21:  // pred: ^bb20
    %178 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = llvm.getelementptr %181[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %183 = llvm.load %182 : !llvm.ptr -> i64
    %184 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %185 = llvm.getelementptr %184[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %183, %185 : i64, !llvm.ptr
    %186 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %187 = llvm.getelementptr %186[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %180, %187 : i64, !llvm.ptr
    %188 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %189 = llvm.getelementptr %188[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %190 = llvm.load %189 : !llvm.ptr -> i64
    %191 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %192 = llvm.getelementptr %191[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %193 = llvm.load %192 : !llvm.ptr -> i64
    %194 = llvm.icmp "ult" %190, %193 : i64
    llvm.cond_br %194, ^bb22, ^bb6
  ^bb22:  // pred: ^bb21
    %195 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %196 = llvm.getelementptr %195[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %197 = llvm.load %196 : !llvm.ptr -> i64
    %198 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %199 = llvm.getelementptr %198[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %200 = llvm.load %199 : !llvm.ptr -> i64
    %201 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %202 = llvm.getelementptr %201[%68] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %200, %202 : i64, !llvm.ptr
    %203 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %197, %204 : i64, !llvm.ptr
    %205 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %207 = llvm.load %206 : !llvm.ptr -> i64
    %208 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %209 = llvm.getelementptr %208[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %210 = llvm.load %209 : !llvm.ptr -> i64
    %211 = llvm.icmp "ult" %207, %210 : i64
    llvm.cond_br %211, ^bb23, ^bb26
  ^bb23:  // pred: ^bb22
    %212 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %213 = llvm.getelementptr %212[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %214 = llvm.load %213 : !llvm.ptr -> i64
    %215 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %216 = llvm.getelementptr %215[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %217 = llvm.load %216 : !llvm.ptr -> i64
    %218 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %219 = llvm.getelementptr %218[%10] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %217, %219 : i64, !llvm.ptr
    %220 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %221 = llvm.getelementptr %220[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %214, %221 : i64, !llvm.ptr
    %222 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %224 = llvm.load %223 : !llvm.ptr -> i64
    %225 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %226 = llvm.getelementptr %225[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %227 = llvm.load %226 : !llvm.ptr -> i64
    %228 = llvm.icmp "ult" %224, %227 : i64
    llvm.cond_br %228, ^bb24, ^bb25
  ^bb24:  // pred: ^bb23
    %229 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %230 = llvm.getelementptr %229[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %231 = llvm.load %230 : !llvm.ptr -> i64
    %232 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %233 = llvm.getelementptr %232[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %234 = llvm.load %233 : !llvm.ptr -> i64
    %235 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %236 = llvm.getelementptr %235[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %234, %236 : i64, !llvm.ptr
    %237 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %238 = llvm.getelementptr %237[%arg0] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %231, %238 : i64, !llvm.ptr
    llvm.br ^bb25
  ^bb25:  // 2 preds: ^bb23, ^bb24
    llvm.br ^bb26
  ^bb26:  // 2 preds: ^bb22, ^bb25
    llvm.br ^bb6
  ^bb27(%239: i64, %240: i64, %241: i64):  // 2 preds: ^bb7, ^bb45
    llvm.br ^bb28(%239, %240, %241 : i64, i64, i64)
  ^bb28(%242: i64, %243: i64, %244: i64):  // pred: ^bb27
    %245 = llvm.icmp "ult" %242, %243 : i64
    llvm.cond_br %245, ^bb29(%242, %243, %244 : i64, i64, i64), ^bb46
  ^bb29(%246: i64, %247: i64, %248: i64):  // pred: ^bb28
    llvm.br ^bb30(%246 : i64)
  ^bb30(%249: i64):  // 2 preds: ^bb29, ^bb31
    %250 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %251 = llvm.getelementptr %250[%249] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %252 = llvm.load %251 : !llvm.ptr -> i64
    %253 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %254 = llvm.getelementptr %253[%248] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %255 = llvm.load %254 : !llvm.ptr -> i64
    %256 = llvm.icmp "ult" %252, %255 : i64
    llvm.cond_br %256, ^bb31(%249 : i64), ^bb32
  ^bb31(%257: i64):  // pred: ^bb30
    %258 = llvm.add %257, %8  : i64
    llvm.br ^bb30(%258 : i64)
  ^bb32:  // pred: ^bb30
    %259 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.getelementptr %259[%249] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %261 = llvm.load %260 : !llvm.ptr -> i64
    %262 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = llvm.getelementptr %262[%248] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %264 = llvm.load %263 : !llvm.ptr -> i64
    %265 = llvm.icmp "eq" %261, %264 : i64
    llvm.br ^bb33(%247 : i64)
  ^bb33(%266: i64):  // 2 preds: ^bb32, ^bb34
    %267 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %268 = llvm.getelementptr %267[%248] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %269 = llvm.load %268 : !llvm.ptr -> i64
    %270 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %271 = llvm.getelementptr %270[%266] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %272 = llvm.load %271 : !llvm.ptr -> i64
    %273 = llvm.icmp "ult" %269, %272 : i64
    llvm.cond_br %273, ^bb34(%266 : i64), ^bb35
  ^bb34(%274: i64):  // pred: ^bb33
    %275 = llvm.add %274, %6  : i64
    llvm.br ^bb33(%275 : i64)
  ^bb35:  // pred: ^bb33
    %276 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %277 = llvm.getelementptr %276[%266] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %278 = llvm.load %277 : !llvm.ptr -> i64
    %279 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %280 = llvm.getelementptr %279[%248] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %281 = llvm.load %280 : !llvm.ptr -> i64
    %282 = llvm.icmp "eq" %278, %281 : i64
    %283 = llvm.icmp "ult" %249, %266 : i64
    llvm.cond_br %283, ^bb36, ^bb44(%249, %266, %248 : i64, i64, i64)
  ^bb36:  // pred: ^bb35
    %284 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %285 = llvm.getelementptr %284[%249] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %286 = llvm.load %285 : !llvm.ptr -> i64
    %287 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %288 = llvm.getelementptr %287[%266] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %289 = llvm.load %288 : !llvm.ptr -> i64
    %290 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %291 = llvm.getelementptr %290[%249] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %289, %291 : i64, !llvm.ptr
    %292 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %293 = llvm.getelementptr %292[%266] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %286, %293 : i64, !llvm.ptr
    %294 = llvm.icmp "eq" %249, %248 : i64
    llvm.cond_br %294, ^bb37, ^bb38
  ^bb37:  // pred: ^bb36
    llvm.br ^bb39(%266 : i64)
  ^bb38:  // pred: ^bb36
    %295 = llvm.icmp "eq" %266, %248 : i64
    %296 = llvm.select %295, %249, %248 : i1, i64
    llvm.br ^bb39(%296 : i64)
  ^bb39(%297: i64):  // 2 preds: ^bb37, ^bb38
    llvm.br ^bb40
  ^bb40:  // pred: ^bb39
    %298 = llvm.and %265, %282  : i1
    llvm.cond_br %298, ^bb41, ^bb42
  ^bb41:  // pred: ^bb40
    %299 = llvm.add %249, %8  : i64
    %300 = llvm.sub %266, %8  : i64
    llvm.br ^bb43(%299, %300 : i64, i64)
  ^bb42:  // pred: ^bb40
    llvm.br ^bb43(%249, %266 : i64, i64)
  ^bb43(%301: i64, %302: i64):  // 2 preds: ^bb41, ^bb42
    llvm.br ^bb44(%301, %302, %297 : i64, i64, i64)
  ^bb44(%303: i64, %304: i64, %305: i64):  // 2 preds: ^bb35, ^bb43
    llvm.br ^bb45(%303, %304, %305 : i64, i64, i64)
  ^bb45(%306: i64, %307: i64, %308: i64):  // pred: ^bb44
    llvm.br ^bb27(%306, %307, %308 : i64, i64, i64)
  ^bb46:  // pred: ^bb28
    llvm.return %244 : i64
  }
  llvm.func @_sparse_hybrid_qsort_1_index(%arg0: i64, %arg1: i64, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: i64, %arg5: i64, %arg6: i64, %arg7: i64) attributes {sym_visibility = "private"} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg2, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg3, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg4, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg5, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg6, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.constant(30 : index) : i64
    %7 = llvm.mlir.constant(1 : i64) : i64
    %8 = llvm.mlir.constant(0 : i64) : i64
    %9 = llvm.mlir.constant(1 : index) : i64
    %10 = llvm.mlir.constant(0 : index) : i64
    llvm.br ^bb1(%arg0, %arg1 : i64, i64)
  ^bb1(%11: i64, %12: i64):  // 2 preds: ^bb0, ^bb14
    %13 = llvm.add %11, %9  : i64
    %14 = llvm.icmp "ult" %13, %12 : i64
    llvm.cond_br %14, ^bb2(%11, %12 : i64, i64), ^bb15
  ^bb2(%15: i64, %16: i64):  // pred: ^bb1
    %17 = llvm.sub %16, %15  : i64
    %18 = llvm.icmp "ule" %17, %6 : i64
    llvm.cond_br %18, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    llvm.call @_sparse_sort_stable_1_index(%15, %16, %arg2, %arg3, %arg4, %arg5, %arg6) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> ()
    llvm.br ^bb13(%15, %15 : i64, i64)
  ^bb4:  // pred: ^bb2
    %19 = llvm.sub %arg7, %7  : i64
    %20 = llvm.icmp "ule" %19, %8 : i64
    llvm.cond_br %20, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    llvm.call @_sparse_heap_sort_1_index(%15, %16, %arg2, %arg3, %arg4, %arg5, %arg6) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> ()
    llvm.br ^bb11(%15, %15 : i64, i64)
  ^bb6:  // pred: ^bb4
    %21 = llvm.call @_sparse_partition_1_index(%15, %16, %arg2, %arg3, %arg4, %arg5, %arg6) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64) -> i64
    %22 = llvm.add %21, %9  : i64
    %23 = llvm.sub %21, %15  : i64
    %24 = llvm.sub %16, %21  : i64
    %25 = llvm.icmp "ule" %23, %24 : i64
    %26 = llvm.select %25, %22, %15 : i1, i64
    %27 = llvm.select %25, %16, %21 : i1, i64
    llvm.cond_br %25, ^bb7(%23, %15, %21 : i64, i64, i64), ^bb7(%24, %22, %16 : i64, i64, i64)
  ^bb7(%28: i64, %29: i64, %30: i64):  // 2 preds: ^bb6, ^bb6
    %31 = llvm.icmp "ne" %28, %10 : i64
    llvm.cond_br %31, ^bb8(%29, %30 : i64, i64), ^bb9
  ^bb8(%32: i64, %33: i64):  // pred: ^bb7
    llvm.call @_sparse_hybrid_qsort_1_index(%32, %33, %arg2, %arg3, %arg4, %arg5, %arg6, %19) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    llvm.br ^bb9
  ^bb9:  // 2 preds: ^bb7, ^bb8
    llvm.br ^bb10
  ^bb10:  // pred: ^bb9
    llvm.br ^bb11(%26, %27 : i64, i64)
  ^bb11(%34: i64, %35: i64):  // 2 preds: ^bb5, ^bb10
    llvm.br ^bb12
  ^bb12:  // pred: ^bb11
    llvm.br ^bb13(%34, %35 : i64, i64)
  ^bb13(%36: i64, %37: i64):  // 2 preds: ^bb3, ^bb12
    llvm.br ^bb14
  ^bb14:  // pred: ^bb13
    llvm.br ^bb1(%36, %37 : i64, i64)
  ^bb15:  // pred: ^bb1
    llvm.return
  }
  llvm.func @MTTKRP.A.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.ptr, %arg26: !llvm.ptr, %arg27: i64, %arg28: i64, %arg29: i64, %arg30: !llvm.ptr, %arg31: !llvm.ptr, %arg32: i64, %arg33: i64, %arg34: i64, %arg35: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg36: !llvm.ptr, %arg37: !llvm.ptr, %arg38: i64, %arg39: i64, %arg40: i64, %arg41: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg42: !llvm.ptr, %arg43: !llvm.ptr, %arg44: i64, %arg45: i64, %arg46: i64, %arg47: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.insertvalue %arg5, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.insertvalue %arg6, %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg7, %8[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg8, %9[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg9, %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %arg12, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg13, %15[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg14, %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.insertvalue %arg15, %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg16, %19[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg17, %20[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %arg18, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg19, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.insertvalue %arg20, %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg21, %25[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg22, %26[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg23, %27[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.insertvalue %arg24, %28[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.insertvalue %arg25, %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg26, %31[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg27, %32[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %arg28, %33[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %arg29, %34[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.insertvalue %arg30, %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg31, %37[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg32, %38[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg33, %39[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.insertvalue %arg34, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %arg36, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %arg37, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %arg38, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %arg39, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %arg40, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.insertvalue %arg42, %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.insertvalue %arg43, %49[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %arg44, %50[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.insertvalue %arg45, %51[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %arg46, %52[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.mlir.constant(4096 : index) : i64
    %55 = llvm.mlir.constant(32 : index) : i64
    %56 = llvm.mlir.constant(0 : index) : i64
    %57 = llvm.mlir.constant(1 : index) : i64
    %58 = llvm.mlir.constant(16 : index) : i64
    %59 = llvm.mlir.constant(true) : i1
    %60 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %61 = llvm.mlir.constant(64 : i64) : i64
    %62 = llvm.mlir.constant(0 : i64) : i64
    %63 = llvm.mlir.constant(1 : i64) : i64
    %64 = llvm.mlir.constant(2 : i64) : i64
    %65 = llvm.mlir.constant(128 : i64) : i64
    %66 = llvm.mlir.constant(32 : i64) : i64
    %67 = llvm.mlir.constant(false) : i1
    %68 = llvm.mlir.constant(4096 : i64) : i64
    %69 = llvm.mlir.constant(4096 : index) : i64
    %70 = llvm.mlir.constant(1 : index) : i64
    %71 = llvm.mlir.constant(32 : index) : i64
    %72 = llvm.mlir.constant(0 : index) : i64
    %73 = llvm.mlir.null : !llvm.ptr
    %74 = llvm.getelementptr %73[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %75 = llvm.ptrtoint %74 : !llvm.ptr to i64
    %76 = llvm.call @malloc(%75) : (i64) -> !llvm.ptr
    %77 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %78 = llvm.insertvalue %76, %77[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.insertvalue %76, %78[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = llvm.insertvalue %56, %79[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %81 = llvm.insertvalue %58, %80[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.insertvalue %57, %81[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %83 = llvm.mlir.null : !llvm.ptr
    %84 = llvm.getelementptr %83[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %85 = llvm.ptrtoint %84 : !llvm.ptr to i64
    %86 = llvm.call @malloc(%85) : (i64) -> !llvm.ptr
    %87 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %88 = llvm.insertvalue %86, %87[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = llvm.insertvalue %86, %88[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.insertvalue %56, %89[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.insertvalue %58, %90[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.insertvalue %57, %91[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %93 = llvm.mlir.null : !llvm.ptr
    %94 = llvm.getelementptr %93[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %95 = llvm.ptrtoint %94 : !llvm.ptr to i64
    %96 = llvm.call @malloc(%95) : (i64) -> !llvm.ptr
    %97 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %98 = llvm.insertvalue %96, %97[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %99 = llvm.insertvalue %96, %98[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %100 = llvm.insertvalue %56, %99[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %101 = llvm.insertvalue %58, %100[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %102 = llvm.insertvalue %57, %101[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %103 = llvm.mlir.null : !llvm.ptr
    %104 = llvm.getelementptr %103[16] : (!llvm.ptr) -> !llvm.ptr, i64
    %105 = llvm.ptrtoint %104 : !llvm.ptr to i64
    %106 = llvm.call @malloc(%105) : (i64) -> !llvm.ptr
    %107 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %108 = llvm.insertvalue %106, %107[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %109 = llvm.insertvalue %106, %108[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.insertvalue %56, %109[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.insertvalue %58, %110[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %112 = llvm.insertvalue %57, %111[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %113 = llvm.mlir.null : !llvm.ptr
    %114 = llvm.getelementptr %113[16] : (!llvm.ptr) -> !llvm.ptr, f32
    %115 = llvm.ptrtoint %114 : !llvm.ptr to i64
    %116 = llvm.call @malloc(%115) : (i64) -> !llvm.ptr
    %117 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %118 = llvm.insertvalue %116, %117[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %119 = llvm.insertvalue %116, %118[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %120 = llvm.insertvalue %56, %119[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.insertvalue %58, %120[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %122 = llvm.insertvalue %57, %121[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.mlir.undef : !llvm.struct<(array<3 x i64>, array<5 x i64>)>
    %124 = llvm.insertvalue %62, %123[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %125 = llvm.insertvalue %62, %124[1, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %126 = llvm.insertvalue %62, %125[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %127 = llvm.insertvalue %62, %126[1, 3] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %128 = llvm.insertvalue %62, %127[1, 4] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %129 = llvm.insertvalue %65, %128[0, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %130 = llvm.getelementptr %76[%72] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %72, %130 : i64, !llvm.ptr
    %131 = llvm.insertvalue %63, %129[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %132 = llvm.insertvalue %65, %131[0, 1] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %133 = llvm.getelementptr %96[%72] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %72, %133 : i64, !llvm.ptr
    %134 = llvm.insertvalue %63, %132[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %135 = llvm.insertvalue %66, %134[0, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %136 = llvm.getelementptr %76[%70] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %72, %136 : i64, !llvm.ptr
    %137 = llvm.insertvalue %64, %135[1, 0] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %138 = llvm.mlir.null : !llvm.ptr
    %139 = llvm.getelementptr %138[32] : (!llvm.ptr) -> !llvm.ptr, f32
    %140 = llvm.ptrtoint %139 : !llvm.ptr to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr
    %142 = llvm.mlir.null : !llvm.ptr
    %143 = llvm.getelementptr %142[32] : (!llvm.ptr) -> !llvm.ptr, i1
    %144 = llvm.ptrtoint %143 : !llvm.ptr to i64
    %145 = llvm.call @malloc(%144) : (i64) -> !llvm.ptr
    %146 = llvm.mlir.null : !llvm.ptr
    %147 = llvm.getelementptr %146[32] : (!llvm.ptr) -> !llvm.ptr, i64
    %148 = llvm.ptrtoint %147 : !llvm.ptr to i64
    %149 = llvm.call @malloc(%148) : (i64) -> !llvm.ptr
    %150 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %151 = llvm.insertvalue %149, %150[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %152 = llvm.insertvalue %149, %151[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %153 = llvm.insertvalue %56, %152[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %154 = llvm.insertvalue %55, %153[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %155 = llvm.insertvalue %57, %154[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    llvm.br ^bb1(%72 : i64)
  ^bb1(%156: i64):  // 2 preds: ^bb0, ^bb2
    %157 = llvm.icmp "slt" %156, %71 : i64
    llvm.cond_br %157, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %158 = llvm.getelementptr %141[%156] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %60, %158 : f32, !llvm.ptr
    %159 = llvm.add %156, %70  : i64
    llvm.br ^bb1(%159 : i64)
  ^bb3:  // pred: ^bb1
    llvm.br ^bb4(%72 : i64)
  ^bb4(%160: i64):  // 2 preds: ^bb3, ^bb5
    %161 = llvm.icmp "slt" %160, %71 : i64
    llvm.cond_br %161, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %162 = llvm.getelementptr %145[%160] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %67, %162 : i1, !llvm.ptr
    %163 = llvm.add %160, %70  : i64
    llvm.br ^bb4(%163 : i64)
  ^bb6:  // pred: ^bb4
    %164 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%72] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %168 = llvm.getelementptr %167[%70] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %169 = llvm.load %168 : !llvm.ptr -> i64
    llvm.br ^bb7(%166, %82, %92, %102, %112, %122, %137 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb7(%170: i64, %171: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %172: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %173: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %174: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %175: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %176: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb6, ^bb24
    %177 = llvm.icmp "slt" %170, %169 : i64
    llvm.cond_br %177, ^bb8, ^bb25
  ^bb8:  // pred: ^bb7
    %178 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %179 = llvm.getelementptr %178[%170] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %180 = llvm.load %179 : !llvm.ptr -> i64
    %181 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %182 = llvm.getelementptr %181[%170] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %183 = llvm.load %182 : !llvm.ptr -> i64
    %184 = llvm.add %170, %70  : i64
    %185 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %186 = llvm.getelementptr %185[%184] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %187 = llvm.load %186 : !llvm.ptr -> i64
    llvm.br ^bb9(%183, %171, %172, %173, %174, %175, %176 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb9(%188: i64, %189: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %190: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %191: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %192: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %193: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %194: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb8, ^bb23
    %195 = llvm.icmp "slt" %188, %187 : i64
    llvm.cond_br %195, ^bb10, ^bb24
  ^bb10:  // pred: ^bb9
    %196 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.getelementptr %196[%188] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %198 = llvm.load %197 : !llvm.ptr -> i64
    %199 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %200 = llvm.getelementptr %199[%188] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %201 = llvm.load %200 : !llvm.ptr -> i64
    %202 = llvm.add %188, %70  : i64
    %203 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %204 = llvm.getelementptr %203[%202] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %205 = llvm.load %204 : !llvm.ptr -> i64
    llvm.br ^bb11(%201, %72 : i64, i64)
  ^bb11(%206: i64, %207: i64):  // 2 preds: ^bb10, ^bb19
    %208 = llvm.icmp "slt" %206, %205 : i64
    llvm.cond_br %208, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %209 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %210 = llvm.getelementptr %209[%206] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %211 = llvm.load %210 : !llvm.ptr -> i64
    %212 = llvm.extractvalue %41[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %213 = llvm.getelementptr %212[%206] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %214 = llvm.load %213 : !llvm.ptr -> f32
    llvm.br ^bb13(%72, %207 : i64, i64)
  ^bb13(%215: i64, %216: i64):  // 2 preds: ^bb12, ^bb18
    %217 = llvm.icmp "slt" %215, %71 : i64
    llvm.cond_br %217, ^bb14, ^bb19
  ^bb14:  // pred: ^bb13
    %218 = llvm.mul %211, %71  : i64
    %219 = llvm.add %218, %215  : i64
    %220 = llvm.getelementptr %141[%215] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %221 = llvm.load %220 : !llvm.ptr -> f32
    %222 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %223 = llvm.getelementptr %222[%219] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %224 = llvm.load %223 : !llvm.ptr -> f32
    %225 = llvm.fmul %214, %224  : f32
    %226 = llvm.fadd %221, %225  : f32
    %227 = llvm.getelementptr %145[%215] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    %228 = llvm.load %227 : !llvm.ptr -> i1
    %229 = llvm.icmp "eq" %228, %67 : i1
    llvm.cond_br %229, ^bb15, ^bb16
  ^bb15:  // pred: ^bb14
    %230 = llvm.getelementptr %145[%215] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %59, %230 : i1, !llvm.ptr
    %231 = llvm.getelementptr %149[%216] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %215, %231 : i64, !llvm.ptr
    %232 = llvm.add %216, %70  : i64
    llvm.br ^bb17(%232 : i64)
  ^bb16:  // pred: ^bb14
    llvm.br ^bb17(%216 : i64)
  ^bb17(%233: i64):  // 2 preds: ^bb15, ^bb16
    llvm.br ^bb18
  ^bb18:  // pred: ^bb17
    %234 = llvm.getelementptr %141[%215] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %226, %234 : f32, !llvm.ptr
    %235 = llvm.add %215, %70  : i64
    llvm.br ^bb13(%235, %233 : i64, i64)
  ^bb19:  // pred: ^bb13
    %236 = llvm.add %206, %70  : i64
    llvm.br ^bb11(%236, %216 : i64, i64)
  ^bb20:  // pred: ^bb11
    %237 = "llvm.intr.ctlz"(%207) <{is_zero_poison = false}> : (i64) -> i64
    %238 = llvm.sub %61, %237  : i64
    llvm.call @_sparse_hybrid_qsort_1_index(%72, %207, %149, %149, %56, %55, %57, %238) : (i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, i64) -> ()
    llvm.br ^bb21(%72, %189, %190, %191, %192, %193, %194 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb21(%239: i64, %240: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %241: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %242: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %243: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %244: !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, %245: !llvm.struct<(array<3 x i64>, array<5 x i64>)>):  // 2 preds: ^bb20, ^bb22
    %246 = llvm.icmp "slt" %239, %207 : i64
    llvm.cond_br %246, ^bb22, ^bb23
  ^bb22:  // pred: ^bb21
    %247 = llvm.getelementptr %149[%239] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %248 = llvm.load %247 : !llvm.ptr -> i64
    %249 = llvm.getelementptr %141[%248] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %250 = llvm.load %249 : !llvm.ptr -> f32
    %251 = llvm.extractvalue %240[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %252 = llvm.extractvalue %240[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %253 = llvm.extractvalue %240[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %254 = llvm.extractvalue %240[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %255 = llvm.extractvalue %240[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %256 = llvm.extractvalue %241[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %257 = llvm.extractvalue %241[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %258 = llvm.extractvalue %241[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %259 = llvm.extractvalue %241[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %260 = llvm.extractvalue %241[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %261 = llvm.extractvalue %242[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %262 = llvm.extractvalue %242[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %263 = llvm.extractvalue %242[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %264 = llvm.extractvalue %242[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %265 = llvm.extractvalue %242[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %266 = llvm.extractvalue %243[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %267 = llvm.extractvalue %243[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %268 = llvm.extractvalue %243[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %269 = llvm.extractvalue %243[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %270 = llvm.extractvalue %243[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %271 = llvm.extractvalue %244[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %272 = llvm.extractvalue %244[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %273 = llvm.extractvalue %244[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %274 = llvm.extractvalue %244[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %275 = llvm.extractvalue %244[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %276 = llvm.call @_insert_compressed_compressed_dense_128_128_32_f32_0_0(%251, %252, %253, %254, %255, %256, %257, %258, %259, %260, %261, %262, %263, %264, %265, %266, %267, %268, %269, %270, %271, %272, %273, %274, %275, %245, %180, %198, %248, %250) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, i64, i64, i64, f32) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)>
    %277 = llvm.extractvalue %276[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %278 = llvm.extractvalue %276[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %279 = llvm.extractvalue %276[2] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %280 = llvm.extractvalue %276[3] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %281 = llvm.extractvalue %276[4] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %282 = llvm.extractvalue %276[5] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<3 x i64>, array<5 x i64>)>)> 
    %283 = llvm.getelementptr %141[%248] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %60, %283 : f32, !llvm.ptr
    %284 = llvm.getelementptr %145[%248] : (!llvm.ptr, i64) -> !llvm.ptr, i1
    llvm.store %67, %284 : i1, !llvm.ptr
    %285 = llvm.add %239, %70  : i64
    llvm.br ^bb21(%285, %277, %278, %279, %280, %281, %282 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb23:  // pred: ^bb21
    %286 = llvm.add %188, %70  : i64
    llvm.br ^bb9(%286, %240, %241, %242, %243, %244, %245 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb24:  // pred: ^bb9
    %287 = llvm.add %170, %70  : i64
    llvm.br ^bb7(%287, %189, %190, %191, %192, %193, %194 : i64, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, !llvm.struct<(array<3 x i64>, array<5 x i64>)>)
  ^bb25:  // pred: ^bb7
    llvm.call @free(%141) : (!llvm.ptr) -> ()
    llvm.call @free(%145) : (!llvm.ptr) -> ()
    llvm.call @free(%149) : (!llvm.ptr) -> ()
    %288 = llvm.extractvalue %176[1, 2] : !llvm.struct<(array<3 x i64>, array<5 x i64>)> 
    %289 = llvm.extractvalue %173[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %290 = llvm.getelementptr %289[%72] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %291 = llvm.load %290 : !llvm.ptr -> i64
    llvm.br ^bb26(%70, %291 : i64, i64)
  ^bb26(%292: i64, %293: i64):  // 2 preds: ^bb25, ^bb29
    %294 = llvm.icmp "slt" %292, %288 : i64
    llvm.cond_br %294, ^bb27, ^bb30
  ^bb27:  // pred: ^bb26
    %295 = llvm.extractvalue %173[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %296 = llvm.getelementptr %295[%292] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %297 = llvm.load %296 : !llvm.ptr -> i64
    %298 = llvm.icmp "eq" %297, %72 : i64
    %299 = llvm.select %298, %293, %297 : i1, i64
    llvm.cond_br %298, ^bb28, ^bb29
  ^bb28:  // pred: ^bb27
    %300 = llvm.extractvalue %173[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %301 = llvm.getelementptr %300[%292] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    llvm.store %293, %301 : i64, !llvm.ptr
    llvm.br ^bb29
  ^bb29:  // 2 preds: ^bb27, ^bb28
    %302 = llvm.add %292, %70  : i64
    llvm.br ^bb26(%302, %299 : i64, i64)
  ^bb30:  // pred: ^bb26
    %303 = llvm.mlir.null : !llvm.ptr
    %304 = llvm.getelementptr %303[4096] : (!llvm.ptr) -> !llvm.ptr, f32
    %305 = llvm.ptrtoint %304 : !llvm.ptr to i64
    %306 = llvm.call @malloc(%305) : (i64) -> !llvm.ptr
    %307 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %308 = llvm.insertvalue %306, %307[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %309 = llvm.insertvalue %306, %308[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %310 = llvm.insertvalue %56, %309[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %311 = llvm.insertvalue %54, %310[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %312 = llvm.insertvalue %57, %311[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %313 = llvm.mlir.undef : !llvm.struct<(array<2 x i64>, array<1 x i64>)>
    %314 = llvm.insertvalue %62, %313[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %315 = llvm.insertvalue %65, %314[0, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %316 = llvm.insertvalue %66, %315[0, 1] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    llvm.br ^bb31(%72 : i64)
  ^bb31(%317: i64):  // 2 preds: ^bb30, ^bb32
    %318 = llvm.icmp "slt" %317, %69 : i64
    llvm.cond_br %318, ^bb32, ^bb33
  ^bb32:  // pred: ^bb31
    %319 = llvm.getelementptr %306[%317] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    llvm.store %60, %319 : f32, !llvm.ptr
    %320 = llvm.add %317, %70  : i64
    llvm.br ^bb31(%320 : i64)
  ^bb33:  // pred: ^bb31
    %321 = llvm.insertvalue %68, %316[1, 0] : !llvm.struct<(array<2 x i64>, array<1 x i64>)> 
    %322 = llvm.extractvalue %171[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %323 = llvm.getelementptr %322[%72] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %324 = llvm.load %323 : !llvm.ptr -> i64
    %325 = llvm.extractvalue %171[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %326 = llvm.getelementptr %325[%70] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %327 = llvm.load %326 : !llvm.ptr -> i64
    omp.parallel   {
      omp.wsloop   for  (%arg48) : i64 = (%324) to (%327) step (%70) {
        %331 = llvm.extractvalue %172[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %332 = llvm.getelementptr %331[%arg48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %333 = llvm.load %332 : !llvm.ptr -> i64
        %334 = llvm.extractvalue %173[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %335 = llvm.getelementptr %334[%arg48] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %336 = llvm.load %335 : !llvm.ptr -> i64
        %337 = llvm.add %arg48, %70  : i64
        %338 = llvm.extractvalue %173[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
        %339 = llvm.getelementptr %338[%337] : (!llvm.ptr, i64) -> !llvm.ptr, i64
        %340 = llvm.load %339 : !llvm.ptr -> i64
        omp.parallel   {
          omp.wsloop   for  (%arg49) : i64 = (%336) to (%340) step (%70) {
            %341 = llvm.extractvalue %174[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
            %342 = llvm.getelementptr %341[%arg49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
            %343 = llvm.load %342 : !llvm.ptr -> i64
            omp.parallel   {
              omp.wsloop   for  (%arg50) : i64 = (%72) to (%71) step (%70) {
                %344 = llvm.mul %arg49, %71  : i64
                %345 = llvm.add %344, %arg50  : i64
                %346 = llvm.mul %343, %71  : i64
                %347 = llvm.add %346, %arg50  : i64
                %348 = llvm.mul %333, %71  : i64
                %349 = llvm.add %348, %arg50  : i64
                %350 = llvm.getelementptr %306[%349] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %351 = llvm.load %350 : !llvm.ptr -> f32
                %352 = llvm.extractvalue %175[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %353 = llvm.getelementptr %352[%345] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %354 = llvm.load %353 : !llvm.ptr -> f32
                %355 = llvm.extractvalue %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
                %356 = llvm.getelementptr %355[%347] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                %357 = llvm.load %356 : !llvm.ptr -> f32
                %358 = llvm.fmul %354, %357  : f32
                %359 = llvm.fadd %351, %358  : f32
                %360 = llvm.getelementptr %306[%349] : (!llvm.ptr, i64) -> !llvm.ptr, f32
                llvm.store %359, %360 : f32, !llvm.ptr
                omp.yield
              }
              omp.terminator
            }
            omp.yield
          }
          omp.terminator
        }
        omp.yield
      }
      omp.terminator
    }
    %328 = llvm.mlir.undef : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    %329 = llvm.insertvalue %312, %328[0] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    %330 = llvm.insertvalue %321, %329[1] : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)> 
    llvm.return %330 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
  }
  llvm.func @_mlir_ciface_MTTKRP.A.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.ptr, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: !llvm.ptr, %arg8: !llvm.struct<(array<3 x i64>, array<7 x i64>)>, %arg9: !llvm.ptr, %arg10: !llvm.struct<(array<2 x i64>, array<1 x i64>)>, %arg11: !llvm.ptr, %arg12: !llvm.struct<(array<2 x i64>, array<1 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg4 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg6 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.extractvalue %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.extractvalue %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.extractvalue %36[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.extractvalue %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.extractvalue %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.load %arg9 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.extractvalue %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.extractvalue %42[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.extractvalue %42[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.load %arg11 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.extractvalue %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %48[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %48[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.call @MTTKRP.A.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %31, %32, %33, %34, %35, %37, %38, %39, %40, %41, %arg8, %43, %44, %45, %46, %47, %arg10, %49, %50, %51, %52, %53, %arg12) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<7 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<1 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<2 x i64>, array<1 x i64>)>) -> !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>
    llvm.store %54, %arg0 : !llvm.struct<(struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>, struct<(array<2 x i64>, array<1 x i64>)>)>, !llvm.ptr
    llvm.return
  }
}


