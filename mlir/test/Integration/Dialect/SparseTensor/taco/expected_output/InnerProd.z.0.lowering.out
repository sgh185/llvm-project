// -----// IR Dump After LinalgGeneralization (linalg-generalize-named-ops) //----- //
func.func @InnerProd.z.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg1: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
  %cst = arith.constant 0.000000e+00 : f32
  %0 = tensor.empty() : tensor<f32>
  %1 = linalg.generic {indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
  ^bb0(%in: f32, %out: f32):
    linalg.yield %in : f32
  } -> tensor<f32>
  %2 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> ()>], iterator_types = ["reduction", "reduction", "reduction"]} ins(%arg0, %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) outs(%1 : tensor<f32>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %3 = arith.mulf %in, %in_0 : f32
    %4 = arith.addf %out, %3 : f32
    linalg.yield %4 : f32
  } -> tensor<f32>
  return %2 : tensor<f32>
}

// -----// IR Dump After PreSparsificationRewrite (pre-sparsification-rewrite) //----- //
#map = affine_map<() -> ()>
#map1 = affine_map<(d0, d1, d2) -> (d0, d1, d2)>
#map2 = affine_map<(d0, d1, d2) -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg1: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
    %cst = arith.constant 0.000000e+00 : f32
    %0 = tensor.empty() : tensor<f32>
    %1 = linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<f32>
    %2 = linalg.generic {indexing_maps = [#map1, #map1, #map2], iterator_types = ["reduction", "reduction", "reduction"]} ins(%arg0, %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) outs(%1 : tensor<f32>) {
    ^bb0(%in: f32, %in_0: f32, %out: f32):
      %3 = arith.mulf %in, %in_0 : f32
      %4 = arith.addf %out, %3 : f32
      linalg.yield %4 : f32
    } -> tensor<f32>
    return %2 : tensor<f32>
  }
}


// -----// IR Dump After EmptyTensorToAllocTensor (empty-tensor-to-alloc-tensor) //----- //
func.func @InnerProd.z.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg1: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
  %cst = arith.constant 0.000000e+00 : f32
  %0 = bufferization.alloc_tensor() : tensor<f32>
  %1 = linalg.generic {indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
  ^bb0(%in: f32, %out: f32):
    linalg.yield %in : f32
  } -> tensor<f32>
  %2 = linalg.generic {indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> (d0, d1, d2)>, affine_map<(d0, d1, d2) -> ()>], iterator_types = ["reduction", "reduction", "reduction"]} ins(%arg0, %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) outs(%1 : tensor<f32>) {
  ^bb0(%in: f32, %in_0: f32, %out: f32):
    %3 = arith.mulf %in, %in_0 : f32
    %4 = arith.addf %out, %3 : f32
    linalg.yield %4 : f32
  } -> tensor<f32>
  return %2 : tensor<f32>
}

// -----// IR Dump After SparsificationPass (sparsification) //----- //
#map = affine_map<() -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg1: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<f32>
    %1 = linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<f32>
    %2 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %4 = sparse_tensor.positions %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %5 = sparse_tensor.coordinates %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %6 = sparse_tensor.values %arg0 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xf32>
    %7 = sparse_tensor.positions %arg1 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %8 = sparse_tensor.coordinates %arg1 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %9 = sparse_tensor.positions %arg1 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %10 = sparse_tensor.coordinates %arg1 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %11 = sparse_tensor.values %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xf32>
    %12 = bufferization.to_memref %1 : memref<f32>
    %13 = memref.load %12[] : memref<f32>
    %14 = scf.for %arg2 = %c0 to %c128 step %c1 iter_args(%arg3 = %13) -> (f32) {
      %16 = memref.load %2[%arg2] : memref<?xindex>
      %17 = arith.addi %arg2, %c1 : index
      %18 = memref.load %2[%17] : memref<?xindex>
      %19 = memref.load %7[%arg2] : memref<?xindex>
      %20 = arith.addi %arg2, %c1 : index
      %21 = memref.load %7[%20] : memref<?xindex>
      %22:3 = scf.while (%arg4 = %16, %arg5 = %19, %arg6 = %arg3) : (index, index, f32) -> (index, index, f32) {
        %23 = arith.cmpi ult, %arg4, %18 : index
        %24 = arith.cmpi ult, %arg5, %21 : index
        %25 = arith.andi %23, %24 : i1
        scf.condition(%25) %arg4, %arg5, %arg6 : index, index, f32
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: f32):
        %23 = memref.load %3[%arg4] : memref<?xindex>
        %24 = memref.load %8[%arg5] : memref<?xindex>
        %25 = arith.cmpi ult, %24, %23 : index
        %26 = arith.select %25, %24, %23 : index
        %27 = arith.cmpi eq, %23, %26 : index
        %28 = arith.cmpi eq, %24, %26 : index
        %29 = arith.andi %27, %28 : i1
        %30 = scf.if %29 -> (f32) {
          %37 = memref.load %4[%arg4] : memref<?xindex>
          %38 = arith.addi %arg4, %c1 : index
          %39 = memref.load %4[%38] : memref<?xindex>
          %40 = memref.load %9[%arg5] : memref<?xindex>
          %41 = arith.addi %arg5, %c1 : index
          %42 = memref.load %9[%41] : memref<?xindex>
          %43:3 = scf.while (%arg7 = %37, %arg8 = %40, %arg9 = %arg6) : (index, index, f32) -> (index, index, f32) {
            %44 = arith.cmpi ult, %arg7, %39 : index
            %45 = arith.cmpi ult, %arg8, %42 : index
            %46 = arith.andi %44, %45 : i1
            scf.condition(%46) %arg7, %arg8, %arg9 : index, index, f32
          } do {
          ^bb0(%arg7: index, %arg8: index, %arg9: f32):
            %44 = memref.load %5[%arg7] : memref<?xindex>
            %45 = memref.load %10[%arg8] : memref<?xindex>
            %46 = arith.cmpi ult, %45, %44 : index
            %47 = arith.select %46, %45, %44 : index
            %48 = arith.cmpi eq, %44, %47 : index
            %49 = arith.cmpi eq, %45, %47 : index
            %50 = arith.andi %48, %49 : i1
            %51 = scf.if %50 -> (f32) {
              %58 = memref.load %6[%arg7] : memref<?xf32>
              %59 = memref.load %11[%arg8] : memref<?xf32>
              %60 = arith.mulf %58, %59 : f32
              %61 = arith.addf %arg9, %60 : f32
              scf.yield %61 : f32
            } else {
              scf.yield %arg9 : f32
            }
            %52 = arith.cmpi eq, %44, %47 : index
            %53 = arith.addi %arg7, %c1 : index
            %54 = arith.select %52, %53, %arg7 : index
            %55 = arith.cmpi eq, %45, %47 : index
            %56 = arith.addi %arg8, %c1 : index
            %57 = arith.select %55, %56, %arg8 : index
            scf.yield %54, %57, %51 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %43#2 : f32
        } else {
          scf.yield %arg6 : f32
        }
        %31 = arith.cmpi eq, %23, %26 : index
        %32 = arith.addi %arg4, %c1 : index
        %33 = arith.select %31, %32, %arg4 : index
        %34 = arith.cmpi eq, %24, %26 : index
        %35 = arith.addi %arg5, %c1 : index
        %36 = arith.select %34, %35, %arg5 : index
        scf.yield %33, %36, %30 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %22#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %14, %12[] : memref<f32>
    %15 = bufferization.to_tensor %12 : memref<f32>
    return %15 : tensor<f32>
  }
}


// -----// IR Dump After PostSparsificationRewrite (post-sparsification-rewrite) //----- //
#map = affine_map<() -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg1: tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<f32>
    %1 = linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<f32>
    %2 = sparse_tensor.positions %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %3 = sparse_tensor.coordinates %arg0 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %4 = sparse_tensor.positions %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %5 = sparse_tensor.coordinates %arg0 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %6 = sparse_tensor.values %arg0 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xf32>
    %7 = sparse_tensor.positions %arg1 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %8 = sparse_tensor.coordinates %arg1 {level = 1 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %9 = sparse_tensor.positions %arg1 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %10 = sparse_tensor.coordinates %arg1 {level = 2 : index} : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xindex>
    %11 = sparse_tensor.values %arg1 : tensor<128x128x128xf32, #sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>> to memref<?xf32>
    %12 = bufferization.to_memref %1 : memref<f32>
    %13 = memref.load %12[] : memref<f32>
    %14 = scf.for %arg2 = %c0 to %c128 step %c1 iter_args(%arg3 = %13) -> (f32) {
      %16 = memref.load %2[%arg2] : memref<?xindex>
      %17 = arith.addi %arg2, %c1 : index
      %18 = memref.load %2[%17] : memref<?xindex>
      %19 = memref.load %7[%arg2] : memref<?xindex>
      %20 = arith.addi %arg2, %c1 : index
      %21 = memref.load %7[%20] : memref<?xindex>
      %22:3 = scf.while (%arg4 = %16, %arg5 = %19, %arg6 = %arg3) : (index, index, f32) -> (index, index, f32) {
        %23 = arith.cmpi ult, %arg4, %18 : index
        %24 = arith.cmpi ult, %arg5, %21 : index
        %25 = arith.andi %23, %24 : i1
        scf.condition(%25) %arg4, %arg5, %arg6 : index, index, f32
      } do {
      ^bb0(%arg4: index, %arg5: index, %arg6: f32):
        %23 = memref.load %3[%arg4] : memref<?xindex>
        %24 = memref.load %8[%arg5] : memref<?xindex>
        %25 = arith.cmpi ult, %24, %23 : index
        %26 = arith.select %25, %24, %23 : index
        %27 = arith.cmpi eq, %23, %26 : index
        %28 = arith.cmpi eq, %24, %26 : index
        %29 = arith.andi %27, %28 : i1
        %30 = scf.if %29 -> (f32) {
          %37 = memref.load %4[%arg4] : memref<?xindex>
          %38 = arith.addi %arg4, %c1 : index
          %39 = memref.load %4[%38] : memref<?xindex>
          %40 = memref.load %9[%arg5] : memref<?xindex>
          %41 = arith.addi %arg5, %c1 : index
          %42 = memref.load %9[%41] : memref<?xindex>
          %43:3 = scf.while (%arg7 = %37, %arg8 = %40, %arg9 = %arg6) : (index, index, f32) -> (index, index, f32) {
            %44 = arith.cmpi ult, %arg7, %39 : index
            %45 = arith.cmpi ult, %arg8, %42 : index
            %46 = arith.andi %44, %45 : i1
            scf.condition(%46) %arg7, %arg8, %arg9 : index, index, f32
          } do {
          ^bb0(%arg7: index, %arg8: index, %arg9: f32):
            %44 = memref.load %5[%arg7] : memref<?xindex>
            %45 = memref.load %10[%arg8] : memref<?xindex>
            %46 = arith.cmpi ult, %45, %44 : index
            %47 = arith.select %46, %45, %44 : index
            %48 = arith.cmpi eq, %44, %47 : index
            %49 = arith.cmpi eq, %45, %47 : index
            %50 = arith.andi %48, %49 : i1
            %51 = scf.if %50 -> (f32) {
              %58 = memref.load %6[%arg7] : memref<?xf32>
              %59 = memref.load %11[%arg8] : memref<?xf32>
              %60 = arith.mulf %58, %59 : f32
              %61 = arith.addf %arg9, %60 : f32
              scf.yield %61 : f32
            } else {
              scf.yield %arg9 : f32
            }
            %52 = arith.cmpi eq, %44, %47 : index
            %53 = arith.addi %arg7, %c1 : index
            %54 = arith.select %52, %53, %arg7 : index
            %55 = arith.cmpi eq, %45, %47 : index
            %56 = arith.addi %arg8, %c1 : index
            %57 = arith.select %55, %56, %arg8 : index
            scf.yield %54, %57, %51 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %43#2 : f32
        } else {
          scf.yield %arg6 : f32
        }
        %31 = arith.cmpi eq, %23, %26 : index
        %32 = arith.addi %arg4, %c1 : index
        %33 = arith.select %31, %32, %arg4 : index
        %34 = arith.cmpi eq, %24, %26 : index
        %35 = arith.addi %arg5, %c1 : index
        %36 = arith.select %34, %35, %arg5 : index
        scf.yield %33, %36, %30 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %22#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %14, %12[] : memref<f32>
    %15 = bufferization.to_tensor %12 : memref<f32>
    return %15 : tensor<f32>
  }
}


// -----// IR Dump After SparseTensorCodegen (sparse-tensor-codegen) //----- //
#map = affine_map<() -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<f32>
    %1 = linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<f32>
    %2 = bufferization.to_memref %1 : memref<f32>
    %3 = memref.load %2[] : memref<f32>
    %4 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %3) -> (f32) {
      %6 = memref.load %arg0[%arg12] : memref<?xindex>
      %7 = arith.addi %arg12, %c1 : index
      %8 = memref.load %arg0[%7] : memref<?xindex>
      %9 = memref.load %arg6[%arg12] : memref<?xindex>
      %10 = arith.addi %arg12, %c1 : index
      %11 = memref.load %arg6[%10] : memref<?xindex>
      %12:3 = scf.while (%arg14 = %6, %arg15 = %9, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
        %13 = arith.cmpi ult, %arg14, %8 : index
        %14 = arith.cmpi ult, %arg15, %11 : index
        %15 = arith.andi %13, %14 : i1
        scf.condition(%15) %arg14, %arg15, %arg16 : index, index, f32
      } do {
      ^bb0(%arg14: index, %arg15: index, %arg16: f32):
        %13 = memref.load %arg1[%arg14] : memref<?xindex>
        %14 = memref.load %arg7[%arg15] : memref<?xindex>
        %15 = arith.cmpi ult, %14, %13 : index
        %16 = arith.select %15, %14, %13 : index
        %17 = arith.cmpi eq, %13, %16 : index
        %18 = arith.cmpi eq, %14, %16 : index
        %19 = arith.andi %17, %18 : i1
        %20 = scf.if %19 -> (f32) {
          %27 = memref.load %arg2[%arg14] : memref<?xindex>
          %28 = arith.addi %arg14, %c1 : index
          %29 = memref.load %arg2[%28] : memref<?xindex>
          %30 = memref.load %arg8[%arg15] : memref<?xindex>
          %31 = arith.addi %arg15, %c1 : index
          %32 = memref.load %arg8[%31] : memref<?xindex>
          %33:3 = scf.while (%arg17 = %27, %arg18 = %30, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
            %34 = arith.cmpi ult, %arg17, %29 : index
            %35 = arith.cmpi ult, %arg18, %32 : index
            %36 = arith.andi %34, %35 : i1
            scf.condition(%36) %arg17, %arg18, %arg19 : index, index, f32
          } do {
          ^bb0(%arg17: index, %arg18: index, %arg19: f32):
            %34 = memref.load %arg3[%arg17] : memref<?xindex>
            %35 = memref.load %arg9[%arg18] : memref<?xindex>
            %36 = arith.cmpi ult, %35, %34 : index
            %37 = arith.select %36, %35, %34 : index
            %38 = arith.cmpi eq, %34, %37 : index
            %39 = arith.cmpi eq, %35, %37 : index
            %40 = arith.andi %38, %39 : i1
            %41 = scf.if %40 -> (f32) {
              %48 = memref.load %arg4[%arg17] : memref<?xf32>
              %49 = memref.load %arg10[%arg18] : memref<?xf32>
              %50 = arith.mulf %48, %49 : f32
              %51 = arith.addf %arg19, %50 : f32
              scf.yield %51 : f32
            } else {
              scf.yield %arg19 : f32
            }
            %42 = arith.cmpi eq, %34, %37 : index
            %43 = arith.addi %arg17, %c1 : index
            %44 = arith.select %42, %43, %arg17 : index
            %45 = arith.cmpi eq, %35, %37 : index
            %46 = arith.addi %arg18, %c1 : index
            %47 = arith.select %45, %46, %arg18 : index
            scf.yield %44, %47, %41 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %33#2 : f32
        } else {
          scf.yield %arg16 : f32
        }
        %21 = arith.cmpi eq, %13, %16 : index
        %22 = arith.addi %arg14, %c1 : index
        %23 = arith.select %21, %22, %arg14 : index
        %24 = arith.cmpi eq, %14, %16 : index
        %25 = arith.addi %arg15, %c1 : index
        %26 = arith.select %24, %25, %arg15 : index
        scf.yield %23, %26, %20 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %12#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %4, %2[] : memref<f32>
    %5 = bufferization.to_tensor %2 : memref<f32>
    return %5 : tensor<f32>
  }
}


// -----// IR Dump After SparseBufferRewrite (sparse-buffer-rewrite) //----- //
#map = affine_map<() -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !sparse_tensor.storage_specifier<#sparse_tensor.encoding<{ lvlTypes = [ "dense", "compressed", "compressed" ] }>>) -> tensor<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<f32>
    %1 = linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<f32>
    %2 = bufferization.to_memref %1 : memref<f32>
    %3 = memref.load %2[] : memref<f32>
    %4 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %3) -> (f32) {
      %6 = memref.load %arg0[%arg12] : memref<?xindex>
      %7 = arith.addi %arg12, %c1 : index
      %8 = memref.load %arg0[%7] : memref<?xindex>
      %9 = memref.load %arg6[%arg12] : memref<?xindex>
      %10 = arith.addi %arg12, %c1 : index
      %11 = memref.load %arg6[%10] : memref<?xindex>
      %12:3 = scf.while (%arg14 = %6, %arg15 = %9, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
        %13 = arith.cmpi ult, %arg14, %8 : index
        %14 = arith.cmpi ult, %arg15, %11 : index
        %15 = arith.andi %13, %14 : i1
        scf.condition(%15) %arg14, %arg15, %arg16 : index, index, f32
      } do {
      ^bb0(%arg14: index, %arg15: index, %arg16: f32):
        %13 = memref.load %arg1[%arg14] : memref<?xindex>
        %14 = memref.load %arg7[%arg15] : memref<?xindex>
        %15 = arith.cmpi ult, %14, %13 : index
        %16 = arith.select %15, %14, %13 : index
        %17 = arith.cmpi eq, %13, %16 : index
        %18 = arith.cmpi eq, %14, %16 : index
        %19 = arith.andi %17, %18 : i1
        %20 = scf.if %19 -> (f32) {
          %27 = memref.load %arg2[%arg14] : memref<?xindex>
          %28 = arith.addi %arg14, %c1 : index
          %29 = memref.load %arg2[%28] : memref<?xindex>
          %30 = memref.load %arg8[%arg15] : memref<?xindex>
          %31 = arith.addi %arg15, %c1 : index
          %32 = memref.load %arg8[%31] : memref<?xindex>
          %33:3 = scf.while (%arg17 = %27, %arg18 = %30, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
            %34 = arith.cmpi ult, %arg17, %29 : index
            %35 = arith.cmpi ult, %arg18, %32 : index
            %36 = arith.andi %34, %35 : i1
            scf.condition(%36) %arg17, %arg18, %arg19 : index, index, f32
          } do {
          ^bb0(%arg17: index, %arg18: index, %arg19: f32):
            %34 = memref.load %arg3[%arg17] : memref<?xindex>
            %35 = memref.load %arg9[%arg18] : memref<?xindex>
            %36 = arith.cmpi ult, %35, %34 : index
            %37 = arith.select %36, %35, %34 : index
            %38 = arith.cmpi eq, %34, %37 : index
            %39 = arith.cmpi eq, %35, %37 : index
            %40 = arith.andi %38, %39 : i1
            %41 = scf.if %40 -> (f32) {
              %48 = memref.load %arg4[%arg17] : memref<?xf32>
              %49 = memref.load %arg10[%arg18] : memref<?xf32>
              %50 = arith.mulf %48, %49 : f32
              %51 = arith.addf %arg19, %50 : f32
              scf.yield %51 : f32
            } else {
              scf.yield %arg19 : f32
            }
            %42 = arith.cmpi eq, %34, %37 : index
            %43 = arith.addi %arg17, %c1 : index
            %44 = arith.select %42, %43, %arg17 : index
            %45 = arith.cmpi eq, %35, %37 : index
            %46 = arith.addi %arg18, %c1 : index
            %47 = arith.select %45, %46, %arg18 : index
            scf.yield %44, %47, %41 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %33#2 : f32
        } else {
          scf.yield %arg16 : f32
        }
        %21 = arith.cmpi eq, %13, %16 : index
        %22 = arith.addi %arg14, %c1 : index
        %23 = arith.select %21, %22, %arg14 : index
        %24 = arith.cmpi eq, %14, %16 : index
        %25 = arith.addi %arg15, %c1 : index
        %26 = arith.select %24, %25, %arg15 : index
        scf.yield %23, %26, %20 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %12#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %4, %2[] : memref<f32>
    %5 = bufferization.to_tensor %2 : memref<f32>
    return %5 : tensor<f32>
  }
}


// -----// IR Dump After StorageSpecifierToLLVM (sparse-storage-specifier-to-llvm) //----- //
#map = affine_map<() -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> tensor<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = bufferization.alloc_tensor() {bufferization.escape = [true]} : tensor<f32>
    %1 = linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%0 : tensor<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    } -> tensor<f32>
    %2 = bufferization.to_memref %1 : memref<f32>
    %3 = memref.load %2[] : memref<f32>
    %4 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %3) -> (f32) {
      %6 = memref.load %arg0[%arg12] : memref<?xindex>
      %7 = arith.addi %arg12, %c1 : index
      %8 = memref.load %arg0[%7] : memref<?xindex>
      %9 = memref.load %arg6[%arg12] : memref<?xindex>
      %10 = arith.addi %arg12, %c1 : index
      %11 = memref.load %arg6[%10] : memref<?xindex>
      %12:3 = scf.while (%arg14 = %6, %arg15 = %9, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
        %13 = arith.cmpi ult, %arg14, %8 : index
        %14 = arith.cmpi ult, %arg15, %11 : index
        %15 = arith.andi %13, %14 : i1
        scf.condition(%15) %arg14, %arg15, %arg16 : index, index, f32
      } do {
      ^bb0(%arg14: index, %arg15: index, %arg16: f32):
        %13 = memref.load %arg1[%arg14] : memref<?xindex>
        %14 = memref.load %arg7[%arg15] : memref<?xindex>
        %15 = arith.cmpi ult, %14, %13 : index
        %16 = arith.select %15, %14, %13 : index
        %17 = arith.cmpi eq, %13, %16 : index
        %18 = arith.cmpi eq, %14, %16 : index
        %19 = arith.andi %17, %18 : i1
        %20 = scf.if %19 -> (f32) {
          %27 = memref.load %arg2[%arg14] : memref<?xindex>
          %28 = arith.addi %arg14, %c1 : index
          %29 = memref.load %arg2[%28] : memref<?xindex>
          %30 = memref.load %arg8[%arg15] : memref<?xindex>
          %31 = arith.addi %arg15, %c1 : index
          %32 = memref.load %arg8[%31] : memref<?xindex>
          %33:3 = scf.while (%arg17 = %27, %arg18 = %30, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
            %34 = arith.cmpi ult, %arg17, %29 : index
            %35 = arith.cmpi ult, %arg18, %32 : index
            %36 = arith.andi %34, %35 : i1
            scf.condition(%36) %arg17, %arg18, %arg19 : index, index, f32
          } do {
          ^bb0(%arg17: index, %arg18: index, %arg19: f32):
            %34 = memref.load %arg3[%arg17] : memref<?xindex>
            %35 = memref.load %arg9[%arg18] : memref<?xindex>
            %36 = arith.cmpi ult, %35, %34 : index
            %37 = arith.select %36, %35, %34 : index
            %38 = arith.cmpi eq, %34, %37 : index
            %39 = arith.cmpi eq, %35, %37 : index
            %40 = arith.andi %38, %39 : i1
            %41 = scf.if %40 -> (f32) {
              %48 = memref.load %arg4[%arg17] : memref<?xf32>
              %49 = memref.load %arg10[%arg18] : memref<?xf32>
              %50 = arith.mulf %48, %49 : f32
              %51 = arith.addf %arg19, %50 : f32
              scf.yield %51 : f32
            } else {
              scf.yield %arg19 : f32
            }
            %42 = arith.cmpi eq, %34, %37 : index
            %43 = arith.addi %arg17, %c1 : index
            %44 = arith.select %42, %43, %arg17 : index
            %45 = arith.cmpi eq, %35, %37 : index
            %46 = arith.addi %arg18, %c1 : index
            %47 = arith.select %45, %46, %arg18 : index
            scf.yield %44, %47, %41 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %33#2 : f32
        } else {
          scf.yield %arg16 : f32
        }
        %21 = arith.cmpi eq, %13, %16 : index
        %22 = arith.addi %arg14, %c1 : index
        %23 = arith.select %21, %22, %arg14 : index
        %24 = arith.cmpi eq, %14, %16 : index
        %25 = arith.addi %arg15, %c1 : index
        %26 = arith.select %24, %25, %arg15 : index
        scf.yield %23, %26, %20 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %12#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %4, %2[] : memref<f32>
    %5 = bufferization.to_tensor %2 : memref<f32>
    return %5 : tensor<f32>
  }
}


// -----// IR Dump After mlir::sparse_tensor::SparsificationAndBufferizationPass () //----- //
#map = affine_map<() -> ()>
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
    linalg.generic {indexing_maps = [#map, #map], iterator_types = []} ins(%cst : f32) outs(%alloc : memref<f32>) {
    ^bb0(%in: f32, %out: f32):
      linalg.yield %in : f32
    }
    %0 = memref.load %alloc[] : memref<f32>
    %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
      %2 = memref.load %arg0[%arg12] : memref<?xindex>
      %3 = arith.addi %arg12, %c1 : index
      %4 = memref.load %arg0[%3] : memref<?xindex>
      %5 = memref.load %arg6[%arg12] : memref<?xindex>
      %6 = arith.addi %arg12, %c1 : index
      %7 = memref.load %arg6[%6] : memref<?xindex>
      %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
        %9 = arith.cmpi ult, %arg14, %4 : index
        %10 = arith.cmpi ult, %arg15, %7 : index
        %11 = arith.andi %9, %10 : i1
        scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
      } do {
      ^bb0(%arg14: index, %arg15: index, %arg16: f32):
        %9 = memref.load %arg1[%arg14] : memref<?xindex>
        %10 = memref.load %arg7[%arg15] : memref<?xindex>
        %11 = arith.cmpi ult, %10, %9 : index
        %12 = arith.select %11, %10, %9 : index
        %13 = arith.cmpi eq, %9, %12 : index
        %14 = arith.cmpi eq, %10, %12 : index
        %15 = arith.andi %13, %14 : i1
        %16 = scf.if %15 -> (f32) {
          %23 = memref.load %arg2[%arg14] : memref<?xindex>
          %24 = arith.addi %arg14, %c1 : index
          %25 = memref.load %arg2[%24] : memref<?xindex>
          %26 = memref.load %arg8[%arg15] : memref<?xindex>
          %27 = arith.addi %arg15, %c1 : index
          %28 = memref.load %arg8[%27] : memref<?xindex>
          %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
            %30 = arith.cmpi ult, %arg17, %25 : index
            %31 = arith.cmpi ult, %arg18, %28 : index
            %32 = arith.andi %30, %31 : i1
            scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
          } do {
          ^bb0(%arg17: index, %arg18: index, %arg19: f32):
            %30 = memref.load %arg3[%arg17] : memref<?xindex>
            %31 = memref.load %arg9[%arg18] : memref<?xindex>
            %32 = arith.cmpi ult, %31, %30 : index
            %33 = arith.select %32, %31, %30 : index
            %34 = arith.cmpi eq, %30, %33 : index
            %35 = arith.cmpi eq, %31, %33 : index
            %36 = arith.andi %34, %35 : i1
            %37 = scf.if %36 -> (f32) {
              %44 = memref.load %arg4[%arg17] : memref<?xf32>
              %45 = memref.load %arg10[%arg18] : memref<?xf32>
              %46 = arith.mulf %44, %45 : f32
              %47 = arith.addf %arg19, %46 : f32
              scf.yield %47 : f32
            } else {
              scf.yield %arg19 : f32
            }
            %38 = arith.cmpi eq, %30, %33 : index
            %39 = arith.addi %arg17, %c1 : index
            %40 = arith.select %38, %39, %arg17 : index
            %41 = arith.cmpi eq, %31, %33 : index
            %42 = arith.addi %arg18, %c1 : index
            %43 = arith.select %41, %42, %arg18 : index
            scf.yield %40, %43, %37 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %29#2 : f32
        } else {
          scf.yield %arg16 : f32
        }
        %17 = arith.cmpi eq, %9, %12 : index
        %18 = arith.addi %arg14, %c1 : index
        %19 = arith.select %17, %18, %arg14 : index
        %20 = arith.cmpi eq, %10, %12 : index
        %21 = arith.addi %arg15, %c1 : index
        %22 = arith.select %20, %21, %arg15 : index
        scf.yield %19, %22, %16 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %8#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %1, %alloc[] : memref<f32>
    return %alloc : memref<f32>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
  linalg.generic {indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = []} ins(%cst : f32) outs(%alloc : memref<f32>) {
  ^bb0(%in: f32, %out: f32):
    linalg.yield %in : f32
  }
  %0 = memref.load %alloc[] : memref<f32>
  %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
    %2 = memref.load %arg0[%arg12] : memref<?xindex>
    %3 = arith.addi %arg12, %c1 : index
    %4 = memref.load %arg0[%3] : memref<?xindex>
    %5 = memref.load %arg6[%arg12] : memref<?xindex>
    %6 = arith.addi %arg12, %c1 : index
    %7 = memref.load %arg6[%6] : memref<?xindex>
    %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
      %9 = arith.cmpi ult, %arg14, %4 : index
      %10 = arith.cmpi ult, %arg15, %7 : index
      %11 = arith.andi %9, %10 : i1
      scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
    } do {
    ^bb0(%arg14: index, %arg15: index, %arg16: f32):
      %9 = memref.load %arg1[%arg14] : memref<?xindex>
      %10 = memref.load %arg7[%arg15] : memref<?xindex>
      %11 = arith.cmpi ult, %10, %9 : index
      %12 = arith.select %11, %10, %9 : index
      %13 = arith.cmpi eq, %9, %12 : index
      %14 = arith.cmpi eq, %10, %12 : index
      %15 = arith.andi %13, %14 : i1
      %16 = scf.if %15 -> (f32) {
        %23 = memref.load %arg2[%arg14] : memref<?xindex>
        %24 = arith.addi %arg14, %c1 : index
        %25 = memref.load %arg2[%24] : memref<?xindex>
        %26 = memref.load %arg8[%arg15] : memref<?xindex>
        %27 = arith.addi %arg15, %c1 : index
        %28 = memref.load %arg8[%27] : memref<?xindex>
        %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
          %30 = arith.cmpi ult, %arg17, %25 : index
          %31 = arith.cmpi ult, %arg18, %28 : index
          %32 = arith.andi %30, %31 : i1
          scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
        } do {
        ^bb0(%arg17: index, %arg18: index, %arg19: f32):
          %30 = memref.load %arg3[%arg17] : memref<?xindex>
          %31 = memref.load %arg9[%arg18] : memref<?xindex>
          %32 = arith.cmpi ult, %31, %30 : index
          %33 = arith.select %32, %31, %30 : index
          %34 = arith.cmpi eq, %30, %33 : index
          %35 = arith.cmpi eq, %31, %33 : index
          %36 = arith.andi %34, %35 : i1
          %37 = scf.if %36 -> (f32) {
            %44 = memref.load %arg4[%arg17] : memref<?xf32>
            %45 = memref.load %arg10[%arg18] : memref<?xf32>
            %46 = arith.mulf %44, %45 : f32
            %47 = arith.addf %arg19, %46 : f32
            scf.yield %47 : f32
          } else {
            scf.yield %arg19 : f32
          }
          %38 = arith.cmpi eq, %30, %33 : index
          %39 = arith.addi %arg17, %c1 : index
          %40 = arith.select %38, %39, %arg17 : index
          %41 = arith.cmpi eq, %31, %33 : index
          %42 = arith.addi %arg18, %c1 : index
          %43 = arith.select %41, %42, %arg18 : index
          scf.yield %40, %43, %37 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        scf.yield %29#2 : f32
      } else {
        scf.yield %arg16 : f32
      }
      %17 = arith.cmpi eq, %9, %12 : index
      %18 = arith.addi %arg14, %c1 : index
      %19 = arith.select %17, %18, %arg14 : index
      %20 = arith.cmpi eq, %10, %12 : index
      %21 = arith.addi %arg15, %c1 : index
      %22 = arith.select %20, %21, %arg15 : index
      scf.yield %19, %22, %16 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    scf.yield %8#2 : f32
  } {"Emitted from" = "linalg.generic"}
  memref.store %1, %alloc[] : memref<f32>
  return %alloc : memref<f32>
}

// -----// IR Dump After FinalizingBufferize (finalizing-bufferize) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
  linalg.generic {indexing_maps = [affine_map<() -> ()>, affine_map<() -> ()>], iterator_types = []} ins(%cst : f32) outs(%alloc : memref<f32>) {
  ^bb0(%in: f32, %out: f32):
    linalg.yield %in : f32
  }
  %0 = memref.load %alloc[] : memref<f32>
  %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
    %2 = memref.load %arg0[%arg12] : memref<?xindex>
    %3 = arith.addi %arg12, %c1 : index
    %4 = memref.load %arg0[%3] : memref<?xindex>
    %5 = memref.load %arg6[%arg12] : memref<?xindex>
    %6 = arith.addi %arg12, %c1 : index
    %7 = memref.load %arg6[%6] : memref<?xindex>
    %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
      %9 = arith.cmpi ult, %arg14, %4 : index
      %10 = arith.cmpi ult, %arg15, %7 : index
      %11 = arith.andi %9, %10 : i1
      scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
    } do {
    ^bb0(%arg14: index, %arg15: index, %arg16: f32):
      %9 = memref.load %arg1[%arg14] : memref<?xindex>
      %10 = memref.load %arg7[%arg15] : memref<?xindex>
      %11 = arith.cmpi ult, %10, %9 : index
      %12 = arith.select %11, %10, %9 : index
      %13 = arith.cmpi eq, %9, %12 : index
      %14 = arith.cmpi eq, %10, %12 : index
      %15 = arith.andi %13, %14 : i1
      %16 = scf.if %15 -> (f32) {
        %23 = memref.load %arg2[%arg14] : memref<?xindex>
        %24 = arith.addi %arg14, %c1 : index
        %25 = memref.load %arg2[%24] : memref<?xindex>
        %26 = memref.load %arg8[%arg15] : memref<?xindex>
        %27 = arith.addi %arg15, %c1 : index
        %28 = memref.load %arg8[%27] : memref<?xindex>
        %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
          %30 = arith.cmpi ult, %arg17, %25 : index
          %31 = arith.cmpi ult, %arg18, %28 : index
          %32 = arith.andi %30, %31 : i1
          scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
        } do {
        ^bb0(%arg17: index, %arg18: index, %arg19: f32):
          %30 = memref.load %arg3[%arg17] : memref<?xindex>
          %31 = memref.load %arg9[%arg18] : memref<?xindex>
          %32 = arith.cmpi ult, %31, %30 : index
          %33 = arith.select %32, %31, %30 : index
          %34 = arith.cmpi eq, %30, %33 : index
          %35 = arith.cmpi eq, %31, %33 : index
          %36 = arith.andi %34, %35 : i1
          %37 = scf.if %36 -> (f32) {
            %44 = memref.load %arg4[%arg17] : memref<?xf32>
            %45 = memref.load %arg10[%arg18] : memref<?xf32>
            %46 = arith.mulf %44, %45 : f32
            %47 = arith.addf %arg19, %46 : f32
            scf.yield %47 : f32
          } else {
            scf.yield %arg19 : f32
          }
          %38 = arith.cmpi eq, %30, %33 : index
          %39 = arith.addi %arg17, %c1 : index
          %40 = arith.select %38, %39, %arg17 : index
          %41 = arith.cmpi eq, %31, %33 : index
          %42 = arith.addi %arg18, %c1 : index
          %43 = arith.select %41, %42, %arg18 : index
          scf.yield %40, %43, %37 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        scf.yield %29#2 : f32
      } else {
        scf.yield %arg16 : f32
      }
      %17 = arith.cmpi eq, %9, %12 : index
      %18 = arith.addi %arg14, %c1 : index
      %19 = arith.select %17, %18, %arg14 : index
      %20 = arith.cmpi eq, %10, %12 : index
      %21 = arith.addi %arg15, %c1 : index
      %22 = arith.select %20, %21, %arg15 : index
      scf.yield %19, %22, %16 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    scf.yield %8#2 : f32
  } {"Emitted from" = "linalg.generic"}
  memref.store %1, %alloc[] : memref<f32>
  return %alloc : memref<f32>
}

// -----// IR Dump After LinalgLowerToLoops (convert-linalg-to-loops) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
  memref.store %cst, %alloc[] : memref<f32>
  %0 = memref.load %alloc[] : memref<f32>
  %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
    %2 = memref.load %arg0[%arg12] : memref<?xindex>
    %3 = arith.addi %arg12, %c1 : index
    %4 = memref.load %arg0[%3] : memref<?xindex>
    %5 = memref.load %arg6[%arg12] : memref<?xindex>
    %6 = arith.addi %arg12, %c1 : index
    %7 = memref.load %arg6[%6] : memref<?xindex>
    %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
      %9 = arith.cmpi ult, %arg14, %4 : index
      %10 = arith.cmpi ult, %arg15, %7 : index
      %11 = arith.andi %9, %10 : i1
      scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
    } do {
    ^bb0(%arg14: index, %arg15: index, %arg16: f32):
      %9 = memref.load %arg1[%arg14] : memref<?xindex>
      %10 = memref.load %arg7[%arg15] : memref<?xindex>
      %11 = arith.cmpi ult, %10, %9 : index
      %12 = arith.select %11, %10, %9 : index
      %13 = arith.cmpi eq, %9, %12 : index
      %14 = arith.cmpi eq, %10, %12 : index
      %15 = arith.andi %13, %14 : i1
      %16 = scf.if %15 -> (f32) {
        %23 = memref.load %arg2[%arg14] : memref<?xindex>
        %24 = arith.addi %arg14, %c1 : index
        %25 = memref.load %arg2[%24] : memref<?xindex>
        %26 = memref.load %arg8[%arg15] : memref<?xindex>
        %27 = arith.addi %arg15, %c1 : index
        %28 = memref.load %arg8[%27] : memref<?xindex>
        %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
          %30 = arith.cmpi ult, %arg17, %25 : index
          %31 = arith.cmpi ult, %arg18, %28 : index
          %32 = arith.andi %30, %31 : i1
          scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
        } do {
        ^bb0(%arg17: index, %arg18: index, %arg19: f32):
          %30 = memref.load %arg3[%arg17] : memref<?xindex>
          %31 = memref.load %arg9[%arg18] : memref<?xindex>
          %32 = arith.cmpi ult, %31, %30 : index
          %33 = arith.select %32, %31, %30 : index
          %34 = arith.cmpi eq, %30, %33 : index
          %35 = arith.cmpi eq, %31, %33 : index
          %36 = arith.andi %34, %35 : i1
          %37 = scf.if %36 -> (f32) {
            %44 = memref.load %arg4[%arg17] : memref<?xf32>
            %45 = memref.load %arg10[%arg18] : memref<?xf32>
            %46 = arith.mulf %44, %45 : f32
            %47 = arith.addf %arg19, %46 : f32
            scf.yield %47 : f32
          } else {
            scf.yield %arg19 : f32
          }
          %38 = arith.cmpi eq, %30, %33 : index
          %39 = arith.addi %arg17, %c1 : index
          %40 = arith.select %38, %39, %arg17 : index
          %41 = arith.cmpi eq, %31, %33 : index
          %42 = arith.addi %arg18, %c1 : index
          %43 = arith.select %41, %42, %arg18 : index
          scf.yield %40, %43, %37 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        scf.yield %29#2 : f32
      } else {
        scf.yield %arg16 : f32
      }
      %17 = arith.cmpi eq, %9, %12 : index
      %18 = arith.addi %arg14, %c1 : index
      %19 = arith.select %17, %18, %arg14 : index
      %20 = arith.cmpi eq, %10, %12 : index
      %21 = arith.addi %arg15, %c1 : index
      %22 = arith.select %20, %21, %arg15 : index
      scf.yield %19, %22, %16 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    scf.yield %8#2 : f32
  } {"Emitted from" = "linalg.generic"}
  memref.store %1, %alloc[] : memref<f32>
  return %alloc : memref<f32>
}

// -----// IR Dump After ConvertVectorToSCF (convert-vector-to-scf) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
  memref.store %cst, %alloc[] : memref<f32>
  %0 = memref.load %alloc[] : memref<f32>
  %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
    %2 = memref.load %arg0[%arg12] : memref<?xindex>
    %3 = arith.addi %arg12, %c1 : index
    %4 = memref.load %arg0[%3] : memref<?xindex>
    %5 = memref.load %arg6[%arg12] : memref<?xindex>
    %6 = arith.addi %arg12, %c1 : index
    %7 = memref.load %arg6[%6] : memref<?xindex>
    %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
      %9 = arith.cmpi ult, %arg14, %4 : index
      %10 = arith.cmpi ult, %arg15, %7 : index
      %11 = arith.andi %9, %10 : i1
      scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
    } do {
    ^bb0(%arg14: index, %arg15: index, %arg16: f32):
      %9 = memref.load %arg1[%arg14] : memref<?xindex>
      %10 = memref.load %arg7[%arg15] : memref<?xindex>
      %11 = arith.cmpi ult, %10, %9 : index
      %12 = arith.select %11, %10, %9 : index
      %13 = arith.cmpi eq, %9, %12 : index
      %14 = arith.cmpi eq, %10, %12 : index
      %15 = arith.andi %13, %14 : i1
      %16 = scf.if %15 -> (f32) {
        %23 = memref.load %arg2[%arg14] : memref<?xindex>
        %24 = arith.addi %arg14, %c1 : index
        %25 = memref.load %arg2[%24] : memref<?xindex>
        %26 = memref.load %arg8[%arg15] : memref<?xindex>
        %27 = arith.addi %arg15, %c1 : index
        %28 = memref.load %arg8[%27] : memref<?xindex>
        %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
          %30 = arith.cmpi ult, %arg17, %25 : index
          %31 = arith.cmpi ult, %arg18, %28 : index
          %32 = arith.andi %30, %31 : i1
          scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
        } do {
        ^bb0(%arg17: index, %arg18: index, %arg19: f32):
          %30 = memref.load %arg3[%arg17] : memref<?xindex>
          %31 = memref.load %arg9[%arg18] : memref<?xindex>
          %32 = arith.cmpi ult, %31, %30 : index
          %33 = arith.select %32, %31, %30 : index
          %34 = arith.cmpi eq, %30, %33 : index
          %35 = arith.cmpi eq, %31, %33 : index
          %36 = arith.andi %34, %35 : i1
          %37 = scf.if %36 -> (f32) {
            %44 = memref.load %arg4[%arg17] : memref<?xf32>
            %45 = memref.load %arg10[%arg18] : memref<?xf32>
            %46 = arith.mulf %44, %45 : f32
            %47 = arith.addf %arg19, %46 : f32
            scf.yield %47 : f32
          } else {
            scf.yield %arg19 : f32
          }
          %38 = arith.cmpi eq, %30, %33 : index
          %39 = arith.addi %arg17, %c1 : index
          %40 = arith.select %38, %39, %arg17 : index
          %41 = arith.cmpi eq, %31, %33 : index
          %42 = arith.addi %arg18, %c1 : index
          %43 = arith.select %41, %42, %arg18 : index
          scf.yield %40, %43, %37 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        scf.yield %29#2 : f32
      } else {
        scf.yield %arg16 : f32
      }
      %17 = arith.cmpi eq, %9, %12 : index
      %18 = arith.addi %arg14, %c1 : index
      %19 = arith.select %17, %18, %arg14 : index
      %20 = arith.cmpi eq, %10, %12 : index
      %21 = arith.addi %arg15, %c1 : index
      %22 = arith.select %20, %21, %arg15 : index
      scf.yield %19, %22, %16 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    scf.yield %8#2 : f32
  } {"Emitted from" = "linalg.generic"}
  memref.store %1, %alloc[] : memref<f32>
  return %alloc : memref<f32>
}

// -----// IR Dump After ConvertSCFToOpenMPPass (convert-scf-to-openmp) //----- //
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
    memref.store %cst, %alloc[] : memref<f32>
    %0 = memref.load %alloc[] : memref<f32>
    %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
      %2 = memref.load %arg0[%arg12] : memref<?xindex>
      %3 = arith.addi %arg12, %c1 : index
      %4 = memref.load %arg0[%3] : memref<?xindex>
      %5 = memref.load %arg6[%arg12] : memref<?xindex>
      %6 = arith.addi %arg12, %c1 : index
      %7 = memref.load %arg6[%6] : memref<?xindex>
      %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
        %9 = arith.cmpi ult, %arg14, %4 : index
        %10 = arith.cmpi ult, %arg15, %7 : index
        %11 = arith.andi %9, %10 : i1
        scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
      } do {
      ^bb0(%arg14: index, %arg15: index, %arg16: f32):
        %9 = memref.load %arg1[%arg14] : memref<?xindex>
        %10 = memref.load %arg7[%arg15] : memref<?xindex>
        %11 = arith.cmpi ult, %10, %9 : index
        %12 = arith.select %11, %10, %9 : index
        %13 = arith.cmpi eq, %9, %12 : index
        %14 = arith.cmpi eq, %10, %12 : index
        %15 = arith.andi %13, %14 : i1
        %16 = scf.if %15 -> (f32) {
          %23 = memref.load %arg2[%arg14] : memref<?xindex>
          %24 = arith.addi %arg14, %c1 : index
          %25 = memref.load %arg2[%24] : memref<?xindex>
          %26 = memref.load %arg8[%arg15] : memref<?xindex>
          %27 = arith.addi %arg15, %c1 : index
          %28 = memref.load %arg8[%27] : memref<?xindex>
          %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
            %30 = arith.cmpi ult, %arg17, %25 : index
            %31 = arith.cmpi ult, %arg18, %28 : index
            %32 = arith.andi %30, %31 : i1
            scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
          } do {
          ^bb0(%arg17: index, %arg18: index, %arg19: f32):
            %30 = memref.load %arg3[%arg17] : memref<?xindex>
            %31 = memref.load %arg9[%arg18] : memref<?xindex>
            %32 = arith.cmpi ult, %31, %30 : index
            %33 = arith.select %32, %31, %30 : index
            %34 = arith.cmpi eq, %30, %33 : index
            %35 = arith.cmpi eq, %31, %33 : index
            %36 = arith.andi %34, %35 : i1
            %37 = scf.if %36 -> (f32) {
              %44 = memref.load %arg4[%arg17] : memref<?xf32>
              %45 = memref.load %arg10[%arg18] : memref<?xf32>
              %46 = arith.mulf %44, %45 : f32
              %47 = arith.addf %arg19, %46 : f32
              scf.yield %47 : f32
            } else {
              scf.yield %arg19 : f32
            }
            %38 = arith.cmpi eq, %30, %33 : index
            %39 = arith.addi %arg17, %c1 : index
            %40 = arith.select %38, %39, %arg17 : index
            %41 = arith.cmpi eq, %31, %33 : index
            %42 = arith.addi %arg18, %c1 : index
            %43 = arith.select %41, %42, %arg18 : index
            scf.yield %40, %43, %37 : index, index, f32
          } attributes {"Emitted from" = "linalg.generic"}
          scf.yield %29#2 : f32
        } else {
          scf.yield %arg16 : f32
        }
        %17 = arith.cmpi eq, %9, %12 : index
        %18 = arith.addi %arg14, %c1 : index
        %19 = arith.select %17, %18, %arg14 : index
        %20 = arith.cmpi eq, %10, %12 : index
        %21 = arith.addi %arg15, %c1 : index
        %22 = arith.select %20, %21, %arg15 : index
        scf.yield %19, %22, %16 : index, index, f32
      } attributes {"Emitted from" = "linalg.generic"}
      scf.yield %8#2 : f32
    } {"Emitted from" = "linalg.generic"}
    memref.store %1, %alloc[] : memref<f32>
    return %alloc : memref<f32>
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
  memref.store %cst, %alloc[] : memref<f32>
  %0 = memref.load %alloc[] : memref<f32>
  %1 = scf.for %arg12 = %c0 to %c128 step %c1 iter_args(%arg13 = %0) -> (f32) {
    %2 = memref.load %arg0[%arg12] : memref<?xindex>
    %3 = arith.addi %arg12, %c1 : index
    %4 = memref.load %arg0[%3] : memref<?xindex>
    %5 = memref.load %arg6[%arg12] : memref<?xindex>
    %6 = arith.addi %arg12, %c1 : index
    %7 = memref.load %arg6[%6] : memref<?xindex>
    %8:3 = scf.while (%arg14 = %2, %arg15 = %5, %arg16 = %arg13) : (index, index, f32) -> (index, index, f32) {
      %9 = arith.cmpi ult, %arg14, %4 : index
      %10 = arith.cmpi ult, %arg15, %7 : index
      %11 = arith.andi %9, %10 : i1
      scf.condition(%11) %arg14, %arg15, %arg16 : index, index, f32
    } do {
    ^bb0(%arg14: index, %arg15: index, %arg16: f32):
      %9 = memref.load %arg1[%arg14] : memref<?xindex>
      %10 = memref.load %arg7[%arg15] : memref<?xindex>
      %11 = arith.cmpi ult, %10, %9 : index
      %12 = arith.select %11, %10, %9 : index
      %13 = arith.cmpi eq, %9, %12 : index
      %14 = arith.cmpi eq, %10, %12 : index
      %15 = arith.andi %13, %14 : i1
      %16 = scf.if %15 -> (f32) {
        %23 = memref.load %arg2[%arg14] : memref<?xindex>
        %24 = arith.addi %arg14, %c1 : index
        %25 = memref.load %arg2[%24] : memref<?xindex>
        %26 = memref.load %arg8[%arg15] : memref<?xindex>
        %27 = arith.addi %arg15, %c1 : index
        %28 = memref.load %arg8[%27] : memref<?xindex>
        %29:3 = scf.while (%arg17 = %23, %arg18 = %26, %arg19 = %arg16) : (index, index, f32) -> (index, index, f32) {
          %30 = arith.cmpi ult, %arg17, %25 : index
          %31 = arith.cmpi ult, %arg18, %28 : index
          %32 = arith.andi %30, %31 : i1
          scf.condition(%32) %arg17, %arg18, %arg19 : index, index, f32
        } do {
        ^bb0(%arg17: index, %arg18: index, %arg19: f32):
          %30 = memref.load %arg3[%arg17] : memref<?xindex>
          %31 = memref.load %arg9[%arg18] : memref<?xindex>
          %32 = arith.cmpi ult, %31, %30 : index
          %33 = arith.select %32, %31, %30 : index
          %34 = arith.cmpi eq, %30, %33 : index
          %35 = arith.cmpi eq, %31, %33 : index
          %36 = arith.andi %34, %35 : i1
          %37 = scf.if %36 -> (f32) {
            %44 = memref.load %arg4[%arg17] : memref<?xf32>
            %45 = memref.load %arg10[%arg18] : memref<?xf32>
            %46 = arith.mulf %44, %45 : f32
            %47 = arith.addf %arg19, %46 : f32
            scf.yield %47 : f32
          } else {
            scf.yield %arg19 : f32
          }
          %38 = arith.cmpi eq, %30, %33 : index
          %39 = arith.addi %arg17, %c1 : index
          %40 = arith.select %38, %39, %arg17 : index
          %41 = arith.cmpi eq, %31, %33 : index
          %42 = arith.addi %arg18, %c1 : index
          %43 = arith.select %41, %42, %arg18 : index
          scf.yield %40, %43, %37 : index, index, f32
        } attributes {"Emitted from" = "linalg.generic"}
        scf.yield %29#2 : f32
      } else {
        scf.yield %arg16 : f32
      }
      %17 = arith.cmpi eq, %9, %12 : index
      %18 = arith.addi %arg14, %c1 : index
      %19 = arith.select %17, %18, %arg14 : index
      %20 = arith.cmpi eq, %10, %12 : index
      %21 = arith.addi %arg15, %c1 : index
      %22 = arith.select %20, %21, %arg15 : index
      scf.yield %19, %22, %16 : index, index, f32
    } attributes {"Emitted from" = "linalg.generic"}
    scf.yield %8#2 : f32
  } {"Emitted from" = "linalg.generic"}
  memref.store %1, %alloc[] : memref<f32>
  return %alloc : memref<f32>
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
  memref.store %cst, %alloc[] : memref<f32>
  %0 = memref.load %alloc[] : memref<f32>
  cf.br ^bb1(%c0, %0 : index, f32)
^bb1(%1: index, %2: f32):  // 2 preds: ^bb0, ^bb16
  %3 = arith.cmpi slt, %1, %c128 : index
  cf.cond_br %3, ^bb2, ^bb17
^bb2:  // pred: ^bb1
  %4 = memref.load %arg0[%1] : memref<?xindex>
  %5 = arith.addi %1, %c1 : index
  %6 = memref.load %arg0[%5] : memref<?xindex>
  %7 = memref.load %arg6[%1] : memref<?xindex>
  %8 = arith.addi %1, %c1 : index
  %9 = memref.load %arg6[%8] : memref<?xindex>
  cf.br ^bb3(%4, %7, %2 : index, index, f32)
^bb3(%10: index, %11: index, %12: f32):  // 2 preds: ^bb2, ^bb15
  %13 = arith.cmpi ult, %10, %6 : index
  %14 = arith.cmpi ult, %11, %9 : index
  %15 = arith.andi %13, %14 : i1
  cf.cond_br %15, ^bb4(%10, %11, %12 : index, index, f32), ^bb16
^bb4(%16: index, %17: index, %18: f32):  // pred: ^bb3
  %19 = memref.load %arg1[%16] : memref<?xindex>
  %20 = memref.load %arg7[%17] : memref<?xindex>
  %21 = arith.cmpi ult, %20, %19 : index
  %22 = arith.select %21, %20, %19 : index
  %23 = arith.cmpi eq, %19, %22 : index
  %24 = arith.cmpi eq, %20, %22 : index
  %25 = arith.andi %23, %24 : i1
  cf.cond_br %25, ^bb5, ^bb13
^bb5:  // pred: ^bb4
  %26 = memref.load %arg2[%16] : memref<?xindex>
  %27 = arith.addi %16, %c1 : index
  %28 = memref.load %arg2[%27] : memref<?xindex>
  %29 = memref.load %arg8[%17] : memref<?xindex>
  %30 = arith.addi %17, %c1 : index
  %31 = memref.load %arg8[%30] : memref<?xindex>
  cf.br ^bb6(%26, %29, %18 : index, index, f32)
^bb6(%32: index, %33: index, %34: f32):  // 2 preds: ^bb5, ^bb11
  %35 = arith.cmpi ult, %32, %28 : index
  %36 = arith.cmpi ult, %33, %31 : index
  %37 = arith.andi %35, %36 : i1
  cf.cond_br %37, ^bb7(%32, %33, %34 : index, index, f32), ^bb12
^bb7(%38: index, %39: index, %40: f32):  // pred: ^bb6
  %41 = memref.load %arg3[%38] : memref<?xindex>
  %42 = memref.load %arg9[%39] : memref<?xindex>
  %43 = arith.cmpi ult, %42, %41 : index
  %44 = arith.select %43, %42, %41 : index
  %45 = arith.cmpi eq, %41, %44 : index
  %46 = arith.cmpi eq, %42, %44 : index
  %47 = arith.andi %45, %46 : i1
  cf.cond_br %47, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %48 = memref.load %arg4[%38] : memref<?xf32>
  %49 = memref.load %arg10[%39] : memref<?xf32>
  %50 = arith.mulf %48, %49 : f32
  %51 = arith.addf %40, %50 : f32
  cf.br ^bb10(%51 : f32)
^bb9:  // pred: ^bb7
  cf.br ^bb10(%40 : f32)
^bb10(%52: f32):  // 2 preds: ^bb8, ^bb9
  cf.br ^bb11
^bb11:  // pred: ^bb10
  %53 = arith.cmpi eq, %41, %44 : index
  %54 = arith.addi %38, %c1 : index
  %55 = arith.select %53, %54, %38 : index
  %56 = arith.cmpi eq, %42, %44 : index
  %57 = arith.addi %39, %c1 : index
  %58 = arith.select %56, %57, %39 : index
  cf.br ^bb6(%55, %58, %52 : index, index, f32)
^bb12:  // pred: ^bb6
  cf.br ^bb14(%34 : f32)
^bb13:  // pred: ^bb4
  cf.br ^bb14(%18 : f32)
^bb14(%59: f32):  // 2 preds: ^bb12, ^bb13
  cf.br ^bb15
^bb15:  // pred: ^bb14
  %60 = arith.cmpi eq, %19, %22 : index
  %61 = arith.addi %16, %c1 : index
  %62 = arith.select %60, %61, %16 : index
  %63 = arith.cmpi eq, %20, %22 : index
  %64 = arith.addi %17, %c1 : index
  %65 = arith.select %63, %64, %17 : index
  cf.br ^bb3(%62, %65, %59 : index, index, f32)
^bb16:  // pred: ^bb3
  %66 = arith.addi %1, %c1 : index
  cf.br ^bb1(%66, %12 : index, f32)
^bb17:  // pred: ^bb1
  memref.store %2, %alloc[] : memref<f32>
  return %alloc : memref<f32>
}

// -----// IR Dump After ExpandStridedMetadata (expand-strided-metadata) //----- //
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
    memref.store %cst, %alloc[] : memref<f32>
    %0 = memref.load %alloc[] : memref<f32>
    cf.br ^bb1(%c0, %0 : index, f32)
  ^bb1(%1: index, %2: f32):  // 2 preds: ^bb0, ^bb15
    %3 = arith.cmpi slt, %1, %c128 : index
    cf.cond_br %3, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %4 = memref.load %arg0[%1] : memref<?xindex>
    %5 = arith.addi %1, %c1 : index
    %6 = memref.load %arg0[%5] : memref<?xindex>
    %7 = memref.load %arg6[%1] : memref<?xindex>
    %8 = arith.addi %1, %c1 : index
    %9 = memref.load %arg6[%8] : memref<?xindex>
    cf.br ^bb3(%4, %7, %2 : index, index, f32)
  ^bb3(%10: index, %11: index, %12: f32):  // 2 preds: ^bb2, ^bb14
    %13 = arith.cmpi ult, %10, %6 : index
    %14 = arith.cmpi ult, %11, %9 : index
    %15 = arith.andi %13, %14 : i1
    cf.cond_br %15, ^bb4(%10, %11, %12 : index, index, f32), ^bb15
  ^bb4(%16: index, %17: index, %18: f32):  // pred: ^bb3
    %19 = memref.load %arg1[%16] : memref<?xindex>
    %20 = memref.load %arg7[%17] : memref<?xindex>
    %21 = arith.cmpi ult, %20, %19 : index
    %22 = arith.select %21, %20, %19 : index
    %23 = arith.cmpi eq, %19, %22 : index
    %24 = arith.cmpi eq, %20, %22 : index
    %25 = arith.andi %23, %24 : i1
    cf.cond_br %25, ^bb5, ^bb12(%18 : f32)
  ^bb5:  // pred: ^bb4
    %26 = memref.load %arg2[%16] : memref<?xindex>
    %27 = arith.addi %16, %c1 : index
    %28 = memref.load %arg2[%27] : memref<?xindex>
    %29 = memref.load %arg8[%17] : memref<?xindex>
    %30 = arith.addi %17, %c1 : index
    %31 = memref.load %arg8[%30] : memref<?xindex>
    cf.br ^bb6(%26, %29, %18 : index, index, f32)
  ^bb6(%32: index, %33: index, %34: f32):  // 2 preds: ^bb5, ^bb11
    %35 = arith.cmpi ult, %32, %28 : index
    %36 = arith.cmpi ult, %33, %31 : index
    %37 = arith.andi %35, %36 : i1
    cf.cond_br %37, ^bb7(%32, %33, %34 : index, index, f32), ^bb12(%34 : f32)
  ^bb7(%38: index, %39: index, %40: f32):  // pred: ^bb6
    %41 = memref.load %arg3[%38] : memref<?xindex>
    %42 = memref.load %arg9[%39] : memref<?xindex>
    %43 = arith.cmpi ult, %42, %41 : index
    %44 = arith.select %43, %42, %41 : index
    %45 = arith.cmpi eq, %41, %44 : index
    %46 = arith.cmpi eq, %42, %44 : index
    %47 = arith.andi %45, %46 : i1
    cf.cond_br %47, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %48 = memref.load %arg4[%38] : memref<?xf32>
    %49 = memref.load %arg10[%39] : memref<?xf32>
    %50 = arith.mulf %48, %49 : f32
    %51 = arith.addf %40, %50 : f32
    cf.br ^bb10(%51 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%40 : f32)
  ^bb10(%52: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %53 = arith.cmpi eq, %41, %44 : index
    %54 = arith.addi %38, %c1 : index
    %55 = arith.select %53, %54, %38 : index
    %56 = arith.cmpi eq, %42, %44 : index
    %57 = arith.addi %39, %c1 : index
    %58 = arith.select %56, %57, %39 : index
    cf.br ^bb6(%55, %58, %52 : index, index, f32)
  ^bb12(%59: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%59 : f32)
  ^bb13(%60: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %61 = arith.cmpi eq, %19, %22 : index
    %62 = arith.addi %16, %c1 : index
    %63 = arith.select %61, %62, %16 : index
    %64 = arith.cmpi eq, %20, %22 : index
    %65 = arith.addi %17, %c1 : index
    %66 = arith.select %64, %65, %17 : index
    cf.br ^bb3(%63, %66, %60 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %67 = arith.addi %1, %c1 : index
    cf.br ^bb1(%67, %12 : index, f32)
  ^bb16:  // pred: ^bb1
    memref.store %2, %alloc[] : memref<f32>
    return %alloc : memref<f32>
  }
}


// -----// IR Dump After ConvertAffineToStandard (lower-affine) //----- //
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
    memref.store %cst, %alloc[] : memref<f32>
    %0 = memref.load %alloc[] : memref<f32>
    cf.br ^bb1(%c0, %0 : index, f32)
  ^bb1(%1: index, %2: f32):  // 2 preds: ^bb0, ^bb15
    %3 = arith.cmpi slt, %1, %c128 : index
    cf.cond_br %3, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %4 = memref.load %arg0[%1] : memref<?xindex>
    %5 = arith.addi %1, %c1 : index
    %6 = memref.load %arg0[%5] : memref<?xindex>
    %7 = memref.load %arg6[%1] : memref<?xindex>
    %8 = arith.addi %1, %c1 : index
    %9 = memref.load %arg6[%8] : memref<?xindex>
    cf.br ^bb3(%4, %7, %2 : index, index, f32)
  ^bb3(%10: index, %11: index, %12: f32):  // 2 preds: ^bb2, ^bb14
    %13 = arith.cmpi ult, %10, %6 : index
    %14 = arith.cmpi ult, %11, %9 : index
    %15 = arith.andi %13, %14 : i1
    cf.cond_br %15, ^bb4(%10, %11, %12 : index, index, f32), ^bb15
  ^bb4(%16: index, %17: index, %18: f32):  // pred: ^bb3
    %19 = memref.load %arg1[%16] : memref<?xindex>
    %20 = memref.load %arg7[%17] : memref<?xindex>
    %21 = arith.cmpi ult, %20, %19 : index
    %22 = arith.select %21, %20, %19 : index
    %23 = arith.cmpi eq, %19, %22 : index
    %24 = arith.cmpi eq, %20, %22 : index
    %25 = arith.andi %23, %24 : i1
    cf.cond_br %25, ^bb5, ^bb12(%18 : f32)
  ^bb5:  // pred: ^bb4
    %26 = memref.load %arg2[%16] : memref<?xindex>
    %27 = arith.addi %16, %c1 : index
    %28 = memref.load %arg2[%27] : memref<?xindex>
    %29 = memref.load %arg8[%17] : memref<?xindex>
    %30 = arith.addi %17, %c1 : index
    %31 = memref.load %arg8[%30] : memref<?xindex>
    cf.br ^bb6(%26, %29, %18 : index, index, f32)
  ^bb6(%32: index, %33: index, %34: f32):  // 2 preds: ^bb5, ^bb11
    %35 = arith.cmpi ult, %32, %28 : index
    %36 = arith.cmpi ult, %33, %31 : index
    %37 = arith.andi %35, %36 : i1
    cf.cond_br %37, ^bb7(%32, %33, %34 : index, index, f32), ^bb12(%34 : f32)
  ^bb7(%38: index, %39: index, %40: f32):  // pred: ^bb6
    %41 = memref.load %arg3[%38] : memref<?xindex>
    %42 = memref.load %arg9[%39] : memref<?xindex>
    %43 = arith.cmpi ult, %42, %41 : index
    %44 = arith.select %43, %42, %41 : index
    %45 = arith.cmpi eq, %41, %44 : index
    %46 = arith.cmpi eq, %42, %44 : index
    %47 = arith.andi %45, %46 : i1
    cf.cond_br %47, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %48 = memref.load %arg4[%38] : memref<?xf32>
    %49 = memref.load %arg10[%39] : memref<?xf32>
    %50 = arith.mulf %48, %49 : f32
    %51 = arith.addf %40, %50 : f32
    cf.br ^bb10(%51 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%40 : f32)
  ^bb10(%52: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %53 = arith.cmpi eq, %41, %44 : index
    %54 = arith.addi %38, %c1 : index
    %55 = arith.select %53, %54, %38 : index
    %56 = arith.cmpi eq, %42, %44 : index
    %57 = arith.addi %39, %c1 : index
    %58 = arith.select %56, %57, %39 : index
    cf.br ^bb6(%55, %58, %52 : index, index, f32)
  ^bb12(%59: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%59 : f32)
  ^bb13(%60: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %61 = arith.cmpi eq, %19, %22 : index
    %62 = arith.addi %16, %c1 : index
    %63 = arith.select %61, %62, %16 : index
    %64 = arith.cmpi eq, %20, %22 : index
    %65 = arith.addi %17, %c1 : index
    %66 = arith.select %64, %65, %17 : index
    cf.br ^bb3(%63, %66, %60 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %67 = arith.addi %1, %c1 : index
    cf.br ^bb1(%67, %12 : index, f32)
  ^bb16:  // pred: ^bb1
    memref.store %2, %alloc[] : memref<f32>
    return %alloc : memref<f32>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<f32>
    memref.store %cst, %alloc[] : memref<f32>
    %0 = memref.load %alloc[] : memref<f32>
    cf.br ^bb1(%c0, %0 : index, f32)
  ^bb1(%1: index, %2: f32):  // 2 preds: ^bb0, ^bb15
    %3 = arith.cmpi slt, %1, %c128 : index
    cf.cond_br %3, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %4 = memref.load %arg0[%1] : memref<?xindex>
    %5 = arith.addi %1, %c1 : index
    %6 = memref.load %arg0[%5] : memref<?xindex>
    %7 = memref.load %arg6[%1] : memref<?xindex>
    %8 = arith.addi %1, %c1 : index
    %9 = memref.load %arg6[%8] : memref<?xindex>
    cf.br ^bb3(%4, %7, %2 : index, index, f32)
  ^bb3(%10: index, %11: index, %12: f32):  // 2 preds: ^bb2, ^bb14
    %13 = arith.cmpi ult, %10, %6 : index
    %14 = arith.cmpi ult, %11, %9 : index
    %15 = arith.andi %13, %14 : i1
    cf.cond_br %15, ^bb4(%10, %11, %12 : index, index, f32), ^bb15
  ^bb4(%16: index, %17: index, %18: f32):  // pred: ^bb3
    %19 = memref.load %arg1[%16] : memref<?xindex>
    %20 = memref.load %arg7[%17] : memref<?xindex>
    %21 = arith.cmpi ult, %20, %19 : index
    %22 = arith.select %21, %20, %19 : index
    %23 = arith.cmpi eq, %19, %22 : index
    %24 = arith.cmpi eq, %20, %22 : index
    %25 = arith.andi %23, %24 : i1
    cf.cond_br %25, ^bb5, ^bb12(%18 : f32)
  ^bb5:  // pred: ^bb4
    %26 = memref.load %arg2[%16] : memref<?xindex>
    %27 = arith.addi %16, %c1 : index
    %28 = memref.load %arg2[%27] : memref<?xindex>
    %29 = memref.load %arg8[%17] : memref<?xindex>
    %30 = arith.addi %17, %c1 : index
    %31 = memref.load %arg8[%30] : memref<?xindex>
    cf.br ^bb6(%26, %29, %18 : index, index, f32)
  ^bb6(%32: index, %33: index, %34: f32):  // 2 preds: ^bb5, ^bb11
    %35 = arith.cmpi ult, %32, %28 : index
    %36 = arith.cmpi ult, %33, %31 : index
    %37 = arith.andi %35, %36 : i1
    cf.cond_br %37, ^bb7(%32, %33, %34 : index, index, f32), ^bb12(%34 : f32)
  ^bb7(%38: index, %39: index, %40: f32):  // pred: ^bb6
    %41 = memref.load %arg3[%38] : memref<?xindex>
    %42 = memref.load %arg9[%39] : memref<?xindex>
    %43 = arith.cmpi ult, %42, %41 : index
    %44 = arith.select %43, %42, %41 : index
    %45 = arith.cmpi eq, %41, %44 : index
    %46 = arith.cmpi eq, %42, %44 : index
    %47 = arith.andi %45, %46 : i1
    cf.cond_br %47, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %48 = memref.load %arg4[%38] : memref<?xf32>
    %49 = memref.load %arg10[%39] : memref<?xf32>
    %50 = arith.mulf %48, %49 : f32
    %51 = arith.addf %40, %50 : f32
    cf.br ^bb10(%51 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%40 : f32)
  ^bb10(%52: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %53 = arith.cmpi eq, %41, %44 : index
    %54 = arith.addi %38, %c1 : index
    %55 = arith.select %53, %54, %38 : index
    %56 = arith.cmpi eq, %42, %44 : index
    %57 = arith.addi %39, %c1 : index
    %58 = arith.select %56, %57, %39 : index
    cf.br ^bb6(%55, %58, %52 : index, index, f32)
  ^bb12(%59: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%59 : f32)
  ^bb13(%60: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %61 = arith.cmpi eq, %19, %22 : index
    %62 = arith.addi %16, %c1 : index
    %63 = arith.select %61, %62, %16 : index
    %64 = arith.cmpi eq, %20, %22 : index
    %65 = arith.addi %17, %c1 : index
    %66 = arith.select %64, %65, %17 : index
    cf.br ^bb3(%63, %66, %60 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %67 = arith.addi %1, %c1 : index
    cf.br ^bb1(%67, %12 : index, f32)
  ^bb16:  // pred: ^bb1
    memref.store %2, %alloc[] : memref<f32>
    return %alloc : memref<f32>
  }
}


// -----// IR Dump After FinalizeMemRefToLLVMConversionPass (finalize-memref-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %10 = llvm.mlir.constant(1 : index) : i64
    %11 = llvm.mlir.null : !llvm.ptr
    %12 = llvm.getelementptr %11[%10] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %13 = llvm.ptrtoint %12 : !llvm.ptr to i64
    %14 = llvm.mlir.constant(64 : index) : i64
    %15 = llvm.add %13, %14  : i64
    %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
    %17 = llvm.ptrtoint %16 : !llvm.ptr to i64
    %18 = llvm.mlir.constant(1 : index) : i64
    %19 = llvm.sub %14, %18  : i64
    %20 = llvm.add %17, %19  : i64
    %21 = llvm.urem %20, %14  : i64
    %22 = llvm.sub %20, %21  : i64
    %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %25 = llvm.insertvalue %16, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.mlir.constant(0 : index) : i64
    %28 = llvm.insertvalue %27, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
    %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    %30 = llvm.extractvalue %28[1] : !llvm.struct<(ptr, ptr, i64)> 
    llvm.store %cst, %30 : f32, !llvm.ptr
    %31 = llvm.extractvalue %28[1] : !llvm.struct<(ptr, ptr, i64)> 
    %32 = llvm.load %31 : !llvm.ptr -> f32
    cf.br ^bb1(%c0, %32 : index, f32)
  ^bb1(%33: index, %34: f32):  // 2 preds: ^bb0, ^bb15
    %35 = builtin.unrealized_conversion_cast %33 : index to i64
    %36 = arith.cmpi slt, %33, %c128 : index
    cf.cond_br %36, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %37 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.getelementptr %37[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %39 = llvm.load %38 : !llvm.ptr -> i64
    %40 = builtin.unrealized_conversion_cast %39 : i64 to index
    %41 = arith.addi %33, %c1 : index
    %42 = builtin.unrealized_conversion_cast %41 : index to i64
    %43 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.getelementptr %43[%42] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %45 = llvm.load %44 : !llvm.ptr -> i64
    %46 = builtin.unrealized_conversion_cast %45 : i64 to index
    %47 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.getelementptr %47[%35] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %49 = llvm.load %48 : !llvm.ptr -> i64
    %50 = builtin.unrealized_conversion_cast %49 : i64 to index
    %51 = arith.addi %33, %c1 : index
    %52 = builtin.unrealized_conversion_cast %51 : index to i64
    %53 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.getelementptr %53[%52] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %55 = llvm.load %54 : !llvm.ptr -> i64
    %56 = builtin.unrealized_conversion_cast %55 : i64 to index
    cf.br ^bb3(%40, %50, %34 : index, index, f32)
  ^bb3(%57: index, %58: index, %59: f32):  // 2 preds: ^bb2, ^bb14
    %60 = arith.cmpi ult, %57, %46 : index
    %61 = arith.cmpi ult, %58, %56 : index
    %62 = arith.andi %60, %61 : i1
    cf.cond_br %62, ^bb4(%57, %58, %59 : index, index, f32), ^bb15
  ^bb4(%63: index, %64: index, %65: f32):  // pred: ^bb3
    %66 = builtin.unrealized_conversion_cast %63 : index to i64
    %67 = builtin.unrealized_conversion_cast %64 : index to i64
    %68 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = llvm.getelementptr %68[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %70 = llvm.load %69 : !llvm.ptr -> i64
    %71 = builtin.unrealized_conversion_cast %70 : i64 to index
    %72 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %73 = llvm.getelementptr %72[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %74 = llvm.load %73 : !llvm.ptr -> i64
    %75 = builtin.unrealized_conversion_cast %74 : i64 to index
    %76 = arith.cmpi ult, %75, %71 : index
    %77 = arith.select %76, %75, %71 : index
    %78 = arith.cmpi eq, %71, %77 : index
    %79 = arith.cmpi eq, %75, %77 : index
    %80 = arith.andi %78, %79 : i1
    cf.cond_br %80, ^bb5, ^bb12(%65 : f32)
  ^bb5:  // pred: ^bb4
    %81 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %82 = llvm.getelementptr %81[%66] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %83 = llvm.load %82 : !llvm.ptr -> i64
    %84 = builtin.unrealized_conversion_cast %83 : i64 to index
    %85 = arith.addi %63, %c1 : index
    %86 = builtin.unrealized_conversion_cast %85 : index to i64
    %87 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %88 = llvm.getelementptr %87[%86] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %89 = llvm.load %88 : !llvm.ptr -> i64
    %90 = builtin.unrealized_conversion_cast %89 : i64 to index
    %91 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %92 = llvm.getelementptr %91[%67] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %93 = llvm.load %92 : !llvm.ptr -> i64
    %94 = builtin.unrealized_conversion_cast %93 : i64 to index
    %95 = arith.addi %64, %c1 : index
    %96 = builtin.unrealized_conversion_cast %95 : index to i64
    %97 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %98 = llvm.getelementptr %97[%96] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %99 = llvm.load %98 : !llvm.ptr -> i64
    %100 = builtin.unrealized_conversion_cast %99 : i64 to index
    cf.br ^bb6(%84, %94, %65 : index, index, f32)
  ^bb6(%101: index, %102: index, %103: f32):  // 2 preds: ^bb5, ^bb11
    %104 = arith.cmpi ult, %101, %90 : index
    %105 = arith.cmpi ult, %102, %100 : index
    %106 = arith.andi %104, %105 : i1
    cf.cond_br %106, ^bb7(%101, %102, %103 : index, index, f32), ^bb12(%103 : f32)
  ^bb7(%107: index, %108: index, %109: f32):  // pred: ^bb6
    %110 = builtin.unrealized_conversion_cast %107 : index to i64
    %111 = builtin.unrealized_conversion_cast %108 : index to i64
    %112 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %113 = llvm.getelementptr %112[%110] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %114 = llvm.load %113 : !llvm.ptr -> i64
    %115 = builtin.unrealized_conversion_cast %114 : i64 to index
    %116 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%111] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %118 = llvm.load %117 : !llvm.ptr -> i64
    %119 = builtin.unrealized_conversion_cast %118 : i64 to index
    %120 = arith.cmpi ult, %119, %115 : index
    %121 = arith.select %120, %119, %115 : index
    %122 = arith.cmpi eq, %115, %121 : index
    %123 = arith.cmpi eq, %119, %121 : index
    %124 = arith.andi %122, %123 : i1
    cf.cond_br %124, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %125 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%110] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %127 = llvm.load %126 : !llvm.ptr -> f32
    %128 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %129 = llvm.getelementptr %128[%111] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %130 = llvm.load %129 : !llvm.ptr -> f32
    %131 = arith.mulf %127, %130 : f32
    %132 = arith.addf %109, %131 : f32
    cf.br ^bb10(%132 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%109 : f32)
  ^bb10(%133: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %134 = arith.cmpi eq, %115, %121 : index
    %135 = arith.addi %107, %c1 : index
    %136 = arith.select %134, %135, %107 : index
    %137 = arith.cmpi eq, %119, %121 : index
    %138 = arith.addi %108, %c1 : index
    %139 = arith.select %137, %138, %108 : index
    cf.br ^bb6(%136, %139, %133 : index, index, f32)
  ^bb12(%140: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%140 : f32)
  ^bb13(%141: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %142 = arith.cmpi eq, %71, %77 : index
    %143 = arith.addi %63, %c1 : index
    %144 = arith.select %142, %143, %63 : index
    %145 = arith.cmpi eq, %75, %77 : index
    %146 = arith.addi %64, %c1 : index
    %147 = arith.select %145, %146, %64 : index
    cf.br ^bb3(%144, %147, %141 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %148 = arith.addi %33, %c1 : index
    cf.br ^bb1(%148, %59 : index, f32)
  ^bb16:  // pred: ^bb1
    %149 = llvm.extractvalue %28[1] : !llvm.struct<(ptr, ptr, i64)> 
    llvm.store %34, %149 : f32, !llvm.ptr
    return %29 : memref<f32>
  }
}


// -----// IR Dump After ConvertComplexToStandard (convert-complex-to-standard) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %6 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %7 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %8 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %9 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %10 = llvm.mlir.constant(1 : index) : i64
  %11 = llvm.mlir.null : !llvm.ptr
  %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, f32
  %13 = llvm.ptrtoint %12 : !llvm.ptr to i64
  %14 = llvm.mlir.constant(64 : index) : i64
  %15 = llvm.add %13, %14  : i64
  %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
  %17 = llvm.ptrtoint %16 : !llvm.ptr to i64
  %18 = llvm.mlir.constant(1 : index) : i64
  %19 = llvm.sub %14, %18  : i64
  %20 = llvm.add %17, %19  : i64
  %21 = llvm.urem %20, %14  : i64
  %22 = llvm.sub %20, %21  : i64
  %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
  %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
  %25 = llvm.insertvalue %16, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
  %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
  %27 = llvm.mlir.constant(0 : index) : i64
  %28 = llvm.insertvalue %27, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
  %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
  llvm.store %cst, %23 : f32, !llvm.ptr
  %30 = llvm.load %23 : !llvm.ptr -> f32
  cf.br ^bb1(%c0, %30 : index, f32)
^bb1(%31: index, %32: f32):  // 2 preds: ^bb0, ^bb15
  %33 = builtin.unrealized_conversion_cast %31 : index to i64
  %34 = arith.cmpi slt, %31, %c128 : index
  cf.cond_br %34, ^bb2, ^bb16
^bb2:  // pred: ^bb1
  %35 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %36 = llvm.getelementptr %35[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %37 = llvm.load %36 : !llvm.ptr -> i64
  %38 = builtin.unrealized_conversion_cast %37 : i64 to index
  %39 = arith.addi %31, %c1 : index
  %40 = builtin.unrealized_conversion_cast %39 : index to i64
  %41 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %42 = llvm.getelementptr %41[%40] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %43 = llvm.load %42 : !llvm.ptr -> i64
  %44 = builtin.unrealized_conversion_cast %43 : i64 to index
  %45 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %46 = llvm.getelementptr %45[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %47 = llvm.load %46 : !llvm.ptr -> i64
  %48 = builtin.unrealized_conversion_cast %47 : i64 to index
  %49 = arith.addi %31, %c1 : index
  %50 = builtin.unrealized_conversion_cast %49 : index to i64
  %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = llvm.getelementptr %51[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %53 = llvm.load %52 : !llvm.ptr -> i64
  %54 = builtin.unrealized_conversion_cast %53 : i64 to index
  cf.br ^bb3(%38, %48, %32 : index, index, f32)
^bb3(%55: index, %56: index, %57: f32):  // 2 preds: ^bb2, ^bb14
  %58 = arith.cmpi ult, %55, %44 : index
  %59 = arith.cmpi ult, %56, %54 : index
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb4(%55, %56, %57 : index, index, f32), ^bb15
^bb4(%61: index, %62: index, %63: f32):  // pred: ^bb3
  %64 = builtin.unrealized_conversion_cast %61 : index to i64
  %65 = builtin.unrealized_conversion_cast %62 : index to i64
  %66 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %67 = llvm.getelementptr %66[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %68 = llvm.load %67 : !llvm.ptr -> i64
  %69 = builtin.unrealized_conversion_cast %68 : i64 to index
  %70 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %71 = llvm.getelementptr %70[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %72 = llvm.load %71 : !llvm.ptr -> i64
  %73 = builtin.unrealized_conversion_cast %72 : i64 to index
  %74 = arith.cmpi ult, %73, %69 : index
  %75 = arith.select %74, %73, %69 : index
  %76 = arith.cmpi eq, %69, %75 : index
  %77 = arith.cmpi eq, %73, %75 : index
  %78 = arith.andi %76, %77 : i1
  cf.cond_br %78, ^bb5, ^bb12(%63 : f32)
^bb5:  // pred: ^bb4
  %79 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %80 = llvm.getelementptr %79[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %81 = llvm.load %80 : !llvm.ptr -> i64
  %82 = builtin.unrealized_conversion_cast %81 : i64 to index
  %83 = arith.addi %61, %c1 : index
  %84 = builtin.unrealized_conversion_cast %83 : index to i64
  %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %86 = llvm.getelementptr %85[%84] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %87 = llvm.load %86 : !llvm.ptr -> i64
  %88 = builtin.unrealized_conversion_cast %87 : i64 to index
  %89 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %90 = llvm.getelementptr %89[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %91 = llvm.load %90 : !llvm.ptr -> i64
  %92 = builtin.unrealized_conversion_cast %91 : i64 to index
  %93 = arith.addi %62, %c1 : index
  %94 = builtin.unrealized_conversion_cast %93 : index to i64
  %95 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %97 = llvm.load %96 : !llvm.ptr -> i64
  %98 = builtin.unrealized_conversion_cast %97 : i64 to index
  cf.br ^bb6(%82, %92, %63 : index, index, f32)
^bb6(%99: index, %100: index, %101: f32):  // 2 preds: ^bb5, ^bb11
  %102 = arith.cmpi ult, %99, %88 : index
  %103 = arith.cmpi ult, %100, %98 : index
  %104 = arith.andi %102, %103 : i1
  cf.cond_br %104, ^bb7(%99, %100, %101 : index, index, f32), ^bb12(%101 : f32)
^bb7(%105: index, %106: index, %107: f32):  // pred: ^bb6
  %108 = builtin.unrealized_conversion_cast %105 : index to i64
  %109 = builtin.unrealized_conversion_cast %106 : index to i64
  %110 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %111 = llvm.getelementptr %110[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %112 = llvm.load %111 : !llvm.ptr -> i64
  %113 = builtin.unrealized_conversion_cast %112 : i64 to index
  %114 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %115 = llvm.getelementptr %114[%109] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %116 = llvm.load %115 : !llvm.ptr -> i64
  %117 = builtin.unrealized_conversion_cast %116 : i64 to index
  %118 = arith.cmpi ult, %117, %113 : index
  %119 = arith.select %118, %117, %113 : index
  %120 = arith.cmpi eq, %113, %119 : index
  %121 = arith.cmpi eq, %117, %119 : index
  %122 = arith.andi %120, %121 : i1
  cf.cond_br %122, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %123 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %124 = llvm.getelementptr %123[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %125 = llvm.load %124 : !llvm.ptr -> f32
  %126 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %127 = llvm.getelementptr %126[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %128 = llvm.load %127 : !llvm.ptr -> f32
  %129 = arith.mulf %125, %128 : f32
  %130 = arith.addf %107, %129 : f32
  cf.br ^bb10(%130 : f32)
^bb9:  // pred: ^bb7
  cf.br ^bb10(%107 : f32)
^bb10(%131: f32):  // 2 preds: ^bb8, ^bb9
  cf.br ^bb11
^bb11:  // pred: ^bb10
  %132 = arith.cmpi eq, %113, %119 : index
  %133 = arith.addi %105, %c1 : index
  %134 = arith.select %132, %133, %105 : index
  %135 = arith.cmpi eq, %117, %119 : index
  %136 = arith.addi %106, %c1 : index
  %137 = arith.select %135, %136, %106 : index
  cf.br ^bb6(%134, %137, %131 : index, index, f32)
^bb12(%138: f32):  // 2 preds: ^bb4, ^bb6
  cf.br ^bb13(%138 : f32)
^bb13(%139: f32):  // pred: ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  %140 = arith.cmpi eq, %69, %75 : index
  %141 = arith.addi %61, %c1 : index
  %142 = arith.select %140, %141, %61 : index
  %143 = arith.cmpi eq, %73, %75 : index
  %144 = arith.addi %62, %c1 : index
  %145 = arith.select %143, %144, %62 : index
  cf.br ^bb3(%142, %145, %139 : index, index, f32)
^bb15:  // pred: ^bb3
  %146 = arith.addi %31, %c1 : index
  cf.br ^bb1(%146, %57 : index, f32)
^bb16:  // pred: ^bb1
  llvm.store %32, %23 : f32, !llvm.ptr
  return %29 : memref<f32>
}

// -----// IR Dump After ArithExpandOps (arith-expand) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %6 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %7 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %8 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %9 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %10 = llvm.mlir.constant(1 : index) : i64
  %11 = llvm.mlir.null : !llvm.ptr
  %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, f32
  %13 = llvm.ptrtoint %12 : !llvm.ptr to i64
  %14 = llvm.mlir.constant(64 : index) : i64
  %15 = llvm.add %13, %14  : i64
  %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
  %17 = llvm.ptrtoint %16 : !llvm.ptr to i64
  %18 = llvm.mlir.constant(1 : index) : i64
  %19 = llvm.sub %14, %18  : i64
  %20 = llvm.add %17, %19  : i64
  %21 = llvm.urem %20, %14  : i64
  %22 = llvm.sub %20, %21  : i64
  %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
  %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
  %25 = llvm.insertvalue %16, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
  %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
  %27 = llvm.mlir.constant(0 : index) : i64
  %28 = llvm.insertvalue %27, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
  %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
  llvm.store %cst, %23 : f32, !llvm.ptr
  %30 = llvm.load %23 : !llvm.ptr -> f32
  cf.br ^bb1(%c0, %30 : index, f32)
^bb1(%31: index, %32: f32):  // 2 preds: ^bb0, ^bb15
  %33 = builtin.unrealized_conversion_cast %31 : index to i64
  %34 = arith.cmpi slt, %31, %c128 : index
  cf.cond_br %34, ^bb2, ^bb16
^bb2:  // pred: ^bb1
  %35 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %36 = llvm.getelementptr %35[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %37 = llvm.load %36 : !llvm.ptr -> i64
  %38 = builtin.unrealized_conversion_cast %37 : i64 to index
  %39 = arith.addi %31, %c1 : index
  %40 = builtin.unrealized_conversion_cast %39 : index to i64
  %41 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %42 = llvm.getelementptr %41[%40] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %43 = llvm.load %42 : !llvm.ptr -> i64
  %44 = builtin.unrealized_conversion_cast %43 : i64 to index
  %45 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %46 = llvm.getelementptr %45[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %47 = llvm.load %46 : !llvm.ptr -> i64
  %48 = builtin.unrealized_conversion_cast %47 : i64 to index
  %49 = arith.addi %31, %c1 : index
  %50 = builtin.unrealized_conversion_cast %49 : index to i64
  %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = llvm.getelementptr %51[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %53 = llvm.load %52 : !llvm.ptr -> i64
  %54 = builtin.unrealized_conversion_cast %53 : i64 to index
  cf.br ^bb3(%38, %48, %32 : index, index, f32)
^bb3(%55: index, %56: index, %57: f32):  // 2 preds: ^bb2, ^bb14
  %58 = arith.cmpi ult, %55, %44 : index
  %59 = arith.cmpi ult, %56, %54 : index
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb4(%55, %56, %57 : index, index, f32), ^bb15
^bb4(%61: index, %62: index, %63: f32):  // pred: ^bb3
  %64 = builtin.unrealized_conversion_cast %61 : index to i64
  %65 = builtin.unrealized_conversion_cast %62 : index to i64
  %66 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %67 = llvm.getelementptr %66[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %68 = llvm.load %67 : !llvm.ptr -> i64
  %69 = builtin.unrealized_conversion_cast %68 : i64 to index
  %70 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %71 = llvm.getelementptr %70[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %72 = llvm.load %71 : !llvm.ptr -> i64
  %73 = builtin.unrealized_conversion_cast %72 : i64 to index
  %74 = arith.cmpi ult, %73, %69 : index
  %75 = arith.select %74, %73, %69 : index
  %76 = arith.cmpi eq, %69, %75 : index
  %77 = arith.cmpi eq, %73, %75 : index
  %78 = arith.andi %76, %77 : i1
  cf.cond_br %78, ^bb5, ^bb12(%63 : f32)
^bb5:  // pred: ^bb4
  %79 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %80 = llvm.getelementptr %79[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %81 = llvm.load %80 : !llvm.ptr -> i64
  %82 = builtin.unrealized_conversion_cast %81 : i64 to index
  %83 = arith.addi %61, %c1 : index
  %84 = builtin.unrealized_conversion_cast %83 : index to i64
  %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %86 = llvm.getelementptr %85[%84] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %87 = llvm.load %86 : !llvm.ptr -> i64
  %88 = builtin.unrealized_conversion_cast %87 : i64 to index
  %89 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %90 = llvm.getelementptr %89[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %91 = llvm.load %90 : !llvm.ptr -> i64
  %92 = builtin.unrealized_conversion_cast %91 : i64 to index
  %93 = arith.addi %62, %c1 : index
  %94 = builtin.unrealized_conversion_cast %93 : index to i64
  %95 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %97 = llvm.load %96 : !llvm.ptr -> i64
  %98 = builtin.unrealized_conversion_cast %97 : i64 to index
  cf.br ^bb6(%82, %92, %63 : index, index, f32)
^bb6(%99: index, %100: index, %101: f32):  // 2 preds: ^bb5, ^bb11
  %102 = arith.cmpi ult, %99, %88 : index
  %103 = arith.cmpi ult, %100, %98 : index
  %104 = arith.andi %102, %103 : i1
  cf.cond_br %104, ^bb7(%99, %100, %101 : index, index, f32), ^bb12(%101 : f32)
^bb7(%105: index, %106: index, %107: f32):  // pred: ^bb6
  %108 = builtin.unrealized_conversion_cast %105 : index to i64
  %109 = builtin.unrealized_conversion_cast %106 : index to i64
  %110 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %111 = llvm.getelementptr %110[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %112 = llvm.load %111 : !llvm.ptr -> i64
  %113 = builtin.unrealized_conversion_cast %112 : i64 to index
  %114 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %115 = llvm.getelementptr %114[%109] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %116 = llvm.load %115 : !llvm.ptr -> i64
  %117 = builtin.unrealized_conversion_cast %116 : i64 to index
  %118 = arith.cmpi ult, %117, %113 : index
  %119 = arith.select %118, %117, %113 : index
  %120 = arith.cmpi eq, %113, %119 : index
  %121 = arith.cmpi eq, %117, %119 : index
  %122 = arith.andi %120, %121 : i1
  cf.cond_br %122, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %123 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %124 = llvm.getelementptr %123[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %125 = llvm.load %124 : !llvm.ptr -> f32
  %126 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %127 = llvm.getelementptr %126[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %128 = llvm.load %127 : !llvm.ptr -> f32
  %129 = arith.mulf %125, %128 : f32
  %130 = arith.addf %107, %129 : f32
  cf.br ^bb10(%130 : f32)
^bb9:  // pred: ^bb7
  cf.br ^bb10(%107 : f32)
^bb10(%131: f32):  // 2 preds: ^bb8, ^bb9
  cf.br ^bb11
^bb11:  // pred: ^bb10
  %132 = arith.cmpi eq, %113, %119 : index
  %133 = arith.addi %105, %c1 : index
  %134 = arith.select %132, %133, %105 : index
  %135 = arith.cmpi eq, %117, %119 : index
  %136 = arith.addi %106, %c1 : index
  %137 = arith.select %135, %136, %106 : index
  cf.br ^bb6(%134, %137, %131 : index, index, f32)
^bb12(%138: f32):  // 2 preds: ^bb4, ^bb6
  cf.br ^bb13(%138 : f32)
^bb13(%139: f32):  // pred: ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  %140 = arith.cmpi eq, %69, %75 : index
  %141 = arith.addi %61, %c1 : index
  %142 = arith.select %140, %141, %61 : index
  %143 = arith.cmpi eq, %73, %75 : index
  %144 = arith.addi %62, %c1 : index
  %145 = arith.select %143, %144, %62 : index
  cf.br ^bb3(%142, %145, %139 : index, index, f32)
^bb15:  // pred: ^bb3
  %146 = arith.addi %31, %c1 : index
  cf.br ^bb1(%146, %57 : index, f32)
^bb16:  // pred: ^bb1
  llvm.store %32, %23 : f32, !llvm.ptr
  return %29 : memref<f32>
}

// -----// IR Dump After ConvertMathToLLVMPass (convert-math-to-llvm) //----- //
func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
  %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %3 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %5 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %6 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %7 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %8 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %9 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
  %c128 = arith.constant 128 : index
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %cst = arith.constant 0.000000e+00 : f32
  %10 = llvm.mlir.constant(1 : index) : i64
  %11 = llvm.mlir.null : !llvm.ptr
  %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, f32
  %13 = llvm.ptrtoint %12 : !llvm.ptr to i64
  %14 = llvm.mlir.constant(64 : index) : i64
  %15 = llvm.add %13, %14  : i64
  %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
  %17 = llvm.ptrtoint %16 : !llvm.ptr to i64
  %18 = llvm.mlir.constant(1 : index) : i64
  %19 = llvm.sub %14, %18  : i64
  %20 = llvm.add %17, %19  : i64
  %21 = llvm.urem %20, %14  : i64
  %22 = llvm.sub %20, %21  : i64
  %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
  %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
  %25 = llvm.insertvalue %16, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
  %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
  %27 = llvm.mlir.constant(0 : index) : i64
  %28 = llvm.insertvalue %27, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
  %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
  llvm.store %cst, %23 : f32, !llvm.ptr
  %30 = llvm.load %23 : !llvm.ptr -> f32
  cf.br ^bb1(%c0, %30 : index, f32)
^bb1(%31: index, %32: f32):  // 2 preds: ^bb0, ^bb15
  %33 = builtin.unrealized_conversion_cast %31 : index to i64
  %34 = arith.cmpi slt, %31, %c128 : index
  cf.cond_br %34, ^bb2, ^bb16
^bb2:  // pred: ^bb1
  %35 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %36 = llvm.getelementptr %35[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %37 = llvm.load %36 : !llvm.ptr -> i64
  %38 = builtin.unrealized_conversion_cast %37 : i64 to index
  %39 = arith.addi %31, %c1 : index
  %40 = builtin.unrealized_conversion_cast %39 : index to i64
  %41 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %42 = llvm.getelementptr %41[%40] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %43 = llvm.load %42 : !llvm.ptr -> i64
  %44 = builtin.unrealized_conversion_cast %43 : i64 to index
  %45 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %46 = llvm.getelementptr %45[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %47 = llvm.load %46 : !llvm.ptr -> i64
  %48 = builtin.unrealized_conversion_cast %47 : i64 to index
  %49 = arith.addi %31, %c1 : index
  %50 = builtin.unrealized_conversion_cast %49 : index to i64
  %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %52 = llvm.getelementptr %51[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %53 = llvm.load %52 : !llvm.ptr -> i64
  %54 = builtin.unrealized_conversion_cast %53 : i64 to index
  cf.br ^bb3(%38, %48, %32 : index, index, f32)
^bb3(%55: index, %56: index, %57: f32):  // 2 preds: ^bb2, ^bb14
  %58 = arith.cmpi ult, %55, %44 : index
  %59 = arith.cmpi ult, %56, %54 : index
  %60 = arith.andi %58, %59 : i1
  cf.cond_br %60, ^bb4(%55, %56, %57 : index, index, f32), ^bb15
^bb4(%61: index, %62: index, %63: f32):  // pred: ^bb3
  %64 = builtin.unrealized_conversion_cast %61 : index to i64
  %65 = builtin.unrealized_conversion_cast %62 : index to i64
  %66 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %67 = llvm.getelementptr %66[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %68 = llvm.load %67 : !llvm.ptr -> i64
  %69 = builtin.unrealized_conversion_cast %68 : i64 to index
  %70 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %71 = llvm.getelementptr %70[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %72 = llvm.load %71 : !llvm.ptr -> i64
  %73 = builtin.unrealized_conversion_cast %72 : i64 to index
  %74 = arith.cmpi ult, %73, %69 : index
  %75 = arith.select %74, %73, %69 : index
  %76 = arith.cmpi eq, %69, %75 : index
  %77 = arith.cmpi eq, %73, %75 : index
  %78 = arith.andi %76, %77 : i1
  cf.cond_br %78, ^bb5, ^bb12(%63 : f32)
^bb5:  // pred: ^bb4
  %79 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %80 = llvm.getelementptr %79[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %81 = llvm.load %80 : !llvm.ptr -> i64
  %82 = builtin.unrealized_conversion_cast %81 : i64 to index
  %83 = arith.addi %61, %c1 : index
  %84 = builtin.unrealized_conversion_cast %83 : index to i64
  %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %86 = llvm.getelementptr %85[%84] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %87 = llvm.load %86 : !llvm.ptr -> i64
  %88 = builtin.unrealized_conversion_cast %87 : i64 to index
  %89 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %90 = llvm.getelementptr %89[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %91 = llvm.load %90 : !llvm.ptr -> i64
  %92 = builtin.unrealized_conversion_cast %91 : i64 to index
  %93 = arith.addi %62, %c1 : index
  %94 = builtin.unrealized_conversion_cast %93 : index to i64
  %95 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %97 = llvm.load %96 : !llvm.ptr -> i64
  %98 = builtin.unrealized_conversion_cast %97 : i64 to index
  cf.br ^bb6(%82, %92, %63 : index, index, f32)
^bb6(%99: index, %100: index, %101: f32):  // 2 preds: ^bb5, ^bb11
  %102 = arith.cmpi ult, %99, %88 : index
  %103 = arith.cmpi ult, %100, %98 : index
  %104 = arith.andi %102, %103 : i1
  cf.cond_br %104, ^bb7(%99, %100, %101 : index, index, f32), ^bb12(%101 : f32)
^bb7(%105: index, %106: index, %107: f32):  // pred: ^bb6
  %108 = builtin.unrealized_conversion_cast %105 : index to i64
  %109 = builtin.unrealized_conversion_cast %106 : index to i64
  %110 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %111 = llvm.getelementptr %110[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %112 = llvm.load %111 : !llvm.ptr -> i64
  %113 = builtin.unrealized_conversion_cast %112 : i64 to index
  %114 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %115 = llvm.getelementptr %114[%109] : (!llvm.ptr, i64) -> !llvm.ptr, i64
  %116 = llvm.load %115 : !llvm.ptr -> i64
  %117 = builtin.unrealized_conversion_cast %116 : i64 to index
  %118 = arith.cmpi ult, %117, %113 : index
  %119 = arith.select %118, %117, %113 : index
  %120 = arith.cmpi eq, %113, %119 : index
  %121 = arith.cmpi eq, %117, %119 : index
  %122 = arith.andi %120, %121 : i1
  cf.cond_br %122, ^bb8, ^bb9
^bb8:  // pred: ^bb7
  %123 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %124 = llvm.getelementptr %123[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %125 = llvm.load %124 : !llvm.ptr -> f32
  %126 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
  %127 = llvm.getelementptr %126[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
  %128 = llvm.load %127 : !llvm.ptr -> f32
  %129 = arith.mulf %125, %128 : f32
  %130 = arith.addf %107, %129 : f32
  cf.br ^bb10(%130 : f32)
^bb9:  // pred: ^bb7
  cf.br ^bb10(%107 : f32)
^bb10(%131: f32):  // 2 preds: ^bb8, ^bb9
  cf.br ^bb11
^bb11:  // pred: ^bb10
  %132 = arith.cmpi eq, %113, %119 : index
  %133 = arith.addi %105, %c1 : index
  %134 = arith.select %132, %133, %105 : index
  %135 = arith.cmpi eq, %117, %119 : index
  %136 = arith.addi %106, %c1 : index
  %137 = arith.select %135, %136, %106 : index
  cf.br ^bb6(%134, %137, %131 : index, index, f32)
^bb12(%138: f32):  // 2 preds: ^bb4, ^bb6
  cf.br ^bb13(%138 : f32)
^bb13(%139: f32):  // pred: ^bb12
  cf.br ^bb14
^bb14:  // pred: ^bb13
  %140 = arith.cmpi eq, %69, %75 : index
  %141 = arith.addi %61, %c1 : index
  %142 = arith.select %140, %141, %61 : index
  %143 = arith.cmpi eq, %73, %75 : index
  %144 = arith.addi %62, %c1 : index
  %145 = arith.select %143, %144, %62 : index
  cf.br ^bb3(%142, %145, %139 : index, index, f32)
^bb15:  // pred: ^bb3
  %146 = arith.addi %31, %c1 : index
  cf.br ^bb1(%146, %57 : index, f32)
^bb16:  // pred: ^bb1
  llvm.store %32, %23 : f32, !llvm.ptr
  return %29 : memref<f32>
}

// -----// IR Dump After ConvertMathToLibm (convert-math-to-libm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %10 = llvm.mlir.constant(1 : index) : i64
    %11 = llvm.mlir.null : !llvm.ptr
    %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %13 = llvm.ptrtoint %12 : !llvm.ptr to i64
    %14 = llvm.mlir.constant(64 : index) : i64
    %15 = llvm.add %13, %14  : i64
    %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
    %17 = llvm.ptrtoint %16 : !llvm.ptr to i64
    %18 = llvm.mlir.constant(1 : index) : i64
    %19 = llvm.sub %14, %18  : i64
    %20 = llvm.add %17, %19  : i64
    %21 = llvm.urem %20, %14  : i64
    %22 = llvm.sub %20, %21  : i64
    %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %25 = llvm.insertvalue %16, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.mlir.constant(0 : index) : i64
    %28 = llvm.insertvalue %27, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
    %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %cst, %23 : f32, !llvm.ptr
    %30 = llvm.load %23 : !llvm.ptr -> f32
    cf.br ^bb1(%c0, %30 : index, f32)
  ^bb1(%31: index, %32: f32):  // 2 preds: ^bb0, ^bb15
    %33 = builtin.unrealized_conversion_cast %31 : index to i64
    %34 = arith.cmpi slt, %31, %c128 : index
    cf.cond_br %34, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.getelementptr %35[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %37 = llvm.load %36 : !llvm.ptr -> i64
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %31, %c1 : index
    %40 = builtin.unrealized_conversion_cast %39 : index to i64
    %41 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%40] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %43 = llvm.load %42 : !llvm.ptr -> i64
    %44 = builtin.unrealized_conversion_cast %43 : i64 to index
    %45 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %47 = llvm.load %46 : !llvm.ptr -> i64
    %48 = builtin.unrealized_conversion_cast %47 : i64 to index
    %49 = arith.addi %31, %c1 : index
    %50 = builtin.unrealized_conversion_cast %49 : index to i64
    %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    cf.br ^bb3(%38, %48, %32 : index, index, f32)
  ^bb3(%55: index, %56: index, %57: f32):  // 2 preds: ^bb2, ^bb14
    %58 = arith.cmpi ult, %55, %44 : index
    %59 = arith.cmpi ult, %56, %54 : index
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb4(%55, %56, %57 : index, index, f32), ^bb15
  ^bb4(%61: index, %62: index, %63: f32):  // pred: ^bb3
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = builtin.unrealized_conversion_cast %62 : index to i64
    %66 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.getelementptr %66[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %68 = llvm.load %67 : !llvm.ptr -> i64
    %69 = builtin.unrealized_conversion_cast %68 : i64 to index
    %70 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %71 = llvm.getelementptr %70[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %72 = llvm.load %71 : !llvm.ptr -> i64
    %73 = builtin.unrealized_conversion_cast %72 : i64 to index
    %74 = arith.cmpi ult, %73, %69 : index
    %75 = arith.select %74, %73, %69 : index
    %76 = arith.cmpi eq, %69, %75 : index
    %77 = arith.cmpi eq, %73, %75 : index
    %78 = arith.andi %76, %77 : i1
    cf.cond_br %78, ^bb5, ^bb12(%63 : f32)
  ^bb5:  // pred: ^bb4
    %79 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = llvm.getelementptr %79[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %81 = llvm.load %80 : !llvm.ptr -> i64
    %82 = builtin.unrealized_conversion_cast %81 : i64 to index
    %83 = arith.addi %61, %c1 : index
    %84 = builtin.unrealized_conversion_cast %83 : index to i64
    %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %86 = llvm.getelementptr %85[%84] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %87 = llvm.load %86 : !llvm.ptr -> i64
    %88 = builtin.unrealized_conversion_cast %87 : i64 to index
    %89 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %91 = llvm.load %90 : !llvm.ptr -> i64
    %92 = builtin.unrealized_conversion_cast %91 : i64 to index
    %93 = arith.addi %62, %c1 : index
    %94 = builtin.unrealized_conversion_cast %93 : index to i64
    %95 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    cf.br ^bb6(%82, %92, %63 : index, index, f32)
  ^bb6(%99: index, %100: index, %101: f32):  // 2 preds: ^bb5, ^bb11
    %102 = arith.cmpi ult, %99, %88 : index
    %103 = arith.cmpi ult, %100, %98 : index
    %104 = arith.andi %102, %103 : i1
    cf.cond_br %104, ^bb7(%99, %100, %101 : index, index, f32), ^bb12(%101 : f32)
  ^bb7(%105: index, %106: index, %107: f32):  // pred: ^bb6
    %108 = builtin.unrealized_conversion_cast %105 : index to i64
    %109 = builtin.unrealized_conversion_cast %106 : index to i64
    %110 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%109] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %117, %113 : index
    %119 = arith.select %118, %117, %113 : index
    %120 = arith.cmpi eq, %113, %119 : index
    %121 = arith.cmpi eq, %117, %119 : index
    %122 = arith.andi %120, %121 : i1
    cf.cond_br %122, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %123 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.getelementptr %123[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %125 = llvm.load %124 : !llvm.ptr -> f32
    %126 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %127 = llvm.getelementptr %126[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %128 = llvm.load %127 : !llvm.ptr -> f32
    %129 = arith.mulf %125, %128 : f32
    %130 = arith.addf %107, %129 : f32
    cf.br ^bb10(%130 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%107 : f32)
  ^bb10(%131: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %132 = arith.cmpi eq, %113, %119 : index
    %133 = arith.addi %105, %c1 : index
    %134 = arith.select %132, %133, %105 : index
    %135 = arith.cmpi eq, %117, %119 : index
    %136 = arith.addi %106, %c1 : index
    %137 = arith.select %135, %136, %106 : index
    cf.br ^bb6(%134, %137, %131 : index, index, f32)
  ^bb12(%138: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%138 : f32)
  ^bb13(%139: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %140 = arith.cmpi eq, %69, %75 : index
    %141 = arith.addi %61, %c1 : index
    %142 = arith.select %140, %141, %61 : index
    %143 = arith.cmpi eq, %73, %75 : index
    %144 = arith.addi %62, %c1 : index
    %145 = arith.select %143, %144, %62 : index
    cf.br ^bb3(%142, %145, %139 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %146 = arith.addi %31, %c1 : index
    cf.br ^bb1(%146, %57 : index, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %32, %23 : f32, !llvm.ptr
    return %29 : memref<f32>
  }
}


// -----// IR Dump After ConvertComplexToLibm (convert-complex-to-libm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %0 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %3 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %10 = llvm.mlir.constant(1 : index) : i64
    %11 = llvm.mlir.null : !llvm.ptr
    %12 = llvm.getelementptr %11[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %13 = llvm.ptrtoint %12 : !llvm.ptr to i64
    %14 = llvm.mlir.constant(64 : index) : i64
    %15 = llvm.add %13, %14  : i64
    %16 = llvm.call @malloc(%15) : (i64) -> !llvm.ptr
    %17 = llvm.ptrtoint %16 : !llvm.ptr to i64
    %18 = llvm.mlir.constant(1 : index) : i64
    %19 = llvm.sub %14, %18  : i64
    %20 = llvm.add %17, %19  : i64
    %21 = llvm.urem %20, %14  : i64
    %22 = llvm.sub %20, %21  : i64
    %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %25 = llvm.insertvalue %16, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.mlir.constant(0 : index) : i64
    %28 = llvm.insertvalue %27, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
    %29 = builtin.unrealized_conversion_cast %28 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %cst, %23 : f32, !llvm.ptr
    %30 = llvm.load %23 : !llvm.ptr -> f32
    cf.br ^bb1(%c0, %30 : index, f32)
  ^bb1(%31: index, %32: f32):  // 2 preds: ^bb0, ^bb15
    %33 = builtin.unrealized_conversion_cast %31 : index to i64
    %34 = arith.cmpi slt, %31, %c128 : index
    cf.cond_br %34, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.getelementptr %35[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %37 = llvm.load %36 : !llvm.ptr -> i64
    %38 = builtin.unrealized_conversion_cast %37 : i64 to index
    %39 = arith.addi %31, %c1 : index
    %40 = builtin.unrealized_conversion_cast %39 : index to i64
    %41 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.getelementptr %41[%40] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %43 = llvm.load %42 : !llvm.ptr -> i64
    %44 = builtin.unrealized_conversion_cast %43 : i64 to index
    %45 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.getelementptr %45[%33] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %47 = llvm.load %46 : !llvm.ptr -> i64
    %48 = builtin.unrealized_conversion_cast %47 : i64 to index
    %49 = arith.addi %31, %c1 : index
    %50 = builtin.unrealized_conversion_cast %49 : index to i64
    %51 = llvm.extractvalue %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.getelementptr %51[%50] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %53 = llvm.load %52 : !llvm.ptr -> i64
    %54 = builtin.unrealized_conversion_cast %53 : i64 to index
    cf.br ^bb3(%38, %48, %32 : index, index, f32)
  ^bb3(%55: index, %56: index, %57: f32):  // 2 preds: ^bb2, ^bb14
    %58 = arith.cmpi ult, %55, %44 : index
    %59 = arith.cmpi ult, %56, %54 : index
    %60 = arith.andi %58, %59 : i1
    cf.cond_br %60, ^bb4(%55, %56, %57 : index, index, f32), ^bb15
  ^bb4(%61: index, %62: index, %63: f32):  // pred: ^bb3
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = builtin.unrealized_conversion_cast %62 : index to i64
    %66 = llvm.extractvalue %2[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.getelementptr %66[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %68 = llvm.load %67 : !llvm.ptr -> i64
    %69 = builtin.unrealized_conversion_cast %68 : i64 to index
    %70 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %71 = llvm.getelementptr %70[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %72 = llvm.load %71 : !llvm.ptr -> i64
    %73 = builtin.unrealized_conversion_cast %72 : i64 to index
    %74 = arith.cmpi ult, %73, %69 : index
    %75 = arith.select %74, %73, %69 : index
    %76 = arith.cmpi eq, %69, %75 : index
    %77 = arith.cmpi eq, %73, %75 : index
    %78 = arith.andi %76, %77 : i1
    cf.cond_br %78, ^bb5, ^bb12(%63 : f32)
  ^bb5:  // pred: ^bb4
    %79 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %80 = llvm.getelementptr %79[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %81 = llvm.load %80 : !llvm.ptr -> i64
    %82 = builtin.unrealized_conversion_cast %81 : i64 to index
    %83 = arith.addi %61, %c1 : index
    %84 = builtin.unrealized_conversion_cast %83 : index to i64
    %85 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %86 = llvm.getelementptr %85[%84] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %87 = llvm.load %86 : !llvm.ptr -> i64
    %88 = builtin.unrealized_conversion_cast %87 : i64 to index
    %89 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %90 = llvm.getelementptr %89[%65] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %91 = llvm.load %90 : !llvm.ptr -> i64
    %92 = builtin.unrealized_conversion_cast %91 : i64 to index
    %93 = arith.addi %62, %c1 : index
    %94 = builtin.unrealized_conversion_cast %93 : index to i64
    %95 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %96 = llvm.getelementptr %95[%94] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %97 = llvm.load %96 : !llvm.ptr -> i64
    %98 = builtin.unrealized_conversion_cast %97 : i64 to index
    cf.br ^bb6(%82, %92, %63 : index, index, f32)
  ^bb6(%99: index, %100: index, %101: f32):  // 2 preds: ^bb5, ^bb11
    %102 = arith.cmpi ult, %99, %88 : index
    %103 = arith.cmpi ult, %100, %98 : index
    %104 = arith.andi %102, %103 : i1
    cf.cond_br %104, ^bb7(%99, %100, %101 : index, index, f32), ^bb12(%101 : f32)
  ^bb7(%105: index, %106: index, %107: f32):  // pred: ^bb6
    %108 = builtin.unrealized_conversion_cast %105 : index to i64
    %109 = builtin.unrealized_conversion_cast %106 : index to i64
    %110 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %111 = llvm.getelementptr %110[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %112 = llvm.load %111 : !llvm.ptr -> i64
    %113 = builtin.unrealized_conversion_cast %112 : i64 to index
    %114 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %115 = llvm.getelementptr %114[%109] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %116 = llvm.load %115 : !llvm.ptr -> i64
    %117 = builtin.unrealized_conversion_cast %116 : i64 to index
    %118 = arith.cmpi ult, %117, %113 : index
    %119 = arith.select %118, %117, %113 : index
    %120 = arith.cmpi eq, %113, %119 : index
    %121 = arith.cmpi eq, %117, %119 : index
    %122 = arith.andi %120, %121 : i1
    cf.cond_br %122, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %123 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %124 = llvm.getelementptr %123[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %125 = llvm.load %124 : !llvm.ptr -> f32
    %126 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %127 = llvm.getelementptr %126[%109] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %128 = llvm.load %127 : !llvm.ptr -> f32
    %129 = arith.mulf %125, %128 : f32
    %130 = arith.addf %107, %129 : f32
    cf.br ^bb10(%130 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%107 : f32)
  ^bb10(%131: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %132 = arith.cmpi eq, %113, %119 : index
    %133 = arith.addi %105, %c1 : index
    %134 = arith.select %132, %133, %105 : index
    %135 = arith.cmpi eq, %117, %119 : index
    %136 = arith.addi %106, %c1 : index
    %137 = arith.select %135, %136, %106 : index
    cf.br ^bb6(%134, %137, %131 : index, index, f32)
  ^bb12(%138: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%138 : f32)
  ^bb13(%139: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %140 = arith.cmpi eq, %69, %75 : index
    %141 = arith.addi %61, %c1 : index
    %142 = arith.select %140, %141, %61 : index
    %143 = arith.cmpi eq, %73, %75 : index
    %144 = arith.addi %62, %c1 : index
    %145 = arith.select %143, %144, %62 : index
    cf.br ^bb3(%142, %145, %139 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %146 = arith.addi %31, %c1 : index
    cf.br ^bb1(%146, %57 : index, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %32, %23 : f32, !llvm.ptr
    return %29 : memref<f32>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(64 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c128 = arith.constant 128 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.mlir.null : !llvm.ptr
    %14 = llvm.getelementptr %13[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
    %16 = llvm.add %15, %1  : i64
    %17 = llvm.call @malloc(%16) : (i64) -> !llvm.ptr
    %18 = llvm.ptrtoint %17 : !llvm.ptr to i64
    %19 = llvm.sub %1, %2  : i64
    %20 = llvm.add %18, %19  : i64
    %21 = llvm.urem %20, %1  : i64
    %22 = llvm.sub %20, %21  : i64
    %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %25 = llvm.insertvalue %17, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.insertvalue %0, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
    %28 = builtin.unrealized_conversion_cast %27 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %cst, %23 : f32, !llvm.ptr
    %29 = llvm.load %23 : !llvm.ptr -> f32
    cf.br ^bb1(%c0, %29 : index, f32)
  ^bb1(%30: index, %31: f32):  // 2 preds: ^bb0, ^bb15
    %32 = builtin.unrealized_conversion_cast %30 : index to i64
    %33 = arith.cmpi slt, %30, %c128 : index
    cf.cond_br %33, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %34 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.getelementptr %34[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %36 = llvm.load %35 : !llvm.ptr -> i64
    %37 = builtin.unrealized_conversion_cast %36 : i64 to index
    %38 = arith.addi %30, %c1 : index
    %39 = builtin.unrealized_conversion_cast %38 : index to i64
    %40 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%39] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.getelementptr %44[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %46 = llvm.load %45 : !llvm.ptr -> i64
    %47 = builtin.unrealized_conversion_cast %46 : i64 to index
    %48 = arith.addi %30, %c1 : index
    %49 = builtin.unrealized_conversion_cast %48 : index to i64
    %50 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = builtin.unrealized_conversion_cast %52 : i64 to index
    cf.br ^bb3(%37, %47, %31 : index, index, f32)
  ^bb3(%54: index, %55: index, %56: f32):  // 2 preds: ^bb2, ^bb14
    %57 = arith.cmpi ult, %54, %43 : index
    %58 = arith.cmpi ult, %55, %53 : index
    %59 = arith.andi %57, %58 : i1
    cf.cond_br %59, ^bb4(%54, %55, %56 : index, index, f32), ^bb15
  ^bb4(%60: index, %61: index, %62: f32):  // pred: ^bb3
    %63 = builtin.unrealized_conversion_cast %60 : index to i64
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.getelementptr %65[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %67 = llvm.load %66 : !llvm.ptr -> i64
    %68 = builtin.unrealized_conversion_cast %67 : i64 to index
    %69 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = arith.cmpi ult, %72, %68 : index
    %74 = arith.select %73, %72, %68 : index
    %75 = arith.cmpi eq, %68, %74 : index
    %76 = arith.cmpi eq, %72, %74 : index
    %77 = arith.andi %75, %76 : i1
    cf.cond_br %77, ^bb5, ^bb12(%62 : f32)
  ^bb5:  // pred: ^bb4
    %78 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.getelementptr %78[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %80 = llvm.load %79 : !llvm.ptr -> i64
    %81 = builtin.unrealized_conversion_cast %80 : i64 to index
    %82 = arith.addi %60, %c1 : index
    %83 = builtin.unrealized_conversion_cast %82 : index to i64
    %84 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = builtin.unrealized_conversion_cast %86 : i64 to index
    %88 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = llvm.getelementptr %88[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %90 = llvm.load %89 : !llvm.ptr -> i64
    %91 = builtin.unrealized_conversion_cast %90 : i64 to index
    %92 = arith.addi %61, %c1 : index
    %93 = builtin.unrealized_conversion_cast %92 : index to i64
    %94 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %95 = llvm.getelementptr %94[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %96 = llvm.load %95 : !llvm.ptr -> i64
    %97 = builtin.unrealized_conversion_cast %96 : i64 to index
    cf.br ^bb6(%81, %91, %62 : index, index, f32)
  ^bb6(%98: index, %99: index, %100: f32):  // 2 preds: ^bb5, ^bb11
    %101 = arith.cmpi ult, %98, %87 : index
    %102 = arith.cmpi ult, %99, %97 : index
    %103 = arith.andi %101, %102 : i1
    cf.cond_br %103, ^bb7(%98, %99, %100 : index, index, f32), ^bb12(%100 : f32)
  ^bb7(%104: index, %105: index, %106: f32):  // pred: ^bb6
    %107 = builtin.unrealized_conversion_cast %104 : index to i64
    %108 = builtin.unrealized_conversion_cast %105 : index to i64
    %109 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %111 = llvm.load %110 : !llvm.ptr -> i64
    %112 = builtin.unrealized_conversion_cast %111 : i64 to index
    %113 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.getelementptr %113[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %115 = llvm.load %114 : !llvm.ptr -> i64
    %116 = builtin.unrealized_conversion_cast %115 : i64 to index
    %117 = arith.cmpi ult, %116, %112 : index
    %118 = arith.select %117, %116, %112 : index
    %119 = arith.cmpi eq, %112, %118 : index
    %120 = arith.cmpi eq, %116, %118 : index
    %121 = arith.andi %119, %120 : i1
    cf.cond_br %121, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %122 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %124 = llvm.load %123 : !llvm.ptr -> f32
    %125 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %127 = llvm.load %126 : !llvm.ptr -> f32
    %128 = arith.mulf %124, %127 : f32
    %129 = arith.addf %106, %128 : f32
    cf.br ^bb10(%129 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%106 : f32)
  ^bb10(%130: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %131 = arith.cmpi eq, %112, %118 : index
    %132 = arith.addi %104, %c1 : index
    %133 = arith.select %131, %132, %104 : index
    %134 = arith.cmpi eq, %116, %118 : index
    %135 = arith.addi %105, %c1 : index
    %136 = arith.select %134, %135, %105 : index
    cf.br ^bb6(%133, %136, %130 : index, index, f32)
  ^bb12(%137: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%137 : f32)
  ^bb13(%138: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %139 = arith.cmpi eq, %68, %74 : index
    %140 = arith.addi %60, %c1 : index
    %141 = arith.select %139, %140, %60 : index
    %142 = arith.cmpi eq, %72, %74 : index
    %143 = arith.addi %61, %c1 : index
    %144 = arith.select %142, %143, %61 : index
    cf.br ^bb3(%141, %144, %138 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %145 = arith.addi %30, %c1 : index
    cf.br ^bb1(%145, %56 : index, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %31, %23 : f32, !llvm.ptr
    return %28 : memref<f32>
  }
}


// -----// IR Dump After ConvertComplexToLLVMPass (convert-complex-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(64 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c128 = arith.constant 128 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.mlir.null : !llvm.ptr
    %14 = llvm.getelementptr %13[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
    %16 = llvm.add %15, %1  : i64
    %17 = llvm.call @malloc(%16) : (i64) -> !llvm.ptr
    %18 = llvm.ptrtoint %17 : !llvm.ptr to i64
    %19 = llvm.sub %1, %2  : i64
    %20 = llvm.add %18, %19  : i64
    %21 = llvm.urem %20, %1  : i64
    %22 = llvm.sub %20, %21  : i64
    %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %25 = llvm.insertvalue %17, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.insertvalue %0, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
    %28 = builtin.unrealized_conversion_cast %27 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %cst, %23 : f32, !llvm.ptr
    %29 = llvm.load %23 : !llvm.ptr -> f32
    cf.br ^bb1(%c0, %29 : index, f32)
  ^bb1(%30: index, %31: f32):  // 2 preds: ^bb0, ^bb15
    %32 = builtin.unrealized_conversion_cast %30 : index to i64
    %33 = arith.cmpi slt, %30, %c128 : index
    cf.cond_br %33, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %34 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.getelementptr %34[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %36 = llvm.load %35 : !llvm.ptr -> i64
    %37 = builtin.unrealized_conversion_cast %36 : i64 to index
    %38 = arith.addi %30, %c1 : index
    %39 = builtin.unrealized_conversion_cast %38 : index to i64
    %40 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%39] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.getelementptr %44[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %46 = llvm.load %45 : !llvm.ptr -> i64
    %47 = builtin.unrealized_conversion_cast %46 : i64 to index
    %48 = arith.addi %30, %c1 : index
    %49 = builtin.unrealized_conversion_cast %48 : index to i64
    %50 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = builtin.unrealized_conversion_cast %52 : i64 to index
    cf.br ^bb3(%37, %47, %31 : index, index, f32)
  ^bb3(%54: index, %55: index, %56: f32):  // 2 preds: ^bb2, ^bb14
    %57 = arith.cmpi ult, %54, %43 : index
    %58 = arith.cmpi ult, %55, %53 : index
    %59 = arith.andi %57, %58 : i1
    cf.cond_br %59, ^bb4(%54, %55, %56 : index, index, f32), ^bb15
  ^bb4(%60: index, %61: index, %62: f32):  // pred: ^bb3
    %63 = builtin.unrealized_conversion_cast %60 : index to i64
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.getelementptr %65[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %67 = llvm.load %66 : !llvm.ptr -> i64
    %68 = builtin.unrealized_conversion_cast %67 : i64 to index
    %69 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = arith.cmpi ult, %72, %68 : index
    %74 = arith.select %73, %72, %68 : index
    %75 = arith.cmpi eq, %68, %74 : index
    %76 = arith.cmpi eq, %72, %74 : index
    %77 = arith.andi %75, %76 : i1
    cf.cond_br %77, ^bb5, ^bb12(%62 : f32)
  ^bb5:  // pred: ^bb4
    %78 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.getelementptr %78[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %80 = llvm.load %79 : !llvm.ptr -> i64
    %81 = builtin.unrealized_conversion_cast %80 : i64 to index
    %82 = arith.addi %60, %c1 : index
    %83 = builtin.unrealized_conversion_cast %82 : index to i64
    %84 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = builtin.unrealized_conversion_cast %86 : i64 to index
    %88 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = llvm.getelementptr %88[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %90 = llvm.load %89 : !llvm.ptr -> i64
    %91 = builtin.unrealized_conversion_cast %90 : i64 to index
    %92 = arith.addi %61, %c1 : index
    %93 = builtin.unrealized_conversion_cast %92 : index to i64
    %94 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %95 = llvm.getelementptr %94[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %96 = llvm.load %95 : !llvm.ptr -> i64
    %97 = builtin.unrealized_conversion_cast %96 : i64 to index
    cf.br ^bb6(%81, %91, %62 : index, index, f32)
  ^bb6(%98: index, %99: index, %100: f32):  // 2 preds: ^bb5, ^bb11
    %101 = arith.cmpi ult, %98, %87 : index
    %102 = arith.cmpi ult, %99, %97 : index
    %103 = arith.andi %101, %102 : i1
    cf.cond_br %103, ^bb7(%98, %99, %100 : index, index, f32), ^bb12(%100 : f32)
  ^bb7(%104: index, %105: index, %106: f32):  // pred: ^bb6
    %107 = builtin.unrealized_conversion_cast %104 : index to i64
    %108 = builtin.unrealized_conversion_cast %105 : index to i64
    %109 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %111 = llvm.load %110 : !llvm.ptr -> i64
    %112 = builtin.unrealized_conversion_cast %111 : i64 to index
    %113 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.getelementptr %113[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %115 = llvm.load %114 : !llvm.ptr -> i64
    %116 = builtin.unrealized_conversion_cast %115 : i64 to index
    %117 = arith.cmpi ult, %116, %112 : index
    %118 = arith.select %117, %116, %112 : index
    %119 = arith.cmpi eq, %112, %118 : index
    %120 = arith.cmpi eq, %116, %118 : index
    %121 = arith.andi %119, %120 : i1
    cf.cond_br %121, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %122 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %124 = llvm.load %123 : !llvm.ptr -> f32
    %125 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %127 = llvm.load %126 : !llvm.ptr -> f32
    %128 = arith.mulf %124, %127 : f32
    %129 = arith.addf %106, %128 : f32
    cf.br ^bb10(%129 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%106 : f32)
  ^bb10(%130: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %131 = arith.cmpi eq, %112, %118 : index
    %132 = arith.addi %104, %c1 : index
    %133 = arith.select %131, %132, %104 : index
    %134 = arith.cmpi eq, %116, %118 : index
    %135 = arith.addi %105, %c1 : index
    %136 = arith.select %134, %135, %105 : index
    cf.br ^bb6(%133, %136, %130 : index, index, f32)
  ^bb12(%137: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%137 : f32)
  ^bb13(%138: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %139 = arith.cmpi eq, %68, %74 : index
    %140 = arith.addi %60, %c1 : index
    %141 = arith.select %139, %140, %60 : index
    %142 = arith.cmpi eq, %72, %74 : index
    %143 = arith.addi %61, %c1 : index
    %144 = arith.select %142, %143, %61 : index
    cf.br ^bb3(%141, %144, %138 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %145 = arith.addi %30, %c1 : index
    cf.br ^bb1(%145, %56 : index, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %31, %23 : f32, !llvm.ptr
    return %28 : memref<f32>
  }
}


// -----// IR Dump After ConvertVectorToLLVMPass (convert-vector-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  func.func @InnerProd.z.0.main(%arg0: memref<?xindex>, %arg1: memref<?xindex>, %arg2: memref<?xindex>, %arg3: memref<?xindex>, %arg4: memref<?xf32>, %arg5: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg6: memref<?xindex>, %arg7: memref<?xindex>, %arg8: memref<?xindex>, %arg9: memref<?xindex>, %arg10: memref<?xf32>, %arg11: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> memref<f32> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.constant(0 : index) : i64
    %1 = llvm.mlir.constant(64 : index) : i64
    %2 = llvm.mlir.constant(1 : index) : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c128 = arith.constant 128 : index
    %3 = builtin.unrealized_conversion_cast %arg0 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %4 = builtin.unrealized_conversion_cast %arg6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %5 = builtin.unrealized_conversion_cast %arg1 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %6 = builtin.unrealized_conversion_cast %arg7 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = builtin.unrealized_conversion_cast %arg2 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = builtin.unrealized_conversion_cast %arg8 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %9 = builtin.unrealized_conversion_cast %arg3 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %10 = builtin.unrealized_conversion_cast %arg9 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %11 = builtin.unrealized_conversion_cast %arg4 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %12 = builtin.unrealized_conversion_cast %arg10 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.mlir.null : !llvm.ptr
    %14 = llvm.getelementptr %13[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %15 = llvm.ptrtoint %14 : !llvm.ptr to i64
    %16 = llvm.add %15, %1  : i64
    %17 = llvm.call @malloc(%16) : (i64) -> !llvm.ptr
    %18 = llvm.ptrtoint %17 : !llvm.ptr to i64
    %19 = llvm.sub %1, %2  : i64
    %20 = llvm.add %18, %19  : i64
    %21 = llvm.urem %20, %1  : i64
    %22 = llvm.sub %20, %21  : i64
    %23 = llvm.inttoptr %22 : i64 to !llvm.ptr
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %25 = llvm.insertvalue %17, %24[0] : !llvm.struct<(ptr, ptr, i64)> 
    %26 = llvm.insertvalue %23, %25[1] : !llvm.struct<(ptr, ptr, i64)> 
    %27 = llvm.insertvalue %0, %26[2] : !llvm.struct<(ptr, ptr, i64)> 
    %28 = builtin.unrealized_conversion_cast %27 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %cst, %23 : f32, !llvm.ptr
    %29 = llvm.load %23 : !llvm.ptr -> f32
    cf.br ^bb1(%c0, %29 : index, f32)
  ^bb1(%30: index, %31: f32):  // 2 preds: ^bb0, ^bb15
    %32 = builtin.unrealized_conversion_cast %30 : index to i64
    %33 = arith.cmpi slt, %30, %c128 : index
    cf.cond_br %33, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %34 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.getelementptr %34[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %36 = llvm.load %35 : !llvm.ptr -> i64
    %37 = builtin.unrealized_conversion_cast %36 : i64 to index
    %38 = arith.addi %30, %c1 : index
    %39 = builtin.unrealized_conversion_cast %38 : index to i64
    %40 = llvm.extractvalue %3[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.getelementptr %40[%39] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %42 = llvm.load %41 : !llvm.ptr -> i64
    %43 = builtin.unrealized_conversion_cast %42 : i64 to index
    %44 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.getelementptr %44[%32] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %46 = llvm.load %45 : !llvm.ptr -> i64
    %47 = builtin.unrealized_conversion_cast %46 : i64 to index
    %48 = arith.addi %30, %c1 : index
    %49 = builtin.unrealized_conversion_cast %48 : index to i64
    %50 = llvm.extractvalue %4[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.getelementptr %50[%49] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %52 = llvm.load %51 : !llvm.ptr -> i64
    %53 = builtin.unrealized_conversion_cast %52 : i64 to index
    cf.br ^bb3(%37, %47, %31 : index, index, f32)
  ^bb3(%54: index, %55: index, %56: f32):  // 2 preds: ^bb2, ^bb14
    %57 = arith.cmpi ult, %54, %43 : index
    %58 = arith.cmpi ult, %55, %53 : index
    %59 = arith.andi %57, %58 : i1
    cf.cond_br %59, ^bb4(%54, %55, %56 : index, index, f32), ^bb15
  ^bb4(%60: index, %61: index, %62: f32):  // pred: ^bb3
    %63 = builtin.unrealized_conversion_cast %60 : index to i64
    %64 = builtin.unrealized_conversion_cast %61 : index to i64
    %65 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.getelementptr %65[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %67 = llvm.load %66 : !llvm.ptr -> i64
    %68 = builtin.unrealized_conversion_cast %67 : i64 to index
    %69 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %70 = llvm.getelementptr %69[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %71 = llvm.load %70 : !llvm.ptr -> i64
    %72 = builtin.unrealized_conversion_cast %71 : i64 to index
    %73 = arith.cmpi ult, %72, %68 : index
    %74 = arith.select %73, %72, %68 : index
    %75 = arith.cmpi eq, %68, %74 : index
    %76 = arith.cmpi eq, %72, %74 : index
    %77 = arith.andi %75, %76 : i1
    cf.cond_br %77, ^bb5, ^bb12(%62 : f32)
  ^bb5:  // pred: ^bb4
    %78 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %79 = llvm.getelementptr %78[%63] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %80 = llvm.load %79 : !llvm.ptr -> i64
    %81 = builtin.unrealized_conversion_cast %80 : i64 to index
    %82 = arith.addi %60, %c1 : index
    %83 = builtin.unrealized_conversion_cast %82 : index to i64
    %84 = llvm.extractvalue %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %85 = llvm.getelementptr %84[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %86 = llvm.load %85 : !llvm.ptr -> i64
    %87 = builtin.unrealized_conversion_cast %86 : i64 to index
    %88 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %89 = llvm.getelementptr %88[%64] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %90 = llvm.load %89 : !llvm.ptr -> i64
    %91 = builtin.unrealized_conversion_cast %90 : i64 to index
    %92 = arith.addi %61, %c1 : index
    %93 = builtin.unrealized_conversion_cast %92 : index to i64
    %94 = llvm.extractvalue %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %95 = llvm.getelementptr %94[%93] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %96 = llvm.load %95 : !llvm.ptr -> i64
    %97 = builtin.unrealized_conversion_cast %96 : i64 to index
    cf.br ^bb6(%81, %91, %62 : index, index, f32)
  ^bb6(%98: index, %99: index, %100: f32):  // 2 preds: ^bb5, ^bb11
    %101 = arith.cmpi ult, %98, %87 : index
    %102 = arith.cmpi ult, %99, %97 : index
    %103 = arith.andi %101, %102 : i1
    cf.cond_br %103, ^bb7(%98, %99, %100 : index, index, f32), ^bb12(%100 : f32)
  ^bb7(%104: index, %105: index, %106: f32):  // pred: ^bb6
    %107 = builtin.unrealized_conversion_cast %104 : index to i64
    %108 = builtin.unrealized_conversion_cast %105 : index to i64
    %109 = llvm.extractvalue %9[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %111 = llvm.load %110 : !llvm.ptr -> i64
    %112 = builtin.unrealized_conversion_cast %111 : i64 to index
    %113 = llvm.extractvalue %10[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %114 = llvm.getelementptr %113[%108] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %115 = llvm.load %114 : !llvm.ptr -> i64
    %116 = builtin.unrealized_conversion_cast %115 : i64 to index
    %117 = arith.cmpi ult, %116, %112 : index
    %118 = arith.select %117, %116, %112 : index
    %119 = arith.cmpi eq, %112, %118 : index
    %120 = arith.cmpi eq, %116, %118 : index
    %121 = arith.andi %119, %120 : i1
    cf.cond_br %121, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %122 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %123 = llvm.getelementptr %122[%107] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %124 = llvm.load %123 : !llvm.ptr -> f32
    %125 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %126 = llvm.getelementptr %125[%108] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %127 = llvm.load %126 : !llvm.ptr -> f32
    %128 = arith.mulf %124, %127 : f32
    %129 = arith.addf %106, %128 : f32
    cf.br ^bb10(%129 : f32)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%106 : f32)
  ^bb10(%130: f32):  // 2 preds: ^bb8, ^bb9
    cf.br ^bb11
  ^bb11:  // pred: ^bb10
    %131 = arith.cmpi eq, %112, %118 : index
    %132 = arith.addi %104, %c1 : index
    %133 = arith.select %131, %132, %104 : index
    %134 = arith.cmpi eq, %116, %118 : index
    %135 = arith.addi %105, %c1 : index
    %136 = arith.select %134, %135, %105 : index
    cf.br ^bb6(%133, %136, %130 : index, index, f32)
  ^bb12(%137: f32):  // 2 preds: ^bb4, ^bb6
    cf.br ^bb13(%137 : f32)
  ^bb13(%138: f32):  // pred: ^bb12
    cf.br ^bb14
  ^bb14:  // pred: ^bb13
    %139 = arith.cmpi eq, %68, %74 : index
    %140 = arith.addi %60, %c1 : index
    %141 = arith.select %139, %140, %60 : index
    %142 = arith.cmpi eq, %72, %74 : index
    %143 = arith.addi %61, %c1 : index
    %144 = arith.select %142, %143, %61 : index
    cf.br ^bb3(%141, %144, %138 : index, index, f32)
  ^bb15:  // pred: ^bb3
    %145 = arith.addi %30, %c1 : index
    cf.br ^bb1(%145, %56 : index, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %31, %23 : f32, !llvm.ptr
    return %28 : memref<f32>
  }
}


// -----// IR Dump After ConvertOpenMPToLLVMPass (convert-openmp-to-llvm) //----- //
module {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @InnerProd.z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.ptr, %arg32: !llvm.ptr, %arg33: i64, %arg34: i64, %arg35: i64, %arg36: !llvm.ptr, %arg37: !llvm.ptr, %arg38: i64, %arg39: i64, %arg40: i64, %arg41: !llvm.ptr, %arg42: !llvm.ptr, %arg43: i64, %arg44: i64, %arg45: i64, %arg46: !llvm.ptr, %arg47: !llvm.ptr, %arg48: i64, %arg49: i64, %arg50: i64, %arg51: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> !llvm.struct<(ptr, ptr, i64)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg15, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg16, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg17, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg18, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg19, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg20, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg21, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg22, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg23, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg24, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg26, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg27, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg28, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg29, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg30, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %arg31, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %arg32, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %arg33, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %arg34, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %arg35, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %49 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %50 = llvm.insertvalue %arg36, %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %arg37, %50[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.insertvalue %arg38, %51[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %arg39, %52[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %arg40, %53[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = builtin.unrealized_conversion_cast %54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %56 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = llvm.insertvalue %arg41, %56[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %arg42, %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.insertvalue %arg43, %58[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.insertvalue %arg44, %59[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %arg45, %60[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = builtin.unrealized_conversion_cast %61 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %63 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %64 = llvm.insertvalue %arg46, %63[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %arg47, %64[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %arg48, %65[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %arg49, %66[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %arg50, %67[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %70 = llvm.mlir.constant(0 : index) : i64
    %71 = llvm.mlir.constant(64 : index) : i64
    %72 = llvm.mlir.constant(1 : index) : i64
    %73 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %74 = llvm.mlir.constant(1 : index) : i64
    %75 = llvm.mlir.constant(0 : index) : i64
    %76 = llvm.mlir.constant(128 : index) : i64
    %77 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %78 = builtin.unrealized_conversion_cast %41 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %79 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %80 = builtin.unrealized_conversion_cast %48 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %81 = builtin.unrealized_conversion_cast %20 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %82 = builtin.unrealized_conversion_cast %55 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %83 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %84 = builtin.unrealized_conversion_cast %62 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %85 = builtin.unrealized_conversion_cast %34 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %86 = builtin.unrealized_conversion_cast %69 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %87 = llvm.mlir.null : !llvm.ptr
    %88 = llvm.getelementptr %87[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %89 = llvm.ptrtoint %88 : !llvm.ptr to i64
    %90 = llvm.add %89, %71  : i64
    %91 = llvm.call @malloc(%90) : (i64) -> !llvm.ptr
    %92 = llvm.ptrtoint %91 : !llvm.ptr to i64
    %93 = llvm.sub %71, %72  : i64
    %94 = llvm.add %92, %93  : i64
    %95 = llvm.urem %94, %71  : i64
    %96 = llvm.sub %94, %95  : i64
    %97 = llvm.inttoptr %96 : i64 to !llvm.ptr
    %98 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %99 = llvm.insertvalue %91, %98[0] : !llvm.struct<(ptr, ptr, i64)> 
    %100 = llvm.insertvalue %97, %99[1] : !llvm.struct<(ptr, ptr, i64)> 
    %101 = llvm.insertvalue %70, %100[2] : !llvm.struct<(ptr, ptr, i64)> 
    %102 = builtin.unrealized_conversion_cast %101 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %73, %97 : f32, !llvm.ptr
    %103 = llvm.load %97 : !llvm.ptr -> f32
    llvm.br ^bb1(%75, %103 : i64, f32)
  ^bb1(%104: i64, %105: f32):  // 2 preds: ^bb0, ^bb15
    %106 = builtin.unrealized_conversion_cast %104 : i64 to index
    %107 = builtin.unrealized_conversion_cast %106 : index to i64
    %108 = llvm.icmp "slt" %104, %76 : i64
    llvm.cond_br %108, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %109 = llvm.extractvalue %77[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %111 = llvm.load %110 : !llvm.ptr -> i64
    %112 = builtin.unrealized_conversion_cast %111 : i64 to index
    %113 = llvm.add %104, %74  : i64
    %114 = builtin.unrealized_conversion_cast %113 : i64 to index
    %115 = builtin.unrealized_conversion_cast %114 : index to i64
    %116 = llvm.extractvalue %77[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%115] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %118 = llvm.load %117 : !llvm.ptr -> i64
    %119 = builtin.unrealized_conversion_cast %118 : i64 to index
    %120 = llvm.extractvalue %78[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.getelementptr %120[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %122 = llvm.load %121 : !llvm.ptr -> i64
    %123 = builtin.unrealized_conversion_cast %122 : i64 to index
    %124 = llvm.add %104, %74  : i64
    %125 = builtin.unrealized_conversion_cast %124 : i64 to index
    %126 = builtin.unrealized_conversion_cast %125 : index to i64
    %127 = llvm.extractvalue %78[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%126] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %129 = llvm.load %128 : !llvm.ptr -> i64
    %130 = builtin.unrealized_conversion_cast %129 : i64 to index
    llvm.br ^bb3(%111, %122, %105 : i64, i64, f32)
  ^bb3(%131: i64, %132: i64, %133: f32):  // 2 preds: ^bb2, ^bb14
    %134 = llvm.icmp "ult" %131, %118 : i64
    %135 = llvm.icmp "ult" %132, %129 : i64
    %136 = llvm.and %134, %135  : i1
    llvm.cond_br %136, ^bb4(%131, %132, %133 : i64, i64, f32), ^bb15
  ^bb4(%137: i64, %138: i64, %139: f32):  // pred: ^bb3
    %140 = builtin.unrealized_conversion_cast %138 : i64 to index
    %141 = builtin.unrealized_conversion_cast %137 : i64 to index
    %142 = builtin.unrealized_conversion_cast %141 : index to i64
    %143 = builtin.unrealized_conversion_cast %140 : index to i64
    %144 = llvm.extractvalue %79[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %146 = llvm.load %145 : !llvm.ptr -> i64
    %147 = builtin.unrealized_conversion_cast %146 : i64 to index
    %148 = llvm.extractvalue %80[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%143] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.icmp "ult" %150, %146 : i64
    %153 = llvm.select %152, %150, %146 : i1, i64
    %154 = llvm.icmp "eq" %146, %153 : i64
    %155 = llvm.icmp "eq" %150, %153 : i64
    %156 = llvm.and %154, %155  : i1
    llvm.cond_br %156, ^bb5, ^bb12(%139 : f32)
  ^bb5:  // pred: ^bb4
    %157 = llvm.extractvalue %81[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = builtin.unrealized_conversion_cast %159 : i64 to index
    %161 = llvm.add %137, %74  : i64
    %162 = builtin.unrealized_conversion_cast %161 : i64 to index
    %163 = builtin.unrealized_conversion_cast %162 : index to i64
    %164 = llvm.extractvalue %81[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%163] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = builtin.unrealized_conversion_cast %166 : i64 to index
    %168 = llvm.extractvalue %82[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %169 = llvm.getelementptr %168[%143] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %170 = llvm.load %169 : !llvm.ptr -> i64
    %171 = builtin.unrealized_conversion_cast %170 : i64 to index
    %172 = llvm.add %138, %74  : i64
    %173 = builtin.unrealized_conversion_cast %172 : i64 to index
    %174 = builtin.unrealized_conversion_cast %173 : index to i64
    %175 = llvm.extractvalue %82[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %176 = llvm.getelementptr %175[%174] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %177 = llvm.load %176 : !llvm.ptr -> i64
    %178 = builtin.unrealized_conversion_cast %177 : i64 to index
    llvm.br ^bb6(%159, %170, %139 : i64, i64, f32)
  ^bb6(%179: i64, %180: i64, %181: f32):  // 2 preds: ^bb5, ^bb11
    %182 = llvm.icmp "ult" %179, %166 : i64
    %183 = llvm.icmp "ult" %180, %177 : i64
    %184 = llvm.and %182, %183  : i1
    llvm.cond_br %184, ^bb7(%179, %180, %181 : i64, i64, f32), ^bb12(%181 : f32)
  ^bb7(%185: i64, %186: i64, %187: f32):  // pred: ^bb6
    %188 = builtin.unrealized_conversion_cast %186 : i64 to index
    %189 = builtin.unrealized_conversion_cast %185 : i64 to index
    %190 = builtin.unrealized_conversion_cast %189 : index to i64
    %191 = builtin.unrealized_conversion_cast %188 : index to i64
    %192 = llvm.extractvalue %83[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %193 = llvm.getelementptr %192[%190] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %194 = llvm.load %193 : !llvm.ptr -> i64
    %195 = builtin.unrealized_conversion_cast %194 : i64 to index
    %196 = llvm.extractvalue %84[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.getelementptr %196[%191] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %198 = llvm.load %197 : !llvm.ptr -> i64
    %199 = builtin.unrealized_conversion_cast %198 : i64 to index
    %200 = llvm.icmp "ult" %198, %194 : i64
    %201 = llvm.select %200, %198, %194 : i1, i64
    %202 = llvm.icmp "eq" %194, %201 : i64
    %203 = llvm.icmp "eq" %198, %201 : i64
    %204 = llvm.and %202, %203  : i1
    llvm.cond_br %204, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %205 = llvm.extractvalue %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%190] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %207 = llvm.load %206 : !llvm.ptr -> f32
    %208 = llvm.extractvalue %86[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %209 = llvm.getelementptr %208[%191] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %210 = llvm.load %209 : !llvm.ptr -> f32
    %211 = llvm.fmul %207, %210  : f32
    %212 = llvm.fadd %187, %211  : f32
    llvm.br ^bb10(%212 : f32)
  ^bb9:  // pred: ^bb7
    llvm.br ^bb10(%187 : f32)
  ^bb10(%213: f32):  // 2 preds: ^bb8, ^bb9
    llvm.br ^bb11
  ^bb11:  // pred: ^bb10
    %214 = llvm.icmp "eq" %194, %201 : i64
    %215 = llvm.add %185, %74  : i64
    %216 = llvm.select %214, %215, %185 : i1, i64
    %217 = llvm.icmp "eq" %198, %201 : i64
    %218 = llvm.add %186, %74  : i64
    %219 = llvm.select %217, %218, %186 : i1, i64
    llvm.br ^bb6(%216, %219, %213 : i64, i64, f32)
  ^bb12(%220: f32):  // 2 preds: ^bb4, ^bb6
    llvm.br ^bb13(%220 : f32)
  ^bb13(%221: f32):  // pred: ^bb12
    llvm.br ^bb14
  ^bb14:  // pred: ^bb13
    %222 = llvm.icmp "eq" %146, %153 : i64
    %223 = llvm.add %137, %74  : i64
    %224 = llvm.select %222, %223, %137 : i1, i64
    %225 = llvm.icmp "eq" %150, %153 : i64
    %226 = llvm.add %138, %74  : i64
    %227 = llvm.select %225, %226, %138 : i1, i64
    llvm.br ^bb3(%224, %227, %221 : i64, i64, f32)
  ^bb15:  // pred: ^bb3
    %228 = llvm.add %104, %74  : i64
    llvm.br ^bb1(%228, %133 : i64, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %105, %97 : f32, !llvm.ptr
    llvm.return %101 : !llvm.struct<(ptr, ptr, i64)>
  }
  llvm.func @_mlir_ciface_InnerProd.z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.ptr, %arg5: !llvm.ptr, %arg6: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg7: !llvm.ptr, %arg8: !llvm.ptr, %arg9: !llvm.ptr, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg4 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.load %arg8 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.extractvalue %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.extractvalue %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.extractvalue %36[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.extractvalue %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.extractvalue %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.load %arg9 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.extractvalue %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.extractvalue %42[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.extractvalue %42[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.load %arg10 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.extractvalue %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %48[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %48[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.load %arg11 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %55 = llvm.extractvalue %54[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.extractvalue %54[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.extractvalue %54[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.extractvalue %54[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.call @InnerProd.z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %arg6, %31, %32, %33, %34, %35, %37, %38, %39, %40, %41, %43, %44, %45, %46, %47, %49, %50, %51, %52, %53, %55, %56, %57, %58, %59, %arg12) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> !llvm.struct<(ptr, ptr, i64)>
    llvm.store %60, %arg0 : !llvm.struct<(ptr, ptr, i64)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ConvertFuncToLLVMPass (convert-func-to-llvm) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @InnerProd.z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.ptr, %arg32: !llvm.ptr, %arg33: i64, %arg34: i64, %arg35: i64, %arg36: !llvm.ptr, %arg37: !llvm.ptr, %arg38: i64, %arg39: i64, %arg40: i64, %arg41: !llvm.ptr, %arg42: !llvm.ptr, %arg43: i64, %arg44: i64, %arg45: i64, %arg46: !llvm.ptr, %arg47: !llvm.ptr, %arg48: i64, %arg49: i64, %arg50: i64, %arg51: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> !llvm.struct<(ptr, ptr, i64)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = builtin.unrealized_conversion_cast %5 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %7 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %8 = llvm.insertvalue %arg5, %7[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg6, %8[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg7, %9[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg8, %10[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.insertvalue %arg9, %11[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %13 = builtin.unrealized_conversion_cast %12 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %14 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %15 = llvm.insertvalue %arg10, %14[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg11, %15[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg12, %16[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.insertvalue %arg13, %17[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %19 = llvm.insertvalue %arg14, %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = builtin.unrealized_conversion_cast %19 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %22 = llvm.insertvalue %arg15, %21[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg16, %22[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.insertvalue %arg17, %23[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %25 = llvm.insertvalue %arg18, %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg19, %25[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = builtin.unrealized_conversion_cast %26 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %28 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %29 = llvm.insertvalue %arg20, %28[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.insertvalue %arg21, %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %31 = llvm.insertvalue %arg22, %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg23, %31[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg24, %32[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = builtin.unrealized_conversion_cast %33 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %35 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %36 = llvm.insertvalue %arg26, %35[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %37 = llvm.insertvalue %arg27, %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg28, %37[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg29, %38[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg30, %39[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = builtin.unrealized_conversion_cast %40 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %arg31, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %arg32, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %arg33, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %arg34, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %arg35, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = builtin.unrealized_conversion_cast %47 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %49 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %50 = llvm.insertvalue %arg36, %49[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %arg37, %50[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.insertvalue %arg38, %51[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %arg39, %52[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.insertvalue %arg40, %53[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %55 = builtin.unrealized_conversion_cast %54 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %56 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %57 = llvm.insertvalue %arg41, %56[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %arg42, %57[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.insertvalue %arg43, %58[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.insertvalue %arg44, %59[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %61 = llvm.insertvalue %arg45, %60[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %62 = builtin.unrealized_conversion_cast %61 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xindex>
    %63 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %64 = llvm.insertvalue %arg46, %63[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %65 = llvm.insertvalue %arg47, %64[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %66 = llvm.insertvalue %arg48, %65[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %67 = llvm.insertvalue %arg49, %66[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %68 = llvm.insertvalue %arg50, %67[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %69 = builtin.unrealized_conversion_cast %68 : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> to memref<?xf32>
    %70 = llvm.mlir.constant(0 : index) : i64
    %71 = llvm.mlir.constant(64 : index) : i64
    %72 = llvm.mlir.constant(1 : index) : i64
    %73 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %74 = llvm.mlir.constant(1 : index) : i64
    %75 = llvm.mlir.constant(0 : index) : i64
    %76 = llvm.mlir.constant(128 : index) : i64
    %77 = builtin.unrealized_conversion_cast %6 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %78 = builtin.unrealized_conversion_cast %41 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %79 = builtin.unrealized_conversion_cast %13 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %80 = builtin.unrealized_conversion_cast %48 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %81 = builtin.unrealized_conversion_cast %20 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %82 = builtin.unrealized_conversion_cast %55 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %83 = builtin.unrealized_conversion_cast %27 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %84 = builtin.unrealized_conversion_cast %62 : memref<?xindex> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %85 = builtin.unrealized_conversion_cast %34 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %86 = builtin.unrealized_conversion_cast %69 : memref<?xf32> to !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %87 = llvm.mlir.null : !llvm.ptr
    %88 = llvm.getelementptr %87[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %89 = llvm.ptrtoint %88 : !llvm.ptr to i64
    %90 = llvm.add %89, %71  : i64
    %91 = llvm.call @malloc(%90) : (i64) -> !llvm.ptr
    %92 = llvm.ptrtoint %91 : !llvm.ptr to i64
    %93 = llvm.sub %71, %72  : i64
    %94 = llvm.add %92, %93  : i64
    %95 = llvm.urem %94, %71  : i64
    %96 = llvm.sub %94, %95  : i64
    %97 = llvm.inttoptr %96 : i64 to !llvm.ptr
    %98 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %99 = llvm.insertvalue %91, %98[0] : !llvm.struct<(ptr, ptr, i64)> 
    %100 = llvm.insertvalue %97, %99[1] : !llvm.struct<(ptr, ptr, i64)> 
    %101 = llvm.insertvalue %70, %100[2] : !llvm.struct<(ptr, ptr, i64)> 
    %102 = builtin.unrealized_conversion_cast %101 : !llvm.struct<(ptr, ptr, i64)> to memref<f32>
    llvm.store %73, %97 : f32, !llvm.ptr
    %103 = llvm.load %97 : !llvm.ptr -> f32
    llvm.br ^bb1(%75, %103 : i64, f32)
  ^bb1(%104: i64, %105: f32):  // 2 preds: ^bb0, ^bb15
    %106 = builtin.unrealized_conversion_cast %104 : i64 to index
    %107 = builtin.unrealized_conversion_cast %106 : index to i64
    %108 = llvm.icmp "slt" %104, %76 : i64
    llvm.cond_br %108, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %109 = llvm.extractvalue %77[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %111 = llvm.load %110 : !llvm.ptr -> i64
    %112 = builtin.unrealized_conversion_cast %111 : i64 to index
    %113 = llvm.add %104, %74  : i64
    %114 = builtin.unrealized_conversion_cast %113 : i64 to index
    %115 = builtin.unrealized_conversion_cast %114 : index to i64
    %116 = llvm.extractvalue %77[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %117 = llvm.getelementptr %116[%115] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %118 = llvm.load %117 : !llvm.ptr -> i64
    %119 = builtin.unrealized_conversion_cast %118 : i64 to index
    %120 = llvm.extractvalue %78[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.getelementptr %120[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %122 = llvm.load %121 : !llvm.ptr -> i64
    %123 = builtin.unrealized_conversion_cast %122 : i64 to index
    %124 = llvm.add %104, %74  : i64
    %125 = builtin.unrealized_conversion_cast %124 : i64 to index
    %126 = builtin.unrealized_conversion_cast %125 : index to i64
    %127 = llvm.extractvalue %78[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%126] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %129 = llvm.load %128 : !llvm.ptr -> i64
    %130 = builtin.unrealized_conversion_cast %129 : i64 to index
    llvm.br ^bb3(%111, %122, %105 : i64, i64, f32)
  ^bb3(%131: i64, %132: i64, %133: f32):  // 2 preds: ^bb2, ^bb14
    %134 = llvm.icmp "ult" %131, %118 : i64
    %135 = llvm.icmp "ult" %132, %129 : i64
    %136 = llvm.and %134, %135  : i1
    llvm.cond_br %136, ^bb4(%131, %132, %133 : i64, i64, f32), ^bb15
  ^bb4(%137: i64, %138: i64, %139: f32):  // pred: ^bb3
    %140 = builtin.unrealized_conversion_cast %138 : i64 to index
    %141 = builtin.unrealized_conversion_cast %137 : i64 to index
    %142 = builtin.unrealized_conversion_cast %141 : index to i64
    %143 = builtin.unrealized_conversion_cast %140 : index to i64
    %144 = llvm.extractvalue %79[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %145 = llvm.getelementptr %144[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %146 = llvm.load %145 : !llvm.ptr -> i64
    %147 = builtin.unrealized_conversion_cast %146 : i64 to index
    %148 = llvm.extractvalue %80[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %149 = llvm.getelementptr %148[%143] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %150 = llvm.load %149 : !llvm.ptr -> i64
    %151 = builtin.unrealized_conversion_cast %150 : i64 to index
    %152 = llvm.icmp "ult" %150, %146 : i64
    %153 = llvm.select %152, %150, %146 : i1, i64
    %154 = llvm.icmp "eq" %146, %153 : i64
    %155 = llvm.icmp "eq" %150, %153 : i64
    %156 = llvm.and %154, %155  : i1
    llvm.cond_br %156, ^bb5, ^bb12(%139 : f32)
  ^bb5:  // pred: ^bb4
    %157 = llvm.extractvalue %81[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%142] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %159 = llvm.load %158 : !llvm.ptr -> i64
    %160 = builtin.unrealized_conversion_cast %159 : i64 to index
    %161 = llvm.add %137, %74  : i64
    %162 = builtin.unrealized_conversion_cast %161 : i64 to index
    %163 = builtin.unrealized_conversion_cast %162 : index to i64
    %164 = llvm.extractvalue %81[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %165 = llvm.getelementptr %164[%163] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %166 = llvm.load %165 : !llvm.ptr -> i64
    %167 = builtin.unrealized_conversion_cast %166 : i64 to index
    %168 = llvm.extractvalue %82[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %169 = llvm.getelementptr %168[%143] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %170 = llvm.load %169 : !llvm.ptr -> i64
    %171 = builtin.unrealized_conversion_cast %170 : i64 to index
    %172 = llvm.add %138, %74  : i64
    %173 = builtin.unrealized_conversion_cast %172 : i64 to index
    %174 = builtin.unrealized_conversion_cast %173 : index to i64
    %175 = llvm.extractvalue %82[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %176 = llvm.getelementptr %175[%174] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %177 = llvm.load %176 : !llvm.ptr -> i64
    %178 = builtin.unrealized_conversion_cast %177 : i64 to index
    llvm.br ^bb6(%159, %170, %139 : i64, i64, f32)
  ^bb6(%179: i64, %180: i64, %181: f32):  // 2 preds: ^bb5, ^bb11
    %182 = llvm.icmp "ult" %179, %166 : i64
    %183 = llvm.icmp "ult" %180, %177 : i64
    %184 = llvm.and %182, %183  : i1
    llvm.cond_br %184, ^bb7(%179, %180, %181 : i64, i64, f32), ^bb12(%181 : f32)
  ^bb7(%185: i64, %186: i64, %187: f32):  // pred: ^bb6
    %188 = builtin.unrealized_conversion_cast %186 : i64 to index
    %189 = builtin.unrealized_conversion_cast %185 : i64 to index
    %190 = builtin.unrealized_conversion_cast %189 : index to i64
    %191 = builtin.unrealized_conversion_cast %188 : index to i64
    %192 = llvm.extractvalue %83[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %193 = llvm.getelementptr %192[%190] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %194 = llvm.load %193 : !llvm.ptr -> i64
    %195 = builtin.unrealized_conversion_cast %194 : i64 to index
    %196 = llvm.extractvalue %84[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %197 = llvm.getelementptr %196[%191] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %198 = llvm.load %197 : !llvm.ptr -> i64
    %199 = builtin.unrealized_conversion_cast %198 : i64 to index
    %200 = llvm.icmp "ult" %198, %194 : i64
    %201 = llvm.select %200, %198, %194 : i1, i64
    %202 = llvm.icmp "eq" %194, %201 : i64
    %203 = llvm.icmp "eq" %198, %201 : i64
    %204 = llvm.and %202, %203  : i1
    llvm.cond_br %204, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %205 = llvm.extractvalue %85[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %206 = llvm.getelementptr %205[%190] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %207 = llvm.load %206 : !llvm.ptr -> f32
    %208 = llvm.extractvalue %86[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %209 = llvm.getelementptr %208[%191] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %210 = llvm.load %209 : !llvm.ptr -> f32
    %211 = llvm.fmul %207, %210  : f32
    %212 = llvm.fadd %187, %211  : f32
    llvm.br ^bb10(%212 : f32)
  ^bb9:  // pred: ^bb7
    llvm.br ^bb10(%187 : f32)
  ^bb10(%213: f32):  // 2 preds: ^bb8, ^bb9
    llvm.br ^bb11
  ^bb11:  // pred: ^bb10
    %214 = llvm.icmp "eq" %194, %201 : i64
    %215 = llvm.add %185, %74  : i64
    %216 = llvm.select %214, %215, %185 : i1, i64
    %217 = llvm.icmp "eq" %198, %201 : i64
    %218 = llvm.add %186, %74  : i64
    %219 = llvm.select %217, %218, %186 : i1, i64
    llvm.br ^bb6(%216, %219, %213 : i64, i64, f32)
  ^bb12(%220: f32):  // 2 preds: ^bb4, ^bb6
    llvm.br ^bb13(%220 : f32)
  ^bb13(%221: f32):  // pred: ^bb12
    llvm.br ^bb14
  ^bb14:  // pred: ^bb13
    %222 = llvm.icmp "eq" %146, %153 : i64
    %223 = llvm.add %137, %74  : i64
    %224 = llvm.select %222, %223, %137 : i1, i64
    %225 = llvm.icmp "eq" %150, %153 : i64
    %226 = llvm.add %138, %74  : i64
    %227 = llvm.select %225, %226, %138 : i1, i64
    llvm.br ^bb3(%224, %227, %221 : i64, i64, f32)
  ^bb15:  // pred: ^bb3
    %228 = llvm.add %104, %74  : i64
    llvm.br ^bb1(%228, %133 : i64, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %105, %97 : f32, !llvm.ptr
    llvm.return %101 : !llvm.struct<(ptr, ptr, i64)>
  }
  llvm.func @_mlir_ciface_InnerProd.z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.ptr, %arg5: !llvm.ptr, %arg6: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg7: !llvm.ptr, %arg8: !llvm.ptr, %arg9: !llvm.ptr, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg4 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.load %arg8 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.extractvalue %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.extractvalue %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.extractvalue %36[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.extractvalue %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.extractvalue %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.load %arg9 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.extractvalue %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.extractvalue %42[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.extractvalue %42[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.load %arg10 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.extractvalue %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %48[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %48[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.load %arg11 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %55 = llvm.extractvalue %54[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.extractvalue %54[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.extractvalue %54[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.extractvalue %54[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.call @InnerProd.z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %arg6, %31, %32, %33, %34, %35, %37, %38, %39, %40, %41, %43, %44, %45, %46, %47, %49, %50, %51, %52, %53, %55, %56, %57, %58, %59, %arg12) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> !llvm.struct<(ptr, ptr, i64)>
    llvm.store %60, %arg0 : !llvm.struct<(ptr, ptr, i64)>, !llvm.ptr
    llvm.return
  }
}


// -----// IR Dump After ReconcileUnrealizedCasts (reconcile-unrealized-casts) //----- //
module attributes {llvm.data_layout = ""} {
  llvm.func @malloc(i64) -> !llvm.ptr
  llvm.func @InnerProd.z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: i64, %arg3: i64, %arg4: i64, %arg5: !llvm.ptr, %arg6: !llvm.ptr, %arg7: i64, %arg8: i64, %arg9: i64, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: i64, %arg13: i64, %arg14: i64, %arg15: !llvm.ptr, %arg16: !llvm.ptr, %arg17: i64, %arg18: i64, %arg19: i64, %arg20: !llvm.ptr, %arg21: !llvm.ptr, %arg22: i64, %arg23: i64, %arg24: i64, %arg25: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg26: !llvm.ptr, %arg27: !llvm.ptr, %arg28: i64, %arg29: i64, %arg30: i64, %arg31: !llvm.ptr, %arg32: !llvm.ptr, %arg33: i64, %arg34: i64, %arg35: i64, %arg36: !llvm.ptr, %arg37: !llvm.ptr, %arg38: i64, %arg39: i64, %arg40: i64, %arg41: !llvm.ptr, %arg42: !llvm.ptr, %arg43: i64, %arg44: i64, %arg45: i64, %arg46: !llvm.ptr, %arg47: !llvm.ptr, %arg48: i64, %arg49: i64, %arg50: i64, %arg51: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> !llvm.struct<(ptr, ptr, i64)> attributes {llvm.emit_c_interface} {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.insertvalue %arg2, %2[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.insertvalue %arg5, %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.insertvalue %arg6, %7[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.insertvalue %arg7, %8[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.insertvalue %arg8, %9[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.insertvalue %arg9, %10[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.insertvalue %arg10, %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.insertvalue %arg11, %13[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.insertvalue %arg12, %14[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.insertvalue %arg13, %15[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.insertvalue %arg14, %16[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.insertvalue %arg15, %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.insertvalue %arg16, %19[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.insertvalue %arg17, %20[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.insertvalue %arg18, %21[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.insertvalue %arg19, %22[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.insertvalue %arg20, %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.insertvalue %arg21, %25[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.insertvalue %arg22, %26[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.insertvalue %arg23, %27[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.insertvalue %arg24, %28[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.insertvalue %arg26, %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.insertvalue %arg27, %31[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.insertvalue %arg28, %32[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.insertvalue %arg29, %33[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.insertvalue %arg30, %34[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.insertvalue %arg31, %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.insertvalue %arg32, %37[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.insertvalue %arg33, %38[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.insertvalue %arg34, %39[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.insertvalue %arg35, %40[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.insertvalue %arg36, %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.insertvalue %arg37, %43[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.insertvalue %arg38, %44[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.insertvalue %arg39, %45[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.insertvalue %arg40, %46[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.insertvalue %arg41, %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.insertvalue %arg42, %49[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.insertvalue %arg43, %50[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.insertvalue %arg44, %51[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.insertvalue %arg45, %52[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %55 = llvm.insertvalue %arg46, %54[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.insertvalue %arg47, %55[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.insertvalue %arg48, %56[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.insertvalue %arg49, %57[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.insertvalue %arg50, %58[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.mlir.constant(0 : index) : i64
    %61 = llvm.mlir.constant(64 : index) : i64
    %62 = llvm.mlir.constant(1 : index) : i64
    %63 = llvm.mlir.constant(0.000000e+00 : f32) : f32
    %64 = llvm.mlir.constant(1 : index) : i64
    %65 = llvm.mlir.constant(0 : index) : i64
    %66 = llvm.mlir.constant(128 : index) : i64
    %67 = llvm.mlir.null : !llvm.ptr
    %68 = llvm.getelementptr %67[1] : (!llvm.ptr) -> !llvm.ptr, f32
    %69 = llvm.ptrtoint %68 : !llvm.ptr to i64
    %70 = llvm.add %69, %61  : i64
    %71 = llvm.call @malloc(%70) : (i64) -> !llvm.ptr
    %72 = llvm.ptrtoint %71 : !llvm.ptr to i64
    %73 = llvm.sub %61, %62  : i64
    %74 = llvm.add %72, %73  : i64
    %75 = llvm.urem %74, %61  : i64
    %76 = llvm.sub %74, %75  : i64
    %77 = llvm.inttoptr %76 : i64 to !llvm.ptr
    %78 = llvm.mlir.undef : !llvm.struct<(ptr, ptr, i64)>
    %79 = llvm.insertvalue %71, %78[0] : !llvm.struct<(ptr, ptr, i64)> 
    %80 = llvm.insertvalue %77, %79[1] : !llvm.struct<(ptr, ptr, i64)> 
    %81 = llvm.insertvalue %60, %80[2] : !llvm.struct<(ptr, ptr, i64)> 
    llvm.store %63, %77 : f32, !llvm.ptr
    %82 = llvm.load %77 : !llvm.ptr -> f32
    llvm.br ^bb1(%65, %82 : i64, f32)
  ^bb1(%83: i64, %84: f32):  // 2 preds: ^bb0, ^bb15
    %85 = llvm.icmp "slt" %83, %66 : i64
    llvm.cond_br %85, ^bb2, ^bb16
  ^bb2:  // pred: ^bb1
    %86 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %87 = llvm.getelementptr %86[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %88 = llvm.load %87 : !llvm.ptr -> i64
    %89 = llvm.add %83, %64  : i64
    %90 = llvm.extractvalue %5[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %91 = llvm.getelementptr %90[%89] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %92 = llvm.load %91 : !llvm.ptr -> i64
    %93 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %94 = llvm.getelementptr %93[%83] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %95 = llvm.load %94 : !llvm.ptr -> i64
    %96 = llvm.add %83, %64  : i64
    %97 = llvm.extractvalue %35[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %98 = llvm.getelementptr %97[%96] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %99 = llvm.load %98 : !llvm.ptr -> i64
    llvm.br ^bb3(%88, %95, %84 : i64, i64, f32)
  ^bb3(%100: i64, %101: i64, %102: f32):  // 2 preds: ^bb2, ^bb14
    %103 = llvm.icmp "ult" %100, %92 : i64
    %104 = llvm.icmp "ult" %101, %99 : i64
    %105 = llvm.and %103, %104  : i1
    llvm.cond_br %105, ^bb4(%100, %101, %102 : i64, i64, f32), ^bb15
  ^bb4(%106: i64, %107: i64, %108: f32):  // pred: ^bb3
    %109 = llvm.extractvalue %11[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %110 = llvm.getelementptr %109[%106] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %111 = llvm.load %110 : !llvm.ptr -> i64
    %112 = llvm.extractvalue %41[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %113 = llvm.getelementptr %112[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %114 = llvm.load %113 : !llvm.ptr -> i64
    %115 = llvm.icmp "ult" %114, %111 : i64
    %116 = llvm.select %115, %114, %111 : i1, i64
    %117 = llvm.icmp "eq" %111, %116 : i64
    %118 = llvm.icmp "eq" %114, %116 : i64
    %119 = llvm.and %117, %118  : i1
    llvm.cond_br %119, ^bb5, ^bb12(%108 : f32)
  ^bb5:  // pred: ^bb4
    %120 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %121 = llvm.getelementptr %120[%106] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %122 = llvm.load %121 : !llvm.ptr -> i64
    %123 = llvm.add %106, %64  : i64
    %124 = llvm.extractvalue %17[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %125 = llvm.getelementptr %124[%123] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %126 = llvm.load %125 : !llvm.ptr -> i64
    %127 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %128 = llvm.getelementptr %127[%107] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %129 = llvm.load %128 : !llvm.ptr -> i64
    %130 = llvm.add %107, %64  : i64
    %131 = llvm.extractvalue %47[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %132 = llvm.getelementptr %131[%130] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %133 = llvm.load %132 : !llvm.ptr -> i64
    llvm.br ^bb6(%122, %129, %108 : i64, i64, f32)
  ^bb6(%134: i64, %135: i64, %136: f32):  // 2 preds: ^bb5, ^bb11
    %137 = llvm.icmp "ult" %134, %126 : i64
    %138 = llvm.icmp "ult" %135, %133 : i64
    %139 = llvm.and %137, %138  : i1
    llvm.cond_br %139, ^bb7(%134, %135, %136 : i64, i64, f32), ^bb12(%136 : f32)
  ^bb7(%140: i64, %141: i64, %142: f32):  // pred: ^bb6
    %143 = llvm.extractvalue %23[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %144 = llvm.getelementptr %143[%140] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %145 = llvm.load %144 : !llvm.ptr -> i64
    %146 = llvm.extractvalue %53[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %147 = llvm.getelementptr %146[%141] : (!llvm.ptr, i64) -> !llvm.ptr, i64
    %148 = llvm.load %147 : !llvm.ptr -> i64
    %149 = llvm.icmp "ult" %148, %145 : i64
    %150 = llvm.select %149, %148, %145 : i1, i64
    %151 = llvm.icmp "eq" %145, %150 : i64
    %152 = llvm.icmp "eq" %148, %150 : i64
    %153 = llvm.and %151, %152  : i1
    llvm.cond_br %153, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %154 = llvm.extractvalue %29[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %155 = llvm.getelementptr %154[%140] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %156 = llvm.load %155 : !llvm.ptr -> f32
    %157 = llvm.extractvalue %59[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %158 = llvm.getelementptr %157[%141] : (!llvm.ptr, i64) -> !llvm.ptr, f32
    %159 = llvm.load %158 : !llvm.ptr -> f32
    %160 = llvm.fmul %156, %159  : f32
    %161 = llvm.fadd %142, %160  : f32
    llvm.br ^bb10(%161 : f32)
  ^bb9:  // pred: ^bb7
    llvm.br ^bb10(%142 : f32)
  ^bb10(%162: f32):  // 2 preds: ^bb8, ^bb9
    llvm.br ^bb11
  ^bb11:  // pred: ^bb10
    %163 = llvm.icmp "eq" %145, %150 : i64
    %164 = llvm.add %140, %64  : i64
    %165 = llvm.select %163, %164, %140 : i1, i64
    %166 = llvm.icmp "eq" %148, %150 : i64
    %167 = llvm.add %141, %64  : i64
    %168 = llvm.select %166, %167, %141 : i1, i64
    llvm.br ^bb6(%165, %168, %162 : i64, i64, f32)
  ^bb12(%169: f32):  // 2 preds: ^bb4, ^bb6
    llvm.br ^bb13(%169 : f32)
  ^bb13(%170: f32):  // pred: ^bb12
    llvm.br ^bb14
  ^bb14:  // pred: ^bb13
    %171 = llvm.icmp "eq" %111, %116 : i64
    %172 = llvm.add %106, %64  : i64
    %173 = llvm.select %171, %172, %106 : i1, i64
    %174 = llvm.icmp "eq" %114, %116 : i64
    %175 = llvm.add %107, %64  : i64
    %176 = llvm.select %174, %175, %107 : i1, i64
    llvm.br ^bb3(%173, %176, %170 : i64, i64, f32)
  ^bb15:  // pred: ^bb3
    %177 = llvm.add %83, %64  : i64
    llvm.br ^bb1(%177, %102 : i64, f32)
  ^bb16:  // pred: ^bb1
    llvm.store %84, %77 : f32, !llvm.ptr
    llvm.return %81 : !llvm.struct<(ptr, ptr, i64)>
  }
  llvm.func @_mlir_ciface_InnerProd.z.0.main(%arg0: !llvm.ptr, %arg1: !llvm.ptr, %arg2: !llvm.ptr, %arg3: !llvm.ptr, %arg4: !llvm.ptr, %arg5: !llvm.ptr, %arg6: !llvm.struct<(array<3 x i64>, array<5 x i64>)>, %arg7: !llvm.ptr, %arg8: !llvm.ptr, %arg9: !llvm.ptr, %arg10: !llvm.ptr, %arg11: !llvm.ptr, %arg12: !llvm.struct<(array<3 x i64>, array<5 x i64>)>) attributes {llvm.emit_c_interface} {
    %0 = llvm.load %arg1 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %1 = llvm.extractvalue %0[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %2 = llvm.extractvalue %0[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %3 = llvm.extractvalue %0[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %4 = llvm.extractvalue %0[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %5 = llvm.extractvalue %0[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %6 = llvm.load %arg2 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %7 = llvm.extractvalue %6[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %8 = llvm.extractvalue %6[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %9 = llvm.extractvalue %6[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %10 = llvm.extractvalue %6[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %11 = llvm.extractvalue %6[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %12 = llvm.load %arg3 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %13 = llvm.extractvalue %12[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %14 = llvm.extractvalue %12[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %15 = llvm.extractvalue %12[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %16 = llvm.extractvalue %12[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %17 = llvm.extractvalue %12[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %18 = llvm.load %arg4 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %19 = llvm.extractvalue %18[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %20 = llvm.extractvalue %18[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %21 = llvm.extractvalue %18[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %22 = llvm.extractvalue %18[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %23 = llvm.extractvalue %18[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %24 = llvm.load %arg5 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %25 = llvm.extractvalue %24[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %26 = llvm.extractvalue %24[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %27 = llvm.extractvalue %24[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %28 = llvm.extractvalue %24[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %29 = llvm.extractvalue %24[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %30 = llvm.load %arg7 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %31 = llvm.extractvalue %30[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %32 = llvm.extractvalue %30[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %33 = llvm.extractvalue %30[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %34 = llvm.extractvalue %30[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %35 = llvm.extractvalue %30[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %36 = llvm.load %arg8 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %37 = llvm.extractvalue %36[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %38 = llvm.extractvalue %36[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %39 = llvm.extractvalue %36[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %40 = llvm.extractvalue %36[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %41 = llvm.extractvalue %36[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %42 = llvm.load %arg9 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %43 = llvm.extractvalue %42[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %44 = llvm.extractvalue %42[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %45 = llvm.extractvalue %42[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %46 = llvm.extractvalue %42[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %47 = llvm.extractvalue %42[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %48 = llvm.load %arg10 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %49 = llvm.extractvalue %48[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %50 = llvm.extractvalue %48[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %51 = llvm.extractvalue %48[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %52 = llvm.extractvalue %48[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %53 = llvm.extractvalue %48[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %54 = llvm.load %arg11 : !llvm.ptr -> !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)>
    %55 = llvm.extractvalue %54[0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %56 = llvm.extractvalue %54[1] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %57 = llvm.extractvalue %54[2] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %58 = llvm.extractvalue %54[3, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %59 = llvm.extractvalue %54[4, 0] : !llvm.struct<(ptr, ptr, i64, array<1 x i64>, array<1 x i64>)> 
    %60 = llvm.call @InnerProd.z.0.main(%1, %2, %3, %4, %5, %7, %8, %9, %10, %11, %13, %14, %15, %16, %17, %19, %20, %21, %22, %23, %25, %26, %27, %28, %29, %arg6, %31, %32, %33, %34, %35, %37, %38, %39, %40, %41, %43, %44, %45, %46, %47, %49, %50, %51, %52, %53, %55, %56, %57, %58, %59, %arg12) : (!llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.ptr, !llvm.ptr, i64, i64, i64, !llvm.struct<(array<3 x i64>, array<5 x i64>)>) -> !llvm.struct<(ptr, ptr, i64)>
    llvm.store %60, %arg0 : !llvm.struct<(ptr, ptr, i64)>, !llvm.ptr
    llvm.return
  }
}


